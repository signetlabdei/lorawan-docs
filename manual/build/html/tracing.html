
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>3.3. Tracing &#8212; Manual</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/default.css?v=bb97339c" />
    <script src="_static/documentation_options.js?v=951d00fa"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3.4. Data Collection" href="data-collection.html" />
    <link rel="prev" title="3.2. Hash Functions" href="hash-functions.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico"
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>


  </head><body>
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" width="100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo">
              <a id="ns3_home1"
                 href="http://www.nsnam.org/">
                 <img alt="ns-3 Logo" style="background-color: unset;"
                      src="_static/ns-3-inverted-notext-small.png"/>
              </a>
            </td>
            <td id="projecttext">
              <div id="projectbrief">A Discrete-Event Network Simulator</div>
              <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
            </td>

            <td id="ns3-menu">
              <div class="menu">
                <ul >
                  <li style="background-image:none">
                    <a id="ns3_home2"
                         href="http://www.nsnam.org/"
                         >&nbsp;&nbsp;Home</a>
                  </li>
                  <li><span
                        onmouseover="mopen('mTuts')"
                        onmouseout="mclosetime()"
                          >Tutorials &nbsp;&#x25BC;</span>
                      <div id="mTuts"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_tut"
                           href="/docs/tutorial/html/index.html"
                            >English</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDocs')"
                        onmouseout="mclosetime()"
                          >Documentation &nbsp;&#x25BC;</span>
                      <div id="mDocs"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_ins"
                           href="/docs/installation/html/index.html"
                           >Installation</a><br/>
                        <a id="ns3_man"
                           href="/docs/manual/html/index.html"
                           >Manual</a><br/>
                        <a id="ns3_mod"
                           href="/docs/models/html/index.html"
                           >Models</a><br/>
                        <a id="ns3_con"
                           href="/docs/contributing/html/index.html"
                           >Contributing</a><br/>
                        <a id="ns3_wiki"
                           href="http://www.nsnam.org/wiki"
                           >Wiki</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDev')"
                        onmouseout="mclosetime()"
                          >Development &nbsp;&#x25BC;</span>
                      <div id="mDev"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_api"
                           href="/docs/doxygen/html/index.html"
                           >API Docs</a><br/>
                        <a id="ns3_bugs"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/issues"
                           >Issue Tracker</a><br/>
                        <a id="ns3_merge"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests"
                           >Merge Requests</a><br/>
                      </div>
                  </li>
                </ul>
              </div>
            </td>

            <td id="projectsection">
              <span style="margin-right:10px">Manual</span>
            </td>
          </tr>
        </tbody>
      </table>
      <script  type="text/javascript">ns3_write_links()</script>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="data-collection.html" title="3.4. Data Collection"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hash-functions.html" title="3.2. Hash Functions"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Manual</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="features.html" accesskey="U"><span class="section-number">3. </span>Additional Tools</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3.3. </span>Tracing</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="tracing">
<h1><span class="section-number">3.3. </span>Tracing<a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h1>
<p>The tracing subsystem is one of the most important mechanisms to understand in
<em>ns-3</em>. In most cases, <em>ns-3</em> users will have a brilliant idea for some new and
improved networking feature. In order to verify that this idea works, the
researcher will make changes to an existing system and then run experiments to
see how the new feature behaves by gathering statistics that capture the
behavior of the feature.</p>
<p>In other words, the whole point of running a simulation is to generate output
for further study. In <em>ns-3</em>, the subsystem that enables a researcher to do this
is the tracing subsystem.</p>
<section id="tracing-motivation">
<h2><span class="section-number">3.3.1. </span>Tracing Motivation<a class="headerlink" href="#tracing-motivation" title="Link to this heading">¶</a></h2>
<p>There are many ways to get information out of a program. The most
straightforward way is to just directly print the information to the standard
output, as in,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="p">...</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;The value of x is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is workable in small environments, but as your simulations get more and
more complicated, you end up with more and more prints and the task of parsing
and performing computations on the output begins to get harder and harder.</p>
<p>Another thing to consider is that every time a new tidbit is needed, the
software core must be edited and another print introduced. There is no
standardized way to control all of this output, so the amount of output tends to
grow without bounds. Eventually, the bandwidth required for simply outputting
this information begins to limit the running time of the simulation. The output
files grow to enormous sizes and parsing them becomes a problem.</p>
<p><em>ns-3</em> provides a simple mechanism for logging and providing some control over
output via <em>Log Components</em>, but the level of control is not very fine grained
at all. The logging module is a relatively blunt instrument.</p>
<p>It is desirable to have a facility that allows one to reach into the core system
and only get the information required without having to change and recompile the
core system. Even better would be a system that notified the user when an item
of interest changed or an interesting event happened.</p>
<p>The <em>ns-3</em> tracing system is designed to work along those lines and is
well-integrated with the Attribute and Config substems allowing for relatively
simple use scenarios.</p>
</section>
<section id="overview">
<h2><span class="section-number">3.3.2. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The tracing subsystem relies heavily on the <em>ns-3</em> Callback and Attribute
mechanisms. You should read and understand the corresponding sections of the
manual before attempting to understand the tracing system.</p>
<p>The <em>ns-3</em> tracing system is built on the concepts of independent tracing sources
and tracing sinks; along with a uniform mechanism for connecting sources to
sinks.</p>
<p>Trace sources are entities that can signal events that happen in a simulation
and provide access to interesting underlying data. For example, a trace source
could indicate when a packet is received by a net device and provide access to
the packet contents for interested trace sinks. A trace source might also
indicate when an interesting state change happens in a model. For example, the
congestion window of a TCP model is a prime candidate for a trace source.</p>
<p>Trace sources are not useful by themselves; they must be connected to other
pieces of code that actually do something useful with the information provided
by the source.  The entities that consume trace information are called trace
sinks. Trace sources are generators of events and trace sinks are consumers.</p>
<p>This explicit division allows for large numbers of trace sources to be scattered
around the system in places which model authors believe might be useful. Unless
a user connects a trace sink to one of these sources, nothing is output. This
arrangement allows relatively unsophisticated users to attach new types of sinks
to existing tracing sources, without requiring editing and recompiling the core
or models of the simulator.</p>
<p>There can be zero or more consumers of trace events generated by a trace source.
One can think of a trace source as a kind of point-to-multipoint information
link.</p>
<p>The “transport protocol” for this conceptual point-to-multipoint link is an
<em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Callback</span></code>.</p>
<p>Recall from the Callback Section that callback facility is a way to allow two
modules in the system to communicate via function calls while at the same time
decoupling the calling function from the called class completely. This is the
same requirement as outlined above for the tracing system.</p>
<p>Basically, a trace source <em>is</em> a callback to which multiple functions may be
registered. When a trace sink expresses interest in receiving trace events, it
adds a callback to a list of callbacks held by the trace source. When an
interesting event happens, the trace source invokes its <code class="docutils literal notranslate"><span class="pre">operator()</span></code> providing
zero or more parameters. This tells the source to go through its list of
callbacks invoking each one in turn. In this way, the parameter(s) are
communicated to the trace sinks, which are just functions.</p>
<section id="the-simplest-example">
<h3><span class="section-number">3.3.2.1. </span>The Simplest Example<a class="headerlink" href="#the-simplest-example" title="Link to this heading">¶</a></h3>
<p>It will be useful to go walk a quick example just to reinforce what we’ve
said.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/object.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/uinteger.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/traced-value.h&quot;</span><span class="c1">&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/trace-source-accessor.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ns3</span><span class="p">;</span>
</pre></div>
</div>
<p>The first thing to do is include the required files. As mentioned above, the
trace system makes heavy use of the Object and Attribute systems. The first two
includes bring in the declarations for those systems. The file,
<code class="docutils literal notranslate"><span class="pre">traced-value.h</span></code> brings in the required declarations for tracing data that
obeys value semantics.</p>
<p>In general, value semantics just means that you can pass the object around, not
an address. In order to use value semantics at all you have to have an object
with an associated copy constructor and assignment operator available. We extend
the requirements to talk about the set of operators that are pre-defined for
plain-old-data (POD) types. Operator=, operator++, operator–, operator+,
operator==, etc.</p>
<p>What this all means is that you will be able to trace changes to an object
made using those operators.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyObject</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Object</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="n">GetTypeId</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeId</span><span class="p">(</span><span class="s">&quot;MyObject&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">Object</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">AddConstructor</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">      </span><span class="p">.</span><span class="n">AddTraceSource</span><span class="p">(</span><span class="s">&quot;MyInteger&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;An integer value to trace.&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="n">MakeTraceSourceAccessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyObject</span><span class="o">::</span><span class="n">m_myInt</span><span class="p">))</span>
<span class="w">      </span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">MyObject</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="n">TracedValue</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_myInt</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Since the tracing system is integrated with Attributes, and Attributes work with
Objects, there must be an <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Object</span></code> for the trace source to live in. The
two important lines of code are the <code class="docutils literal notranslate"><span class="pre">.AddTraceSource</span></code> and the <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code>
declaration.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.AddTraceSource</span></code> provides the “hooks” used for connecting the trace
source to the outside world. The <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> declaration provides the
infrastructure that overloads the operators mentioned above and drives the
callback process.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">IntTrace</span><span class="p">(</span><span class="n">Int</span><span class="w"> </span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="n">newValue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Traced &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oldValue</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">newValue</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is the definition of the trace sink. It corresponds directly to a callback
function. This function will be called whenever one of the operators of the
<code class="docutils literal notranslate"><span class="pre">TracedValue</span></code> is executed.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;MyInteger&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IntTrace</span><span class="p">));</span>

<span class="w">  </span><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">m_myInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this snippet, the first thing that needs to be done is to create the object
in which the trace source lives.</p>
<p>The next step, the <code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code>, forms the connection between
the trace source and the trace sink. Notice the <code class="docutils literal notranslate"><span class="pre">MakeCallback</span></code> template
function. Recall from the Callback section that this creates the specialized
functor responsible for providing the overloaded <code class="docutils literal notranslate"><span class="pre">operator()</span></code> used to “fire”
the callback. The overloaded operators (++, –, etc.) will use this
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> to actually invoke the callback. The
<code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code>, takes a string parameter that provides the name
of the Attribute assigned to the trace source. Let’s ignore the bit about
context for now since it is not important yet.</p>
<p>Finally, the line,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">m_myInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span>
</pre></div>
</div>
<p>should be interpreted as an invocation of <code class="docutils literal notranslate"><span class="pre">operator=</span></code> on the member variable
<code class="docutils literal notranslate"><span class="pre">m_myInt</span></code> with the integer <img class="math" src="_images/math/b648f8658ef578b3c1312db5aea9b2e8d436c232.png" alt="1234"/> passed as a parameter. It turns out
that this operator is defined (by <code class="docutils literal notranslate"><span class="pre">TracedValue</span></code>) to execute a callback that
returns void and takes two integer values as parameters – an old value and a
new value for the integer in question. That is exactly the function signature
for the callback function we provided – <code class="docutils literal notranslate"><span class="pre">IntTrace</span></code>.</p>
<p>To summarize, a trace source is, in essence, a variable that holds a list of
callbacks. A trace sink is a function used as the target of a callback. The
Attribute and object type information systems are used to provide a way to
connect trace sources to trace sinks. The act of “hitting” a trace source is
executing an operator on the trace source which fires callbacks. This results in
the trace sink callbacks registering interest in the source being called with
the parameters provided by the source.</p>
</section>
<section id="using-the-config-subsystem-to-connect-to-trace-sources">
<h3><span class="section-number">3.3.2.2. </span>Using the Config Subsystem to Connect to Trace Sources<a class="headerlink" href="#using-the-config-subsystem-to-connect-to-trace-sources" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TraceConnectWithoutContext</span></code> call shown above in the simple example is
actually very rarely used in the system. More typically, the <code class="docutils literal notranslate"><span class="pre">Config</span></code>
subsystem is used to allow selecting a trace source in the system using what is
called a <em>config path</em>.</p>
<p>For example, one might find something that looks like the following in the
system (taken from <code class="docutils literal notranslate"><span class="pre">examples/tcp-large-transfer.cc</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">CwndTracer</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">oldval</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">newval</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="p">...</span>

<span class="n">Config</span><span class="o">::</span><span class="n">ConnectWithoutContext</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CwndTracer</span><span class="p">));</span>
</pre></div>
</div>
<p>This should look very familiar. It is the same thing as the previous example,
except that a static member function of class <code class="docutils literal notranslate"><span class="pre">Config</span></code> is being called instead
of a method on <code class="docutils literal notranslate"><span class="pre">Object</span></code>; and instead of an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> name, a path is being
provided.</p>
<p>The first thing to do is to read the path backward. The last segment of the path
must be an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>. In fact, if you had a pointer to the
<code class="docutils literal notranslate"><span class="pre">Object</span></code> that has the “CongestionWindow” <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> handy (call it
<code class="docutils literal notranslate"><span class="pre">theObject</span></code>), you could write this just like the previous example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">CwndTracer</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">oldval</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">newval</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="p">...</span>

<span class="n">theObject</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CongestionWindow&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CwndTracer</span><span class="p">));</span>
</pre></div>
</div>
<p>It turns out that the code for <code class="docutils literal notranslate"><span class="pre">Config::ConnectWithoutContext</span></code> does exactly
that. This function takes a path that represents a chain of <code class="docutils literal notranslate"><span class="pre">Object</span></code> pointers
and follows them until it gets to the end of the path and interprets the last
segment as an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> on the last object. Let’s walk through what
happens.</p>
<p>The leading “/” character in the path refers to a so-called namespace. One of the
predefined namespaces in the config system is “NodeList” which is a list of all of
the nodes in the simulation. Items in the list are referred to by indices into the
list, so “/NodeList/0” refers to the zeroth node in the list of nodes created by
the simulation. This node is actually a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> and so is a subclass of
an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Object</span></code>.</p>
<p>As described in the <a class="reference internal" href="object-model.html#object-model"><span class="std std-ref">Object model</span></a> section, <em>ns-3</em> supports an object
aggregation model. The next path segment begins with the “$” character which
indicates a <code class="docutils literal notranslate"><span class="pre">GetObject</span></code> call should be made looking for the type that follows.
When a node is initialized by an <code class="docutils literal notranslate"><span class="pre">InternetStackHelper</span></code> a number of interfaces
are aggregated to the node. One of these is the TCP level four protocol. The
runtime type of this protocol object is <code class="docutils literal notranslate"><span class="pre">ns3::TcpL4Protocol''.</span> <span class="pre">When</span> <span class="pre">the</span>
<span class="pre">``GetObject</span></code> is executed, it returns a pointer to the object of this type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TcpL4Protocol</span></code> class defines an Attribute called “SocketList” which is a
list of sockets.  Each socket is actually an <code class="docutils literal notranslate"><span class="pre">ns3::Object</span></code> with its own
<code class="docutils literal notranslate"><span class="pre">Attributes</span></code>.  The items in the list of sockets are referred to by index just
as in the NodeList, so “SocketList/0” refers to the zeroth socket in the list of
sockets on the zeroth node in the NodeList – the first node constructed in the
simulation.</p>
<p>This socket, the type of which turns out to be an <code class="docutils literal notranslate"><span class="pre">ns3::TcpSocketImpl</span></code> defines
an attribute called “CongestionWindow” which is a <code class="docutils literal notranslate"><span class="pre">TracedValue&lt;uint32_t&gt;</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Config::ConnectWithoutContext</span></code> now does a,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">object</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;CongestionWindow&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CwndTracer</span><span class="p">));</span>
</pre></div>
</div>
<p>using the object pointer from “SocketList/0” which makes the connection between
the trace source defined in the socket to the callback – <code class="docutils literal notranslate"><span class="pre">CwndTracer</span></code>.</p>
<p>Now, whenever a change is made to the <code class="docutils literal notranslate"><span class="pre">TracedValue&lt;uint32_t&gt;</span></code> representing the
congestion window in the TCP socket, the registered callback will be executed
and the function <code class="docutils literal notranslate"><span class="pre">CwndTracer</span></code> will be called printing out the old and new
values of the TCP congestion window.</p>
<p>As a final note, the <cite>Config::Connect…()</cite> functions
will throw an error if the targeted TraceSource does not exist at the path
given.  There are also “fail-safe” versions,
<cite>Config::Connect…FailSafe()</cite>, if you can’t be sure the TraceSource
exists.  The fail-safe versions return <cite>true</cite> if at least one connection
could be made.</p>
</section>
</section>
<section id="using-the-tracing-api">
<h2><span class="section-number">3.3.3. </span>Using the Tracing API<a class="headerlink" href="#using-the-tracing-api" title="Link to this heading">¶</a></h2>
<p>There are three levels of interaction with the tracing system:</p>
<ul class="simple">
<li><p>Beginning user can easily control which objects are participating in tracing;</p></li>
<li><p>Intermediate users can extend the tracing system to modify the output format
generated or use existing trace sources in different ways, without modifying
the core of the simulator;</p></li>
<li><p>Advanced users can modify the simulator core to add new tracing sources and
sinks.</p></li>
</ul>
</section>
<section id="using-trace-helpers">
<h2><span class="section-number">3.3.4. </span>Using Trace Helpers<a class="headerlink" href="#using-trace-helpers" title="Link to this heading">¶</a></h2>
<p>The <em>ns-3</em> trace helpers provide a rich environment for configuring and selecting
different trace events and writing them to files. In previous sections,
primarily “Building Topologies,” we have seen several varieties of the trace
helper methods designed for use inside other (device) helpers.</p>
<p>Perhaps you will recall seeing some of these variations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnablePcapAll</span><span class="p">(</span><span class="s">&quot;second&quot;</span><span class="p">);</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;second&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p2pNodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetId</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">csma</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;third&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">csmaDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnableAsciiAll</span><span class="p">(</span><span class="n">ascii</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;myfirst.tr&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>What may not be obvious, though, is that there is a consistent model for all of
the trace-related methods found in the system. We will now take a little time
and take a look at the “big picture”.</p>
<p>There are currently two primary use cases of the tracing helpers in <em>ns-3</em>:
Device helpers and protocol helpers. Device helpers look at the problem of
specifying which traces should be enabled through a node, device pair.  For
example, you may want to specify that pcap tracing should be enabled on a
particular device on a specific node. This follows from the <em>ns-3</em> device
conceptual model, and also the conceptual models of the various device helpers.
Following naturally from this, the files created follow a
&lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; naming convention.</p>
<p>Protocol helpers look at the problem of specifying which traces should be
enabled through a protocol and interface pair. This follows from the <em>ns-3</em>
protocol stack conceptual model, and also the conceptual models of internet
stack helpers. Naturally, the trace files should follow a
&lt;prefix&gt;-&lt;protocol&gt;-&lt;interface&gt; naming convention.</p>
<p>The trace helpers therefore fall naturally into a two-dimensional taxonomy.
There are subtleties that prevent all four classes from behaving identically,
but we do strive to make them all work as similarly as possible; and whenever
possible there are analogs for all methods in all classes.</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>pcap</p></th>
<th class="head"><p>ascii</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Device Helper</p></td>
<td><p><img class="math" src="_images/math/eb43d5592546eaaff233c50b390d221dc5c75cd9.png" alt="\checkmark"/></p></td>
<td><p><img class="math" src="_images/math/eb43d5592546eaaff233c50b390d221dc5c75cd9.png" alt="\checkmark"/></p></td>
</tr>
<tr class="row-odd"><td><p>Protocol Helper</p></td>
<td><p><img class="math" src="_images/math/eb43d5592546eaaff233c50b390d221dc5c75cd9.png" alt="\checkmark"/></p></td>
<td><p><img class="math" src="_images/math/eb43d5592546eaaff233c50b390d221dc5c75cd9.png" alt="\checkmark"/></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>We use an approach called a <code class="docutils literal notranslate"><span class="pre">mixin</span></code> to add tracing functionality to our helper
classes. A <code class="docutils literal notranslate"><span class="pre">mixin</span></code> is a class that provides functionality to that is
inherited by a subclass. Inheriting from a mixin is not considered a form of
specialization but is really a way to collect functionality.</p>
<p>Let’s take a quick look at all four of these cases and their respective
<code class="docutils literal notranslate"><span class="pre">mixins</span></code>.</p>
<section id="pcap-tracing-device-helpers">
<h3><span class="section-number">3.3.4.1. </span>Pcap Tracing Device Helpers<a class="headerlink" href="#pcap-tracing-device-helpers" title="Link to this heading">¶</a></h3>
<p>The goal of these helpers is to make it easy to add a consistent pcap trace
facility to an <em>ns-3</em> device. We want all of the various flavors of pcap tracing
to work the same across all devices, so the methods of these helpers are
inherited by device helpers. Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you
want to follow the discussion while looking at real code.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">PcapHelperForDevice</span></code> is a <code class="docutils literal notranslate"><span class="pre">mixin</span></code> provides the high level
functionality for using pcap tracing in an <em>ns-3</em> device. Every device must
implement a single virtual method inherited from this class.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapInternal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the device-centric view of the situation
at this level. All of the public methods inherited from class
<code class="docutils literal notranslate"><span class="pre">PcapUserHelperForDevice</span></code> reduce to calling this single device-dependent
implementation method. For example, the lowest level pcap method,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnablePcapInternal</span></code> directly. All
other public pcap tracing methods build on this implementation to provide
additional user-level functionality. What this means to the user is that all
device helpers in the system will have all of the pcap trace methods available;
and these methods will all work in the same way across devices if the device
implements <code class="docutils literal notranslate"><span class="pre">EnablePcapInternal</span></code> correctly.</p>
<section id="pcap-tracing-device-helper-methods">
<h4><span class="section-number">3.3.4.1.1. </span>Pcap Tracing Device Helper Methods<a class="headerlink" href="#pcap-tracing-device-helper-methods" title="Link to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span>
<span class="w">                </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">,</span>
<span class="w">                </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="p">,</span>
<span class="w">                </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">                </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">,</span>
<span class="w">                </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapAll</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>In each of the methods shown above, there is a default parameter called
<code class="docutils literal notranslate"><span class="pre">promiscuous</span></code> that defaults to false. This parameter indicates that the trace
should not be gathered in promiscuous mode. If you do want your traces to
include all traffic seen by the device (and if the device supports a promiscuous
mode) simply add a true parameter to any of the calls above. For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>will enable promiscuous mode captures on the <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> specified by <code class="docutils literal notranslate"><span class="pre">nd</span></code>.</p>
<p>The first two methods also include a default parameter called
<code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code> that will be discussed below.</p>
<p>You are encouraged to peruse the Doxygen for class <code class="docutils literal notranslate"><span class="pre">PcapHelperForDevice</span></code> to
find the details of these methods; but to summarize …</p>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a
<code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code> to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method. The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> is implicit
since the net device must belong to exactly one <code class="docutils literal notranslate"><span class="pre">Node</span></code>. For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code>
method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code> is looked up from the name string.  Again, the
<code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since the named net device must belong to exactly one
<code class="docutils literal notranslate"><span class="pre">Node</span></code>.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server/ath0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on a collection of node/net-device pairs by
providing a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> in the container the
type is checked.  For each device of the proper type (the same type as is
managed by the device helper), tracing is enabled. Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is
implicit since the found net device must belong to exactly one <code class="docutils literal notranslate"><span class="pre">Node</span></code>. For
example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on a collection of node/net-device pairs by
providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> its
attached <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code> are iterated.  For each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> attached to each
node in the container, the type of that device is checked.  For each device of
the proper type (the same type as is managed by the device helper), tracing is
enabled.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on the basis of node ID and device ID as well as
with explicit <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>. Each <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the system has an integer node ID and
each device connected to a node has an integer device ID.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, you can enable pcap tracing for all devices in the system, with the
same type as that managed by the device helper.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapAll</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="pcap-tracing-device-helper-filename-selection">
<h4><span class="section-number">3.3.4.1.2. </span>Pcap Tracing Device Helper Filename Selection<a class="headerlink" href="#pcap-tracing-device-helper-filename-selection" title="Link to this heading">¶</a></h4>
<p>Implicit in the method descriptions above is the construction of a complete
filename by the implementation method. By convention, pcap traces in the <em>ns-3</em>
system are of the form <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span> <span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.pcap</span></code></p>
<p>As previously mentioned, every node in the system will have a system-assigned
node id; and every device will have an interface index (also called a device id)
relative to its node. By default, then, a pcap trace file created as a result
of enabling tracing on the first device of node 21 using the prefix “prefix”
would be <code class="docutils literal notranslate"><span class="pre">prefix-21-1.pcap</span></code>.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more clear.  For
example, if you use the object name service to assign the name “server” to node
21, the resulting pcap trace file name will automatically become,
<code class="docutils literal notranslate"><span class="pre">prefix-server-1.pcap</span></code> and if you also assign the name “eth0” to the device,
your pcap file name will automatically pick this up and be called
<code class="docutils literal notranslate"><span class="pre">prefix-server-eth0.pcap</span></code>.</p>
<p>Finally, two of the methods shown above,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">promiscuous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicitFilename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>have a default parameter called <code class="docutils literal notranslate"><span class="pre">explicitFilename</span></code>. When set to true, this
parameter disables the automatic filename completion mechanism and allows you to
create an explicit filename. This option is only available in the methods which
enable pcap tracing on a single device.</p>
<p>For example, in order to arrange for a device helper to create a single
promiscuous pcap capture file of a specific name (<code class="docutils literal notranslate"><span class="pre">my-pcap-file.pcap</span></code>) on a
given device, one could:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;my-pcap-file.pcap&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The first <code class="docutils literal notranslate"><span class="pre">true</span></code> parameter enables promiscuous mode traces and the second
tells the helper to interpret the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> parameter as a complete filename.</p>
</section>
</section>
<section id="ascii-tracing-device-helpers">
<h3><span class="section-number">3.3.4.2. </span>Ascii Tracing Device Helpers<a class="headerlink" href="#ascii-tracing-device-helpers" title="Link to this heading">¶</a></h3>
<p>The behavior of the ASCII trace helper <code class="docutils literal notranslate"><span class="pre">mixin</span></code> is substantially similar to
the pcap version. Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you want to
follow the discussion while looking at real code.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForDevice</span></code> adds the high level functionality for
using ASCII tracing to a device helper class. As in the pcap case, every device
must implement a single virtual method inherited from the ASCII trace
<code class="docutils literal notranslate"><span class="pre">mixin</span></code>.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiInternal</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the device-centric view of the situation
at this level; and also the fact that the helper may be writing to a shared
output stream. All of the public ASCII-trace-related methods inherited from
class <code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForDevice</span></code> reduce to calling this single device-
dependent implementation method. For example, the lowest level ASCII trace
methods,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnableAsciiInternal</span></code> directly,
providing either a valid prefix or stream.  All other public ASCII tracing
methods will build on these low-level functions to provide additional user-level
functionality. What this means to the user is that all device helpers in the
system will have all of the ASCII trace methods available; and these methods
will all work in the same way across devices if the devices implement
<code class="docutils literal notranslate"><span class="pre">EnablAsciiInternal</span></code> correctly.</p>
<section id="ascii-tracing-device-helper-methods">
<h4><span class="section-number">3.3.4.2.1. </span>Ascii Tracing Device Helper Methods<a class="headerlink" href="#ascii-tracing-device-helper-methods" title="Link to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ndName</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAscii</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiAll</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiAll</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>You are encouraged to peruse the Doxygen for class <code class="docutils literal notranslate"><span class="pre">TraceHelperForDevice</span></code> to
find the details of these methods; but to summarize …</p>
<p>There are twice as many methods available for ASCII tracing as there were for
pcap tracing. This is because, in addition to the pcap-style model where traces
from each unique node/device pair are written to a unique file, we support a
model in which trace information for many node/device pairs is written to a
common file.  This means that the &lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; file name generation
mechanism is replaced by a mechanism to refer to a common file; and the number
of API methods is doubled to allow all combinations.</p>
<p>Just as in pcap tracing, you can enable ASCII tracing on a particular
node/net-device pair by providing a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code> to an <code class="docutils literal notranslate"><span class="pre">EnableAscii</span></code>
method. The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> is implicit since the net device must belong to
exactly one <code class="docutils literal notranslate"><span class="pre">Node</span></code>. For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nd</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, no trace contexts are written to the ASCII trace file since they
would be redundant. The system will pick the file name to be created using the
same rules as described in the pcap section, except that the file will have the
suffix “.tr” instead of “.pcap”.</p>
<p>If you want to enable ASCII tracing on more than one net device and have all
traces sent to a single file, you can do that as well by using an object to
refer to a single file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd1</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd2</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">nd1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">nd2</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, trace contexts are written to the ASCII trace file since they
are required to disambiguate traces from the two devices.  Note that since the
user is completely specifying the file name, the string should include the “.tr”
for consistency.</p>
<p>You can enable ASCII tracing on a particular node/net-device pair by providing a
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string to an
<code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;NetDevice&gt;</span></code> is looked up from the name
string.  Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since the named net device must
belong to exactly one <code class="docutils literal notranslate"><span class="pre">Node</span></code>.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;client/eth0&quot;</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server/eth0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in two files named <code class="docutils literal notranslate"><span class="pre">prefix-client-eth0.tr</span></code> and
<code class="docutils literal notranslate"><span class="pre">prefix-server-eth0.tr</span></code> with traces for each device in the respective trace
file. Since all of the EnableAscii functions are overloaded to take a stream
wrapper, you can use that form as well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;client/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;server/eth0&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;client/eth0&quot;</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;server/eth0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a single trace file called <code class="docutils literal notranslate"><span class="pre">trace-file-name.tr</span></code> that
contains all of the trace events for both devices. The events would be
disambiguated by trace context strings.</p>
<p>You can enable ASCII tracing on a collection of node/net-device pairs by
providing a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> in the container the
type is checked. For each device of the proper type (the same type as is managed
by the device helper), tracing is enabled. Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit
since the found net device must belong to exactly one <code class="docutils literal notranslate"><span class="pre">Node</span></code>.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, each of which
follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable ascii tracing on a collection of node/net-device pairs by
providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> its
attached <code class="docutils literal notranslate"><span class="pre">NetDevices</span></code> are iterated.  For each <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> attached to each
node in the container, the type of that device is checked.  For each device of
the proper type (the same type as is managed by the device helper), tracing is
enabled.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, each of which
follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:</p>
<p>You can enable pcap tracing on the basis of node ID and device ID as well as
with explicit <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>. Each <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the system has an integer node ID and
each device connected to a node has an integer device ID.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAscii</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Of course, the traces can be combined into a single file as shown above.</p>
<p>Finally, you can enable pcap tracing for all devices in the system, with the
same type as that managed by the device helper.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiAll</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, one for
every device in the system of the type managed by the helper. All of these
files will follow the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining
all of the traces into a single file is accomplished similarly to the examples
above.</p>
</section>
<section id="ascii-tracing-device-helper-filename-selection">
<h4><span class="section-number">3.3.4.2.2. </span>Ascii Tracing Device Helper Filename Selection<a class="headerlink" href="#ascii-tracing-device-helper-filename-selection" title="Link to this heading">¶</a></h4>
<p>Implicit in the prefix-style method descriptions above is the construction of
the complete filenames by the implementation method. By convention, ASCII traces
in the <em>ns-3</em> system are of the form <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span> <span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.tr</span></code>.</p>
<p>As previously mentioned, every node in the system will have a system-assigned
node id; and every device will have an interface index (also called a device id)
relative to its node.  By default, then, an ASCII trace file created as a result
of enabling tracing on the first device of node 21, using the prefix “prefix”,
would be <code class="docutils literal notranslate"><span class="pre">prefix-21-1.tr</span></code>.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more clear.  For
example, if you use the object name service to assign the name “server” to node
21, the resulting ASCII trace file name will automatically become,
<code class="docutils literal notranslate"><span class="pre">prefix-server-1.tr</span></code> and if you also assign the name “eth0” to the device,
your ASCII trace file name will automatically pick this up and be called
<code class="docutils literal notranslate"><span class="pre">prefix-server-eth0.tr</span></code>.</p>
</section>
</section>
<section id="pcap-tracing-protocol-helpers">
<h3><span class="section-number">3.3.4.3. </span>Pcap Tracing Protocol Helpers<a class="headerlink" href="#pcap-tracing-protocol-helpers" title="Link to this heading">¶</a></h3>
<p>The goal of these <code class="docutils literal notranslate"><span class="pre">mixins</span></code> is to make it easy to add a consistent pcap trace
facility to protocols. We want all of the various flavors of pcap tracing to
work the same across all protocols, so the methods of these helpers are
inherited by stack helpers. Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you
want to follow the discussion while looking at real code.</p>
<p>In this section we will be illustrating the methods as applied to the protocol
<code class="docutils literal notranslate"><span class="pre">Ipv4</span></code>.  To specify traces in similar protocols, just substitute the
appropriate type.  For example, use a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv6&gt;</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code>
and call <code class="docutils literal notranslate"><span class="pre">EnablePcapIpv6</span></code> instead of <code class="docutils literal notranslate"><span class="pre">EnablePcapIpv4</span></code>.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">PcapHelperForIpv4</span></code> provides the high level functionality for using
pcap tracing in the <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code> protocol.  Each protocol helper enabling these
methods must implement a single virtual method inherited from this class.  There
will be a separate implementation for <code class="docutils literal notranslate"><span class="pre">Ipv6</span></code>, for example, but the only
difference will be in the method names and signatures.  Different method names
are required to disambiguate class <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code> from <code class="docutils literal notranslate"><span class="pre">Ipv6</span></code> which are both derived
from class <code class="docutils literal notranslate"><span class="pre">Object</span></code>, and methods that share the same signature.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4Internal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the protocol and interface-centric view of
the situation at this level. All of the public methods inherited from class
<code class="docutils literal notranslate"><span class="pre">PcapHelperForIpv4</span></code> reduce to calling this single device-dependent
implementation method.  For example, the lowest level pcap method,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnablePcapIpv4Internal</span></code> directly.  All
other public pcap tracing methods build on this implementation to provide
additional user-level functionality. What this means to the user is that all
protocol helpers in the system will have all of the pcap trace methods
available; and these methods will all work in the same way across protocols if
the helper implements <code class="docutils literal notranslate"><span class="pre">EnablePcapIpv4Internal</span></code> correctly.</p>
<section id="pcap-tracing-protocol-helper-methods">
<h4><span class="section-number">3.3.4.3.1. </span>Pcap Tracing Protocol Helper Methods<a class="headerlink" href="#pcap-tracing-protocol-helper-methods" title="Link to this heading">¶</a></h4>
<p>These methods are designed to be in one-to-one correspondence with the <code class="docutils literal notranslate"><span class="pre">Node</span></code>-
and <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>- centric versions of the device versions. Instead of
<code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> pair constraints, we use protocol and interface
constraints.</p>
<p>Note that just like in the device version, there are six methods:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ipv4Name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnablePcapIpv4All</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
</pre></div>
</div>
<p>You are encouraged to peruse the Doxygen for class <code class="docutils literal notranslate"><span class="pre">PcapHelperForIpv4</span></code> to find
the details of these methods; but to summarize …</p>
<p>You can enable pcap tracing on a particular protocol/interface pair by providing
a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">interface</span></code> to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code> method.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code>
method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> is looked up from the name string.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;serverIPv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;serverIpv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on a collection of protocol/interface pairs by
providing an <code class="docutils literal notranslate"><span class="pre">Ipv4InterfaceContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">Ipv4</span></code> / interface pair in
the container the protocol type is checked. For each protocol of the proper type
(the same type as is managed by the device helper), tracing is enabled for the
corresponding interface.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">interfaces</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on a collection of protocol/interface pairs by
providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> the
appropriate protocol is found. For each protocol, its interfaces are enumerated
and tracing is enabled on the resulting pairs. For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable pcap tracing on the basis of node ID and interface as well. In
this case, the node-id is translated to a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> and the appropriate
protocol is looked up in the node. The resulting protocol and interface are used
to specify the resulting trace source.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, you can enable pcap tracing for all interfaces in the system, with
associated protocol being the same type as that managed by the device helper.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnablePcapIpv4All</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="pcap-tracing-protocol-helper-filename-selection">
<h4><span class="section-number">3.3.4.3.2. </span>Pcap Tracing Protocol Helper Filename Selection<a class="headerlink" href="#pcap-tracing-protocol-helper-filename-selection" title="Link to this heading">¶</a></h4>
<p>Implicit in all of the method descriptions above is the construction of the
complete filenames by the implementation method. By convention, pcap traces
taken for devices in the <em>ns-3</em> system are of the form <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;-&lt;node</span>
<span class="pre">id&gt;-&lt;device</span> <span class="pre">id&gt;.pcap</span></code>. In the case of protocol traces, there is a one-to-one
correspondence between protocols and <code class="docutils literal notranslate"><span class="pre">Nodes</span></code>. This is because protocol
<code class="docutils literal notranslate"><span class="pre">Objects</span></code> are aggregated to <code class="docutils literal notranslate"><span class="pre">Node</span> <span class="pre">Objects</span></code>. Since there is no global
protocol id in the system, we use the corresponding node id in file naming.
Therefore there is a possibility for file name collisions in automatically
chosen trace file names. For this reason, the file name convention is changed
for protocol traces.</p>
<p>As previously mentioned, every node in the system will have a system-assigned
node id. Since there is a one-to-one correspondence between protocol instances
and node instances we use the node id. Each interface has an interface id
relative to its protocol. We use the convention “&lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface
id&gt;.pcap” for trace file naming in protocol helpers.</p>
<p>Therefore, by default, a pcap trace file created as a result of enabling tracing
on interface 1 of the Ipv4 protocol of node 21 using the prefix “prefix”
would be “prefix-n21-i1.pcap”.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more clear.
For example, if you use the object name service to assign the name “serverIpv4”
to the Ptr&lt;Ipv4&gt; on node 21, the resulting pcap trace file name will
automatically become, “prefix-nserverIpv4-i1.pcap”.</p>
</section>
</section>
<section id="ascii-tracing-protocol-helpers">
<h3><span class="section-number">3.3.4.4. </span>Ascii Tracing Protocol Helpers<a class="headerlink" href="#ascii-tracing-protocol-helpers" title="Link to this heading">¶</a></h3>
<p>The behavior of the ASCII trace helpers is substantially similar to the pcap
case.  Take a look at <code class="docutils literal notranslate"><span class="pre">src/network/helper/trace-helper.h</span></code> if you want to follow the
discussion while looking at real code.</p>
<p>In this section we will be illustrating the methods as applied to the protocol
<code class="docutils literal notranslate"><span class="pre">Ipv4</span></code>. To specify traces in similar protocols, just substitute the
appropriate type. For example, use a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv6&gt;</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code>
and call <code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv6</span></code> instead of <code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv4</span></code>.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">AsciiTraceHelperForIpv4</span></code> adds the high level functionality for
using ASCII tracing to a protocol helper. Each protocol that enables these
methods must implement a single virtual method inherited from this class.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4Internal</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The signature of this method reflects the protocol- and interface-centric view
of the situation at this level; and also the fact that the helper may be writing
to a shared output stream.  All of the public methods inherited from class
<code class="docutils literal notranslate"><span class="pre">PcapAndAsciiTraceHelperForIpv4</span></code> reduce to calling this single device-
dependent implementation method. For example, the lowest level ascii trace
methods,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
</pre></div>
</div>
<p>will call the device implementation of <code class="docutils literal notranslate"><span class="pre">EnableAsciiIpv4Internal</span></code> directly,
providing either the prefix or the stream. All other public ascii tracing
methods will build on these low-level functions to provide additional user-level
functionality. What this means to the user is that all device helpers in the
system will have all of the ascii trace methods available; and these methods
will all work in the same way across protocols if the protocols implement
<code class="docutils literal notranslate"><span class="pre">EnablAsciiIpv4Internal</span></code> correctly.</p>
<section id="id1">
<h4><span class="section-number">3.3.4.4.1. </span>Ascii Tracing Device Helper Methods<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ipv4Name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ipv4Name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceid</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nodeid</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4All</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">EnableAsciiIpv4All</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>You are encouraged to peruse the Doxygen for class <code class="docutils literal notranslate"><span class="pre">PcapAndAsciiHelperForIpv4</span></code>
to find the details of these methods; but to summarize …</p>
<p>There are twice as many methods available for ASCII tracing as there were for
pcap tracing. This is because, in addition to the pcap-style model where traces
from each unique protocol/interface pair are written to a unique file, we
support a model in which trace information for many protocol/interface pairs is
written to a common file. This means that the &lt;prefix&gt;-n&lt;node id&gt;-&lt;interface&gt;
file name generation mechanism is replaced by a mechanism to refer to a common
file; and the number of API methods is doubled to allow all combinations.</p>
<p>Just as in pcap tracing, you can enable ASCII tracing on a particular
protocol/interface pair by providing a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> and an <code class="docutils literal notranslate"><span class="pre">interface</span></code> to an
<code class="docutils literal notranslate"><span class="pre">EnableAscii</span></code> method.  For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ipv4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, no trace contexts are written to the ASCII trace file since they
would be redundant. The system will pick the file name to be created using the
same rules as described in the pcap section, except that the file will have the
suffix “.tr” instead of “.pcap”.</p>
<p>If you want to enable ASCII tracing on more than one interface and have all
traces sent to a single file, you can do that as well by using an object to
refer to a single file. We have already something similar to this in the “cwnd”
example above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">protocol1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">protocol2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">protocol1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">protocol2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, trace contexts are written to the ASCII trace file since they are
required to disambiguate traces from the two interfaces. Note that since the
user is completely specifying the file name, the string should include the “.tr”
for consistency.</p>
<p>You can enable ASCII tracing on a particular protocol by providing a
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> representing an object name service string to an <code class="docutils literal notranslate"><span class="pre">EnablePcap</span></code>
method.  The <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Ipv4&gt;</span></code> is looked up from the name string.  The <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> in
the resulting filenames is implicit since there is a one-to-one correspondence
between protocol instances and nodes, For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node1Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node2Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node1Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node2Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in two files named “prefix-nnode1Ipv4-i1.tr” and
“prefix-nnode2Ipv4-i1.tr” with traces for each interface in the respective
trace file. Since all of the EnableAscii functions are overloaded to take a
stream wrapper, you can use that form as well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node1Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="n">Names</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="s">&quot;node2Ipv4&quot;</span><span class="w"> </span><span class="p">...);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node1Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;node2Ipv4&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a single trace file called “trace-file-name.tr” that
contains all of the trace events for both interfaces. The events would be
disambiguated by trace context strings.</p>
<p>You can enable ASCII tracing on a collection of protocol/interface pairs by
providing an <code class="docutils literal notranslate"><span class="pre">Ipv4InterfaceContainer</span></code>. For each protocol of the proper type
(the same type as is managed by the device helper), tracing is enabled for the
corresponding interface.  Again, the <code class="docutils literal notranslate"><span class="pre">&lt;Node&gt;</span></code> is implicit since there is a
one-to-one correspondence between each protocol and its node. For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">interfaces</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, each of which
follows the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface&gt;.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="s">&quot;10.1.1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;255.255.255.0&quot;</span><span class="p">);</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">interfaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">OutputStreamWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asciiTraceHelper</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;trace-file-name.tr&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">interfaces</span><span class="p">);</span>
</pre></div>
</div>
<p>You can enable ASCII tracing on a collection of protocol/interface pairs by
providing a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>. For each <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> the
appropriate protocol is found.  For each protocol, its interfaces are enumerated
and tracing is enabled on the resulting pairs. For example,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, each of which
follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:</p>
<p>You can enable pcap tracing on the basis of node ID and device ID as well. In
this case, the node-id is translated to a <code class="docutils literal notranslate"><span class="pre">Ptr&lt;Node&gt;</span></code> and the appropriate
protocol is looked up in the node.  The resulting protocol and interface are
used to specify the resulting trace source.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Of course, the traces can be combined into a single file as shown above.</p>
<p>Finally, you can enable ASCII tracing for all interfaces in the system, with
associated protocol being the same type as that managed by the device helper.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">helper</span><span class="p">.</span><span class="n">EnableAsciiIpv4All</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This would result in a number of ASCII trace files being created, one for
every interface in the system related to a protocol of the type managed by the
helper. All of these files will follow the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface.tr
convention. Combining all of the traces into a single file is accomplished
similarly to the examples above.</p>
</section>
<section id="id2">
<h4><span class="section-number">3.3.4.4.2. </span>Ascii Tracing Device Helper Filename Selection<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<p>Implicit in the prefix-style method descriptions above is the construction of
the complete filenames by the implementation method. By convention, ASCII traces
in the <em>ns-3</em> system are of the form “&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr.”</p>
<p>As previously mentioned, every node in the system will have a system-assigned
node id. Since there is a one-to-one correspondence between protocols and nodes
we use to node-id to identify the protocol identity. Every interface on a given
protocol will have an interface index (also called simply an interface) relative
to its protocol. By default, then, an ASCII trace file created as a result of
enabling tracing on the first device of node 21, using the prefix “prefix”,
would be “prefix-n21-i1.tr”. Use the prefix to disambiguate multiple protocols
per node.</p>
<p>You can always use the <em>ns-3</em> object name service to make this more clear.
For example, if you use the object name service to assign the name “serverIpv4”
to the protocol on node 21, and also specify interface one, the resulting ASCII
trace file name will automatically become, “prefix-nserverIpv4-1.tr”.</p>
</section>
</section>
</section>
<section id="tracing-implementation-details">
<h2><span class="section-number">3.3.5. </span>Tracing implementation details<a class="headerlink" href="#tracing-implementation-details" title="Link to this heading">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">3.3. Tracing</a><ul>
<li><a class="reference internal" href="#tracing-motivation">3.3.1. Tracing Motivation</a></li>
<li><a class="reference internal" href="#overview">3.3.2. Overview</a><ul>
<li><a class="reference internal" href="#the-simplest-example">3.3.2.1. The Simplest Example</a></li>
<li><a class="reference internal" href="#using-the-config-subsystem-to-connect-to-trace-sources">3.3.2.2. Using the Config Subsystem to Connect to Trace Sources</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-tracing-api">3.3.3. Using the Tracing API</a></li>
<li><a class="reference internal" href="#using-trace-helpers">3.3.4. Using Trace Helpers</a><ul>
<li><a class="reference internal" href="#pcap-tracing-device-helpers">3.3.4.1. Pcap Tracing Device Helpers</a><ul>
<li><a class="reference internal" href="#pcap-tracing-device-helper-methods">3.3.4.1.1. Pcap Tracing Device Helper Methods</a></li>
<li><a class="reference internal" href="#pcap-tracing-device-helper-filename-selection">3.3.4.1.2. Pcap Tracing Device Helper Filename Selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ascii-tracing-device-helpers">3.3.4.2. Ascii Tracing Device Helpers</a><ul>
<li><a class="reference internal" href="#ascii-tracing-device-helper-methods">3.3.4.2.1. Ascii Tracing Device Helper Methods</a></li>
<li><a class="reference internal" href="#ascii-tracing-device-helper-filename-selection">3.3.4.2.2. Ascii Tracing Device Helper Filename Selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pcap-tracing-protocol-helpers">3.3.4.3. Pcap Tracing Protocol Helpers</a><ul>
<li><a class="reference internal" href="#pcap-tracing-protocol-helper-methods">3.3.4.3.1. Pcap Tracing Protocol Helper Methods</a></li>
<li><a class="reference internal" href="#pcap-tracing-protocol-helper-filename-selection">3.3.4.3.2. Pcap Tracing Protocol Helper Filename Selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ascii-tracing-protocol-helpers">3.3.4.4. Ascii Tracing Protocol Helpers</a><ul>
<li><a class="reference internal" href="#id1">3.3.4.4.1. Ascii Tracing Device Helper Methods</a></li>
<li><a class="reference internal" href="#id2">3.3.4.4.2. Ascii Tracing Device Helper Filename Selection</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tracing-implementation-details">3.3.5. Tracing implementation details</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="hash-functions.html"
                          title="previous chapter"><span class="section-number">3.2. </span>Hash Functions</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="data-collection.html"
                          title="next chapter"><span class="section-number">3.4. </span>Data Collection</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tracing.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="data-collection.html" title="3.4. Data Collection"
             >next</a> |</li>
        <li class="right" >
          <a href="hash-functions.html" title="3.2. Hash Functions"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Manual</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="features.html" ><span class="section-number">3. </span>Additional Tools</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3.3. </span>Tracing</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006-2019, ns-3 project.
      Last updated on Mar 20, 2024 11:47.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>