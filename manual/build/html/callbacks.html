
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2.2. Callbacks &#8212; Manual</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/default.css?v=bb97339c" />
    <script src="_static/documentation_options.js?v=316584e3"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.3. Object model" href="object-model.html" />
    <link rel="prev" title="2.1. Events and Simulator" href="events.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico"
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>


  </head><body>
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" width="100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo">
              <a id="ns3_home1"
                 href="http://www.nsnam.org/">
                 <img alt="ns-3 Logo" style="background-color: unset;"
                      src="_static/ns-3-inverted-notext-small.png"/>
              </a>
            </td>
            <td id="projecttext">
              <div id="projectbrief">A Discrete-Event Network Simulator</div>
              <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
            </td>

            <td id="ns3-menu">
              <div class="menu">
                <ul >
                  <li style="background-image:none">
                    <a id="ns3_home2"
                         href="http://www.nsnam.org/"
                         >&nbsp;&nbsp;Home</a>
                  </li>
                  <li><span
                        onmouseover="mopen('mTuts')"
                        onmouseout="mclosetime()"
                          >Tutorials &nbsp;&#x25BC;</span>
                      <div id="mTuts"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_tut"
                           href="/docs/tutorial/html/index.html"
                            >English</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDocs')"
                        onmouseout="mclosetime()"
                          >Documentation &nbsp;&#x25BC;</span>
                      <div id="mDocs"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_ins"
                           href="/docs/installation/html/index.html"
                           >Installation</a><br/>
                        <a id="ns3_man"
                           href="/docs/manual/html/index.html"
                           >Manual</a><br/>
                        <a id="ns3_mod"
                           href="/docs/models/html/index.html"
                           >Models</a><br/>
                        <a id="ns3_con"
                           href="/docs/contributing/html/index.html"
                           >Contributing</a><br/>
                        <a id="ns3_wiki"
                           href="http://www.nsnam.org/wiki"
                           >Wiki</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDev')"
                        onmouseout="mclosetime()"
                          >Development &nbsp;&#x25BC;</span>
                      <div id="mDev"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_api"
                           href="/docs/doxygen/html/index.html"
                           >API Docs</a><br/>
                        <a id="ns3_bugs"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/issues"
                           >Issue Tracker</a><br/>
                        <a id="ns3_merge"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests"
                           >Merge Requests</a><br/>
                      </div>
                  </li>
                </ul>
              </div>
            </td>

            <td id="projectsection">
              <span style="margin-right:10px">Manual</span>
            </td>
          </tr>
        </tbody>
      </table>
      <script  type="text/javascript">ns3_write_links()</script>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="object-model.html" title="2.3. Object model"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="events.html" title="2.1. Events and Simulator"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Manual</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="simulator.html" accesskey="U"><span class="section-number">2. </span>Simulator</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.2. </span>Callbacks</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="callbacks">
<h1><span class="section-number">2.2. </span>Callbacks<a class="headerlink" href="#callbacks" title="Link to this heading">¶</a></h1>
<p>Some new users to <em>ns-3</em> are unfamiliar with an extensively used programming
idiom used throughout the code: the <em>ns-3 callback</em>. This chapter provides some
motivation on the callback, guidance on how to use it, and details on its
implementation.</p>
<section id="callbacks-motivation">
<h2><span class="section-number">2.2.1. </span>Callbacks Motivation<a class="headerlink" href="#callbacks-motivation" title="Link to this heading">¶</a></h2>
<p>Consider that you have two simulation models A and B, and you wish to have them
pass information between them during the simulation. One way that you can do
that is that you can make A and B each explicitly knowledgeable about the other,
so that they can invoke methods on each other:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">ReceiveInput</span><span class="p">(</span><span class="w"> </span><span class="cm">/* parameters */</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and in another source file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DoSomething</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">a_instance</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointer to an A</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">B</span><span class="o">::</span><span class="n">DoSomething</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Tell a_instance that something happened</span>
<span class="w">  </span><span class="n">a_instance</span><span class="o">-&gt;</span><span class="n">ReceiveInput</span><span class="p">(</span><span class="w"> </span><span class="cm">/* parameters */</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This certainly works, but it has the drawback that it introduces a dependency on
A and B to know about the other at compile time (this makes it harder to have
independent compilation units in the simulator) and is not generalized; if in a
later usage scenario, B needs to talk to a completely different C object, the
source code for B needs to be changed to add a <code class="docutils literal notranslate"><span class="pre">c_instance</span></code> and so forth. It
is easy to see that this is a brute force mechanism of communication that can
lead to programming cruft in the models.</p>
<p>This is not to say that objects should not know about one another if there is a
hard dependency between them, but that often the model can be made more flexible
if its interactions are less constrained at compile time.</p>
<p>This is not an abstract problem for network simulation research, but rather it
has been a source of problems in previous simulators, when researchers want to
extend or modify the system to do different things (as they are apt to do in
research). Consider, for example, a user who wants to add an IPsec security
protocol sublayer between TCP and IP:</p>
<p>If the simulator has made assumptions, and hard coded into the code, that IP
always talks to a transport protocol above, the user may be forced to hack the
system to get the desired interconnections. This is clearly not an optimal way
to design a generic simulator.</p>
</section>
<section id="callbacks-background">
<h2><span class="section-number">2.2.2. </span>Callbacks Background<a class="headerlink" href="#callbacks-background" title="Link to this heading">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Readers familiar with programming callbacks may skip this tutorial
section.</p>
</div>
<p>The basic mechanism that allows one to address the problem above is known as a
<em>callback</em>. The ultimate goal is to allow one piece of code to call a function
(or method in C++) without any specific inter-module dependency.</p>
<p>This ultimately means you need some kind of indirection – you treat the address
of the called function as a variable.  This variable is called a
pointer-to-function variable. The relationship between function and
pointer-to-function pointer is really no different that that of object and
pointer-to-object.</p>
<p>In C the canonical example of a pointer-to-function is a
pointer-to-function-returning-integer (PFI). For a PFI taking one int parameter,
this could be declared like,:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pfi</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>What you get from this is a variable named simply <code class="docutils literal notranslate"><span class="pre">pfi</span></code> that is initialized to
the value 0. If you want to initialize this pointer to something meaningful, you
have to have a function with a matching signature. In this case:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">MyFunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>If you have this target, you can initialize the variable to point to your
function like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pfi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyFunction</span><span class="p">;</span>
</pre></div>
</div>
<p>You can then call MyFunction indirectly using the more suggestive form of the
call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pfi</span><span class="p">)(</span><span class="mi">1234</span><span class="p">);</span>
</pre></div>
</div>
<p>This is suggestive since it looks like you are dereferencing the function
pointer just like you would dereference any pointer. Typically, however, people
take advantage of the fact that the compiler knows what is going on and will
just use a shorter form:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfi</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
</pre></div>
</div>
<p>Notice that the function pointer obeys value semantics, so you can pass it
around like any other value. Typically, when you use an asynchronous interface
you will pass some entity like this to a function which will perform an action
and <em>call back</em> to let you know it completed. It calls back by following the
indirection and executing the provided function.</p>
<p>In C++ you have the added complexity of objects. The analogy with the PFI above
means you have a pointer to a member function returning an int (PMI) instead of
the pointer to function returning an int (PFI).</p>
<p>The declaration of the variable providing the indirection looks only slightly
different:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">MyClass</span><span class="o">::*</span><span class="n">pmi</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This declares a variable named <code class="docutils literal notranslate"><span class="pre">pmi</span></code> just as the previous example declared a
variable named <code class="docutils literal notranslate"><span class="pre">pfi</span></code>. Since the will be to call a method of an instance of a
particular class, one must declare that method in a class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">MyMethod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Given this class declaration, one would then initialize that variable like
this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">pmi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">MyMethod</span><span class="p">;</span>
</pre></div>
</div>
<p>This assigns the address of the code implementing the method to the variable,
completing the indirection. In order to call a method, the code needs a <code class="docutils literal notranslate"><span class="pre">this</span></code>
pointer. This, in turn, means there must be an object of MyClass to refer to. A
simplistic example of this is just calling a method indirectly (think virtual
function):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">MyClass</span><span class="o">::*</span><span class="n">pmi</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="c1">// Declare a PMI</span>
<span class="n">pmi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">MyMethod</span><span class="p">;</span><span class="w">           </span><span class="c1">// Point at the implementation code</span>

<span class="n">MyClass</span><span class="w"> </span><span class="n">myClass</span><span class="p">;</span><span class="w">                    </span><span class="c1">// Need an instance of the class</span>
<span class="p">(</span><span class="n">myClass</span><span class="p">.</span><span class="o">*</span><span class="n">pmi</span><span class="p">)(</span><span class="mi">1234</span><span class="p">);</span><span class="w">              </span><span class="c1">// Call the method with an object ptr</span>
</pre></div>
</div>
<p>Just like in the C example, you can use this in an asynchronous call to another
module which will <em>call back</em> using a method and an object pointer. The
straightforward extension one might consider is to pass a pointer to the object
and the PMI variable. The module would just do:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="n">objectPtr</span><span class="p">.</span><span class="o">*</span><span class="n">pmi</span><span class="p">)(</span><span class="mi">1234</span><span class="p">);</span>
</pre></div>
</div>
<p>to execute the callback on the desired object.</p>
<p>One might ask at this time, <em>what’s the point</em>? The called module will have to
understand the concrete type of the calling object in order to properly make the
callback. Why not just accept this, pass the correctly typed object pointer and
do <code class="docutils literal notranslate"><span class="pre">object-&gt;Method(1234)</span></code> in the code instead of the callback?  This is
precisely the problem described above. What is needed is a way to decouple the
calling function from the called class completely. This requirement led to the
development of the <em>Functor</em>.</p>
<p>A functor is the outgrowth of something invented in the 1960s called a closure.
It is basically just a packaged-up function call, possibly with some state.</p>
<p>A functor has two parts, a specific part and a generic part, related through
inheritance. The calling code (the code that executes the callback) will execute
a generic overloaded <code class="docutils literal notranslate"><span class="pre">operator()</span></code> of a generic functor to cause the callback
to be called. The called code (the code that wants to be called back) will have
to provide a specialized implementation of the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> that performs the
class-specific work that caused the close-coupling problem above.</p>
<p>With the specific functor and its overloaded <code class="docutils literal notranslate"><span class="pre">operator()</span></code> created, the called
code then gives the specialized code to the module that will execute the
callback (the calling code).</p>
<p>The calling code will take a generic functor as a parameter, so an implicit cast
is done in the function call to convert the specific functor to a generic
functor.  This means that the calling module just needs to understand the
generic functor type. It is decoupled from the calling code completely.</p>
<p>The information one needs to make a specific functor is the object pointer and
the pointer-to-method address.</p>
<p>The essence of what needs to happen is that the system declares a generic part
of the functor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Functor</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The caller defines a specific part of the functor that really is just there to
implement the specific <code class="docutils literal notranslate"><span class="pre">operator()</span></code> method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ARG</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SpecificFunctor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Functor</span><span class="o">&lt;</span><span class="n">ARG</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">SpecificFunctor</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="n">_pmi</span><span class="p">)(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">m_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">m_pmi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_pmi</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">m_p</span><span class="p">.</span><span class="o">*</span><span class="n">m_pmi</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="n">m_pmi</span><span class="p">)(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">m_p</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here is an example of the usage:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a0</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">Hello</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">b0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello from A, a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; b0 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b0</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">  </span><span class="n">SpecificFunctor</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">Hello</span><span class="p">);</span>
<span class="w">  </span><span class="n">sf</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The previous code is not real ns-3 code.  It is simplistic example
code used only to illustrate the concepts involved and to help you understand
the system more.  Do not expect to find this code anywhere in the ns-3 tree.</p>
</div>
<p>Notice that there are two variables defined in the class above.  The m_p
variable is the object pointer and m_pmi is the variable containing the
address of the function to execute.</p>
<p>Notice that when <code class="docutils literal notranslate"><span class="pre">operator()</span></code> is called, it in turn calls the method provided
with the object pointer using the C++ PMI syntax.</p>
<p>To use this, one could then declare some model code that takes a generic functor
as a parameter:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">LibraryFunction</span><span class="p">(</span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">);</span>
</pre></div>
</div>
<p>The code that will talk to the model would build a specific functor and pass it to <code class="docutils literal notranslate"><span class="pre">LibraryFunction</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span><span class="w"> </span><span class="n">myClass</span><span class="p">;</span>
<span class="n">SpecificFunctor</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">functor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myclass</span><span class="p">,</span><span class="w"> </span><span class="n">MyClass</span><span class="o">::</span><span class="n">MyMethod</span><span class="p">);</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">LibraryFunction</span></code> is done, it executes the callback using the
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> on the generic functor it was passed, and in this particular
case, provides the integer argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">LibraryFunction</span><span class="p">(</span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Execute the library function</span>
<span class="w">  </span><span class="n">functor</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">LibraryFunction</span></code> is completely decoupled from the specific
type of the client.  The connection is made through the Functor polymorphism.</p>
<p>The Callback API in <em>ns-3</em> implements object-oriented callbacks using
the functor mechanism.  This callback API, being based on C++ templates, is
type-safe; that is, it performs static type checks to enforce proper signature
compatibility between callers and callees.  It is therefore more type-safe to
use than traditional function pointers, but the syntax may look imposing at
first.  This section is designed to walk you through the Callback system so
that you can be comfortable using it in <em>ns-3</em>.</p>
</section>
<section id="using-the-callback-api">
<h2><span class="section-number">2.2.3. </span>Using the Callback API<a class="headerlink" href="#using-the-callback-api" title="Link to this heading">¶</a></h2>
<p>The Callback API is fairly minimal, providing only two services:</p>
<p>1. callback type declaration: a way to declare a type of callback
with a given signature, and,</p>
<p>2. callback instantiation: a way to instantiate a
template-generated forwarding callback which can forward any calls
to another C++ class member method or C++ function.</p>
<p>This is best observed via walking through an example, based on
<code class="docutils literal notranslate"><span class="pre">samples/main-callback.cc</span></code>.</p>
<section id="using-the-callback-api-with-static-functions">
<h3><span class="section-number">2.2.3.1. </span>Using the Callback API with static functions<a class="headerlink" href="#using-the-callback-api-with-static-functions" title="Link to this heading">¶</a></h3>
<p>Consider a function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">double</span>
<span class="nf">CbOne</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;invoke cbOne a=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, b=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Consider also the following main program snippet:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// return type: double</span>
<span class="w">  </span><span class="c1">// first arg type: double</span>
<span class="w">  </span><span class="c1">// second arg type: double</span>
<span class="w">  </span><span class="n">Callback</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">one</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is an example of a C-style callback – one which does not include or need
a <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer.  The function template <code class="docutils literal notranslate"><span class="pre">Callback</span></code> is essentially the
declaration of the variable containing the pointer-to-function.  In the example
above, we explicitly showed a pointer to a function that returned an integer and
took a single integer as a parameter,  The <code class="docutils literal notranslate"><span class="pre">Callback</span></code> template function is
a generic version of that – it is used to declare the type of a callback.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Readers unfamiliar with C++ templates may consult <a class="reference external" href="http://www.cplusplus.com/doc/tutorial/templates/">http://www.cplusplus.com/doc/tutorial/templates/</a>.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Callback</span></code> template requires one mandatory argument (the return type
of the function to be assigned to this callback) and up to five optional
arguments, which each specify the type of the arguments (if your particular
callback function has more than five arguments, then this can be handled
by extending the callback implementation).</p>
<p>So in the above example, we have a declared a callback named “one” that will
eventually hold a function pointer.  The signature of the function that it will
hold must return double and must support two double arguments.  If one tries
to pass a function whose signature does not match the declared callback,
a compilation error will occur.  Also, if one tries to assign to a callback
an incompatible one, compilation will succeed but a run-time
NS_FATAL_ERROR will be raised.  The sample program
<code class="docutils literal notranslate"><span class="pre">src/core/examples/main-callback.cc</span></code> demonstrates both of these error cases
at the end of the <code class="docutils literal notranslate"><span class="pre">main()</span></code> program.</p>
<p>Now, we need to tie together this callback instance and the actual target function
(CbOne).  Notice above that CbOne has the same function signature types as the
callback– this is important.  We can pass in any such properly-typed function
to this callback.  Let’s look at this more closely:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="nf">CbOne</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">           </span><span class="o">^</span><span class="w">             </span><span class="o">^</span><span class="w">         </span><span class="o">^</span>
<span class="w">           </span><span class="o">|</span><span class="w">             </span><span class="o">|</span><span class="w">         </span><span class="o">|</span>
<span class="w">           </span><span class="o">|</span><span class="w">             </span><span class="o">|</span><span class="w">         </span><span class="o">|</span>
<span class="n">Callback</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w">       </span><span class="kt">double</span><span class="p">,</span><span class="w">   </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">one</span><span class="p">;</span>
</pre></div>
</div>
<p>You can only bind a function to a callback if they have the matching signature.
The first template argument is the return type, and the additional template
arguments are the types of the arguments of the function signature.</p>
<p>Now, let’s bind our callback “one” to the function that matches its signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// build callback instance which points to cbOne function</span>
<span class="n">one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CbOne</span><span class="p">);</span>
</pre></div>
</div>
<p>This call to <code class="docutils literal notranslate"><span class="pre">MakeCallback</span></code> is, in essence, creating one of the specialized
functors mentioned above.  The variable declared using the <code class="docutils literal notranslate"><span class="pre">Callback</span></code>
template function is going to be playing the part of the generic functor.  The
assignment <code class="docutils literal notranslate"><span class="pre">one</span> <span class="pre">=</span> <span class="pre">MakeCallback(&amp;CbOne)</span></code> is the cast that converts the
specialized functor known to the callee to a generic functor known to the caller.</p>
<p>Then, later in the program, if the callback is needed, it can be used as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NS_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">one</span><span class="p">.</span><span class="n">IsNull</span><span class="p">());</span>

<span class="c1">// invoke cbOne function through callback instance</span>
<span class="kt">double</span><span class="w"> </span><span class="n">retOne</span><span class="p">;</span>
<span class="n">retOne</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">one</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span><span class="w"> </span><span class="mf">20.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The check for <code class="docutils literal notranslate"><span class="pre">IsNull()</span></code> ensures that the callback is not null – that there
is a function to call behind this callback.  Then, <code class="docutils literal notranslate"><span class="pre">one()</span></code> executes the
generic <code class="docutils literal notranslate"><span class="pre">operator()</span></code> which is really overloaded with a specific implementation
of <code class="docutils literal notranslate"><span class="pre">operator()</span></code> and returns the same result as if <code class="docutils literal notranslate"><span class="pre">CbOne()</span></code> had been
called directly.</p>
</section>
<section id="using-the-callback-api-with-member-functions">
<h3><span class="section-number">2.2.3.2. </span>Using the Callback API with member functions<a class="headerlink" href="#using-the-callback-api-with-member-functions" title="Link to this heading">¶</a></h3>
<p>Generally, you will not be calling static functions but instead public member
functions of an object.  In this case, an extra argument is needed to the
MakeCallback function, to tell the system on which object the function should be
invoked.  Consider this example, also from main-callback.cc:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyCb</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">CbTwo</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;invoke cbTwo a=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-5</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// return type: int</span>
<span class="w">  </span><span class="c1">// first arg type: double</span>
<span class="w">  </span><span class="n">Callback</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">two</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyCb</span><span class="w"> </span><span class="n">cb</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// build callback instance which points to MyCb::cbTwo</span>
<span class="w">  </span><span class="n">two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyCb</span><span class="o">::</span><span class="n">CbTwo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we pass an additional object pointer to the <code class="docutils literal notranslate"><span class="pre">MakeCallback&lt;&gt;</span></code> function.
Recall from the background section above that <code class="docutils literal notranslate"><span class="pre">Operator()</span></code> will use the pointer to
member syntax when it executes on an object:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">m_p</span><span class="p">.</span><span class="o">*</span><span class="n">m_pmi</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And so we needed to provide the two variables (<code class="docutils literal notranslate"><span class="pre">m_p</span></code> and <code class="docutils literal notranslate"><span class="pre">m_pmi</span></code>) when
we made the specific functor.  The line:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyCb</span><span class="o">::</span><span class="n">CbTwo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<p>does precisely that.  In this case, when <code class="docutils literal notranslate"><span class="pre">two()</span></code> is invoked:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">two</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>will result in a call to the <code class="docutils literal notranslate"><span class="pre">CbTwo</span></code> member function (method) on the object
pointed to by <code class="docutils literal notranslate"><span class="pre">&amp;cb</span></code>.</p>
</section>
<section id="building-null-callbacks">
<h3><span class="section-number">2.2.3.3. </span>Building Null Callbacks<a class="headerlink" href="#building-null-callbacks" title="Link to this heading">¶</a></h3>
<p>It is possible for callbacks to be null; hence it may be wise to
check before using them.  There is a special construct for a null
callback, which is preferable to simply passing “0” as an argument;
it is the <code class="docutils literal notranslate"><span class="pre">MakeNullCallback&lt;&gt;</span></code> construct:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeNullCallback</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">NS_ASSERT</span><span class="p">(</span><span class="n">two</span><span class="p">.</span><span class="n">IsNull</span><span class="p">());</span>
</pre></div>
</div>
<p>Invoking a null callback is just like invoking a null function pointer: it will
crash at runtime.</p>
</section>
</section>
<section id="bound-callbacks">
<h2><span class="section-number">2.2.4. </span>Bound Callbacks<a class="headerlink" href="#bound-callbacks" title="Link to this heading">¶</a></h2>
<p>A very useful extension to the functor concept is that of a Bound Callback.
Previously it was mentioned that closures were originally function calls
packaged up for later execution.  Notice that in all of the Callback
descriptions above, there is no way to package up any parameters for use
later – when the <code class="docutils literal notranslate"><span class="pre">Callback</span></code> is called via <code class="docutils literal notranslate"><span class="pre">operator()</span></code>.  All of
the parameters are provided by the calling function.</p>
<p>What if it is desired to allow the client function (the one that provides the
callback) to provide some of the parameters?
<a class="reference external" href="http://erdani.org/index.php/books/modern-c-design/index.html">Alexandrescu</a>
calls the process of allowing a client to specify one of the parameters <em>“binding”</em>.
One of the parameters of <code class="docutils literal notranslate"><span class="pre">operator()</span></code> has been bound (fixed) by the client.</p>
<p>Some of our pcap tracing code provides a nice example of this.  There is a
function that needs to be called whenever a packet is received.  This function
calls an object that actually writes the packet to disk in the pcap file
format.  The signature of one of these functions will be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DefaultSink</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PcapFileWrapper</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>The static keyword means this is a static function which does not need a
<code class="docutils literal notranslate"><span class="pre">this</span></code> pointer, so it will be using C-style callbacks.  We don’t want the
calling code to have to know about anything but the Packet.  What we want in
the calling code is just a call that looks like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m_promiscSnifferTrace</span><span class="p">(</span><span class="n">m_currentPkt</span><span class="p">);</span>
</pre></div>
</div>
<p>What we want to do is to <em>bind</em> the <code class="docutils literal notranslate"><span class="pre">Ptr&lt;PcapFileWriter&gt;</span> <span class="pre">file</span></code> to the
specific callback implementation when it is created and arrange for the
<code class="docutils literal notranslate"><span class="pre">operator()</span></code> of the Callback to provide that parameter for free.</p>
<p>We provide the <code class="docutils literal notranslate"><span class="pre">MakeBoundCallback</span></code> template function for that purpose.  It
takes the same parameters as the <code class="docutils literal notranslate"><span class="pre">MakeCallback</span></code> template function but also
takes the parameters to be bound.  In the case of the example above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DefaultSink</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span>
</pre></div>
</div>
<p>will create a specific callback implementation that knows to add in the extra
bound arguments.  Conceptually, it extends the specific functor described above
with one or more bound arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ARG</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BOUND_ARG</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SpecificFunctor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Functor</span>
<span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">SpecificFunctor</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="n">_pmi</span><span class="p">)(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">),</span><span class="w"> </span><span class="n">BOUND_ARG</span><span class="w"> </span><span class="n">boundArg</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">      </span><span class="n">m_pmi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pmi</span><span class="p">;</span>
<span class="w">      </span><span class="n">m_boundArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundArg</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">m_p</span><span class="p">.</span><span class="o">*</span><span class="n">m_pmi</span><span class="p">)(</span><span class="n">m_boundArg</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="n">m_pmi</span><span class="p">)(</span><span class="n">ARG</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">m_p</span><span class="p">;</span>
<span class="w">    </span><span class="n">BOUND_ARG</span><span class="w"> </span><span class="n">m_boundArg</span><span class="p">;</span>
<span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>You can see that when the specific functor is created, the bound argument is saved
in the functor / callback object itself.  When the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> is invoked with
the single parameter, as in:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m_promiscSnifferTrace</span><span class="p">(</span><span class="n">m_currentPkt</span><span class="p">);</span>
</pre></div>
</div>
<p>the implementation of <code class="docutils literal notranslate"><span class="pre">operator()</span></code> adds the bound parameter into the actual
function call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="n">m_p</span><span class="p">.</span><span class="o">*</span><span class="n">m_pmi</span><span class="p">)(</span><span class="n">m_boundArg</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
<p>It’s possible to bind two or three arguments as well.  Say we have a function with
signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">NotifyEvent</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">MyEventType</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
</pre></div>
</div>
<p>One can create bound callback binding first two arguments like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NotifyEvent</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">);</span>
</pre></div>
</div>
<p>assuming <cite>a1</cite> and <cite>b1</cite> are objects of type <cite>A</cite> and <cite>B</cite> respectively.  Similarly for
three arguments one would have function with a signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">NotifyEvent</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">MyEventType</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
</pre></div>
</div>
<p>Binding three arguments in done with:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NotifyEvent</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">);</span>
</pre></div>
</div>
<p>again assuming <cite>a1</cite>, <cite>b1</cite> and <cite>c1</cite> are objects of type <cite>A</cite>, <cite>B</cite> and <cite>C</cite> respectively.</p>
<p>This kind of binding can be used for exchanging information between objects in
simulation; specifically, bound callbacks can be used as traced callbacks, which will
be described in the next section.</p>
</section>
<section id="traced-callbacks">
<h2><span class="section-number">2.2.5. </span>Traced Callbacks<a class="headerlink" href="#traced-callbacks" title="Link to this heading">¶</a></h2>
<p><em>Placeholder subsection</em></p>
</section>
<section id="callback-locations-in-ns-3">
<h2><span class="section-number">2.2.6. </span>Callback locations in ns-3<a class="headerlink" href="#callback-locations-in-ns-3" title="Link to this heading">¶</a></h2>
<p>Where are callbacks frequently used in <em>ns-3</em>?  Here are some of the
more visible ones to typical users:</p>
<ul class="simple">
<li><p>Socket API</p></li>
<li><p>Layer-2/Layer-3 API</p></li>
<li><p>Tracing subsystem</p></li>
<li><p>API between IP and routing subsystems</p></li>
</ul>
</section>
<section id="implementation-details">
<h2><span class="section-number">2.2.7. </span>Implementation details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h2>
<p>The code snippets above are simplistic and only designed to illustrate the mechanism
itself.  The actual Callback code is quite complicated and very template-intense and
a deep understanding of the code is not required.  If interested, expert users may
find the following useful.</p>
<p>The code was originally written based on the techniques described in
<a class="reference external" href="http://www.codeproject.com/cpp/TTLFunction.asp">http://www.codeproject.com/cpp/TTLFunction.asp</a>.
It was subsequently rewritten to follow the architecture outlined in
<a class="reference external" href="http://erdani.org/index.php/books/modern-c-design/index.html">Modern C++ Design, Generic Programming and Design Patterns Applied, Alexandrescu, chapter 5, Generalized Functors</a>.</p>
<p>This code uses:</p>
<ul class="simple">
<li><p>default template parameters to saves users from having to
specify empty parameters when the number of parameters
is smaller than the maximum supported number</p></li>
<li><p>the pimpl idiom: the Callback class is passed around by
value and delegates the crux of the work to its pimpl pointer.</p></li>
<li><p>two pimpl implementations which derive from CallbackImpl
FunctorCallbackImpl can be used with any functor-type
while MemPtrCallbackImpl can be used with pointers to
member functions.</p></li>
<li><p>a reference list implementation to implement the Callback’s
value semantics.</p></li>
</ul>
<p>This code most notably departs from the Alexandrescu implementation in that it
does not use type lists to specify and pass around the types of the callback
arguments. Of course, it also does not use copy-destruction semantics and
relies on a reference list rather than autoPtr to hold the pointer.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">2.2. Callbacks</a><ul>
<li><a class="reference internal" href="#callbacks-motivation">2.2.1. Callbacks Motivation</a></li>
<li><a class="reference internal" href="#callbacks-background">2.2.2. Callbacks Background</a></li>
<li><a class="reference internal" href="#using-the-callback-api">2.2.3. Using the Callback API</a><ul>
<li><a class="reference internal" href="#using-the-callback-api-with-static-functions">2.2.3.1. Using the Callback API with static functions</a></li>
<li><a class="reference internal" href="#using-the-callback-api-with-member-functions">2.2.3.2. Using the Callback API with member functions</a></li>
<li><a class="reference internal" href="#building-null-callbacks">2.2.3.3. Building Null Callbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bound-callbacks">2.2.4. Bound Callbacks</a></li>
<li><a class="reference internal" href="#traced-callbacks">2.2.5. Traced Callbacks</a></li>
<li><a class="reference internal" href="#callback-locations-in-ns-3">2.2.6. Callback locations in ns-3</a></li>
<li><a class="reference internal" href="#implementation-details">2.2.7. Implementation details</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="events.html"
                          title="previous chapter"><span class="section-number">2.1. </span>Events and Simulator</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="object-model.html"
                          title="next chapter"><span class="section-number">2.3. </span>Object model</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/callbacks.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="object-model.html" title="2.3. Object model"
             >next</a> |</li>
        <li class="right" >
          <a href="events.html" title="2.1. Events and Simulator"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Manual</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="simulator.html" ><span class="section-number">2. </span>Simulator</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.2. </span>Callbacks</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006-2019.
      Last updated on Nov 29, 2023 13:25.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>