%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

\usepackage{amssymb}
 \definecolor{VerbatimBorderColor}{rgb}{1,1,1}
 \renewcommand{\sphinxcode}[1]{\texttt{\small{#1}}}


\title{ns-3 Manual}
\date{Jan 19, 2024}
\release{ns\sphinxhyphen{}3.40}
\author{ns-3 project}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{ns-3.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
This is the \sphinxstyleemphasis{ns\sphinxhyphen{}3 Manual}. Primary documentation for the ns\sphinxhyphen{}3 project is organized as
follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Several guides that are version controlled for each release (the
\sphinxhref{https://www.nsnam.org/documentation/latest/}{latest release}) and
\sphinxhref{https://www.nsnam.org/ns-3-dev/documentation/}{development tree}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tutorial

\item {} 
\sphinxAtStartPar
Installation Guide

\item {} 
\sphinxAtStartPar
Manual \sphinxstyleemphasis{(this document)}

\item {} 
\sphinxAtStartPar
Model Library

\item {} 
\sphinxAtStartPar
Contributing Guide

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.nsnam.org/docs/doxygen/index.html}{ns\sphinxhyphen{}3 Doxygen}: Documentation of the public APIs of
the simulator

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.nsnam.org/wiki/Main\_Page}{ns\sphinxhyphen{}3 wiki}

\end{itemize}

\sphinxAtStartPar
This document is written in \sphinxhref{http://docutils.sourceforge.net/rst.html}{reStructuredText} for \sphinxhref{https://www.sphinx-doc.org/}{Sphinx} and is maintained in the
\sphinxcode{\sphinxupquote{doc/manual}} directory of ns\sphinxhyphen{}3’s source code.  Source file column width is 100 columns.

\sphinxstepscope


\chapter{Organization}
\label{\detokenize{organization:organization}}\label{\detokenize{organization::doc}}
\sphinxAtStartPar
This chapter describes the overall \sphinxstyleemphasis{ns\sphinxhyphen{}3} software organization and the
corresponding organization of this manual.

\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is a discrete\sphinxhyphen{}event network simulator in which the simulation core
and models are implemented in C++. \sphinxstyleemphasis{ns\sphinxhyphen{}3} is built as a library which may be
statically or dynamically linked to a C++ main program that defines the
simulation topology and starts the simulator. \sphinxstyleemphasis{ns\sphinxhyphen{}3} also exports nearly all
of its API to Python, allowing Python programs to import an “ns3” module in
much the same way as the \sphinxstyleemphasis{ns\sphinxhyphen{}3} library is linked by executables in C++.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{software-organization}.pdf}
\caption{Software organization of \sphinxstyleemphasis{ns\sphinxhyphen{}3}}\label{\detokenize{organization:id1}}\label{\detokenize{organization:software-organization}}\end{figure}

\sphinxAtStartPar
The source code for \sphinxstyleemphasis{ns\sphinxhyphen{}3} is mostly organized in the \sphinxcode{\sphinxupquote{src}} directory and
can be described by the diagram in {\hyperref[\detokenize{organization:software-organization}]{\sphinxcrossref{\DUrole{std,std-ref}{Software organization of ns\sphinxhyphen{}3}}}}. We will
work our way from the bottom up; in general, modules only have dependencies
on modules beneath them in the figure.

\sphinxAtStartPar
We first describe the core of the simulator; those components that are
common across all protocol, hardware, and environmental models.
The simulation core is implemented in \sphinxcode{\sphinxupquote{src/core}}. Packets are
fundamental objects in a network simulator
and are implemented in \sphinxcode{\sphinxupquote{src/network}}. These two simulation modules by
themselves are intended to comprise a generic simulation core that can be
used by different kinds of networks, not just Internet\sphinxhyphen{}based networks.  The
above modules of \sphinxstyleemphasis{ns\sphinxhyphen{}3} are independent of specific network and device
models, which are covered in subsequent parts of this manual.

\sphinxAtStartPar
In addition to the above \sphinxstyleemphasis{ns\sphinxhyphen{}3} core, we introduce, also in the initial
portion of the manual, two other modules that supplement the core C++\sphinxhyphen{}based
API.  \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs may access
all of the API directly or may make use of a so\sphinxhyphen{}called \sphinxstyleemphasis{helper API} that
provides convenient wrappers or encapsulation of low\sphinxhyphen{}level API calls. The
fact that \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs can be written to two APIs (or a combination
thereof) is a fundamental aspect of the simulator.
We also describe how Python is supported in \sphinxstyleemphasis{ns\sphinxhyphen{}3} before moving onto
specific models of relevance to network simulation.

\sphinxAtStartPar
The remainder of the manual is focused on documenting the models and
supporting capabilities.  The next part focuses on two fundamental objects in
\sphinxstyleemphasis{ns\sphinxhyphen{}3}:  the \sphinxcode{\sphinxupquote{Node}} and \sphinxcode{\sphinxupquote{NetDevice}}. Two special NetDevice types are
designed to support network emulation use cases, and emulation is described
next.  The following chapter is devoted to Internet\sphinxhyphen{}related models,
including the
sockets API used by Internet applications. The next chapter covers
applications, and the following chapter describes additional support for
simulation, such as animators and statistics.

\sphinxAtStartPar
The project maintains a manual section devoted to testing and validation
of \sphinxstyleemphasis{ns\sphinxhyphen{}3} code (see the \sphinxhref{https://www.nsnam.org/docs/manual/html/tests.html}{tests section in the ns\sphinxhyphen{}3 manual}).

\sphinxstepscope


\chapter{Simulator}
\label{\detokenize{simulator:simulator}}\label{\detokenize{simulator::doc}}
\sphinxAtStartPar
This chapter explains some of the core ns\sphinxhyphen{}3 simulator concepts.

\sphinxstepscope


\section{Events and Simulator}
\label{\detokenize{events:events-and-simulator}}\label{\detokenize{events::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is a discrete\sphinxhyphen{}event network simulator.  Conceptually, the simulator
keeps track of a number of events that are scheduled to execute at a
specified simulation time.  The job of the simulator is to execute the
events in sequential time order.  Once the completion of an event occurs,
the simulator will move to the next event (or will exit if there are no
more events in the event queue).  If, for example, an event scheduled
for simulation time “100 seconds” is executed, and the next event is not
scheduled until “200 seconds”, the simulator will immediately jump from
100 seconds to 200 seconds (of simulation time) to execute the next event.
This is what is meant by “discrete\sphinxhyphen{}event” simulator.

\sphinxAtStartPar
To make this all happen, the simulator needs a few things:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
a simulator object that can access an event queue where events are
stored and that can manage the execution of events

\item {} 
\sphinxAtStartPar
a scheduler responsible for inserting and removing events from the queue

\item {} 
\sphinxAtStartPar
a way to represent simulation time

\item {} 
\sphinxAtStartPar
the events themselves

\end{enumerate}

\sphinxAtStartPar
This chapter of the manual describes these fundamental objects
(simulator, scheduler, time, event) and how they are used.


\subsection{Event}
\label{\detokenize{events:event}}
\sphinxAtStartPar
\sphinxstyleemphasis{To be completed}


\subsection{Simulator}
\label{\detokenize{events:simulator}}
\sphinxAtStartPar
The Simulator class is the public entry point to access event scheduling
facilities. Once a couple of events have been scheduled to start the
simulation, the user can start to execute them by entering the simulator
main loop (call \sphinxcode{\sphinxupquote{Simulator::Run}}). Once the main loop starts running, it
will sequentially execute all scheduled events in order from oldest to
most recent until there are either no more events left in the event
queue or Simulator::Stop has been called.

\sphinxAtStartPar
To schedule events for execution by the simulator main loop, the
Simulator class provides the Simulator::Schedule* family of functions.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Handling event handlers with different signatures

\end{enumerate}

\sphinxAtStartPar
These functions are declared and implemented as C++ templates to handle
automatically the wide variety of C++ event handler signatures used in
the wild. For example, to schedule an event to execute 10 seconds in the
future, and invoke a C++ method or function with specific arguments, you
might write this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{handler}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg0}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg1}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{handler called with argument arg0=}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arg0}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and}
\PYG{+w}{     }\PYG{n}{arg1}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{}\PYGZlt{} arg1 \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{handler}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Which will output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
handler called with argument arg0=10 and arg1=5
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course, these C++ templates can also handle transparently member
methods on C++ objects:

\sphinxAtStartPar
\sphinxstyleemphasis{To be completed:  member method example}

\sphinxAtStartPar
Notes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Schedule methods recognize automatically functions and
methods only if they take less than 5 arguments. If you need them to
support more arguments, please, file a bug report.

\item {} 
\sphinxAtStartPar
Readers familiar with the term ‘fully\sphinxhyphen{}bound functors’ will recognize
the Simulator::Schedule methods as a way to automatically construct such
objects.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Common scheduling operations

\end{enumerate}

\sphinxAtStartPar
The Simulator API was designed to make it really simple to schedule most
events. It provides three variants to do so (ordered from most commonly
used to least commonly used):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Schedule methods which allow you to schedule an event in the future
by providing the delay between the current simulation time and the
expiration date of the target event.

\item {} 
\sphinxAtStartPar
ScheduleNow methods which allow you to schedule an event for the
current simulation time: they will execute \_after\_ the current event is
finished executing but \_before\_ the simulation time is changed for the
next event.

\item {} 
\sphinxAtStartPar
ScheduleDestroy methods which allow you to hook in the shutdown
process of the Simulator to cleanup simulation resources: every
‘destroy’ event is executed when the user calls the Simulator::Destroy
method.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Maintaining the simulation context

\end{enumerate}

\sphinxAtStartPar
There are two basic ways to schedule events, with and without \sphinxstyleemphasis{context}.
What does this mean?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule}\PYG{p}{(}\PYG{n}{Time}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{time}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MEM}\PYG{+w}{ }\PYG{n}{mem\PYGZus{}ptr}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{OBJ}\PYG{+w}{ }\PYG{n}{obj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
vs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ScheduleWithContext}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Time}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{time}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MEM}\PYG{+w}{ }\PYG{n}{mem\PYGZus{}ptr}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{OBJ}\PYG{+w}{ }\PYG{n}{obj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Readers who invest time and effort in developing or using a non\sphinxhyphen{}trivial
simulation model will know the value of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} logging framework to
debug simple and complex simulations alike. One of the important
features that is provided by this logging framework is the automatic
display of the network node id associated with the ‘currently’ running
event.

\sphinxAtStartPar
The node id of the currently executing network node is in fact tracked
by the Simulator class. It can be accessed with the
Simulator::GetContext method which returns the ‘context’ (a 32\sphinxhyphen{}bit
integer) associated and stored in the currently\sphinxhyphen{}executing event. In some
rare cases, when an event is not associated with a specific network
node, its ‘context’ is set to 0xffffffff.

\sphinxAtStartPar
To associate a context to each event, the Schedule, and ScheduleNow
methods automatically reuse the context of the currently\sphinxhyphen{}executing event
as the context of the event scheduled for execution later.

\sphinxAtStartPar
In some cases, most notably when simulating the transmission of a packet
from a node to another, this behavior is undesirable since the expected
context of the reception event is that of the receiving node, not the
sending node. To avoid this problem, the Simulator class provides a
specific schedule method: ScheduleWithContext which allows one to
provide explicitly the node id of the receiving node associated with
the receive event.

\sphinxAtStartPar
\sphinxstyleemphasis{XXX: code example}

\sphinxAtStartPar
In some very rare cases, developers might need to modify or understand
how the context (node id) of the first event is set to that of its
associated node. This is accomplished by the NodeList class: whenever a
new node is created, the NodeList class uses ScheduleWithContext to
schedule a ‘initialize’ event for this node. The ‘initialize’ event thus executes
with a context set to that of the node id and can use the normal variety
of Schedule methods. It invokes the Node::Initialize method which propagates
the ‘initialize’ event by calling the DoInitialize method for each object
associated with the node. The DoInitialize method overridden in some of these
objects (most notably in the Application base class) will schedule some
events (most notably Application::StartApplication) which will in turn
scheduling traffic generation events which will in turn schedule
network\sphinxhyphen{}level events.

\sphinxAtStartPar
Notes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Users need to be careful to propagate DoInitialize methods across objects
by calling Initialize explicitly on their member objects

\item {} 
\sphinxAtStartPar
The context id associated with each ScheduleWithContext method has
other uses beyond logging: it is used by an experimental branch of \sphinxstyleemphasis{ns\sphinxhyphen{}3}
to perform parallel simulation on multicore systems using
multithreading.

\end{itemize}

\sphinxAtStartPar
The Simulator::* functions do not know what the context is: they
merely make sure that whatever context you specify with
ScheduleWithContext is available when the corresponding event executes
with ::GetContext.

\sphinxAtStartPar
It is up to the models implemented on top of Simulator::* to interpret
the context value. In \sphinxstyleemphasis{ns\sphinxhyphen{}3}, the network models interpret the context
as the node id of the node which generated an event. This is why it is
important to call ScheduleWithContext in ns3::Channel subclasses
because we are generating an event from node i to node j and we want
to make sure that the event which will run on node j has the right
context.


\subsubsection{Available Simulator Engines}
\label{\detokenize{events:available-simulator-engines}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} supplies two different types of basic simulator engine to manage
event execution.  These are derived from the abstract base class \sphinxtitleref{SimulatorImpl}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{DefaultSimulatorImpl}  This is a classic sequential discrete event
simulator engine which uses a single thread of execution.  This engine
executes events as fast as possible.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{DistributedSimulatorImpl} This is a classic YAWNS distributed (“parallel”)
simulator engine. By labeling and instantiating your model components
appropriately this engine will execute the model in parallel across many
compute processes, yet in a time\sphinxhyphen{}synchronized way, as if the model had
executed sequentially. The two advantages are to execute models faster
and to execute models too large to fit in one compute node.  This engine also
attempts to execute as fast as possible.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{NullMessageSimulatorImpl}  This implements a variant of the Chandy\sphinxhyphen{}
Misra\sphinxhyphen{}Bryant (CMB) null message algorithm for parallel simulation.
Like \sphinxtitleref{DistributedSimulatorImpl} this requires appropriate labeling and
instantiation of model components. This engine attempts to execute
events as fast as possible.

\end{itemize}

\sphinxAtStartPar
You can choose which simulator engine to use by setting a global variable,
for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GlobalValue}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SimulatorImplementationType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::DistributedSimulatorImpl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or by using a command line argument

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./ns3 run \PYGZdq{}...  \PYGZhy{}\textendash{}SimulatorImplementationType=ns3::DistributedSimulatorImpl\PYGZdq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
In addition to the basic simulator engines there is a general facility used
to build “adapters” which provide small behavior modifications to one of
the core \sphinxtitleref{SimulatorImpl} engines.  The adapter base class is
\sphinxtitleref{SimulatorAdapter}, itself derived from \sphinxtitleref{SimulatorImpl}.  \sphinxtitleref{SimluatorAdapter}
uses the \sphinxhref{https://en.cppreference.com/w/cpp/language/pimpl}{PIMPL (pointer to implementation)}
idiom to forward all calls to the configured base simulator engine.
This makes it easy to provide small customizations
just by overriding the specific Simulator calls needed, and allowing
\sphinxtitleref{SimulatorAdapter} to handle the rest.

\sphinxAtStartPar
There are few places where adapters are used currently:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{ReadltimeSimulatorImpl}  This adapter attempts to execute in real time
by pacing the wall clock evolution.  This pacing is “best effort”,
meaning actual event execution may not occur exactly in sync, but
close to it. This engine is normally only used with the
\sphinxtitleref{DefaultSimulatorImpl}, but it can be used to keep a distributed
simulation synchronized with real time.  See the {\hyperref[\detokenize{realtime::doc}]{\sphinxcrossref{\DUrole{doc}{RealTime}}}} chapter.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{VisualSimulatorImpl}  This adapter starts a live visualization of the
running simulation, showing the network graph and each packet traversing
the links.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{LocalTimeSimulatorImpl}  This adapter enables attaching noisy local clocks
to \sphinxtitleref{Nodes}, then scheduling events with respect to the local noisy clock,
instead of relative to the true simulator time.

\end{itemize}

\sphinxAtStartPar
In addition to the PIMPL idiom of \sphinxtitleref{SimulatorAdapter} there is a special
per\sphinxhyphen{}event customization hook:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SimulatorImpl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PreEventHook}\PYG{p}{(}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{EventId}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{id}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
One can use this to perform any housekeeping actions before the next event
actually executes.

\sphinxAtStartPar
The distinction between a core engine and an adapter is the following: there
can only ever be one core engine running, while there can be several adapters
chained up each providing a variation on the base engine execution.
For example one can use noisy local clocks with the real time adapter.

\sphinxAtStartPar
A single adapter can be added on top of the \sphinxtitleref{DefaultSimulatorImpl} by the same
two methods above: binding the \sphinxtitleref{“SimulatorImplementationType”} global value or
using the command line argument.  To chain multiple adapters a different
approach must be used; see the \sphinxtitleref{SimulatorAdapter::AddAdapter()}
API documentation.

\sphinxAtStartPar
The simulator engine type can be set once, but must be set before the
first call to the \sphinxtitleref{Simulator()} API.  In practice, since some models have
to schedule their start up events when they are constructed, this means
generally you should set the engine type before instantiating any other
model components.

\sphinxAtStartPar
The engine type can be changed after \sphinxtitleref{Simulator::Destroy()} but before
any additional calls to the Simulator API, for instance when executing
multiple runs in a single \sphinxstyleemphasis{ns\sphinxhyphen{}3} invocation.


\subsection{Time}
\label{\detokenize{events:time}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} internally represents simulation times and durations as
64\sphinxhyphen{}bit signed integers (with the sign bit used for negative durations).
The time values are interpreted with respect to a “resolution” unit in the
customary SI units: fs, ps, ns, us, ms, s, min, h, d, y.
The unit defines the minimum Time value.
It can be changed once before any calls to \sphinxtitleref{Simulator::Run()}.
It is not stored with the 64\sphinxhyphen{}bit time value itself.

\sphinxAtStartPar
Times can be constructed from all standard numeric types
(using the configured default unit)
or with explicit units (as in \sphinxtitleref{Time MicroSeconds (uint64\_t value)}).
Times can be compared, tested for sign or equality to zero, rounded to
a given unit, converted to standard numeric types in specific units.
All basic arithmetic operations are supported
(addition, subtraction, multiplication or division
by a scalar (numeric value)). Times can be written to/read from IO streams.
In the case of writing it is easy to choose the output unit, different
from the resolution unit.


\subsection{Scheduler}
\label{\detokenize{events:scheduler}}
\sphinxAtStartPar
The main job of the \sphinxtitleref{Scheduler} classes is to maintain the priority queue of
future events.  The scheduler can be set with a global variable,
similar to choosing the \sphinxtitleref{SimulatorImpl}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GlobalValue}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SchedulerType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::DistributedSimulatorImpl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The scheduler can be changed at any time via \sphinxtitleref{Simulator::SetScheduler()}.
The default scheduler is \sphinxtitleref{MapScheduler} which uses a \sphinxtitleref{std::map\textless{}\textgreater{}} to
store events in time order.

\sphinxAtStartPar
Because event distributions vary by model there is no one
best strategy for the priority queue, so \sphinxstyleemphasis{ns\sphinxhyphen{}3} has several options with
differing tradeoffs.  The example \sphinxtitleref{utils/bench\sphinxhyphen{}scheduler.c} can be used
to test the performance for a user\sphinxhyphen{}supplied event distribution.
For modest execution times (less than an hour, say) the choice of priority
queue is usually not significant; configuring the build type to optimized
is much more important in reducing execution times.

\sphinxAtStartPar
The available scheduler types, and a summary of their time and space
complexity on \sphinxtitleref{Insert()} and \sphinxtitleref{RemoveNext()}, are listed in the
following table.  See the individual Scheduler API pages for details on the
complexity of the other API calls.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTT}
\sphinxtoprule
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Scheduler Type
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Complexity
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline\sphinxmultirow{2}{3}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
\sphinxtitleref{SchedulerImpl} Type
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{4}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Method
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Time
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Space
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxvlinecrossing{1}\sphinxcline{3-6}\sphinxfixclines{6}\sphinxtablestrut{3}&\sphinxtablestrut{4}&\sphinxstyletheadfamily 
\sphinxAtStartPar
Insert()
&\sphinxstyletheadfamily 
\sphinxAtStartPar
RemoveNext()
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Overhead
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Per Event
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
CalendarScheduler
&
\sphinxAtStartPar
\sphinxtitleref{\textless{}std::list\textgreater{} {[}{]}}
&
\sphinxAtStartPar
Constant
&
\sphinxAtStartPar
Constant
&
\sphinxAtStartPar
24 bytes
&
\sphinxAtStartPar
16 bytes
\\
\sphinxhline
\sphinxAtStartPar
HeapScheduler
&
\sphinxAtStartPar
Heap on \sphinxtitleref{std::vector}
&
\sphinxAtStartPar
Logarithmic
&
\sphinxAtStartPar
Logarithmic
&
\sphinxAtStartPar
24 bytes
&
\sphinxAtStartPar
0
\\
\sphinxhline
\sphinxAtStartPar
ListScheduler
&
\sphinxAtStartPar
\sphinxtitleref{std::list}
&
\sphinxAtStartPar
Linear
&
\sphinxAtStartPar
Constant
&
\sphinxAtStartPar
24 bytes
&
\sphinxAtStartPar
16 bytes
\\
\sphinxhline
\sphinxAtStartPar
MapScheduler
&
\sphinxAtStartPar
\sphinxtitleref{st::map}
&
\sphinxAtStartPar
Logarithmic
&
\sphinxAtStartPar
Constant
&
\sphinxAtStartPar
40 bytes
&
\sphinxAtStartPar
32 bytes
\\
\sphinxhline
\sphinxAtStartPar
PriorityQueueScheduler
&
\sphinxAtStartPar
\sphinxtitleref{std::priority\_queue\textless{},std::vector\textgreater{}}
&
\sphinxAtStartPar
Logarithimc
&
\sphinxAtStartPar
Logarithims
&
\sphinxAtStartPar
24 bytes
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\section{Callbacks}
\label{\detokenize{callbacks:callbacks}}\label{\detokenize{callbacks::doc}}
\sphinxAtStartPar
Some new users to \sphinxstyleemphasis{ns\sphinxhyphen{}3} are unfamiliar with an extensively used programming
idiom used throughout the code: the \sphinxstyleemphasis{ns\sphinxhyphen{}3 callback}. This chapter provides some
motivation on the callback, guidance on how to use it, and details on its
implementation.


\subsection{Callbacks Motivation}
\label{\detokenize{callbacks:callbacks-motivation}}
\sphinxAtStartPar
Consider that you have two simulation models A and B, and you wish to have them
pass information between them during the simulation. One way that you can do
that is that you can make A and B each explicitly knowledgeable about the other,
so that they can invoke methods on each other:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{A}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{ReceiveInput}\PYG{p}{(}\PYG{+w}{ }\PYG{c+cm}{/* parameters */}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and in another source file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{B}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{DoSomething}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{A}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{a\PYGZus{}instance}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// pointer to an A}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}
\PYG{n}{B}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DoSomething}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+c1}{// Tell a\PYGZus{}instance that something happened}
\PYG{+w}{  }\PYG{n}{a\PYGZus{}instance}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ReceiveInput}\PYG{p}{(}\PYG{+w}{ }\PYG{c+cm}{/* parameters */}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This certainly works, but it has the drawback that it introduces a dependency on
A and B to know about the other at compile time (this makes it harder to have
independent compilation units in the simulator) and is not generalized; if in a
later usage scenario, B needs to talk to a completely different C object, the
source code for B needs to be changed to add a \sphinxcode{\sphinxupquote{c\_instance}} and so forth. It
is easy to see that this is a brute force mechanism of communication that can
lead to programming cruft in the models.

\sphinxAtStartPar
This is not to say that objects should not know about one another if there is a
hard dependency between them, but that often the model can be made more flexible
if its interactions are less constrained at compile time.

\sphinxAtStartPar
This is not an abstract problem for network simulation research, but rather it
has been a source of problems in previous simulators, when researchers want to
extend or modify the system to do different things (as they are apt to do in
research). Consider, for example, a user who wants to add an IPsec security
protocol sublayer between TCP and IP:

\sphinxAtStartPar
If the simulator has made assumptions, and hard coded into the code, that IP
always talks to a transport protocol above, the user may be forced to hack the
system to get the desired interconnections. This is clearly not an optimal way
to design a generic simulator.


\subsection{Callbacks Background}
\label{\detokenize{callbacks:callbacks-background}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Readers familiar with programming callbacks may skip this tutorial
section.
\end{sphinxadmonition}

\sphinxAtStartPar
The basic mechanism that allows one to address the problem above is known as a
\sphinxstyleemphasis{callback}. The ultimate goal is to allow one piece of code to call a function
(or method in C++) without any specific inter\sphinxhyphen{}module dependency.

\sphinxAtStartPar
This ultimately means you need some kind of indirection \textendash{} you treat the address
of the called function as a variable.  This variable is called a
pointer\sphinxhyphen{}to\sphinxhyphen{}function variable. The relationship between function and
pointer\sphinxhyphen{}to\sphinxhyphen{}function pointer is really no different that that of object and
pointer\sphinxhyphen{}to\sphinxhyphen{}object.

\sphinxAtStartPar
In C the canonical example of a pointer\sphinxhyphen{}to\sphinxhyphen{}function is a
pointer\sphinxhyphen{}to\sphinxhyphen{}function\sphinxhyphen{}returning\sphinxhyphen{}integer (PFI). For a PFI taking one int parameter,
this could be declared like,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{pfi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
What you get from this is a variable named simply \sphinxcode{\sphinxupquote{pfi}} that is initialized to
the value 0. If you want to initialize this pointer to something meaningful, you
have to have a function with a matching signature. In this case:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{MyFunction}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you have this target, you can initialize the variable to point to your
function like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pfi}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{MyFunction}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can then call MyFunction indirectly using the more suggestive form of the
call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{pfi}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is suggestive since it looks like you are dereferencing the function
pointer just like you would dereference any pointer. Typically, however, people
take advantage of the fact that the compiler knows what is going on and will
just use a shorter form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pfi}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that the function pointer obeys value semantics, so you can pass it
around like any other value. Typically, when you use an asynchronous interface
you will pass some entity like this to a function which will perform an action
and \sphinxstyleemphasis{call back} to let you know it completed. It calls back by following the
indirection and executing the provided function.

\sphinxAtStartPar
In C++ you have the added complexity of objects. The analogy with the PFI above
means you have a pointer to a member function returning an int (PMI) instead of
the pointer to function returning an int (PFI).

\sphinxAtStartPar
The declaration of the variable providing the indirection looks only slightly
different:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This declares a variable named \sphinxcode{\sphinxupquote{pmi}} just as the previous example declared a
variable named \sphinxcode{\sphinxupquote{pfi}}. Since the will be to call a method of an instance of a
particular class, one must declare that method in a class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyClass}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{MyMethod}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Given this class declaration, one would then initialize that variable like
this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pmi}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyMethod}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This assigns the address of the code implementing the method to the variable,
completing the indirection. In order to call a method, the code needs a \sphinxcode{\sphinxupquote{this}}
pointer. This, in turn, means there must be an object of MyClass to refer to. A
simplistic example of this is just calling a method indirectly (think virtual
function):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// Declare a PMI}
\PYG{n}{pmi}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyMethod}\PYG{p}{;}\PYG{+w}{           }\PYG{c+c1}{// Point at the implementation code}

\PYG{n}{MyClass}\PYG{+w}{ }\PYG{n}{myClass}\PYG{p}{;}\PYG{+w}{                    }\PYG{c+c1}{// Need an instance of the class}
\PYG{p}{(}\PYG{n}{myClass}\PYG{p}{.}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{              }\PYG{c+c1}{// Call the method with an object ptr}
\end{sphinxVerbatim}

\sphinxAtStartPar
Just like in the C example, you can use this in an asynchronous call to another
module which will \sphinxstyleemphasis{call back} using a method and an object pointer. The
straightforward extension one might consider is to pass a pointer to the object
and the PMI variable. The module would just do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{*}\PYG{n}{objectPtr}\PYG{p}{.}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to execute the callback on the desired object.

\sphinxAtStartPar
One might ask at this time, \sphinxstyleemphasis{what’s the point}? The called module will have to
understand the concrete type of the calling object in order to properly make the
callback. Why not just accept this, pass the correctly typed object pointer and
do \sphinxcode{\sphinxupquote{object\sphinxhyphen{}\textgreater{}Method(1234)}} in the code instead of the callback?  This is
precisely the problem described above. What is needed is a way to decouple the
calling function from the called class completely. This requirement led to the
development of the \sphinxstyleemphasis{Functor}.

\sphinxAtStartPar
A functor is the outgrowth of something invented in the 1960s called a closure.
It is basically just a packaged\sphinxhyphen{}up function call, possibly with some state.

\sphinxAtStartPar
A functor has two parts, a specific part and a generic part, related through
inheritance. The calling code (the code that executes the callback) will execute
a generic overloaded \sphinxcode{\sphinxupquote{operator()}} of a generic functor to cause the callback
to be called. The called code (the code that wants to be called back) will have
to provide a specialized implementation of the \sphinxcode{\sphinxupquote{operator()}} that performs the
class\sphinxhyphen{}specific work that caused the close\sphinxhyphen{}coupling problem above.

\sphinxAtStartPar
With the specific functor and its overloaded \sphinxcode{\sphinxupquote{operator()}} created, the called
code then gives the specialized code to the module that will execute the
callback (the calling code).

\sphinxAtStartPar
The calling code will take a generic functor as a parameter, so an implicit cast
is done in the function call to convert the specific functor to a generic
functor.  This means that the calling module just needs to understand the
generic functor type. It is decoupled from the calling code completely.

\sphinxAtStartPar
The information one needs to make a specific functor is the object pointer and
the pointer\sphinxhyphen{}to\sphinxhyphen{}method address.

\sphinxAtStartPar
The essence of what needs to happen is that the system declares a generic part
of the functor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Functor}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{T}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The caller defines a specific part of the functor that really is just there to
implement the specific \sphinxcode{\sphinxupquote{operator()}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{ARG}\PYG{o}{\PYGZgt{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{SpecificFunctor}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Functor}\PYG{o}{\PYGZlt{}}\PYG{n}{ARG}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{SpecificFunctor}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{m\PYGZus{}p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{m\PYGZus{}pmi}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}pmi}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{T}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{m\PYGZus{}p}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is an example of the usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{n}{A}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{Hello}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{b0}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello from A, a = }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b0 = }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{b0}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{A}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{SpecificFunctor}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sf}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{A}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Hello}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{sf}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The previous code is not real ns\sphinxhyphen{}3 code.  It is simplistic example
code used only to illustrate the concepts involved and to help you understand
the system more.  Do not expect to find this code anywhere in the ns\sphinxhyphen{}3 tree.
\end{sphinxadmonition}

\sphinxAtStartPar
Notice that there are two variables defined in the class above.  The m\_p
variable is the object pointer and m\_pmi is the variable containing the
address of the function to execute.

\sphinxAtStartPar
Notice that when \sphinxcode{\sphinxupquote{operator()}} is called, it in turn calls the method provided
with the object pointer using the C++ PMI syntax.

\sphinxAtStartPar
To use this, one could then declare some model code that takes a generic functor
as a parameter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{LibraryFunction}\PYG{p}{(}\PYG{n}{Functor}\PYG{+w}{ }\PYG{n}{functor}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The code that will talk to the model would build a specific functor and pass it to \sphinxcode{\sphinxupquote{LibraryFunction}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MyClass}\PYG{+w}{ }\PYG{n}{myClass}\PYG{p}{;}
\PYG{n}{SpecificFunctor}\PYG{o}{\PYGZlt{}}\PYG{n}{MyClass}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{functor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{myclass}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyMethod}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{LibraryFunction}} is done, it executes the callback using the
\sphinxcode{\sphinxupquote{operator()}} on the generic functor it was passed, and in this particular
case, provides the integer argument:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{LibraryFunction}\PYG{p}{(}\PYG{n}{Functor}\PYG{+w}{ }\PYG{n}{functor}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+c1}{// Execute the library function}
\PYG{+w}{  }\PYG{n}{functor}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that \sphinxcode{\sphinxupquote{LibraryFunction}} is completely decoupled from the specific
type of the client.  The connection is made through the Functor polymorphism.

\sphinxAtStartPar
The Callback API in \sphinxstyleemphasis{ns\sphinxhyphen{}3} implements object\sphinxhyphen{}oriented callbacks using
the functor mechanism.  This callback API, being based on C++ templates, is
type\sphinxhyphen{}safe; that is, it performs static type checks to enforce proper signature
compatibility between callers and callees.  It is therefore more type\sphinxhyphen{}safe to
use than traditional function pointers, but the syntax may look imposing at
first.  This section is designed to walk you through the Callback system so
that you can be comfortable using it in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Using the Callback API}
\label{\detokenize{callbacks:using-the-callback-api}}
\sphinxAtStartPar
The Callback API is fairly minimal, providing only two services:

\sphinxAtStartPar
1. callback type declaration: a way to declare a type of callback
with a given signature, and,

\sphinxAtStartPar
2. callback instantiation: a way to instantiate a
template\sphinxhyphen{}generated forwarding callback which can forward any calls
to another C++ class member method or C++ function.

\sphinxAtStartPar
This is best observed via walking through an example, based on
\sphinxcode{\sphinxupquote{samples/main\sphinxhyphen{}callback.cc}}.


\subsubsection{Using the Callback API with static functions}
\label{\detokenize{callbacks:using-the-callback-api-with-static-functions}}
\sphinxAtStartPar
Consider a function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{double}
\PYG{n+nf}{CbOne}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{invoke cbOne a=}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, b=}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Consider also the following main program snippet:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+c1}{// return type: double}
\PYG{+w}{  }\PYG{c+c1}{// first arg type: double}
\PYG{+w}{  }\PYG{c+c1}{// second arg type: double}
\PYG{+w}{  }\PYG{n}{Callback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is an example of a C\sphinxhyphen{}style callback \textendash{} one which does not include or need
a \sphinxcode{\sphinxupquote{this}} pointer.  The function template \sphinxcode{\sphinxupquote{Callback}} is essentially the
declaration of the variable containing the pointer\sphinxhyphen{}to\sphinxhyphen{}function.  In the example
above, we explicitly showed a pointer to a function that returned an integer and
took a single integer as a parameter,  The \sphinxcode{\sphinxupquote{Callback}} template function is
a generic version of that \textendash{} it is used to declare the type of a callback.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Readers unfamiliar with C++ templates may consult \sphinxurl{http://www.cplusplus.com/doc/tutorial/templates/}.
\end{sphinxadmonition}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Callback}} template requires one mandatory argument (the return type
of the function to be assigned to this callback) and up to five optional
arguments, which each specify the type of the arguments (if your particular
callback function has more than five arguments, then this can be handled
by extending the callback implementation).

\sphinxAtStartPar
So in the above example, we have a declared a callback named “one” that will
eventually hold a function pointer.  The signature of the function that it will
hold must return double and must support two double arguments.  If one tries
to pass a function whose signature does not match the declared callback,
a compilation error will occur.  Also, if one tries to assign to a callback
an incompatible one, compilation will succeed but a run\sphinxhyphen{}time
NS\_FATAL\_ERROR will be raised.  The sample program
\sphinxcode{\sphinxupquote{src/core/examples/main\sphinxhyphen{}callback.cc}} demonstrates both of these error cases
at the end of the \sphinxcode{\sphinxupquote{main()}} program.

\sphinxAtStartPar
Now, we need to tie together this callback instance and the actual target function
(CbOne).  Notice above that CbOne has the same function signature types as the
callback\textendash{} this is important.  We can pass in any such properly\sphinxhyphen{}typed function
to this callback.  Let’s look at this more closely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{   }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{CbOne}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{           }\PYG{o}{\PYGZca{}}\PYG{+w}{             }\PYG{o}{\PYGZca{}}\PYG{+w}{         }\PYG{o}{\PYGZca{}}
\PYG{+w}{           }\PYG{o}{|}\PYG{+w}{             }\PYG{o}{|}\PYG{+w}{         }\PYG{o}{|}
\PYG{+w}{           }\PYG{o}{|}\PYG{+w}{             }\PYG{o}{|}\PYG{+w}{         }\PYG{o}{|}
\PYG{n}{Callback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{p}{,}\PYG{+w}{       }\PYG{k+kt}{double}\PYG{p}{,}\PYG{+w}{   }\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can only bind a function to a callback if they have the matching signature.
The first template argument is the return type, and the additional template
arguments are the types of the arguments of the function signature.

\sphinxAtStartPar
Now, let’s bind our callback “one” to the function that matches its signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// build callback instance which points to cbOne function}
\PYG{n}{one}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CbOne}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This call to \sphinxcode{\sphinxupquote{MakeCallback}} is, in essence, creating one of the specialized
functors mentioned above.  The variable declared using the \sphinxcode{\sphinxupquote{Callback}}
template function is going to be playing the part of the generic functor.  The
assignment \sphinxcode{\sphinxupquote{one = MakeCallback(\&CbOne)}} is the cast that converts the
specialized functor known to the callee to a generic functor known to the caller.

\sphinxAtStartPar
Then, later in the program, if the callback is needed, it can be used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}ASSERT}\PYG{p}{(}\PYG{o}{!}\PYG{n}{one}\PYG{p}{.}\PYG{n}{IsNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// invoke cbOne function through callback instance}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{retOne}\PYG{p}{;}
\PYG{n}{retOne}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The check for \sphinxcode{\sphinxupquote{IsNull()}} ensures that the callback is not null \textendash{} that there
is a function to call behind this callback.  Then, \sphinxcode{\sphinxupquote{one()}} executes the
generic \sphinxcode{\sphinxupquote{operator()}} which is really overloaded with a specific implementation
of \sphinxcode{\sphinxupquote{operator()}} and returns the same result as if \sphinxcode{\sphinxupquote{CbOne()}} had been
called directly.


\subsubsection{Using the Callback API with member functions}
\label{\detokenize{callbacks:using-the-callback-api-with-member-functions}}
\sphinxAtStartPar
Generally, you will not be calling static functions but instead public member
functions of an object.  In this case, an extra argument is needed to the
MakeCallback function, to tell the system on which object the function should be
invoked.  Consider this example, also from main\sphinxhyphen{}callback.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyCb}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{CbTwo}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{invoke cbTwo a=}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{  }\PYG{c+c1}{// return type: int}
\PYG{+w}{  }\PYG{c+c1}{// first arg type: double}
\PYG{+w}{  }\PYG{n}{Callback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{MyCb}\PYG{+w}{ }\PYG{n}{cb}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+c1}{// build callback instance which points to MyCb::cbTwo}
\PYG{+w}{  }\PYG{n}{two}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyCb}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CbTwo}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{cb}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, we pass an additional object pointer to the \sphinxcode{\sphinxupquote{MakeCallback\textless{}\textgreater{}}} function.
Recall from the background section above that \sphinxcode{\sphinxupquote{Operator()}} will use the pointer to
member syntax when it executes on an object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
And so we needed to provide the two variables (\sphinxcode{\sphinxupquote{m\_p}} and \sphinxcode{\sphinxupquote{m\_pmi}}) when
we made the specific functor.  The line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{two}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyCb}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CbTwo}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{cb}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
does precisely that.  In this case, when \sphinxcode{\sphinxupquote{two()}} is invoked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will result in a call to the \sphinxcode{\sphinxupquote{CbTwo}} member function (method) on the object
pointed to by \sphinxcode{\sphinxupquote{\&cb}}.


\subsubsection{Building Null Callbacks}
\label{\detokenize{callbacks:building-null-callbacks}}
\sphinxAtStartPar
It is possible for callbacks to be null; hence it may be wise to
check before using them.  There is a special construct for a null
callback, which is preferable to simply passing “0” as an argument;
it is the \sphinxcode{\sphinxupquote{MakeNullCallback\textless{}\textgreater{}}} construct:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{two}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{MakeNullCallback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT}\PYG{p}{(}\PYG{n}{two}\PYG{p}{.}\PYG{n}{IsNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Invoking a null callback is just like invoking a null function pointer: it will
crash at runtime.


\subsection{Bound Callbacks}
\label{\detokenize{callbacks:bound-callbacks}}
\sphinxAtStartPar
A very useful extension to the functor concept is that of a Bound Callback.
Previously it was mentioned that closures were originally function calls
packaged up for later execution.  Notice that in all of the Callback
descriptions above, there is no way to package up any parameters for use
later \textendash{} when the \sphinxcode{\sphinxupquote{Callback}} is called via \sphinxcode{\sphinxupquote{operator()}}.  All of
the parameters are provided by the calling function.

\sphinxAtStartPar
What if it is desired to allow the client function (the one that provides the
callback) to provide some of the parameters?
\sphinxhref{http://erdani.org/index.php/books/modern-c-design/index.html}{Alexandrescu}
calls the process of allowing a client to specify one of the parameters \sphinxstyleemphasis{“binding”}.
One of the parameters of \sphinxcode{\sphinxupquote{operator()}} has been bound (fixed) by the client.

\sphinxAtStartPar
Some of our pcap tracing code provides a nice example of this.  There is a
function that needs to be called whenever a packet is received.  This function
calls an object that actually writes the packet to disk in the pcap file
format.  The signature of one of these functions will be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DefaultSink}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PcapFileWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{file}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The static keyword means this is a static function which does not need a
\sphinxcode{\sphinxupquote{this}} pointer, so it will be using C\sphinxhyphen{}style callbacks.  We don’t want the
calling code to have to know about anything but the Packet.  What we want in
the calling code is just a call that looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}promiscSnifferTrace}\PYG{p}{(}\PYG{n}{m\PYGZus{}currentPkt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
What we want to do is to \sphinxstyleemphasis{bind} the \sphinxcode{\sphinxupquote{Ptr\textless{}PcapFileWriter\textgreater{} file}} to the
specific callback implementation when it is created and arrange for the
\sphinxcode{\sphinxupquote{operator()}} of the Callback to provide that parameter for free.

\sphinxAtStartPar
We provide the \sphinxcode{\sphinxupquote{MakeBoundCallback}} template function for that purpose.  It
takes the same parameters as the \sphinxcode{\sphinxupquote{MakeCallback}} template function but also
takes the parameters to be bound.  In the case of the example above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeBoundCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{DefaultSink}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{file}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will create a specific callback implementation that knows to add in the extra
bound arguments.  Conceptually, it extends the specific functor described above
with one or more bound arguments:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{ARG}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{BOUND\PYGZus{}ARG}\PYG{o}{\PYGZgt{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{SpecificFunctor}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Functor}
\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{ }\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{SpecificFunctor}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{BOUND\PYGZus{}ARG}\PYG{+w}{ }\PYG{n}{boundArg}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}pmi}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pmi}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}boundArg}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{boundArg}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{m\PYGZus{}boundArg}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{T}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{m\PYGZus{}p}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BOUND\PYGZus{}ARG}\PYG{+w}{ }\PYG{n}{m\PYGZus{}boundArg}\PYG{p}{;}
\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see that when the specific functor is created, the bound argument is saved
in the functor / callback object itself.  When the \sphinxcode{\sphinxupquote{operator()}} is invoked with
the single parameter, as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}promiscSnifferTrace}\PYG{p}{(}\PYG{n}{m\PYGZus{}currentPkt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
the implementation of \sphinxcode{\sphinxupquote{operator()}} adds the bound parameter into the actual
function call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{m\PYGZus{}boundArg}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It’s possible to bind two or three arguments as well.  Say we have a function with
signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{NotifyEvent}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MyEventType}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
One can create bound callback binding first two arguments like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeBoundCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyEvent}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
assuming \sphinxtitleref{a1} and \sphinxtitleref{b1} are objects of type \sphinxtitleref{A} and \sphinxtitleref{B} respectively.  Similarly for
three arguments one would have function with a signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{NotifyEvent}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MyEventType}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Binding three arguments in done with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeBoundCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyEvent}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
again assuming \sphinxtitleref{a1}, \sphinxtitleref{b1} and \sphinxtitleref{c1} are objects of type \sphinxtitleref{A}, \sphinxtitleref{B} and \sphinxtitleref{C} respectively.

\sphinxAtStartPar
This kind of binding can be used for exchanging information between objects in
simulation; specifically, bound callbacks can be used as traced callbacks, which will
be described in the next section.


\subsection{Traced Callbacks}
\label{\detokenize{callbacks:traced-callbacks}}
\sphinxAtStartPar
\sphinxstyleemphasis{Placeholder subsection}


\subsection{Callback locations in ns\sphinxhyphen{}3}
\label{\detokenize{callbacks:callback-locations-in-ns-3}}
\sphinxAtStartPar
Where are callbacks frequently used in \sphinxstyleemphasis{ns\sphinxhyphen{}3}?  Here are some of the
more visible ones to typical users:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Socket API

\item {} 
\sphinxAtStartPar
Layer\sphinxhyphen{}2/Layer\sphinxhyphen{}3 API

\item {} 
\sphinxAtStartPar
Tracing subsystem

\item {} 
\sphinxAtStartPar
API between IP and routing subsystems

\end{itemize}


\subsection{Implementation details}
\label{\detokenize{callbacks:implementation-details}}
\sphinxAtStartPar
The code snippets above are simplistic and only designed to illustrate the mechanism
itself.  The actual Callback code is quite complicated and very template\sphinxhyphen{}intense and
a deep understanding of the code is not required.  If interested, expert users may
find the following useful.

\sphinxAtStartPar
The code was originally written based on the techniques described in
\sphinxurl{http://www.codeproject.com/cpp/TTLFunction.asp}.
It was subsequently rewritten to follow the architecture outlined in
\sphinxhref{http://erdani.org/index.php/books/modern-c-design/index.html}{Modern C++ Design, Generic Programming and Design Patterns Applied, Alexandrescu, chapter 5, Generalized Functors}.

\sphinxAtStartPar
This code uses:
\begin{itemize}
\item {} 
\sphinxAtStartPar
default template parameters to saves users from having to
specify empty parameters when the number of parameters
is smaller than the maximum supported number

\item {} 
\sphinxAtStartPar
the pimpl idiom: the Callback class is passed around by
value and delegates the crux of the work to its pimpl pointer.

\item {} 
\sphinxAtStartPar
two pimpl implementations which derive from CallbackImpl
FunctorCallbackImpl can be used with any functor\sphinxhyphen{}type
while MemPtrCallbackImpl can be used with pointers to
member functions.

\item {} 
\sphinxAtStartPar
a reference list implementation to implement the Callback’s
value semantics.

\end{itemize}

\sphinxAtStartPar
This code most notably departs from the Alexandrescu implementation in that it
does not use type lists to specify and pass around the types of the callback
arguments. Of course, it also does not use copy\sphinxhyphen{}destruction semantics and
relies on a reference list rather than autoPtr to hold the pointer.

\sphinxstepscope


\section{Object model}
\label{\detokenize{object-model:object-model}}\label{\detokenize{object-model:id1}}\label{\detokenize{object-model::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is fundamentally a C++ object system. Objects can be declared and
instantiated as usual, per C++ rules. \sphinxstyleemphasis{ns\sphinxhyphen{}3} also adds some features to
traditional C++ objects, as described below, to provide greater functionality
and features. This manual chapter is intended to introduce the reader to the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} object model.

\sphinxAtStartPar
This section describes the C++ class design for \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects. In brief,
several design patterns in use include classic object\sphinxhyphen{}oriented design
(polymorphic interfaces and implementations), separation of interface and
implementation, the non\sphinxhyphen{}virtual public interface design pattern, an object
aggregation facility, and reference counting for memory management. Those
familiar with component models such as COM or Bonobo will recognize elements of
the design in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object aggregation model, although the \sphinxstyleemphasis{ns\sphinxhyphen{}3} design is
not strictly in accordance with either.


\subsection{Object\sphinxhyphen{}oriented behavior}
\label{\detokenize{object-model:object-oriented-behavior}}
\sphinxAtStartPar
C++ objects, in general, provide common object\sphinxhyphen{}oriented capabilities
(abstraction, encapsulation, inheritance, and polymorphism) that are part
of classic object\sphinxhyphen{}oriented design. \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects make use of these
properties; for instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Address}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{Address}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Address}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{type}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{buffer}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Address}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Address}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{address}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Address}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Address}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{address}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{m\PYGZus{}type}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{m\PYGZus{}len}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Object base classes}
\label{\detokenize{object-model:object-base-classes}}
\sphinxAtStartPar
There are three special base classes used in \sphinxstyleemphasis{ns\sphinxhyphen{}3}. Classes that inherit
from these base classes can instantiate objects with special properties.
These base classes are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{Object}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ObjectBase}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{SimpleRefCount}}

\end{itemize}

\sphinxAtStartPar
It is not required that \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects inherit from these class, but
those that do get special properties. Classes deriving from
class \sphinxcode{\sphinxupquote{Object}} get the following properties.
\begin{itemize}
\item {} 
\sphinxAtStartPar
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} type and attribute system (see {\hyperref[\detokenize{attributes:attributes}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration and Attributes}}}})

\item {} 
\sphinxAtStartPar
an object aggregation system

\item {} 
\sphinxAtStartPar
a smart\sphinxhyphen{}pointer reference counting system (class Ptr)

\end{itemize}

\sphinxAtStartPar
Classes that derive from class \sphinxcode{\sphinxupquote{ObjectBase}} get the first two
properties above, but do not get smart pointers. Classes that derive from class
\sphinxcode{\sphinxupquote{SimpleRefCount}}: get only the smart\sphinxhyphen{}pointer reference counting
system.

\sphinxAtStartPar
In practice, class \sphinxcode{\sphinxupquote{Object}} is the variant of the three above that
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} developer will most commonly encounter.


\subsection{Memory management and class Ptr}
\label{\detokenize{object-model:memory-management-and-class-ptr}}\label{\detokenize{object-model:id2}}
\sphinxAtStartPar
Memory management in a C++ program is a complex process, and is often done
incorrectly or inconsistently. We have settled on a reference counting design
described as follows.

\sphinxAtStartPar
All objects using reference counting maintain an internal reference count to
determine when an object can safely delete itself. Each time that a pointer is
obtained to an interface, the object’s reference count is incremented by calling
\sphinxcode{\sphinxupquote{Ref()}}. It is the obligation of the user of the pointer to explicitly
\sphinxcode{\sphinxupquote{Unref()}} the pointer when done. When the reference count falls to zero, the
object is deleted.
\begin{itemize}
\item {} 
\sphinxAtStartPar
When the client code obtains a pointer from the object itself through object
creation, or via GetObject, it does not have to increment the reference count.

\item {} 
\sphinxAtStartPar
When client code obtains a pointer from another source (e.g., copying a
pointer) it must call \sphinxcode{\sphinxupquote{Ref()}} to increment the reference count.

\item {} 
\sphinxAtStartPar
All users of the object pointer must call \sphinxcode{\sphinxupquote{Unref()}} to release the
reference.

\end{itemize}

\sphinxAtStartPar
The burden for calling \sphinxcode{\sphinxupquote{Unref()}} is somewhat relieved by the use of
the reference counting smart pointer class described below.

\sphinxAtStartPar
Users using a low\sphinxhyphen{}level API who wish to explicitly allocate
non\sphinxhyphen{}reference\sphinxhyphen{}counted objects on the heap, using operator new, are responsible
for deleting such objects.


\subsubsection{Reference counting smart pointer (Ptr)}
\label{\detokenize{object-model:reference-counting-smart-pointer-ptr}}
\sphinxAtStartPar
Calling \sphinxcode{\sphinxupquote{Ref()}} and \sphinxcode{\sphinxupquote{Unref()}} all the time would be cumbersome, so \sphinxstyleemphasis{ns\sphinxhyphen{}3}
provides a smart pointer class \sphinxcode{\sphinxupquote{Ptr}} similar to
\sphinxcode{\sphinxupquote{Boost::intrusive\_ptr}}. This smart\sphinxhyphen{}pointer class assumes that the
underlying type provides a pair of \sphinxcode{\sphinxupquote{Ref}} and \sphinxcode{\sphinxupquote{Unref}} methods that are
expected to increment and decrement the internal refcount of the object
instance.

\sphinxAtStartPar
This implementation allows you to manipulate the smart pointer as if it was a
normal pointer: you can compare it with zero, compare it against other pointers,
assign zero to it, etc.

\sphinxAtStartPar
It is possible to extract the raw pointer from this smart pointer with the
\sphinxcode{\sphinxupquote{GetPointer()}} and \sphinxcode{\sphinxupquote{PeekPointer()}} methods.

\sphinxAtStartPar
If you want to store a newed object into a smart pointer, we recommend you to
use the CreateObject template functions to create the object and store it in a
smart pointer to avoid memory leaks. These functions are really small
convenience functions and their goal is just to save you a small bit of typing.


\subsection{CreateObject and Create}
\label{\detokenize{object-model:createobject-and-create}}
\sphinxAtStartPar
Objects in C++ may be statically, dynamically, or automatically created.  This
holds true for \sphinxstyleemphasis{ns\sphinxhyphen{}3} also, but some objects in the system have some additional
frameworks available. Specifically, reference counted objects are usually
allocated using a templated Create or CreateObject method, as follows.

\sphinxAtStartPar
For objects deriving from class \sphinxcode{\sphinxupquote{Object}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{device}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Please do not create such objects using \sphinxcode{\sphinxupquote{operator new}}; create them using
\sphinxcode{\sphinxupquote{CreateObject()}} instead.

\sphinxAtStartPar
For objects deriving from class \sphinxcode{\sphinxupquote{SimpleRefCount}}, or other objects
that support usage of the smart pointer class, a templated helper function is
available and recommended to be used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is simply a wrapper around operator new that correctly handles the
reference counting system.

\sphinxAtStartPar
In summary, use \sphinxcode{\sphinxupquote{Create\textless{}B\textgreater{}}} if B is not an object but just uses reference
counting (e.g. \sphinxcode{\sphinxupquote{Packet}}), and use \sphinxcode{\sphinxupquote{CreateObject\textless{}B\textgreater{}}} if B derives
from \sphinxcode{\sphinxupquote{ns3::Object}}.


\subsection{Aggregation}
\label{\detokenize{object-model:aggregation}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} object aggregation system is motivated in strong part by a recognition
that a common use case for \sphinxstyleemphasis{ns\sphinxhyphen{}2} has been the use of inheritance and
polymorphism to extend protocol models. For instance, specialized versions of
TCP such as RenoTcpAgent derive from (and override functions from) class
TcpAgent.

\sphinxAtStartPar
However, two problems that have arisen in the \sphinxstyleemphasis{ns\sphinxhyphen{}2} model are downcasts and
“weak base class.” Downcasting refers to the procedure of using a base class
pointer to an object and querying it at run time to find out type information,
used to explicitly cast the pointer to a subclass pointer so that the subclass
API can be used. Weak base class refers to the problems that arise when a class
cannot be effectively reused (derived from) because it lacks necessary
functionality, leading the developer to have to modify the base class and
causing proliferation of base class API calls, some of which may not be
semantically correct for all subclasses.

\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is using a version of the query interface design pattern to avoid these
problems. This design is based on elements of the \sphinxhref{http://en.wikipedia.org/wiki/Component\_Object\_Model}{Component Object Model} and \sphinxhref{http://en.wikipedia.org/wiki/Bonobo\_(component\_model)}{GNOME Bonobo} although full
binary\sphinxhyphen{}level compatibility of replaceable components is not supported and we
have tried to simplify the syntax and impact on model developers.


\subsection{Examples}
\label{\detokenize{object-model:examples}}

\subsubsection{Aggregation example}
\label{\detokenize{object-model:aggregation-example}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Node}} is a good example of the use of aggregation in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  Note
that there are not derived classes of Nodes in \sphinxstyleemphasis{ns\sphinxhyphen{}3} such as class
\sphinxcode{\sphinxupquote{InternetNode}}.  Instead, components (protocols) are aggregated to a
node. Let’s look at how some Ipv4 protocols are added to a node.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}
\PYG{n+nf}{AddIpv4Stack}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4L3Protocol}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4L3Protocol}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{ipv4}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetNode}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AggregateObject}\PYG{p}{(}\PYG{n}{ipv4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4Impl}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4Impl}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4Impl}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{ipv4Impl}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetIpv4}\PYG{p}{(}\PYG{n}{ipv4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AggregateObject}\PYG{p}{(}\PYG{n}{ipv4Impl}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the Ipv4 protocols are created using \sphinxcode{\sphinxupquote{CreateObject()}}.
Then, they are aggregated to the node. In this manner, the Node base class does
not need to be edited to allow users with a base class Node pointer to access
the Ipv4 interface; users may ask the node for a pointer to its Ipv4 interface
at runtime. How the user asks the node is described in the next subsection.

\sphinxAtStartPar
Note that it is a programming error to aggregate more than one object of the
same type to an \sphinxcode{\sphinxupquote{ns3::Object}}. So, for instance, aggregation is not
an option for storing all of the active sockets of a node.


\subsubsection{GetObject example}
\label{\detokenize{object-model:getobject-example}}
\sphinxAtStartPar
GetObject is a type\sphinxhyphen{}safe way to achieve a safe downcasting and to allow
interfaces to be found on an object.

\sphinxAtStartPar
Consider a node pointer \sphinxcode{\sphinxupquote{m\_node}} that points to a Node object that has an
implementation of IPv4 previously aggregated to it. The client code wishes to
configure a default route. To do so, it must access an object within the node
that has an interface to the IP forwarding configuration. It performs the
following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{m\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the node in fact does not have an Ipv4 object aggregated to it, then the
method will return null. Therefore, it is good practice to check the return
value from such a function call. If successful, the user can now use the Ptr to
the Ipv4 object that was previously aggregated to the node.

\sphinxAtStartPar
Another example of how one might use aggregation is to add optional models to
objects. For instance, an existing Node object may have an “Energy Model” object
aggregated to it at run time (without modifying and recompiling the node class).
An existing model (such as a wireless net device) can then later “GetObject” for
the energy model and act appropriately if the interface has been either built in
to the underlying Node object or aggregated to it at run time.  However, other
nodes need not know anything about energy models.

\sphinxAtStartPar
We hope that this mode of programming will require much less need for developers
to modify the base classes.


\subsection{Object factories}
\label{\detokenize{object-model:object-factories}}
\sphinxAtStartPar
A common use case is to create lots of similarly configured objects. One can
repeatedly call \sphinxcode{\sphinxupquote{CreateObject()}} but there is also a factory design
pattern in use in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system. It is heavily used in the “helper” API.

\sphinxAtStartPar
Class \sphinxcode{\sphinxupquote{ObjectFactory}} can be used to instantiate objects and to
configure the attributes on those objects:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SetTypeId}\PYG{p}{(}\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Set}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{name}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{AttributeValue}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{Create}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first method allows one to use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} TypeId system to specify the type
of objects created. The second allows one to set attributes on the objects to be
created, and the third allows one to create the objects themselves.

\sphinxAtStartPar
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ObjectFactory}\PYG{+w}{ }\PYG{n}{factory}\PYG{p}{;}
\PYG{c+c1}{// Make this factory create objects of type FriisPropagationLossModel}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{SetTypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::FriisPropagationLossModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{// Make this factory object change a default value of an attribute, for}
\PYG{c+c1}{// subsequently created objects}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SystemLoss}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Create one such object}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{object}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SystemLoss}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Create another object with a different SystemLoss}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{object}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Downcasting}
\label{\detokenize{object-model:downcasting}}
\sphinxAtStartPar
A question that has arisen several times is, “If I have a base class pointer
(Ptr) to an object and I want the derived class pointer, should I downcast (via
C++ dynamic cast) to get the derived pointer, or should I use the object
aggregation system to \sphinxcode{\sphinxupquote{GetObject\textless{}\textgreater{} ()}} to find a Ptr to the interface
to the subclass API?”

\sphinxAtStartPar
The answer to this is that in many situations, both techniques will work.
\sphinxstyleemphasis{ns\sphinxhyphen{}3} provides a templated function for making the syntax of Object
dynamic casting much more user friendly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T1}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T2}\PYG{o}{\PYGZgt{}}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{o}{\PYGZgt{}}
\PYG{n}{DynamicCast}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T2}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{k}{const}\PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{dynamic\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{PeekPointer}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
DynamicCast works when the programmer has a base type pointer and is testing
against a subclass pointer. GetObject works when looking for different objects
aggregated, but also works with subclasses, in the same way as DynamicCast. If
unsure, the programmer should use GetObject, as it works in all cases. If the
programmer knows the class hierarchy of the object under consideration, it is
more direct to just use DynamicCast.

\sphinxstepscope


\section{Configuration and Attributes}
\label{\detokenize{attributes:configuration-and-attributes}}\label{\detokenize{attributes:attributes}}\label{\detokenize{attributes::doc}}
\sphinxAtStartPar
In \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations, there are two main aspects to configuration:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The simulation topology and how objects are connected.

\item {} 
\sphinxAtStartPar
The values used by the models instantiated in the topology.

\end{itemize}

\sphinxAtStartPar
This chapter focuses on the second item above: how the many values in use in
\sphinxstyleemphasis{ns\sphinxhyphen{}3} are organized, documented, and modifiable by \sphinxstyleemphasis{ns\sphinxhyphen{}3} users. The \sphinxstyleemphasis{ns\sphinxhyphen{}3}
attribute system is also the underpinning of how traces and statistics are
gathered in the simulator.

\sphinxAtStartPar
In the course of this chapter we will discuss the various ways to set or
modify the values used by \sphinxstyleemphasis{ns\sphinxhyphen{}3} model objects.  In increasing order of
specificity, these are:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Method
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Scope
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Default Attribute values set when
Attributes are defined in
\sphinxcode{\sphinxupquote{GetTypeId()}}.
&
\sphinxAtStartPar
Affect all instances of the class.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CommandLine}}
\sphinxcode{\sphinxupquote{Config::SetDefault()}}
\sphinxcode{\sphinxupquote{ConfigStore}}
&
\sphinxAtStartPar
Affect all future instances.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ObjectFactory}}
&
\sphinxAtStartPar
Affects all instances created with
the factory.
\\
\sphinxhline
\sphinxAtStartPar
Helper methods with (string/
AttributeValue) parameter pairs
&
\sphinxAtStartPar
Affects all instances created by
the helper.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyClass::SetX()}}
\sphinxcode{\sphinxupquote{Object::SetAttribute()}}
\sphinxcode{\sphinxupquote{Config::Set()}}
&
\sphinxAtStartPar
Alters this particular instance.
Generally this is the only form
which can be scheduled to alter
an instance once the simulation
is running.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
By “specificity” we mean that methods in later rows in the table
override the values set by, and typically affect fewer instances than,
earlier methods.

\sphinxAtStartPar
Before delving into details of the attribute value system, it will help to
review some basic properties of class \sphinxcode{\sphinxupquote{Object}}.


\subsection{Object Overview}
\label{\detokenize{attributes:object-overview}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is fundamentally a C++ object\sphinxhyphen{}based system. By this we mean that new C++
classes (types) can be declared, defined, and subclassed as usual.

\sphinxAtStartPar
Many \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects inherit from the \sphinxcode{\sphinxupquote{Object}} base class.  These
objects have some additional properties that we exploit for organizing the
system and improving the memory management of our objects:
\begin{itemize}
\item {} 
\sphinxAtStartPar
“Metadata” system that links the class name to a lot of meta\sphinxhyphen{}information
about the object, including:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The base class of the subclass,

\item {} 
\sphinxAtStartPar
The set of accessible constructors in the subclass,

\item {} 
\sphinxAtStartPar
The set of “attributes” of the subclass,

\item {} 
\sphinxAtStartPar
Whether each attribute can be set, or is read\sphinxhyphen{}only,

\item {} 
\sphinxAtStartPar
The allowed range of values for each attribute.

\end{itemize}

\item {} 
\sphinxAtStartPar
Reference counting smart pointer implementation, for memory management.

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} objects that use the attribute system derive from either
\sphinxcode{\sphinxupquote{Object}} or \sphinxcode{\sphinxupquote{ObjectBase}}. Most \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects we
will discuss derive from \sphinxcode{\sphinxupquote{Object}}, but a few that are outside
the smart pointer memory management framework derive from
\sphinxcode{\sphinxupquote{ObjectBase}}.

\sphinxAtStartPar
Let’s review a couple of properties of these objects.


\subsubsection{Smart Pointers}
\label{\detokenize{attributes:smart-pointers}}
\sphinxAtStartPar
As introduced in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tutorial, \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects are memory managed by a
\sphinxhref{http://en.wikipedia.org/wiki/Smart\_pointer}{reference counting smart pointer implementation}, class \sphinxcode{\sphinxupquote{Ptr}}.

\sphinxAtStartPar
Smart pointers are used extensively in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} APIs, to avoid passing
references to heap\sphinxhyphen{}allocated objects that may cause memory leaks.
For most basic usage (syntax), treat a smart pointer like a regular pointer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{n}{nd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CallSomeFunction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// etc.}
\end{sphinxVerbatim}

\sphinxAtStartPar
So how do you get a smart pointer to an object, as in the first line
of this example?


\paragraph{CreateObject}
\label{\detokenize{attributes:createobject}}
\sphinxAtStartPar
As we discussed above in {\hyperref[\detokenize{object-model:memory-management-and-class-ptr}]{\sphinxcrossref{\DUrole{std,std-ref}{Memory management and class Ptr}}}}, at the
lowest\sphinxhyphen{}level API, objects of type \sphinxcode{\sphinxupquote{Object}} are not instantiated
using \sphinxcode{\sphinxupquote{operator new}} as usual but instead by a templated function called
\sphinxcode{\sphinxupquote{CreateObject()}}.

\sphinxAtStartPar
A typical way to create such an object is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can think of this as being functionally equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{WifiNetDevice}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{nd}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{WifiNetDevice}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Objects that derive from \sphinxcode{\sphinxupquote{Object}} must be allocated on the heap
using \sphinxcode{\sphinxupquote{CreateObject()}}. Those deriving from \sphinxcode{\sphinxupquote{ObjectBase}},
such as \sphinxstyleemphasis{ns\sphinxhyphen{}3} helper functions and packet headers and trailers,
can be allocated on the stack.

\sphinxAtStartPar
In some scripts, you may not see a lot of \sphinxcode{\sphinxupquote{CreateObject()}} calls
in the code; this is because there are some helper objects in effect
that are doing the \sphinxcode{\sphinxupquote{CreateObject()}} calls for you.


\subsubsection{TypeId}
\label{\detokenize{attributes:typeid}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} classes that derive from class \sphinxcode{\sphinxupquote{Object}} can include
a metadata class called \sphinxcode{\sphinxupquote{TypeId}} that records meta\sphinxhyphen{}information
about the class, for use in the object aggregation and component manager
systems:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A unique string identifying the class.

\item {} 
\sphinxAtStartPar
The base class of the subclass, within the metadata system.

\item {} 
\sphinxAtStartPar
The set of accessible constructors in the subclass.

\item {} 
\sphinxAtStartPar
A list of publicly accessible properties (“attributes”) of the class.

\end{itemize}


\subsubsection{Object Summary}
\label{\detokenize{attributes:object-summary}}
\sphinxAtStartPar
Putting all of these concepts together, let’s look at a specific
example: class \sphinxcode{\sphinxupquote{Node}}.

\sphinxAtStartPar
The public header file \sphinxcode{\sphinxupquote{node.h}} has a declaration that includes
a static \sphinxcode{\sphinxupquote{GetTypeId()}} function call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Node}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is defined in the \sphinxcode{\sphinxupquote{node.cc}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}
\PYG{n+nf}{Node::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Node}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeviceList}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The list of devices associated to this Node.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{ObjectVectorValue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeObjectVectorAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}devices}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeObjectVectorChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ApplicationList}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The list of applications associated to this Node.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{ObjectVectorValue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeObjectVectorAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}applications}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeObjectVectorChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{Application}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Id}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The id(unique integer) of this Node.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{TypeId}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ATTR\PYGZus{}GET}\PYG{p}{,}\PYG{+w}{ }\PYG{c+c1}{// allow only getting it.}
\PYG{+w}{                  }\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeUintegerAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeUintegerChecker}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Consider the \sphinxcode{\sphinxupquote{TypeId}} of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxcode{\sphinxupquote{Object}} class
as an extended form of run time type information (RTTI). The C++ language
includes a simple kind of RTTI in order to support \sphinxcode{\sphinxupquote{dynamic\_cast}} and
\sphinxcode{\sphinxupquote{typeid}} operators.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{SetParent\textless{}Object\textgreater{}()}} call in the definition above is used in
conjunction with our object aggregation mechanisms to allow safe up\sphinxhyphen{} and
down\sphinxhyphen{}casting in inheritance trees during \sphinxcode{\sphinxupquote{GetObject()}}.
It also enables subclasses to inherit the Attributes of their parent class.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{AddConstructor\textless{}Node\textgreater{}()}} call is used in conjunction
with our abstract object factory mechanisms to allow us to construct
C++ objects without forcing a user to know the concrete class of
the object she is building.

\sphinxAtStartPar
The three calls to \sphinxcode{\sphinxupquote{AddAttribute()}} associate a given string
with a strongly typed value in the class. Notice that you must provide
a help string which may be displayed, for example, \sphinxstyleemphasis{via} command line
processors. Each \sphinxcode{\sphinxupquote{Attribute}} is associated with mechanisms
for accessing the underlying member variable in the object (for example,
\sphinxcode{\sphinxupquote{MakeUintegerAccessor()}} tells the generic \sphinxcode{\sphinxupquote{Attribute}}
code how to get to the node ID above). There are also “Checker” methods which
are used to validate values against range limitations, such as maximum
and minimum allowed values.

\sphinxAtStartPar
When users want to create Nodes, they will usually call some form of
\sphinxcode{\sphinxupquote{CreateObject()}},:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or more abstractly, using an object factory, you can create a
\sphinxcode{\sphinxupquote{Node}} object without even knowing the concrete C++ type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ObjectFactory}\PYG{+w}{ }\PYG{n}{factory}\PYG{p}{;}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{typeId}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Node\PYGZsq{}\PYGZsq{};}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{SetTypeId}\PYG{p}{(}\PYG{n}{typeId}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Create}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Both of these methods result in fully initialized attributes being available
in the resulting \sphinxcode{\sphinxupquote{Object}} instances.

\sphinxAtStartPar
We next discuss how attributes (values associated with member variables or
functions of the class) are plumbed into the above \sphinxcode{\sphinxupquote{TypeId}}.


\subsection{Attributes}
\label{\detokenize{attributes:id1}}
\sphinxAtStartPar
The goal of the attribute system is to organize the access of
internal member objects of a simulation. This goal arises because,
typically in simulation, users will cut and paste/modify existing
simulation scripts, or will use higher\sphinxhyphen{}level simulation constructs,
but often will be interested in studying or tracing particular
internal variables.  For instance, use cases such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{“I want to trace the packets on the wireless interface only on the first
access point.”}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{“I want to trace the value of the TCP congestion window (every time it
changes) on a particular TCP socket.”}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{“I want a dump of all values that were used in my simulation.”}

\end{itemize}

\sphinxAtStartPar
Similarly, users may want fine\sphinxhyphen{}grained access to internal variables in the
simulation, or may want to broadly change the initial value used for a
particular parameter in all subsequently created objects. Finally, users may
wish to know what variables are settable and retrievable in a simulation
configuration. This is not just for direct simulation interaction on the command
line; consider also a (future) graphical user interface that would like to be
able to provide a feature whereby a user might right\sphinxhyphen{}click on an node on the
canvas and see a hierarchical, organized list of parameters that are settable on
the node and its constituent member objects, and help text and default values
for each parameter.


\subsubsection{Available AttributeValue Types}
\label{\detokenize{attributes:available-attributevalue-types}}\begin{itemize}
\item {} 
\sphinxAtStartPar
AddressValue

\item {} 
\sphinxAtStartPar
AttributeContainerValue

\item {} 
\sphinxAtStartPar
BooleanValue

\item {} 
\sphinxAtStartPar
BoxValue

\item {} 
\sphinxAtStartPar
CallbackValue

\item {} 
\sphinxAtStartPar
DataRateValue

\item {} 
\sphinxAtStartPar
DoubleValue

\item {} 
\sphinxAtStartPar
EmptyAttributeValue

\item {} 
\sphinxAtStartPar
EnumValue

\item {} 
\sphinxAtStartPar
IntegerValue

\item {} 
\sphinxAtStartPar
Ipv4AddressValue

\item {} 
\sphinxAtStartPar
Ipv4MaskValue

\item {} 
\sphinxAtStartPar
Ipv6AddressValue

\item {} 
\sphinxAtStartPar
Ipv6PrefixValue

\item {} 
\sphinxAtStartPar
LengthValue

\item {} 
\sphinxAtStartPar
Mac16AddressValue

\item {} 
\sphinxAtStartPar
Mac48AddressValue

\item {} 
\sphinxAtStartPar
Mac64AddressValue

\item {} 
\sphinxAtStartPar
ObjectFactoryValue

\item {} 
\sphinxAtStartPar
ObjectPtrContainerValue

\item {} 
\sphinxAtStartPar
PairValue\textless{}A, B\textgreater{}

\item {} 
\sphinxAtStartPar
PointerValue

\item {} 
\sphinxAtStartPar
PriomapValue

\item {} 
\sphinxAtStartPar
QueueSizeValue

\item {} 
\sphinxAtStartPar
RectangleValue

\item {} 
\sphinxAtStartPar
SsidValue

\item {} 
\sphinxAtStartPar
TimeValue

\item {} 
\sphinxAtStartPar
TupleValue\textless{}Args…\textgreater{}

\sphinxAtStartPar
A TupleValue is capable of storing values of different types, hence it is suitable for
structured data. A prominent example is the ChannelSettings attribute of WifiPhy, which
consists of channel number, channel width, PHY band and primary 20 MHz channel index.
In this case the values have to be mutually consistent, which makes it difficult to set them
as individual Attributes. Capturing them in a TupleValue simplifies this problem, see
\sphinxcode{\sphinxupquote{src/wifi/model/wifi\sphinxhyphen{}phy.cc}}.

\sphinxAtStartPar
Values stored in a TupleValue object can be set/get through a std::tuple object or
can be serialized to/deserialized from a string containing a comma\sphinxhyphen{}separated sequence of
the values enclosed in a pair of curly braces (e.g., “\{36, 20, BAND\_5GHZ, 0\}”).

\sphinxAtStartPar
The usage of the TupleValue attribute is illustrated in
\sphinxcode{\sphinxupquote{src/core/test/tuple\sphinxhyphen{}value\sphinxhyphen{}test\sphinxhyphen{}suite.cc}}.

\item {} 
\sphinxAtStartPar
TypeIdValue

\item {} 
\sphinxAtStartPar
UanModesListValue

\item {} 
\sphinxAtStartPar
UintegerValue

\item {} 
\sphinxAtStartPar
Vector2DValue

\item {} 
\sphinxAtStartPar
Vector3DValue

\item {} 
\sphinxAtStartPar
WaypointValue

\item {} 
\sphinxAtStartPar
WifiModeValue

\end{itemize}


\subsubsection{Defining Attributes}
\label{\detokenize{attributes:defining-attributes}}
\sphinxAtStartPar
We provide a way for users to access values deep in the system, without having
to plumb accessors (pointers) through the system and walk pointer chains to get
to them. Consider a class \sphinxcode{\sphinxupquote{QueueBase}} that has a member variable
\sphinxcode{\sphinxupquote{m\_maxSize}} controlling the depth of the queue.

\sphinxAtStartPar
If we look at the declaration of \sphinxcode{\sphinxupquote{QueueBase}}, we see
the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{QueueBase}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Object}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{  }\PYG{n}{QueueSize}\PYG{+w}{ }\PYG{n}{m\PYGZus{}maxSize}\PYG{p}{;}\PYG{+w}{                }\PYG{c+c1}{//!\PYGZlt{} max queue size}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QueueSize}} is a special type in \sphinxstyleemphasis{ns\sphinxhyphen{}3} that allows size
to be represented in different units:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{QueueSizeUnit}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{PACKETS}\PYG{p}{,}\PYG{+w}{     }\PYG{c+cm}{/**\PYGZlt{} Use number of packets for queue size */}
\PYG{+w}{  }\PYG{n}{BYTES}\PYG{p}{,}\PYG{+w}{       }\PYG{c+cm}{/**\PYGZlt{} Use number of bytes for queue size */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{QueueSize}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{  }\PYG{n}{QueueSizeUnit}\PYG{+w}{ }\PYG{n}{m\PYGZus{}unit}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//!\PYGZlt{} unit}
\PYG{+w}{  }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{m\PYGZus{}value}\PYG{p}{;}\PYG{+w}{     }\PYG{c+c1}{//!\PYGZlt{} queue size [bytes or packets]}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, the class \sphinxcode{\sphinxupquote{DropTailQueue}} inherits from this base
class and provides the semantics that packets that are submitted to
a full queue will be dropped from the back of the queue (“drop tail”).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}ingroup queue}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * \PYGZbs{}brief A FIFO packet queue that drops tail\PYGZhy{}end packets on overflow}
\PYG{c+cm}{ */}
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{Item}\PYG{o}{\PYGZgt{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{DropTailQueue}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s consider things that a user may want to do with the value of
\sphinxcode{\sphinxupquote{m\_maxSize}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Set a default value for the system, such that whenever a new
\sphinxcode{\sphinxupquote{DropTailQueue}} is created, this member is initialized
to that default.

\item {} 
\sphinxAtStartPar
Set or get the value on an already instantiated queue.

\end{itemize}

\sphinxAtStartPar
The above things typically require providing \sphinxcode{\sphinxupquote{Set()}} and \sphinxcode{\sphinxupquote{Get()}}
functions, and some type of global default value.

\sphinxAtStartPar
In the \sphinxstyleemphasis{ns\sphinxhyphen{}3} attribute system, these value definitions and accessor function
registrations are moved into the \sphinxcode{\sphinxupquote{TypeId}} class; \sphinxstyleemphasis{e.g}.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED}\PYG{p}{(}\PYG{n}{QueueBase}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId}
\PYG{n+nf}{QueueBase::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::DropTailQueue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The max queue size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{QueueSizeValue}\PYG{p}{(}\PYG{n}{QueueSize}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeQueueSizeAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{QueueBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetMaxSize}\PYG{p}{,}
\PYG{+w}{                                        }\PYG{o}{\PYGZam{}}\PYG{n}{QueueBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetMaxSize}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeQueueSizeChecker}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{    }\PYG{p}{;}

\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{AddAttribute()}} method is performing a number of things for the
\sphinxcode{\sphinxupquote{m\_maxSize}} value:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Binding the (usually private) member variable \sphinxcode{\sphinxupquote{m\_maxSize}}
to a public string \sphinxcode{\sphinxupquote{"MaxSize"}}.

\item {} 
\sphinxAtStartPar
Providing a default value (0 packets).

\item {} 
\sphinxAtStartPar
Providing some help text defining the meaning of the value.

\item {} 
\sphinxAtStartPar
Providing a “Checker” (not used in this example) that can be used to set
bounds on the allowable range of values.

\end{itemize}

\sphinxAtStartPar
The key point is that now the value of this variable and its default value are
accessible in the attribute namespace, which is based on strings such as
\sphinxcode{\sphinxupquote{"MaxSize"}} and \sphinxcode{\sphinxupquote{TypeId}} name strings. In the next section,
we will provide an example script that shows how users may manipulate
these values.

\sphinxAtStartPar
Note that initialization of the attribute relies on the macro
\sphinxcode{\sphinxupquote{NS\_OBJECT\_ENSURE\_REGISTERED(QueueBase)}} being called; if you leave this
out of your new class implementation, your attributes will not be initialized
correctly.

\sphinxAtStartPar
While we have described how to create attributes, we still haven’t described how
to access and manage these values. For instance, there is no \sphinxcode{\sphinxupquote{globals.h}}
header file where these are stored; attributes are stored with their classes.
Questions that naturally arise are how do users easily learn about all of the
attributes of their models, and how does a user access these attributes, or
document their values as part of the record of their simulation?

\sphinxAtStartPar
Detailed documentation of the actual attributes defined for a type,
and a global list of all defined attributes, are available in
the API documentation.  For the rest of this document we are going
to demonstrate the various ways of getting and setting attribute values.


\subsubsection{Setting Default Values}
\label{\detokenize{attributes:setting-default-values}}

\paragraph{Config::SetDefault and CommandLine}
\label{\detokenize{attributes:config-setdefault-and-commandline}}
\sphinxAtStartPar
Let’s look at how a user script might access a specific attribute value.
We’re going to use the
\sphinxcode{\sphinxupquote{src/point\sphinxhyphen{}to\sphinxhyphen{}point/examples/main\sphinxhyphen{}attribute\sphinxhyphen{}value.cc}}
script for illustration, with some details stripped out.  The \sphinxcode{\sphinxupquote{main}}
function begins:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a basic example of how to use the attribute system to}
\PYG{c+c1}{// set and get a value in the underlying system; namely, the maximum}
\PYG{c+c1}{// size of the FIFO queue in the PointToPointNetDevice}
\PYG{c+c1}{//}

\PYG{k+kt}{int}
\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{+w}{  }\PYG{c+c1}{// Queues in ns\PYGZhy{}3 are objects that hold items (other objects) in}
\PYG{+w}{  }\PYG{c+c1}{// a queue structure.  The C++ implementation uses templates to}
\PYG{+w}{  }\PYG{c+c1}{// allow queues to hold various types of items, but the most}
\PYG{+w}{  }\PYG{c+c1}{// common is a pointer to a packet(Ptr\PYGZlt{}Packet\PYGZgt{}).}
\PYG{+w}{  }\PYG{c+c1}{//}
\PYG{+w}{  }\PYG{c+c1}{// The maximum queue size can either be enforced in bytes (\PYGZsq{}b\PYGZsq{}) or}
\PYG{+w}{  }\PYG{c+c1}{// packets (\PYGZsq{}p\PYGZsq{}).  A special type called the ns3::QueueSize can}
\PYG{+w}{  }\PYG{c+c1}{// hold queue size values in either unit (bytes or packets).  The}
\PYG{+w}{  }\PYG{c+c1}{// queue base class ns3::QueueBase has a MaxSize attribute that can}
\PYG{+w}{  }\PYG{c+c1}{// be set to a QueueSize.}

\PYG{+w}{  }\PYG{c+c1}{// By default, the MaxSize attribute has a value of 100 packets (\PYGZsq{}100p\PYGZsq{})}
\PYG{+w}{  }\PYG{c+c1}{// (this default can be observed in the function QueueBase::GetTypeId)}
\PYG{+w}{  }\PYG{c+c1}{//}
\PYG{+w}{  }\PYG{c+c1}{// Here, we set it to 80 packets.  We could use one of two value types:}
\PYG{+w}{  }\PYG{c+c1}{// a string\PYGZhy{}based value or a QueueSizeValue value}
\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::QueueBase::MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{80p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+c1}{// The below function call is redundant}
\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::QueueBase::MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QueueSizeValue}\PYG{p}{(}\PYG{n}{QueueSize}\PYG{p}{(}\PYG{n}{QueueSizeUnit}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PACKETS}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The main thing to notice in the above are the two equivalent calls to
\sphinxcode{\sphinxupquote{Config::SetDefault()}}.  This is how we set the default value
for all subsequently instantiated \sphinxcode{\sphinxupquote{DropTailQueue}}s.  We illustrate
that two types of \sphinxcode{\sphinxupquote{Value}} classes, a \sphinxcode{\sphinxupquote{StringValue}} and
a \sphinxcode{\sphinxupquote{QueueSizeValue}} class, can be used to assign the value
to the attribute named by “ns3::QueueBase::MaxSize”.

\sphinxAtStartPar
It is also possible to manipulate Attributes using the \sphinxcode{\sphinxupquote{CommandLine}};
we saw some examples early in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Tutorial.  In particular, it is
straightforward to add a shorthand argument name, such as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}maxSize}},
for an Attribute that is particular relevant for your model, in this case
\sphinxcode{\sphinxupquote{"ns3::QueueBase::MaxSize"}}.  This has the additional feature that
the help string for the Attribute will be printed as part of the usage
message for the script.  For more information see
the \sphinxcode{\sphinxupquote{CommandLine}} API documentation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Allow the user to override any of the defaults and the above}
\PYG{c+c1}{// SetDefaults() at run\PYGZhy{}time, via command\PYGZhy{}line arguments}
\PYG{c+c1}{// For example, via \PYGZdq{}\PYGZhy{}\PYGZhy{}ns3::QueueBase::MaxSize=80p\PYGZdq{}}
\PYG{n}{CommandLine}\PYG{+w}{ }\PYG{n}{cmd}\PYG{p}{;}
\PYG{c+c1}{// This provides yet another way to set the value from the command line:}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::QueueBase::MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, we will create a few objects using the low\sphinxhyphen{}level API.  Our
newly created queues will not have \sphinxcode{\sphinxupquote{m\_maxSize}} initialized to
0 packets, as defined in the \sphinxcode{\sphinxupquote{QueueBase::GetTypeId()}}
function, but to 80 packets, because of what we did above with
default values.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{n0}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{net0}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{n0}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddDevice}\PYG{p}{(}\PYG{n}{net0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{q}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DropTailQueue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{net0}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddQueue}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, we have created a single \sphinxcode{\sphinxupquote{Node}} (\sphinxcode{\sphinxupquote{n0}})
and a single \sphinxcode{\sphinxupquote{PointToPointNetDevice}} (\sphinxcode{\sphinxupquote{net0}}),
added a \sphinxcode{\sphinxupquote{DropTailQueue}} (\sphinxcode{\sphinxupquote{q}}) to \sphinxcode{\sphinxupquote{net0}},
which will be configured with a queue size limit of 80 packets.

\sphinxAtStartPar
As a final note, the \sphinxtitleref{Config::Set…()} functions
will throw an error if the targeted Attribute does not exist at the path
given.  There are also “fail\sphinxhyphen{}safe” versions,
\sphinxtitleref{Config::Set…FailSafe()}, if you can’t be sure the Attribute
exists.  The fail\sphinxhyphen{}safe versions return \sphinxtitleref{true} if at least one instance
could be set.


\paragraph{Constructors, Helpers and ObjectFactory}
\label{\detokenize{attributes:constructors-helpers-and-objectfactory}}
\sphinxAtStartPar
Arbitrary combinations of attributes can be set and fetched from
the helper and low\sphinxhyphen{}level APIs; either from the constructors themselves:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{GridPositionAllocator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{  }\PYG{n}{CreateObjectWithAttributes}\PYG{o}{\PYGZlt{}}\PYG{n}{GridPositionAllocator}\PYG{o}{\PYGZgt{}}
\PYG{+w}{   }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{\PYGZhy{}100.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{\PYGZhy{}100.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GridWidth}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LayoutType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RowFirst}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or from the higher\sphinxhyphen{}level helper APIs, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mobility}\PYG{p}{.}\PYG{n}{SetPositionAllocator}
\PYG{+w}{   }\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::GridPositionAllocator}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{\PYGZhy{}100.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{\PYGZhy{}100.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DoubleValue}\PYG{p}{(}\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GridWidth}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LayoutType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RowFirst}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We don’t illustrate it here, but you can also configure an
\sphinxcode{\sphinxupquote{ObjectFactory}} with new values for specific attributes.
Instances created by the \sphinxcode{\sphinxupquote{ObjectFactory}} will have those
attributes set during construction.  This is very similar to using
one of the helper APIs for the class.

\sphinxAtStartPar
To review, there are several ways to set values for attributes for
class instances \sphinxstyleemphasis{to be created in the future:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Config::SetDefault()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CommandLine::AddValue()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CreateObjectWithAttributes\textless{}\textgreater{}()}}

\item {} 
\sphinxAtStartPar
Various helper APIs

\end{itemize}

\sphinxAtStartPar
But what if you’ve already created an instance, and you want
to change the value of the attribute?  In this example, how can we
manipulate the \sphinxcode{\sphinxupquote{m\_maxSize}} value of the already instantiated
\sphinxcode{\sphinxupquote{DropTailQueue}}?  Here are various ways to do that.


\subsubsection{Changing Values}
\label{\detokenize{attributes:changing-values}}

\paragraph{SmartPointer}
\label{\detokenize{attributes:smartpointer}}
\sphinxAtStartPar
Assume that a smart pointer (\sphinxcode{\sphinxupquote{Ptr}}) to a relevant network device
is in hand; in the current example, it is the \sphinxcode{\sphinxupquote{net0}} pointer.

\sphinxAtStartPar
One way to change the value is to access a pointer to the underlying queue and
modify its attribute.

\sphinxAtStartPar
First, we observe that we can get a pointer to the (base class)
\sphinxcode{\sphinxupquote{Queue}} \sphinxstyleemphasis{via} the
\sphinxcode{\sphinxupquote{PointToPointNetDevice}} attributes, where it is called
\sphinxcode{\sphinxupquote{"TxQueue"}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PointerValue}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{;}
\PYG{n}{net0}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TxQueue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{txQueue}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{.}\PYG{n}{Get}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Using the \sphinxcode{\sphinxupquote{GetObject()}} function, we can perform a safe downcast
to a \sphinxcode{\sphinxupquote{DropTailQueue}}.  The \sphinxtitleref{NS\_ASSERT} checks that the pointer is
valid.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DropTailQueue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{dtq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DropTailQueue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{dtq}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, we can get the value of an attribute on this queue.  We have introduced
wrapper \sphinxcode{\sphinxupquote{Value}} classes for the underlying data types, similar
to Java wrappers around these types, since the attribute system stores values
serialized to strings, and not disparate types.  Here, the attribute value
method on this value produces the (unwrapped) \sphinxcode{\sphinxupquote{QueueSize}}.  That is,
is assigned to a \sphinxcode{\sphinxupquote{QueueSizeValue}}, and the \sphinxcode{\sphinxupquote{Get()}}
the variable \sphinxtitleref{limit} is written into by the GetAttribute method.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QueueSizeValue}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{;}
\PYG{n}{dtq}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.  dtq limit: }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the above downcast is not really needed; we could have gotten
the attribute value directly from \sphinxcode{\sphinxupquote{txQueue}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2.  txQueue limit: }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, let’s set it to another value (60 packets).  Let’s also make
use of the StringValue shorthand notation to set the size by
passing in a string (the string must be a positive integer suffixed
by either the \sphinxtitleref{p} or \sphinxtitleref{b} character).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{60p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3.  txQueue limit changed: }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Config Namespace Path}
\label{\detokenize{attributes:config-namespace-path}}
\sphinxAtStartPar
An alternative way to get at the attribute is to use the configuration
namespace.  Here, this attribute resides on a known path in this namespace; this
approach is useful if one doesn’t have access to the underlying pointers and
would like to configure a specific attribute with a single statement.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/0/DeviceList/0/TxQueue/MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4.  txQueue limit changed through namespace: }\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{            }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The configuration path often has the form of
\sphinxcode{\sphinxupquote{".../\textless{}container name\textgreater{}/\textless{}index\textgreater{}/.../\textless{}attribute\textgreater{}/\textless{}attribute\textgreater{}"}}
to refer to a specific instance by index of an object in the container.
In this case the first container is the list of all \sphinxcode{\sphinxupquote{Node}}s;
the second container is the list of all \sphinxcode{\sphinxupquote{NetDevice}}s on
the chosen \sphinxcode{\sphinxupquote{Node}}.  Finally, the configuration path usually
ends with a succession of member attributes, in this case the \sphinxcode{\sphinxupquote{"MaxSize"}}
attribute of the \sphinxcode{\sphinxupquote{"TxQueue"}} of the chosen \sphinxcode{\sphinxupquote{NetDevice}}.

\sphinxAtStartPar
We could have also used wildcards to set this value for all nodes and all net
devices(which in this simple example has the same effect as the previous
\sphinxcode{\sphinxupquote{Config::Set()}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/DeviceList/*/TxQueue/MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{15p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5.  txQueue limit changed through wildcarded namespace: }\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{            }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you run this program from the command line, you should see the following
output corresponding to the steps we took above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }main\PYGZhy{}attribute\PYGZhy{}value
\PYG{l+m}{1}.\PYG{+w}{  }dtq\PYG{+w}{ }limit:\PYG{+w}{ }80p
\PYG{l+m}{2}.\PYG{+w}{  }txQueue\PYG{+w}{ }limit:\PYG{+w}{ }80p
\PYG{l+m}{3}.\PYG{+w}{  }txQueue\PYG{+w}{ }limit\PYG{+w}{ }changed:\PYG{+w}{ }60p
\PYG{l+m}{4}.\PYG{+w}{  }txQueue\PYG{+w}{ }limit\PYG{+w}{ }changed\PYG{+w}{ }through\PYG{+w}{ }namespace:\PYG{+w}{ }25p
\PYG{l+m}{5}.\PYG{+w}{  }txQueue\PYG{+w}{ }limit\PYG{+w}{ }changed\PYG{+w}{ }through\PYG{+w}{ }wildcarded\PYG{+w}{ }namespace:\PYG{+w}{ }15p
\end{sphinxVerbatim}


\paragraph{Object Name Service}
\label{\detokenize{attributes:object-name-service}}
\sphinxAtStartPar
Another way to get at the attribute is to use the object name service facility.
The object name service allows us to add items to the configuration
namespace under the \sphinxcode{\sphinxupquote{"/Names/"}} path with a user\sphinxhyphen{}defined name string.
This approach is useful if one doesn’t have access to the underlying
pointers and it is difficult to determine the required concrete configuration
namespace path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{net0}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/server/eth0/TxQueue/MaxPackets}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we’ve added the path elements \sphinxcode{\sphinxupquote{"server"}} and \sphinxcode{\sphinxupquote{"eth0"}} under
the \sphinxcode{\sphinxupquote{"/Names/"}} namespace, then used the resulting configuration path
to set the attribute.

\sphinxAtStartPar
See {\hyperref[\detokenize{object-names:object-names}]{\sphinxcrossref{\DUrole{std,std-ref}{Object names}}}} for a fuller treatment of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration namespace.


\subsection{Implementation Details}
\label{\detokenize{attributes:implementation-details}}

\subsubsection{Value Classes}
\label{\detokenize{attributes:value-classes}}
\sphinxAtStartPar
Readers will note the \sphinxcode{\sphinxupquote{TypeValue}} classes which are subclasses of the
\sphinxcode{\sphinxupquote{AttributeValue}} base class. These can be thought of as
intermediate classes which are used to convert from raw types to the
\sphinxcode{\sphinxupquote{AttributeValue}}s that are used by the attribute system.
Recall that this database is holding objects of many types serialized
to strings. Conversions to this type can either be done using
an intermediate class (such as \sphinxcode{\sphinxupquote{IntegerValue}},
or \sphinxcode{\sphinxupquote{DoubleValue}} for floating point numbers)
or \sphinxstyleemphasis{via} strings. Direct implicit conversion of types to
\sphinxcode{\sphinxupquote{AttributeValue}} is not really practical.
So in the above, users have a choice of using strings or values:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cwnd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// string\PYGZhy{}based setter}
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Set}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cwnd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{IntegerValue}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// integer\PYGZhy{}based setter}
\end{sphinxVerbatim}

\sphinxAtStartPar
The system provides some macros that help users declare and define
new AttributeValue subclasses for new types that they want to introduce into
the attribute system:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ATTRIBUTE\_HELPER\_HEADER}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ATTRIBUTE\_HELPER\_CPP}}

\end{itemize}

\sphinxAtStartPar
See the API documentation for these constructs for more information.


\subsubsection{Initialization Order}
\label{\detokenize{attributes:initialization-order}}
\sphinxAtStartPar
Attributes in the system must not depend on the state of any other Attribute in
this system. This is because an ordering of Attribute initialization is not
specified, nor enforced, by the system. A specific example of this can be seen
in automated configuration programs such as \sphinxcode{\sphinxupquote{ConfigStore}}.
Although a given model may arrange it so that Attributes are initialized in a
particular order, another automatic configurator may decide independently to
change Attributes in, for example, alphabetic order.

\sphinxAtStartPar
Because of this non\sphinxhyphen{}specific ordering, no Attribute in the system may have any
dependence on any other Attribute. As a corollary, Attribute setters must never
fail due to the state of another Attribute. No Attribute setter may change (set)
any other Attribute value as a result of changing its value.

\sphinxAtStartPar
This is a very strong restriction and there are cases where Attributes must set
consistently to allow correct operation. To this end we do allow for consistency
checking \sphinxstyleemphasis{when the attribute is used} (\sphinxstyleemphasis{cf}. \sphinxcode{\sphinxupquote{NS\_ASSERT\_MSG}}
or \sphinxcode{\sphinxupquote{NS\_ABORT\_MSG}}).

\sphinxAtStartPar
In general, the attribute code to assign values to the underlying class member
variables is executed after an object is constructed. But what if you need the
values assigned before the constructor body executes, because you need them in
the logic of the constructor? There is a way to do this, used for example in the
class \sphinxcode{\sphinxupquote{ConfigStore}}: call \sphinxcode{\sphinxupquote{ObjectBase::ConstructSelf()}} as
follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ConfigStore}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ConfigStore}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{ObjectBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ConstructSelf}\PYG{p}{(}\PYG{n}{AttributeConstructionList}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+c1}{// continue on with constructor.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Beware that the object and all its derived classes must also implement
a \sphinxcode{\sphinxupquote{GetInstanceTypeId()}} method. Otherwise
the \sphinxcode{\sphinxupquote{ObjectBase::ConstructSelf()}} will not be able to read
the attributes.


\subsubsection{Adding Attributes}
\label{\detokenize{attributes:adding-attributes}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} system will place a number of internal values under the attribute
system, but undoubtedly users will want to extend this to pick up ones we have
missed, or to add their own classes to the system.

\sphinxAtStartPar
There are three typical use cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Making an existing class data member accessible as an Attribute,
when it isn’t already.

\item {} 
\sphinxAtStartPar
Making a new class able to expose some data members as Attributes
by giving it a TypeId.

\item {} 
\sphinxAtStartPar
Creating an \sphinxcode{\sphinxupquote{AttributeValue}} subclass for a new class
so that it can be accessed as an Attribute.

\end{itemize}


\paragraph{Existing Member Variable}
\label{\detokenize{attributes:existing-member-variable}}
\sphinxAtStartPar
Consider this variable in \sphinxcode{\sphinxupquote{TcpSocket}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{m\PYGZus{}cWnd}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// Congestion window}
\end{sphinxVerbatim}

\sphinxAtStartPar
Suppose that someone working with TCP wanted to get or set the value of that
variable using the metadata system. If it were not already provided by \sphinxstyleemphasis{ns\sphinxhyphen{}3},
the user could declare the following addition in the runtime metadata system (to
the \sphinxcode{\sphinxupquote{GetTypeId()}} definition for \sphinxcode{\sphinxupquote{TcpSocket}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Congestion window}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{              }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tcp congestion window(bytes)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{              }\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{              }\PYG{n}{MakeUintegerAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{TcpSocket}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}cWnd}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{              }\PYG{n}{MakeUintegerChecker}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, the user with a pointer to a \sphinxcode{\sphinxupquote{TcpSocket}} instance
can perform operations such as
setting and getting the value, without having to add these functions explicitly.
Furthermore, access controls can be applied, such as allowing the parameter to
be read and not written, or bounds checking on the permissible values can be
applied.


\paragraph{New Class TypeId}
\label{\detokenize{attributes:new-class-typeid}}
\sphinxAtStartPar
Here, we discuss the impact on a user who wants to add a new class to \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
What additional things must be done to enable it to hold attributes?

\sphinxAtStartPar
Let’s assume our new class, called \sphinxcode{\sphinxupquote{ns3::MyMobility}},
is a type of mobility model.  First, the class should inherit from
its parent class, \sphinxcode{\sphinxupquote{ns3::MobilityModel}}.
In the \sphinxcode{\sphinxupquote{my\sphinxhyphen{}mobility.h}} header file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyMobility}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{MobilityModel}
\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This requires we declare the \sphinxcode{\sphinxupquote{GetTypeId()}} function.
This is a one\sphinxhyphen{}line public function declaration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{c+cm}{/**}
\PYG{c+cm}{   *  Register this type.}
\PYG{c+cm}{   *  \PYGZbs{}return The object TypeId.}
\PYG{c+cm}{   */}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We’ve already introduced what a \sphinxcode{\sphinxupquote{TypeId}} definition will look like
in the \sphinxcode{\sphinxupquote{my\sphinxhyphen{}mobility.cc}} implementation file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED}\PYG{p}{(}\PYG{n}{MyMobility}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId}
\PYG{n+nf}{MyMobility::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::MyMobility}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{MobilityModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mobility}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{MyMobility}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bounds}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bounds of the area to cruise.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{RectangleValue}\PYG{p}{(}\PYG{n}{Rectangle}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{100.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeRectangleAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyMobility}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}bounds}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeRectangleChecker}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Change current direction and speed after moving for this delay.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{c+c1}{// etc (more parameters).}
\PYG{+w}{                  }\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeTimeAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyMobility}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}modeTime}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakeTimeChecker}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we don’t want to subclass from an existing class, in the header file
we just inherit from \sphinxcode{\sphinxupquote{ns3::Object}}, and in the object file
we set the parent class to \sphinxcode{\sphinxupquote{ns3::Object}} with
\sphinxcode{\sphinxupquote{.SetParent\textless{}Object\textgreater{}()}}.

\sphinxAtStartPar
Typical mistakes here involve:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Not calling \sphinxcode{\sphinxupquote{NS\_OBJECT\_ENSURE\_REGISTERED()}}

\item {} 
\sphinxAtStartPar
Not calling the \sphinxcode{\sphinxupquote{SetParent()}} method,
or calling it with the wrong type.

\item {} 
\sphinxAtStartPar
Not calling the \sphinxcode{\sphinxupquote{AddConstructor()}} method,
or calling it with the wrong type.

\item {} 
\sphinxAtStartPar
Introducing a typographical error in the name of the \sphinxcode{\sphinxupquote{TypeId}}
in its constructor.

\item {} 
\sphinxAtStartPar
Not using the fully\sphinxhyphen{}qualified C++ typename of the enclosing C++ class as the
name of the \sphinxcode{\sphinxupquote{TypeId}}.  Note that \sphinxcode{\sphinxupquote{"ns3::"}} is required.

\end{itemize}

\sphinxAtStartPar
None of these mistakes can be detected by the \sphinxstyleemphasis{ns\sphinxhyphen{}3} codebase, so users
are advised to check carefully multiple times that they got these right.


\paragraph{New AttributeValue Type}
\label{\detokenize{attributes:new-attributevalue-type}}
\sphinxAtStartPar
From the perspective of the user who writes a new class in the system and wants
it to be accessible as an attribute, there is mainly the matter of writing the
conversions to/from strings and attribute values.  Most of this can be
copy/pasted with macro\sphinxhyphen{}ized code.  For instance, consider a class declaration
for \sphinxcode{\sphinxupquote{Rectangle}} in the \sphinxcode{\sphinxupquote{src/mobility/model}} directory:


\subparagraph{Header File}
\label{\detokenize{attributes:header-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}brief a 2d rectangle}
\PYG{c+cm}{ */}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Rectangle}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{xMin}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{xMax}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{yMin}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{yMax}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
One macro call and two operators, must be added below the class declaration in
order to turn a Rectangle into a value usable by the \sphinxcode{\sphinxupquote{Attribute}} system:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Rectangle}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Rectangle}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ATTRIBUTE\PYGZus{}HELPER\PYGZus{}HEADER}\PYG{p}{(}\PYG{n}{Rectangle}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{Implementation File}
\label{\detokenize{attributes:implementation-file}}
\sphinxAtStartPar
In the class definition (\sphinxcode{\sphinxupquote{.cc}} file), the code looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ATTRIBUTE\PYGZus{}HELPER\PYGZus{}CPP}\PYG{p}{(}\PYG{n}{Rectangle}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}
\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Rectangle}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{os}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMin}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMax}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMin}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|}\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{     }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMax}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}
\PYG{k}{operator}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Rectangle}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}
\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c3}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{is}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMin}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMax}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMin}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{c3}
\PYG{+w}{     }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMax}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{|}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}
\PYG{+w}{      }\PYG{n}{c2}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{|}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}
\PYG{+w}{      }\PYG{n}{c3}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{|}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{is}\PYG{p}{.}\PYG{n}{setstate}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ios\PYGZus{}base}\PYG{o}{:}\PYG{o}{:}\PYG{n}{failbit}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
These stream operators simply convert from a string representation of the
Rectangle(\sphinxcode{\sphinxupquote{"xMin|xMax|yMin|yMax"}}) to the underlying Rectangle.  The modeler
must specify these operators and the string syntactical representation of an
instance of the new class.


\subsection{ConfigStore}
\label{\detokenize{attributes:configstore}}
\sphinxAtStartPar
Values for \sphinxstyleemphasis{ns\sphinxhyphen{}3} attributes can be stored in an ASCII or XML text file
and loaded into a future simulation run.  This feature is known as the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} ConfigStore.  The \sphinxcode{\sphinxupquote{ConfigStore}} is a specialized database for attribute values and default values.

\sphinxAtStartPar
Although it is a separately maintained module in the
\sphinxcode{\sphinxupquote{src/config\sphinxhyphen{}store/}} directory, we document it here because of its
sole dependency on \sphinxstyleemphasis{ns\sphinxhyphen{}3} core module and attributes.

\sphinxAtStartPar
We can explore this system by using an example from
\sphinxcode{\sphinxupquote{src/config\sphinxhyphen{}store/examples/config\sphinxhyphen{}store\sphinxhyphen{}save.cc}}.

\sphinxAtStartPar
First, all users of the \sphinxcode{\sphinxupquote{ConfigStore}} must include
the following statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/config\PYGZhy{}store\PYGZhy{}module.h\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, this program adds a sample object \sphinxcode{\sphinxupquote{ConfigExample}}
to show how the system is extended:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ConfigExample}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::A}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{help text}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{IntegerValue}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}2}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MakeIntegerAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{A}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}int16}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MakeIntegerChecker}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int16\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{k+kt}{int16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{m\PYGZus{}int16}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED}\PYG{p}{(}\PYG{n}{ConfigExample}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, we use the Config subsystem to override the defaults in a couple of
ways:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigExample::TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{IntegerValue}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a\PYGZus{}obj}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ABORT\PYGZus{}MSG\PYGZus{}UNLESS}\PYG{p}{(}\PYG{n}{a\PYGZus{}obj}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}int16}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{,}
\PYG{+w}{                    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot set ConfigExample\PYGZsq{}s integer attribute via Config::SetDefault}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a2\PYGZus{}obj}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{a2\PYGZus{}obj}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{IntegerValue}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntegerValue}\PYG{+w}{ }\PYG{n}{iv}\PYG{p}{;}
\PYG{n}{a2\PYGZus{}obj}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{iv}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ABORT\PYGZus{}MSG\PYGZus{}UNLESS}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}3}\PYG{p}{,}
\PYG{+w}{                    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot set ConfigExample\PYGZsq{}s integer attribute via SetAttribute}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next statement is necessary to make sure that (one of) the objects
created is rooted in the configuration namespace as an object instance.
This normally happens when you aggregate objects to a \sphinxcode{\sphinxupquote{ns3::Node}}
or \sphinxcode{\sphinxupquote{ns3::Channel}} instance,
but here, since we are working at the core level, we need to create a
new root namespace object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{RegisterRootNamespaceObject}\PYG{p}{(}\PYG{n}{a2\PYGZus{}obj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Writing}
\label{\detokenize{attributes:writing}}
\sphinxAtStartPar
Next, we want to output the configuration store.  The examples show how
to do it in two formats, XML and raw text.  In practice, one should perform
this step just before calling \sphinxcode{\sphinxupquote{Simulator::Run()}} to save the
final configuration just before running the simulation.

\sphinxAtStartPar
There are three Attributes that govern the behavior of the ConfigStore:
\sphinxcode{\sphinxupquote{"Mode"}}, \sphinxcode{\sphinxupquote{"Filename"}}, and \sphinxcode{\sphinxupquote{"FileFormat"}}.  The Mode (default \sphinxcode{\sphinxupquote{"None"}})
configures whether \sphinxstyleemphasis{ns\sphinxhyphen{}3} should load configuration from a previously saved file
(specify \sphinxcode{\sphinxupquote{"Mode=Load"}}) or save it to a file (specify \sphinxcode{\sphinxupquote{"Mode=Save"}}).
The Filename (default \sphinxcode{\sphinxupquote{""}}) is where the ConfigStore should read or write
its data.  The FileFormat (default \sphinxcode{\sphinxupquote{"RawText"}}) governs whether
the ConfigStore format is plain text or Xml (\sphinxcode{\sphinxupquote{"FileFormat=Xml"}})

\sphinxAtStartPar
The example shows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZhy{}attributes.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Save}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ConfigStore}\PYG{+w}{ }\PYG{n}{outputConfig}\PYG{p}{;}
\PYG{n}{outputConfig}\PYG{p}{.}\PYG{n}{ConfigureDefaults}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{outputConfig}\PYG{p}{.}\PYG{n}{ConfigureAttributes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Output config store to txt format}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZhy{}attributes.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RawText}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Save}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ConfigStore}\PYG{+w}{ }\PYG{n}{outputConfig2}\PYG{p}{;}
\PYG{n}{outputConfig2}\PYG{p}{.}\PYG{n}{ConfigureDefaults}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{outputConfig2}\PYG{p}{.}\PYG{n}{ConfigureAttributes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the placement of these statements just prior to the
values in place just prior to starting the simulation (\sphinxstyleemphasis{i.e}. after
all of the configuration has taken place).

\sphinxAtStartPar
After running, you can open the \sphinxcode{\sphinxupquote{output\sphinxhyphen{}attributes.txt}} file and see:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
...
default ns3::ErrorModel::IsEnabled \PYGZdq{}true\PYGZdq{}
default ns3::RateErrorModel::ErrorUnit \PYGZdq{}ERROR\PYGZus{}UNIT\PYGZus{}BYTE\PYGZdq{}
default ns3::RateErrorModel::ErrorRate \PYGZdq{}0\PYGZdq{}
default ns3::RateErrorModel::RanVar \PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}
default ns3::BurstErrorModel::ErrorRate \PYGZdq{}0\PYGZdq{}
default ns3::BurstErrorModel::BurstStart \PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}
default ns3::BurstErrorModel::BurstSize \PYGZdq{}ns3::UniformRandomVariable[Min=1|Max=4]\PYGZdq{}
default ns3::PacketSocket::RcvBufSize \PYGZdq{}131072\PYGZdq{}
default ns3::PcapFileWrapper::CaptureSize \PYGZdq{}65535\PYGZdq{}
default ns3::PcapFileWrapper::NanosecMode \PYGZdq{}false\PYGZdq{}
default ns3::SimpleNetDevice::PointToPointMode \PYGZdq{}false\PYGZdq{}
default ns3::SimpleNetDevice::TxQueue \PYGZdq{}ns3::DropTailQueue\PYGZlt{}Packet\PYGZgt{}\PYGZdq{}
default ns3::SimpleNetDevice::DataRate \PYGZdq{}0bps\PYGZdq{}
default ns3::PacketSocketClient::MaxPackets \PYGZdq{}100\PYGZdq{}
default ns3::PacketSocketClient::Interval \PYGZdq{}+1000000000.0ns\PYGZdq{}
default ns3::PacketSocketClient::PacketSize \PYGZdq{}1024\PYGZdq{}
default ns3::PacketSocketClient::Priority \PYGZdq{}0\PYGZdq{}
default ns3::ConfigStore::Mode \PYGZdq{}Save\PYGZdq{}
default ns3::ConfigStore::Filename \PYGZdq{}output\PYGZhy{}attributes.txt\PYGZdq{}
default ns3::ConfigStore::FileFormat \PYGZdq{}RawText\PYGZdq{}
default ns3::ConfigExample::TestInt16 \PYGZdq{}\PYGZhy{}5\PYGZdq{}
global SimulatorImplementationType \PYGZdq{}ns3::DefaultSimulatorImpl\PYGZdq{}
global SchedulerType \PYGZdq{}ns3::MapScheduler\PYGZdq{}
global RngSeed \PYGZdq{}1\PYGZdq{}
global RngRun \PYGZdq{}1\PYGZdq{}
global ChecksumEnabled \PYGZdq{}false\PYGZdq{}
value /\PYGZdl{}ns3::ConfigExample/TestInt16 \PYGZdq{}\PYGZhy{}3\PYGZdq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above, several of the default values for attributes for the core
and network modules are shown.  Then, all the values for the \sphinxstyleemphasis{ns\sphinxhyphen{}3} global values
are recorded.  Finally, the value of the instance of \sphinxcode{\sphinxupquote{ConfigExample}}
that was rooted in the configuration namespace is shown.  In a real
\sphinxstyleemphasis{ns\sphinxhyphen{}3} program, many more models, attributes, and defaults would be shown.

\sphinxAtStartPar
An XML version also exists in \sphinxcode{\sphinxupquote{output\sphinxhyphen{}attributes.xml}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}?\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ns3}\PYG{n+nt}{\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ErrorModel::IsEnabled\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}true\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::RateErrorModel::ErrorUnit\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ERROR\PYGZus{}UNIT\PYGZus{}BYTE\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::RateErrorModel::ErrorRate\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::RateErrorModel::RanVar\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::BurstErrorModel::ErrorRate\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::BurstErrorModel::BurstStart\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::BurstErrorModel::BurstSize\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::UniformRandomVariable[Min=1|Max=4]\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocket::RcvBufSize\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}131072\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PcapFileWrapper::CaptureSize\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}65535\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PcapFileWrapper::NanosecMode\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::SimpleNetDevice::PointToPointMode\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::SimpleNetDevice::TxQueue\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::DropTailQueue\PYGZam{}lt;Packet\PYGZam{}gt;\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::SimpleNetDevice::DataRate\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0bps\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::MaxPackets\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}100\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::Interval\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}+1000000000.0ns\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::PacketSize\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}1024\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::Priority\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigStore::Mode\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}Save\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigStore::Filename\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}output\PYGZhy{}attributes.xml\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigStore::FileFormat\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}Xml\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}default}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigExample::TestInt16\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}\PYGZhy{}5\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}global}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}SimulatorImplementationType\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::DefaultSimulatorImpl\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}global}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}SchedulerType\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::MapScheduler\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}global}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}RngSeed\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}global}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}RngRun\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}global}\PYG{+w}{ }\PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ChecksumEnabled\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{+w}{ }\PYG{n+nt}{\PYGZlt{}value}\PYG{+w}{ }\PYG{n+na}{path=}\PYG{l+s}{\PYGZdq{}/\PYGZdl{}ns3::ConfigExample/TestInt16\PYGZdq{}}\PYG{+w}{ }\PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}\PYGZhy{}3\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/ns3\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This file can be archived with your simulation script and output data.


\subsubsection{Reading}
\label{\detokenize{attributes:reading}}
\sphinxAtStartPar
Next, we discuss configuring simulations \sphinxstyleemphasis{via} a stored input
configuration file.  There are a couple of key differences
compared to writing the final simulation configuration.  First, we
need to place statements such as these at the beginning of the program,
before simulation configuration statements are written (so the values
are registered before being used in object construction).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{input\PYGZhy{}defaults.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Load}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ConfigStore}\PYG{+w}{ }\PYG{n}{inputConfig}\PYG{p}{;}
\PYG{n}{inputConfig}\PYG{p}{.}\PYG{n}{ConfigureDefaults}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, note that loading of input configuration data is limited to Attribute
default (\sphinxstyleemphasis{i.e}. not instance) values, and global values.  Attribute instance
values are not supported because at this stage of the simulation, before
any objects are constructed, there are no such object instances around.
(Note, future enhancements to the config store may change this behavior).

\sphinxAtStartPar
Second, while the output of \sphinxcode{\sphinxupquote{ConfigStore}} state
will list everything in the database, the input file need only contain
the specific values to be overridden.  So, one way to use this class
for input file configuration is to generate an initial configuration
using the output (\sphinxcode{\sphinxupquote{"Save"}}) \sphinxcode{\sphinxupquote{"Mode"}} described above, extract from
that configuration file only the elements one wishes to change,
and move these minimal elements to a new configuration file
which can then safely be edited and loaded in a subsequent simulation run.

\sphinxAtStartPar
When the \sphinxcode{\sphinxupquote{ConfigStore}} object is instantiated, its attributes
\sphinxcode{\sphinxupquote{"Filename"}}, \sphinxcode{\sphinxupquote{"Mode"}}, and \sphinxcode{\sphinxupquote{"FileFormat"}} must be set,
either \sphinxstyleemphasis{via} command\sphinxhyphen{}line or \sphinxstyleemphasis{via} program statements.


\subsubsection{Reading/Writing Example}
\label{\detokenize{attributes:reading-writing-example}}
\sphinxAtStartPar
As a more complicated example, let’s assume that we want to read in a
configuration of defaults from an input file named \sphinxcode{\sphinxupquote{input\sphinxhyphen{}defaults.xml}}, and
write out the resulting attributes to a separate file called
\sphinxcode{\sphinxupquote{output\sphinxhyphen{}attributes.xml}}.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/config\PYGZhy{}store\PYGZhy{}module.h\PYGZdq{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{input\PYGZhy{}defaults.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Load}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{ConfigStore}\PYG{+w}{ }\PYG{n}{inputConfig}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{inputConfig}\PYG{p}{.}\PYG{n}{ConfigureDefaults}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{//}
\PYG{+w}{  }\PYG{c+c1}{// Allow the user to override any of the defaults and the above Bind() at}
\PYG{+w}{  }\PYG{c+c1}{// run\PYGZhy{}time, viacommand\PYGZhy{}line arguments}
\PYG{+w}{  }\PYG{c+c1}{//}
\PYG{+w}{  }\PYG{n}{CommandLine}\PYG{+w}{ }\PYG{n}{cmd}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// setup topology}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{+w}{  }\PYG{c+c1}{// Invoke just before entering Simulator::Run()}
\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZhy{}attributes.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Save}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{ConfigStore}\PYG{+w}{ }\PYG{n}{outputConfig}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{outputConfig}\PYG{p}{.}\PYG{n}{ConfigureAttributes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{ConfigStore use cases (pre\sphinxhyphen{} and post\sphinxhyphen{}simulation)}
\label{\detokenize{attributes:configstore-use-cases-pre-and-post-simulation}}
\sphinxAtStartPar
It is worth stressing that ConfigStore can be used for different purposes, and this is
reflected in where in the script ConfigStore is invoked.

\sphinxAtStartPar
The typical use\sphinxhyphen{}cases are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Change an Object default attributes

\item {} 
\sphinxAtStartPar
Inspect/change a \sphinxstyleemphasis{specific} Object attributes

\item {} 
\sphinxAtStartPar
Inspect the simulation Objects and their attributes

\end{itemize}

\sphinxAtStartPar
As a matter of fact, some Objects might be created when the simulation starts.
Hence, ConfigStore will not “report” their attributes if invoked earlier in the code.

\sphinxAtStartPar
A typical workflow might involve running the simulation, calling ConfigStore
at the end of the simulation (after \sphinxcode{\sphinxupquote{Simulator::Run()}} and before \sphinxcode{\sphinxupquote{Simulator::Destroy()}})
This will show all the attributes in the Objects, both those with default values, and those
with values changed during the simulation execution.

\sphinxAtStartPar
To change these values, you’ll need to either change the default (class\sphinxhyphen{}wide) attribute values
(in this case call ConfigStore before the Object creation), or  specific object attribute
(in this case call ConfigStore after the Object creation, typically just before \sphinxcode{\sphinxupquote{Simulator::Run()}}.


\subsubsection{ConfigStore GUI}
\label{\detokenize{attributes:configstore-gui}}
\sphinxAtStartPar
There is a GTK\sphinxhyphen{}based front end for the ConfigStore.  This allows users to use a
GUI to access and change variables.

\sphinxAtStartPar
Some screenshots are presented here. They are the result of using GtkConfig on
\sphinxcode{\sphinxupquote{src/lte/examples/lena\sphinxhyphen{}dual\sphinxhyphen{}stripe.cc}} after \sphinxcode{\sphinxupquote{Simulator::Run()}}.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{gtk-config-lena-dual-stripe-device-view}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{gtk-config-lena-dual-stripe-eNB-tx-power}.png}
\end{figure}

\sphinxAtStartPar
To use this feature, one must install \sphinxcode{\sphinxupquote{libgtk\sphinxhyphen{}3\sphinxhyphen{}dev}}; an example
Ubuntu installation command is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }sudo\PYG{+w}{ }apt\PYGZhy{}get\PYG{+w}{ }install\PYG{+w}{ }libgtk\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

\sphinxAtStartPar
On a MacOS it is possible to install GTK\sphinxhyphen{}3 using \sphinxhref{https://brew.sh}{Homebrew}.
The installation command is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }brew\PYG{+w}{ }install\PYG{+w}{ }gtk+3\PYG{+w}{ }adwaita\PYGZhy{}icon\PYGZhy{}theme
\end{sphinxVerbatim}

\sphinxAtStartPar
To check whether it is configured or not, check the output of the step:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }Summary\PYG{+w}{ }of\PYG{+w}{ }optional\PYG{+w}{ }NS\PYGZhy{}3\PYG{+w}{ }features:
Python\PYG{+w}{ }Bindings\PYG{+w}{               }:\PYG{+w}{ }enabled
Python\PYG{+w}{ }API\PYG{+w}{ }Scanning\PYG{+w}{ }Support\PYG{+w}{   }:\PYG{+w}{ }enabled
NS\PYGZhy{}3\PYG{+w}{ }Click\PYG{+w}{ }Integration\PYG{+w}{        }:\PYG{+w}{ }enabled
GtkConfigStore\PYG{+w}{                }:\PYG{+w}{ }not\PYG{+w}{ }enabled\PYG{+w}{ }\PYG{o}{(}library\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}gtk+\PYGZhy{}3.0 \PYGZgt{}= 3.0\PYGZsq{}}\PYG{+w}{ }not\PYG{+w}{ }found\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above example, it was not enabled, so it cannot be used until a suitable
version is installed and:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{}\PYG{+w}{ }./ns3
\end{sphinxVerbatim}

\sphinxAtStartPar
is rerun.

\sphinxAtStartPar
Usage is almost the same as the non\sphinxhyphen{}GTK\sphinxhyphen{}based version, but there
are no \sphinxcode{\sphinxupquote{ConfigStore}} attributes involved:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Invoke just before entering Simulator::Run()}
\PYG{n}{GtkConfigStore}\PYG{+w}{ }\PYG{n}{config}\PYG{p}{;}
\PYG{n}{config}\PYG{p}{.}\PYG{n}{ConfigureDefaults}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{config}\PYG{p}{.}\PYG{n}{ConfigureAttributes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, when you run the script, a GUI should pop up, allowing you to open menus of
attributes on different nodes/objects, and then launch the simulation execution
when you are done.

\sphinxAtStartPar
Note that “launch the simulation” means to proceed with the simulation script.
If GtkConfigStore has been called after \sphinxcode{\sphinxupquote{Simulator::Run()}} the simulation will
not be started again \sphinxhyphen{} it will just end.

\sphinxstepscope


\section{Object names}
\label{\detokenize{object-names:object-names}}\label{\detokenize{object-names:id1}}\label{\detokenize{object-names::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{Placeholder chapter}

\sphinxstepscope


\section{RealTime}
\label{\detokenize{realtime:realtime}}\label{\detokenize{realtime::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} has been designed for integration into testbed and virtual machine
environments. To integrate with real network stacks and emit/consume packets, a
real\sphinxhyphen{}time scheduler is needed to try to lock the simulation clock with the
hardware clock. We describe here a component of this: the RealTime scheduler.

\sphinxAtStartPar
The purpose of the realtime scheduler is to cause the progression of the
simulation clock to occur synchronously with respect to some external time base.
Without the presence of an external time base (wall clock), simulation time
jumps instantly from one simulated time to the next.


\subsection{Behavior}
\label{\detokenize{realtime:behavior}}
\sphinxAtStartPar
When using a non\sphinxhyphen{}realtime scheduler (the default in \sphinxstyleemphasis{ns\sphinxhyphen{}3}), the simulator
advances the simulation time to the next scheduled event. During event
execution, simulation time is frozen. With the realtime scheduler, the behavior
is similar from the perspective of simulation models (i.e., simulation time is
frozen during event execution), but between events, the simulator will attempt
to keep the simulation clock aligned with the machine clock.

\sphinxAtStartPar
When an event is finished executing, and the scheduler moves to the next event,
the scheduler compares the next event execution time with the machine clock.  If
the next event is scheduled for a future time, the simulator sleeps until that
realtime is reached and then executes the next event.

\sphinxAtStartPar
It may happen that, due to the processing inherent in the execution of
simulation events, that the simulator cannot keep up with realtime.  In such a
case, it is up to the user configuration what to do. There are two \sphinxstyleemphasis{ns\sphinxhyphen{}3}
attributes that govern the behavior. The first is
\sphinxcode{\sphinxupquote{ns3::RealTimeSimulatorImpl::SynchronizationMode}}. The two entries possible
for this attribute are \sphinxcode{\sphinxupquote{BestEffort}} (the default) or \sphinxcode{\sphinxupquote{HardLimit}}. In
“BestEffort” mode, the simulator will just try to catch up to realtime by
executing events until it reaches a point where the next event is in the
(realtime) future, or else the simulation ends. In BestEffort mode, then, it is
possible for the simulation to consume more time than the wall clock time. The
other option “HardLimit” will cause the simulation to abort if the tolerance
threshold is exceeded.  This attribute is
\sphinxcode{\sphinxupquote{ns3::RealTimeSimulatorImpl::HardLimit}} and the default is 0.1 seconds.

\sphinxAtStartPar
A different mode of operation is one in which simulated time is \sphinxstylestrong{not} frozen
during an event execution. This mode of realtime simulation was implemented but
removed from the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tree because of questions of whether it would be useful.
If users are interested in a realtime simulator for which simulation time does
not freeze during event execution (i.e., every call to \sphinxcode{\sphinxupquote{Simulator::Now()}}
returns the current wall clock time, not the time at which the event started
executing), please contact the ns\sphinxhyphen{}developers mailing list.


\subsection{Usage}
\label{\detokenize{realtime:usage}}
\sphinxAtStartPar
The usage of the realtime simulator is straightforward, from a scripting
perspective.  Users just need to set the attribute
\sphinxcode{\sphinxupquote{SimulatorImplementationType}} to the Realtime simulator, such as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GlobalValue}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SimulatorImplementationType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RealtimeSimulatorImpl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is a script in \sphinxcode{\sphinxupquote{examples/realtime/realtime\sphinxhyphen{}udp\sphinxhyphen{}echo.cc}} that
has an example of how to configure the realtime behavior.  Try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }realtime\PYGZhy{}udp\PYGZhy{}echo
\end{sphinxVerbatim}

\sphinxAtStartPar
Whether the simulator will work in a best effort or hard limit policy fashion is
governed by the attributes explained in the previous section.


\subsection{Implementation}
\label{\detokenize{realtime:implementation}}
\sphinxAtStartPar
The implementation is contained in the following files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{src/core/model/realtime\sphinxhyphen{}simulator\sphinxhyphen{}impl.\{cc,h\}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{src/core/model/wall\sphinxhyphen{}clock\sphinxhyphen{}synchronizer.\{cc,h\}}}

\end{itemize}

\sphinxAtStartPar
In order to create a realtime scheduler, to a first approximation you just want
to cause simulation time jumps to consume real time. We propose doing this using
a combination of sleep\sphinxhyphen{} and busy\sphinxhyphen{} waits. Sleep\sphinxhyphen{}waits cause the calling process
(thread) to yield the processor for some amount of time. Even though this
specified amount of time can be passed to nanosecond resolution, it is actually
converted to an OS\sphinxhyphen{}specific granularity. In Linux, the granularity is called a
Jiffy. Typically this resolution is insufficient for our needs (on the order of
a ten milliseconds), so we round down and sleep for some smaller number of
Jiffies. The process is then awakened after the specified number of Jiffies has
passed. At this time, we have some residual time to wait. This time is generally
smaller than the minimum sleep time, so we busy\sphinxhyphen{}wait for the remainder of the
time. This means that the thread just sits in a for loop consuming cycles until
the desired time arrives. After the combination of sleep\sphinxhyphen{} and busy\sphinxhyphen{}waits, the
elapsed realtime (wall) clock should agree with the simulation time of the next
event and the simulation proceeds.

\sphinxstepscope


\chapter{Additional Tools}
\label{\detokenize{features:additional-tools}}\label{\detokenize{features::doc}}
\sphinxAtStartPar
This chapter covers some additional features provided by ns\sphinxhyphen{}3 which can be useful in writing models and scripts.

\sphinxstepscope


\section{Random Variables}
\label{\detokenize{random-variables:random-variables}}\label{\detokenize{random-variables::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} contains a built\sphinxhyphen{}in pseudo\sphinxhyphen{}random number generator (PRNG). It is important
for serious users of the simulator to understand the functionality,
configuration, and usage of this PRNG, and to decide whether it is sufficient
for his or her research use.


\subsection{Quick Overview}
\label{\detokenize{random-variables:quick-overview}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} random numbers are provided via instances of
\sphinxcode{\sphinxupquote{ns3::RandomVariableStream}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
by default, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations use a fixed seed; if there is any randomness in
the simulation, each run of the program will yield identical results unless
the seed and/or run number is changed.

\item {} 
\sphinxAtStartPar
in \sphinxstyleemphasis{ns\sphinxhyphen{}3.3} and earlier, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations used a random seed by default; this
marks a change in policy starting with \sphinxstyleemphasis{ns\sphinxhyphen{}3.4}.

\item {} 
\sphinxAtStartPar
in \sphinxstyleemphasis{ns\sphinxhyphen{}3.14} and earlier, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations used a different wrapper class
called \sphinxcode{\sphinxupquote{ns3::RandomVariable}}.  As of \sphinxstyleemphasis{ns\sphinxhyphen{}3.15}, this class has been
replaced by \sphinxcode{\sphinxupquote{ns3::RandomVariableStream}}; the underlying pseudo\sphinxhyphen{}random
number generator has not changed.

\item {} 
\sphinxAtStartPar
to obtain randomness across multiple simulation runs, you must either set the
seed differently or set the run number differently.  To set a seed, call
\sphinxcode{\sphinxupquote{ns3::RngSeedManager::SetSeed()}} at the beginning of the program; to set
a run number with the same seed, call \sphinxcode{\sphinxupquote{ns3::RngSeedManager::SetRun()}} at
the beginning of the program; see {\hyperref[\detokenize{random-variables:seeding-and-independent-replications}]{\sphinxcrossref{\DUrole{std,std-ref}{Creating random variables}}}}.

\item {} 
\sphinxAtStartPar
each RandomVariableStream used in \sphinxstyleemphasis{ns\sphinxhyphen{}3} has a virtual random number generator
associated with it; all random variables use either a fixed or random seed
based on the use of the global seed (previous bullet);

\item {} 
\sphinxAtStartPar
if you intend to perform multiple runs of the same scenario, with different
random numbers, please be sure to read the section on how to perform
independent replications: {\hyperref[\detokenize{random-variables:seeding-and-independent-replications}]{\sphinxcrossref{\DUrole{std,std-ref}{Creating random variables}}}}.

\end{itemize}

\sphinxAtStartPar
Read further for more explanation about the random number facility for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Background}
\label{\detokenize{random-variables:background}}
\sphinxAtStartPar
Simulations use a lot of random numbers; one study
found that most network simulations spend as much as 50\%
of the CPU generating random numbers.  Simulation users need
to be concerned with the quality of the (pseudo) random numbers and
the independence between different streams of random numbers.

\sphinxAtStartPar
Users need to be concerned with a few issues, such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the seeding of the random number generator and whether a
simulation outcome is deterministic or not,

\item {} 
\sphinxAtStartPar
how to acquire different streams of random numbers that are
independent from one another, and

\item {} 
\sphinxAtStartPar
how long it takes for streams to cycle

\end{itemize}

\sphinxAtStartPar
We will introduce a few terms here:  a RNG provides a long sequence
of (pseudo) random numbers.
The length of this sequence is called the \sphinxstyleemphasis{cycle length}
or \sphinxstyleemphasis{period}, after which the RNG will repeat itself.
This sequence can
be  partitioned into disjoint \sphinxstyleemphasis{streams}.  A stream of a
RNG is a contiguous subset or block of the RNG sequence.
For instance, if the
RNG period is of length N, and two streams are provided from this
RNG, then
the first stream might use the first N/2 values and the second
stream might produce the second N/2 values.  An important property
here is that the two streams are uncorrelated.  Likewise, each
stream can be partitioned disjointedly to a number of
uncorrelated \sphinxstyleemphasis{substreams}.  The underlying RNG hopefully
produces a pseudo\sphinxhyphen{}random sequence of numbers with a very long
cycle length, and partitions this into streams and substreams in an
efficient manner.

\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the same underlying random number generator as does \sphinxstyleemphasis{ns\sphinxhyphen{}2}:  the
MRG32k3a generator from Pierre L’Ecuyer.  A detailed description can be found in
\sphinxurl{http://www.iro.umontreal.ca/~lecuyer/myftp/papers/streams00.pdf}.  The MRG32k3a
generator provides \(1.8x10^{19}\) independent streams of random numbers,
each of which consists of \(2.3x10^{15}\) substreams. Each substream has a
period (\sphinxstyleemphasis{i.e.}, the number of random numbers before overlap) of
\(7.6x10^{22}\). The period of the entire generator is \(3.1x10^{57}\).

\sphinxAtStartPar
Class \sphinxcode{\sphinxupquote{ns3::RandomVariableStream}} is the public interface to this
underlying random number generator.  When users create new random variables
(such as \sphinxcode{\sphinxupquote{ns3::UniformRandomVariable}},
\sphinxcode{\sphinxupquote{ns3::ExponentialRandomVariable}}, etc.), they create an object that uses
one of the distinct, independent streams of the random number generator.
Therefore, each object of type \sphinxcode{\sphinxupquote{ns3::RandomVariableStream}} has,
conceptually, its own “virtual” RNG.  Furthermore, each
\sphinxcode{\sphinxupquote{ns3::RandomVariableStream}} can be configured to use one of the set of
substreams drawn from the main stream.

\sphinxAtStartPar
An alternate implementation would be to allow each RandomVariable to have its
own (differently seeded) RNG.  However, we cannot guarantee as strongly that the
different sequences would be uncorrelated in such a case; hence, we prefer to
use a single RNG and streams and substreams from it.


\subsection{Creating random variables}
\label{\detokenize{random-variables:creating-random-variables}}\label{\detokenize{random-variables:seeding-and-independent-replications}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} supports a number of random variable objects from the base class
\sphinxcode{\sphinxupquote{RandomVariableStream}}.  These objects derive from
\sphinxcode{\sphinxupquote{ns3::Object}} and are handled by smart pointers.

\sphinxAtStartPar
The correct way to create these objects is to use the templated
\sphinxtitleref{CreateObject\textless{}\textgreater{}} method, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then you can access values by calling methods on the object such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myRandomNo}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetInteger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you try to instead do something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myRandomNo}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UniformRandomVariable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{GetInteger}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
your program will encounter a segmentation fault, because the implementation
relies on some attribute construction that occurs only when \sphinxtitleref{CreateObject}
is called.

\sphinxAtStartPar
Much of the rest of this chapter now discusses the properties of the
stream of pseudo\sphinxhyphen{}random numbers generated from such objects, and how to
control the seeding of such objects.


\subsection{Seeding and independent replications}
\label{\detokenize{random-variables:id1}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations can be configured to produce deterministic or random results.
If the \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation is configured to use a fixed, deterministic seed with
the same run number, it should give the same output each time it is run.

\sphinxAtStartPar
By default, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations use a fixed seed and run number.  These values
are stored in two \sphinxcode{\sphinxupquote{ns3::GlobalValue}} instances: \sphinxcode{\sphinxupquote{g\_rngSeed}} and
\sphinxcode{\sphinxupquote{g\_rngRun}}.

\sphinxAtStartPar
A typical use case is to run a simulation as a sequence of independent trials,
so as to compute statistics on a large number of independent runs.  The user can
either change the global seed and rerun the simulation, or can advance the
substream state of the RNG, which is referred to as incrementing the run number.

\sphinxAtStartPar
A class \sphinxcode{\sphinxupquote{ns3::RngSeedManager}} provides an API to control the seeding and
run number behavior.  This seeding and substream state setting must be called
before any random variables are created; e.g:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RngSeedManager}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetSeed}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// Changes seed from default of 1 to 3}
\PYG{n}{RngSeedManager}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetRun}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// Changes run number from default of 1 to 7}
\PYG{c+c1}{// Now, create random variables}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ExponentialRandomVariable}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ExponentialRandomVarlable}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Which is better, setting a new seed or advancing the substream state?  There is
no guarantee that the streams produced by two random seeds will not overlap.
The only way to guarantee that two streams do not overlap is to use the
substream capability provided by the RNG implementation.  \sphinxstyleemphasis{Therefore, use the
substream capability to produce multiple independent runs of the same
simulation.} In other words, the more statistically rigorous way to configure
multiple independent replications is to use a fixed seed and to advance the run
number.  This implementation allows for a maximum of \(2.3x10^{15}\)
independent replications using the substreams.

\sphinxAtStartPar
For ease of use, it is not necessary to control the seed and run number from
within the program; the user can set the \sphinxcode{\sphinxupquote{NS\_GLOBAL\_VALUE}} environment
variable as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}GLOBAL\PYGZus{}VALUE}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}RngRun=3\PYGZdq{}}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }program\PYGZhy{}name
\end{sphinxVerbatim}

\sphinxAtStartPar
Another way to control this is by passing a command\sphinxhyphen{}line argument; since this is
an \sphinxstyleemphasis{ns\sphinxhyphen{}3} GlobalValue instance, it is equivalently done such as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }program\PYGZhy{}name\PYG{+w}{ }\PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}s \PYGZhy{}\PYGZhy{}RngRun=3\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
or, if you are running programs directly outside of ns3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./build/optimized/scratch/program\PYGZhy{}name\PYG{+w}{ }\PYGZhy{}\PYGZhy{}RngRun\PYG{o}{=}\PYG{l+m}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above command\sphinxhyphen{}line variants make it easy to run lots of different
runs from a shell script by just passing a different RngRun index.


\subsection{Class RandomVariableStream}
\label{\detokenize{random-variables:class-randomvariablestream}}
\sphinxAtStartPar
All random variables should derive from class \sphinxcode{\sphinxupquote{RandomVariable}}. This
base class provides a few methods for globally configuring the behavior
of the random number generator. Derived classes provide API for drawing random
variates from the particular distribution being supported.

\sphinxAtStartPar
Each RandomVariableStream created in the simulation is given a generator that is a
new RNGStream from the underlying PRNG. Used in this manner, the L’Ecuyer
implementation allows for a maximum of \(1.8x10^19\) random variables.  Each
random variable in a single replication can produce up to \(7.6x10^22\)
random numbers before overlapping.


\subsection{Base class public API}
\label{\detokenize{random-variables:base-class-public-api}}
\sphinxAtStartPar
Below are excerpted a few public methods of class \sphinxcode{\sphinxupquote{RandomVariableStream}}
that access the next value in the substream.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}brief Returns a random double from the underlying distribution}
\PYG{c+cm}{ * \PYGZbs{}return A floating point random value}
\PYG{c+cm}{ */}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{GetValue}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}brief Returns a random integer from the underlying distribution}
\PYG{c+cm}{ * \PYGZbs{}return  Integer cast of ::GetValue()}
\PYG{c+cm}{ */}
\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{GetInteger}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have already described the seeding configuration above. Different
RandomVariable subclasses may have additional API.


\subsection{Types of RandomVariables}
\label{\detokenize{random-variables:types-of-randomvariables}}
\sphinxAtStartPar
The following types of random variables are provided, and are documented in the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} Doxygen or by reading \sphinxcode{\sphinxupquote{src/core/model/random\sphinxhyphen{}variable\sphinxhyphen{}stream.h}}.  Users
can also create their own custom random variables by deriving from class
\sphinxcode{\sphinxupquote{RandomVariableStream}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{UniformRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ConstantRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{SequentialRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ExponentialRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ParetoRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{WeibullRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{NormalRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{LogNormalRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{GammaRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ErlangRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{TriangularRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ZipfRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{ZetaRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{DeterministicRandomVariable}}

\item {} 
\sphinxAtStartPar
class \sphinxcode{\sphinxupquote{EmpiricalRandomVariable}}

\end{itemize}


\subsection{Semantics of RandomVariableStream objects}
\label{\detokenize{random-variables:semantics-of-randomvariablestream-objects}}
\sphinxAtStartPar
RandomVariableStream objects derive from \sphinxcode{\sphinxupquote{ns3::Object}} and are
handled by smart pointers.

\sphinxAtStartPar
RandomVariableStream instances can also be used in \sphinxstyleemphasis{ns\sphinxhyphen{}3} attributes, which means
that values can be set for them through the \sphinxstyleemphasis{ns\sphinxhyphen{}3} attribute system.
An example is in the propagation models for WifiNetDevice:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}
\PYG{n+nf}{RandomPropagationDelayModel::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RandomPropagationDelayModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{PropagationDelayModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Propagation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{RandomPropagationDelayModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Variable}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The random variable which generates random delays (s).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::UniformRandomVariable}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakePointerAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{RandomPropagationDelayModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}variable}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                  }\PYG{n}{MakePointerChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{RandomVariableStream}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, the \sphinxstyleemphasis{ns\sphinxhyphen{}3} user can change the default random variable for this
delay model (which is a UniformRandomVariable ranging from 0 to 1) through
the attribute system.


\subsection{Using other PRNG}
\label{\detokenize{random-variables:using-other-prng}}
\sphinxAtStartPar
There is presently no support for substituting a different underlying
random number generator (e.g., the GNU Scientific Library or the Akaroa
package).  Patches are welcome.


\subsection{Setting the stream number}
\label{\detokenize{random-variables:setting-the-stream-number}}
\sphinxAtStartPar
The underlying MRG32k3a generator provides 2\textasciicircum{}64 independent streams.
In ns\sphinxhyphen{}3, these are assigned sequentially starting from the first stream as
new RandomVariableStream instances make their first call to GetValue().

\sphinxAtStartPar
As a result of how these RandomVariableStream objects are assigned to
underlying streams, the assignment is sensitive to perturbations of
the simulation configuration.  The consequence is that if any aspect of the
simulation configuration is changed, the mapping of RandomVariables to
streams may (or may not) change.

\sphinxAtStartPar
As a concrete example, a user running a comparative study between routing
protocols may find that the act of changing one routing protocol for another
will notice that the underlying mobility pattern also changed.

\sphinxAtStartPar
Starting with ns\sphinxhyphen{}3.15, some control has been provided to users to allow
users to optionally fix the assignment of selected RandomVariableStream
objects to underlying streams.  This is the \sphinxcode{\sphinxupquote{Stream}} attribute, part
of the base class RandomVariableStream.

\sphinxAtStartPar
By partitioning the existing sequence of streams from before:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
stream 0                                                   stream (2\PYGZca{}64 \PYGZhy{} 1)
\end{sphinxVerbatim}

\sphinxAtStartPar
into two equal\sphinxhyphen{}sized sets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZca{}                                    \PYGZca{}\PYGZca{}                                    \PYGZca{}
|                                    ||                                    |
stream 0            stream (2\PYGZca{}63 \PYGZhy{} 1)  stream 2\PYGZca{}63         stream (2\PYGZca{}64 \PYGZhy{} 1)
\PYGZlt{}\PYGZhy{} automatically assigned \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZlt{}\PYGZhy{} assigned by user \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first 2\textasciicircum{}63 streams continue to be automatically assigned, while
the last 2\textasciicircum{}63 are given stream indices starting with zero up to
2\textasciicircum{}63\sphinxhyphen{}1.

\sphinxAtStartPar
The assignment of streams to a fixed stream number is optional; instances
of RandomVariableStream that do not have a stream value assigned will
be assigned the next one from the pool of automatic streams.

\sphinxAtStartPar
To fix a RandomVariableStream to a particular underlying stream, assign
its \sphinxcode{\sphinxupquote{Stream}} attribute to a non\sphinxhyphen{}negative integer (the default value
of \sphinxhyphen{}1 means that a value will be automatically allocated).


\subsection{Publishing your results}
\label{\detokenize{random-variables:publishing-your-results}}
\sphinxAtStartPar
When you publish simulation results, a key piece of configuration
information that you should always state is how you used the
random number generator.
\begin{itemize}
\item {} 
\sphinxAtStartPar
what seeds you used,

\item {} 
\sphinxAtStartPar
what RNG you used if not the default,

\item {} 
\sphinxAtStartPar
how were independent runs performed,

\item {} 
\sphinxAtStartPar
for large simulations, how did you check that you did not cycle.

\end{itemize}

\sphinxAtStartPar
It is incumbent on the researcher publishing results to include enough
information to allow others to reproduce his or her results. It is also
incumbent on the researcher to convince oneself that the random numbers used
were statistically valid, and to state in the paper why such confidence is
assumed.


\subsection{Summary}
\label{\detokenize{random-variables:summary}}
\sphinxAtStartPar
Let’s review what things you should do when creating a simulation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Decide whether you are running with a fixed seed or random seed; a fixed seed
is the default,

\item {} 
\sphinxAtStartPar
Decide how you are going to manage independent replications, if applicable,

\item {} 
\sphinxAtStartPar
Convince yourself that you are not drawing more random values than the cycle
length, if you are running a very long simulation, and

\item {} 
\sphinxAtStartPar
When you publish, follow the guidelines above about documenting your use of
the random number generator.

\end{itemize}

\sphinxstepscope


\section{Hash Functions}
\label{\detokenize{hash-functions:hash-functions}}\label{\detokenize{hash-functions::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} provides a generic interface to general purpose hash functions.
In the simplest usage, the hash function returns the 32\sphinxhyphen{}bit or 64\sphinxhyphen{}bit
hash of a data buffer or string.  The default underlying hash function
is \sphinxhref{http://code.google.com/p/smhasher/wiki/MurmurHash3}{murmur3}, chosen because it has good hash function properties and
offers a 64\sphinxhyphen{}bit version.  The venerable \sphinxhref{http://isthe.com/chongo/tech/comp/fnv/}{FNV1a} hash is also available.

\sphinxAtStartPar
There is a straight\sphinxhyphen{}forward mechanism to
add (or provide at run time) alternative hash function implementations.


\subsection{Basic Usage}
\label{\detokenize{hash-functions:basic-usage}}
\sphinxAtStartPar
The simplest way to get a hash value of a data buffer or string is just

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/hash.h\PYGZdq{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{p}{;}

\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{buffer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{buffer\PYGZus{}size}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}

\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{buffer\PYGZus{}hash}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Hash32}\PYG{p}{(}\PYG{n}{buffer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{buffer\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{string\PYGZus{}hash}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Hash32}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Equivalent functions are defined for 64\sphinxhyphen{}bit hash values.


\subsection{Incremental Hashing}
\label{\detokenize{hash-functions:incremental-hashing}}
\sphinxAtStartPar
In some situations it’s useful to compute the hash of multiple buffers,
as if they had been joined together.  (For example, you might want
the hash of a packet stream, but not want to assemble a single buffer
with the combined contents of all the packets.)

\sphinxAtStartPar
This is almost as straight\sphinxhyphen{}forward as the first example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/hash.h\PYGZdq{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{p}{;}

\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{buffer}\PYG{p}{;}
\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{buffer\PYGZus{}size}\PYG{p}{;}

\PYG{n}{Hasher}\PYG{+w}{ }\PYG{n}{hasher}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// Use default hash function}

\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{every}\PYG{+w}{ }\PYG{n}{buffer}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{buffer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{get\PYGZus{}next\PYGZus{}buffer}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hasher}\PYG{p}{(}\PYG{n}{buffer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{buffer\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{combined\PYGZus{}hash}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{hasher}\PYG{p}{.}\PYG{n}{GetHash32}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default \sphinxcode{\sphinxupquote{Hasher}} preserves internal state to enable incremental
hashing.  If you want to reuse a \sphinxcode{\sphinxupquote{Hasher}} object (for example
because it’s configured with a non\sphinxhyphen{}default hash function), but don’t
want to add to the previously computed hash, you need to \sphinxcode{\sphinxupquote{clear()}}
first

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hasher}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{GetHash32}\PYG{p}{(}\PYG{n}{buffer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{buffer\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This reinitializes the internal state before hashing the buffer.


\subsection{Using an Alternative Hash Function}
\label{\detokenize{hash-functions:using-an-alternative-hash-function}}
\sphinxAtStartPar
The default hash function is \sphinxhref{http://code.google.com/p/smhasher/wiki/MurmurHash3}{murmur3}.  \sphinxhref{http://isthe.com/chongo/tech/comp/fnv/}{FNV1a} is also available.  To specify
the hash function explicitly, use this constructor

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Hasher}\PYG{+w}{ }\PYG{n}{hasher}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Hasher}\PYG{p}{(}\PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{Hash}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Function}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Fnv1a}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Adding New Hash Function Implementations}
\label{\detokenize{hash-functions:adding-new-hash-function-implementations}}
\sphinxAtStartPar
To add the hash function \sphinxcode{\sphinxupquote{foo}}, follow the \sphinxcode{\sphinxupquote{hash\sphinxhyphen{}murmur3.h}}/\sphinxcode{\sphinxupquote{.cc}} pattern:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Create a class declaration (\sphinxcode{\sphinxupquote{.h}}) and definition (\sphinxcode{\sphinxupquote{.cc}}) inheriting
from \sphinxcode{\sphinxupquote{Hash::Implementation}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{include}} the declaration in \sphinxcode{\sphinxupquote{hash.h}} (at the point where
\sphinxcode{\sphinxupquote{hash\sphinxhyphen{}murmur3.h}} is included.

\item {} 
\sphinxAtStartPar
In your own code, instantiate a \sphinxcode{\sphinxupquote{Hasher}} object via the constructor
\sphinxcode{\sphinxupquote{Hasher(Ptr\textless{}Hash::Function::Foo\textgreater{}())}}

\end{itemize}

\sphinxAtStartPar
If your hash function is a single function, e.g. \sphinxcode{\sphinxupquote{hashf}}, you don’t
even need to create a new class derived from HashImplementation

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Hasher}\PYG{+w}{ }\PYG{n}{hasher}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Hasher}\PYG{p}{(}\PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{Hash}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Function}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Hash32}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{hashf}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
For this to compile, your \sphinxcode{\sphinxupquote{hashf}} has to match one of the function pointer
signatures

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{Hash32Function\PYGZus{}ptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{typedef}\PYG{+w}{ }\PYG{k+kt}{uint64\PYGZus{}t}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{Hash64Function\PYGZus{}ptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Sources for Hash Functions}
\label{\detokenize{hash-functions:sources-for-hash-functions}}
\sphinxAtStartPar
Sources for other hash function implementations include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Peter Kankowski: \sphinxurl{http://www.strchr.com}

\item {} 
\sphinxAtStartPar
Arash Partow:    \sphinxurl{http://www.partow.net/programming/hashfunctions/index.html}

\item {} 
\sphinxAtStartPar
SMHasher:        \sphinxurl{http://code.google.com/p/smhasher/}

\item {} 
\sphinxAtStartPar
Sanmayce:        \sphinxurl{http://www.sanmayce.com/Fastest\_Hash/index.html}

\end{itemize}

\sphinxstepscope


\section{Tracing}
\label{\detokenize{tracing:tracing}}\label{\detokenize{tracing::doc}}
\sphinxAtStartPar
The tracing subsystem is one of the most important mechanisms to understand in
\sphinxstyleemphasis{ns\sphinxhyphen{}3}. In most cases, \sphinxstyleemphasis{ns\sphinxhyphen{}3} users will have a brilliant idea for some new and
improved networking feature. In order to verify that this idea works, the
researcher will make changes to an existing system and then run experiments to
see how the new feature behaves by gathering statistics that capture the
behavior of the feature.

\sphinxAtStartPar
In other words, the whole point of running a simulation is to generate output
for further study. In \sphinxstyleemphasis{ns\sphinxhyphen{}3}, the subsystem that enables a researcher to do this
is the tracing subsystem.


\subsection{Tracing Motivation}
\label{\detokenize{tracing:tracing-motivation}}
\sphinxAtStartPar
There are many ways to get information out of a program. The most
straightforward way is to just directly print the information to the standard
output, as in,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The value of x is }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is workable in small environments, but as your simulations get more and
more complicated, you end up with more and more prints and the task of parsing
and performing computations on the output begins to get harder and harder.

\sphinxAtStartPar
Another thing to consider is that every time a new tidbit is needed, the
software core must be edited and another print introduced. There is no
standardized way to control all of this output, so the amount of output tends to
grow without bounds. Eventually, the bandwidth required for simply outputting
this information begins to limit the running time of the simulation. The output
files grow to enormous sizes and parsing them becomes a problem.

\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} provides a simple mechanism for logging and providing some control over
output via \sphinxstyleemphasis{Log Components}, but the level of control is not very fine grained
at all. The logging module is a relatively blunt instrument.

\sphinxAtStartPar
It is desirable to have a facility that allows one to reach into the core system
and only get the information required without having to change and recompile the
core system. Even better would be a system that notified the user when an item
of interest changed or an interesting event happened.

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} tracing system is designed to work along those lines and is
well\sphinxhyphen{}integrated with the Attribute and Config substems allowing for relatively
simple use scenarios.


\subsection{Overview}
\label{\detokenize{tracing:overview}}
\sphinxAtStartPar
The tracing subsystem relies heavily on the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Callback and Attribute
mechanisms. You should read and understand the corresponding sections of the
manual before attempting to understand the tracing system.

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} tracing system is built on the concepts of independent tracing sources
and tracing sinks; along with a uniform mechanism for connecting sources to
sinks.

\sphinxAtStartPar
Trace sources are entities that can signal events that happen in a simulation
and provide access to interesting underlying data. For example, a trace source
could indicate when a packet is received by a net device and provide access to
the packet contents for interested trace sinks. A trace source might also
indicate when an interesting state change happens in a model. For example, the
congestion window of a TCP model is a prime candidate for a trace source.

\sphinxAtStartPar
Trace sources are not useful by themselves; they must be connected to other
pieces of code that actually do something useful with the information provided
by the source.  The entities that consume trace information are called trace
sinks. Trace sources are generators of events and trace sinks are consumers.

\sphinxAtStartPar
This explicit division allows for large numbers of trace sources to be scattered
around the system in places which model authors believe might be useful. Unless
a user connects a trace sink to one of these sources, nothing is output. This
arrangement allows relatively unsophisticated users to attach new types of sinks
to existing tracing sources, without requiring editing and recompiling the core
or models of the simulator.

\sphinxAtStartPar
There can be zero or more consumers of trace events generated by a trace source.
One can think of a trace source as a kind of point\sphinxhyphen{}to\sphinxhyphen{}multipoint information
link.

\sphinxAtStartPar
The “transport protocol” for this conceptual point\sphinxhyphen{}to\sphinxhyphen{}multipoint link is an
\sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxcode{\sphinxupquote{Callback}}.

\sphinxAtStartPar
Recall from the Callback Section that callback facility is a way to allow two
modules in the system to communicate via function calls while at the same time
decoupling the calling function from the called class completely. This is the
same requirement as outlined above for the tracing system.

\sphinxAtStartPar
Basically, a trace source \sphinxstyleemphasis{is} a callback to which multiple functions may be
registered. When a trace sink expresses interest in receiving trace events, it
adds a callback to a list of callbacks held by the trace source. When an
interesting event happens, the trace source invokes its \sphinxcode{\sphinxupquote{operator()}} providing
zero or more parameters. This tells the source to go through its list of
callbacks invoking each one in turn. In this way, the parameter(s) are
communicated to the trace sinks, which are just functions.


\subsubsection{The Simplest Example}
\label{\detokenize{tracing:the-simplest-example}}
\sphinxAtStartPar
It will be useful to go walk a quick example just to reinforce what we’ve
said.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/object.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/uinteger.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/traced\PYGZhy{}value.h\PYGZdq{}}\PYG{c+c1}{\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/trace\PYGZhy{}source\PYGZhy{}accessor.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first thing to do is include the required files. As mentioned above, the
trace system makes heavy use of the Object and Attribute systems. The first two
includes bring in the declarations for those systems. The file,
\sphinxcode{\sphinxupquote{traced\sphinxhyphen{}value.h}} brings in the required declarations for tracing data that
obeys value semantics.

\sphinxAtStartPar
In general, value semantics just means that you can pass the object around, not
an address. In order to use value semantics at all you have to have an object
with an associated copy constructor and assignment operator available. We extend
the requirements to talk about the set of operators that are pre\sphinxhyphen{}defined for
plain\sphinxhyphen{}old\sphinxhyphen{}data (POD) types. Operator=, operator++, operator\textendash{}, operator+,
operator==, etc.

\sphinxAtStartPar
What this all means is that you will be able to trace changes to an object
made using those operators.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyObject}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyObject}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{.}\PYG{n}{SetParent}\PYG{p}{(}\PYG{n}{Object}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{MyObject}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{.}\PYG{n}{AddTraceSource}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyInteger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{An integer value to trace.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{n}{MakeTraceSourceAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyObject}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}myInt}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{n}{MyObject}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{n}{TracedValue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}myInt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since the tracing system is integrated with Attributes, and Attributes work with
Objects, there must be an \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxcode{\sphinxupquote{Object}} for the trace source to live in. The
two important lines of code are the \sphinxcode{\sphinxupquote{.AddTraceSource}} and the \sphinxcode{\sphinxupquote{TracedValue}}
declaration.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.AddTraceSource}} provides the “hooks” used for connecting the trace
source to the outside world. The \sphinxcode{\sphinxupquote{TracedValue}} declaration provides the
infrastructure that overloads the operators mentioned above and drives the
callback process.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{IntTrace}\PYG{p}{(}\PYG{n}{Int}\PYG{+w}{ }\PYG{n}{oldValue}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Int}\PYG{+w}{ }\PYG{n}{newValue}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Traced }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{oldValue}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ to }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{newValue}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is the definition of the trace sink. It corresponds directly to a callback
function. This function will be called whenever one of the operators of the
\sphinxcode{\sphinxupquote{TracedValue}} is executed.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}
\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{MyObject}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{myObject}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{MyObject}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnectWithoutContext}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyInteger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{IntTrace}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}myInt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1234}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this snippet, the first thing that needs to be done is to create the object
in which the trace source lives.

\sphinxAtStartPar
The next step, the \sphinxcode{\sphinxupquote{TraceConnectWithoutContext}}, forms the connection between
the trace source and the trace sink. Notice the \sphinxcode{\sphinxupquote{MakeCallback}} template
function. Recall from the Callback section that this creates the specialized
functor responsible for providing the overloaded \sphinxcode{\sphinxupquote{operator()}} used to “fire”
the callback. The overloaded operators (++, \textendash{}, etc.) will use this
\sphinxcode{\sphinxupquote{operator()}} to actually invoke the callback. The
\sphinxcode{\sphinxupquote{TraceConnectWithoutContext}}, takes a string parameter that provides the name
of the Attribute assigned to the trace source. Let’s ignore the bit about
context for now since it is not important yet.

\sphinxAtStartPar
Finally, the line,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}myInt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1234}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
should be interpreted as an invocation of \sphinxcode{\sphinxupquote{operator=}} on the member variable
\sphinxcode{\sphinxupquote{m\_myInt}} with the integer \(1234\) passed as a parameter. It turns out
that this operator is defined (by \sphinxcode{\sphinxupquote{TracedValue}}) to execute a callback that
returns void and takes two integer values as parameters \textendash{} an old value and a
new value for the integer in question. That is exactly the function signature
for the callback function we provided \textendash{} \sphinxcode{\sphinxupquote{IntTrace}}.

\sphinxAtStartPar
To summarize, a trace source is, in essence, a variable that holds a list of
callbacks. A trace sink is a function used as the target of a callback. The
Attribute and object type information systems are used to provide a way to
connect trace sources to trace sinks. The act of “hitting” a trace source is
executing an operator on the trace source which fires callbacks. This results in
the trace sink callbacks registering interest in the source being called with
the parameters provided by the source.


\subsubsection{Using the Config Subsystem to Connect to Trace Sources}
\label{\detokenize{tracing:using-the-config-subsystem-to-connect-to-trace-sources}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{TraceConnectWithoutContext}} call shown above in the simple example is
actually very rarely used in the system. More typically, the \sphinxcode{\sphinxupquote{Config}}
subsystem is used to allow selecting a trace source in the system using what is
called a \sphinxstyleemphasis{config path}.

\sphinxAtStartPar
For example, one might find something that looks like the following in the
system (taken from \sphinxcode{\sphinxupquote{examples/tcp\sphinxhyphen{}large\sphinxhyphen{}transfer.cc}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{CwndTracer}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{oldval}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{newval}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ConnectWithoutContext}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/0/\PYGZdl{}ns3::TcpL4Protocol/SocketList/0/CongestionWindow}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CwndTracer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This should look very familiar. It is the same thing as the previous example,
except that a static member function of class \sphinxcode{\sphinxupquote{Config}} is being called instead
of a method on \sphinxcode{\sphinxupquote{Object}}; and instead of an \sphinxcode{\sphinxupquote{Attribute}} name, a path is being
provided.

\sphinxAtStartPar
The first thing to do is to read the path backward. The last segment of the path
must be an \sphinxcode{\sphinxupquote{Attribute}} of an \sphinxcode{\sphinxupquote{Object}}. In fact, if you had a pointer to the
\sphinxcode{\sphinxupquote{Object}} that has the “CongestionWindow” \sphinxcode{\sphinxupquote{Attribute}} handy (call it
\sphinxcode{\sphinxupquote{theObject}}), you could write this just like the previous example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{CwndTracer}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{oldval}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{newval}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{theObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnectWithoutContext}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CongestionWindow}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CwndTracer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It turns out that the code for \sphinxcode{\sphinxupquote{Config::ConnectWithoutContext}} does exactly
that. This function takes a path that represents a chain of \sphinxcode{\sphinxupquote{Object}} pointers
and follows them until it gets to the end of the path and interprets the last
segment as an \sphinxcode{\sphinxupquote{Attribute}} on the last object. Let’s walk through what
happens.

\sphinxAtStartPar
The leading “/” character in the path refers to a so\sphinxhyphen{}called namespace. One of the
predefined namespaces in the config system is “NodeList” which is a list of all of
the nodes in the simulation. Items in the list are referred to by indices into the
list, so “/NodeList/0” refers to the zeroth node in the list of nodes created by
the simulation. This node is actually a \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} and so is a subclass of
an \sphinxcode{\sphinxupquote{ns3::Object}}.

\sphinxAtStartPar
As described in the {\hyperref[\detokenize{object-model:object-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Object model}}}} section, \sphinxstyleemphasis{ns\sphinxhyphen{}3} supports an object
aggregation model. The next path segment begins with the “\$” character which
indicates a \sphinxcode{\sphinxupquote{GetObject}} call should be made looking for the type that follows.
When a node is initialized by an \sphinxcode{\sphinxupquote{InternetStackHelper}} a number of interfaces
are aggregated to the node. One of these is the TCP level four protocol. The
runtime type of this protocol object is \sphinxcode{\sphinxupquote{ns3::TcpL4Protocol\textquotesingle{}\textquotesingle{}. When the
\textasciigrave{}\textasciigrave{}GetObject}} is executed, it returns a pointer to the object of this type.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{TcpL4Protocol}} class defines an Attribute called “SocketList” which is a
list of sockets.  Each socket is actually an \sphinxcode{\sphinxupquote{ns3::Object}} with its own
\sphinxcode{\sphinxupquote{Attributes}}.  The items in the list of sockets are referred to by index just
as in the NodeList, so “SocketList/0” refers to the zeroth socket in the list of
sockets on the zeroth node in the NodeList \textendash{} the first node constructed in the
simulation.

\sphinxAtStartPar
This socket, the type of which turns out to be an \sphinxcode{\sphinxupquote{ns3::TcpSocketImpl}} defines
an attribute called “CongestionWindow” which is a \sphinxcode{\sphinxupquote{TracedValue\textless{}uint32\_t\textgreater{}}}.
The \sphinxcode{\sphinxupquote{Config::ConnectWithoutContext}} now does a,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{object}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnectWithoutContext}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CongestionWindow}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CwndTracer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
using the object pointer from “SocketList/0” which makes the connection between
the trace source defined in the socket to the callback \textendash{} \sphinxcode{\sphinxupquote{CwndTracer}}.

\sphinxAtStartPar
Now, whenever a change is made to the \sphinxcode{\sphinxupquote{TracedValue\textless{}uint32\_t\textgreater{}}} representing the
congestion window in the TCP socket, the registered callback will be executed
and the function \sphinxcode{\sphinxupquote{CwndTracer}} will be called printing out the old and new
values of the TCP congestion window.

\sphinxAtStartPar
As a final note, the \sphinxtitleref{Config::Connect…()} functions
will throw an error if the targeted TraceSource does not exist at the path
given.  There are also “fail\sphinxhyphen{}safe” versions,
\sphinxtitleref{Config::Connect…FailSafe()}, if you can’t be sure the TraceSource
exists.  The fail\sphinxhyphen{}safe versions return \sphinxtitleref{true} if at least one connection
could be made.


\subsection{Using the Tracing API}
\label{\detokenize{tracing:using-the-tracing-api}}
\sphinxAtStartPar
There are three levels of interaction with the tracing system:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Beginning user can easily control which objects are participating in tracing;

\item {} 
\sphinxAtStartPar
Intermediate users can extend the tracing system to modify the output format
generated or use existing trace sources in different ways, without modifying
the core of the simulator;

\item {} 
\sphinxAtStartPar
Advanced users can modify the simulator core to add new tracing sources and
sinks.

\end{itemize}


\subsection{Using Trace Helpers}
\label{\detokenize{tracing:using-trace-helpers}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace helpers provide a rich environment for configuring and selecting
different trace events and writing them to files. In previous sections,
primarily “Building Topologies,” we have seen several varieties of the trace
helper methods designed for use inside other (device) helpers.

\sphinxAtStartPar
Perhaps you will recall seeing some of these variations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pointToPoint}\PYG{p}{.}\PYG{n}{EnablePcapAll}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{second}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pointToPoint}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{second}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p2pNodes}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csma}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{third}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{csmaDevices}\PYG{p}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pointToPoint}\PYG{p}{.}\PYG{n}{EnableAsciiAll}\PYG{p}{(}\PYG{n}{ascii}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myfirst.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
What may not be obvious, though, is that there is a consistent model for all of
the trace\sphinxhyphen{}related methods found in the system. We will now take a little time
and take a look at the “big picture”.

\sphinxAtStartPar
There are currently two primary use cases of the tracing helpers in \sphinxstyleemphasis{ns\sphinxhyphen{}3}:
Device helpers and protocol helpers. Device helpers look at the problem of
specifying which traces should be enabled through a node, device pair.  For
example, you may want to specify that pcap tracing should be enabled on a
particular device on a specific node. This follows from the \sphinxstyleemphasis{ns\sphinxhyphen{}3} device
conceptual model, and also the conceptual models of the various device helpers.
Following naturally from this, the files created follow a
\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node\textgreater{}\sphinxhyphen{}\textless{}device\textgreater{} naming convention.

\sphinxAtStartPar
Protocol helpers look at the problem of specifying which traces should be
enabled through a protocol and interface pair. This follows from the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
protocol stack conceptual model, and also the conceptual models of internet
stack helpers. Naturally, the trace files should follow a
\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}protocol\textgreater{}\sphinxhyphen{}\textless{}interface\textgreater{} naming convention.

\sphinxAtStartPar
The trace helpers therefore fall naturally into a two\sphinxhyphen{}dimensional taxonomy.
There are subtleties that prevent all four classes from behaving identically,
but we do strive to make them all work as similarly as possible; and whenever
possible there are analogs for all methods in all classes.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
pcap
&\sphinxstyletheadfamily 
\sphinxAtStartPar
ascii
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Device Helper
&
\sphinxAtStartPar
\(\checkmark\)
&
\sphinxAtStartPar
\(\checkmark\)
\\
\sphinxhline
\sphinxAtStartPar
Protocol Helper
&
\sphinxAtStartPar
\(\checkmark\)
&
\sphinxAtStartPar
\(\checkmark\)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
We use an approach called a \sphinxcode{\sphinxupquote{mixin}} to add tracing functionality to our helper
classes. A \sphinxcode{\sphinxupquote{mixin}} is a class that provides functionality to that is
inherited by a subclass. Inheriting from a mixin is not considered a form of
specialization but is really a way to collect functionality.

\sphinxAtStartPar
Let’s take a quick look at all four of these cases and their respective
\sphinxcode{\sphinxupquote{mixins}}.


\subsubsection{Pcap Tracing Device Helpers}
\label{\detokenize{tracing:pcap-tracing-device-helpers}}
\sphinxAtStartPar
The goal of these helpers is to make it easy to add a consistent pcap trace
facility to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} device. We want all of the various flavors of pcap tracing
to work the same across all devices, so the methods of these helpers are
inherited by device helpers. Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you
want to follow the discussion while looking at real code.

\sphinxAtStartPar
The class \sphinxcode{\sphinxupquote{PcapHelperForDevice}} is a \sphinxcode{\sphinxupquote{mixin}} provides the high level
functionality for using pcap tracing in an \sphinxstyleemphasis{ns\sphinxhyphen{}3} device. Every device must
implement a single virtual method inherited from this class.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapInternal}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The signature of this method reflects the device\sphinxhyphen{}centric view of the situation
at this level. All of the public methods inherited from class
\sphinxcode{\sphinxupquote{PcapUserHelperForDevice}} reduce to calling this single device\sphinxhyphen{}dependent
implementation method. For example, the lowest level pcap method,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{explicitFilename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will call the device implementation of \sphinxcode{\sphinxupquote{EnablePcapInternal}} directly. All
other public pcap tracing methods build on this implementation to provide
additional user\sphinxhyphen{}level functionality. What this means to the user is that all
device helpers in the system will have all of the pcap trace methods available;
and these methods will all work in the same way across devices if the device
implements \sphinxcode{\sphinxupquote{EnablePcapInternal}} correctly.


\paragraph{Pcap Tracing Device Helper Methods}
\label{\detokenize{tracing:pcap-tracing-device-helper-methods}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{,}
\PYG{+w}{                }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{explicitFilename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ndName}\PYG{p}{,}
\PYG{+w}{                }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{explicitFilename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{,}
\PYG{+w}{                }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}
\PYG{+w}{                }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{nodeid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{deviceid}\PYG{p}{,}
\PYG{+w}{                }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapAll}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In each of the methods shown above, there is a default parameter called
\sphinxcode{\sphinxupquote{promiscuous}} that defaults to false. This parameter indicates that the trace
should not be gathered in promiscuous mode. If you do want your traces to
include all traffic seen by the device (and if the device supports a promiscuous
mode) simply add a true parameter to any of the calls above. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will enable promiscuous mode captures on the \sphinxcode{\sphinxupquote{NetDevice}} specified by \sphinxcode{\sphinxupquote{nd}}.

\sphinxAtStartPar
The first two methods also include a default parameter called
\sphinxcode{\sphinxupquote{explicitFilename}} that will be discussed below.

\sphinxAtStartPar
You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{PcapHelperForDevice}} to
find the details of these methods; but to summarize …

\sphinxAtStartPar
You can enable pcap tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} to an \sphinxcode{\sphinxupquote{EnablePcap}} method. The \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} is implicit
since the net device must belong to exactly one \sphinxcode{\sphinxupquote{Node}}. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an \sphinxcode{\sphinxupquote{EnablePcap}}
method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} is looked up from the name string.  Again, the
\sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit since the named net device must belong to exactly one
\sphinxcode{\sphinxupquote{Node}}.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/ath0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NetDeviceContainer}}. For each \sphinxcode{\sphinxupquote{NetDevice}} in the container the
type is checked.  For each device of the proper type (the same type as is
managed by the device helper), tracing is enabled. Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is
implicit since the found net device must belong to exactly one \sphinxcode{\sphinxupquote{Node}}. For
example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} its
attached \sphinxcode{\sphinxupquote{NetDevices}} are iterated.  For each \sphinxcode{\sphinxupquote{NetDevice}} attached to each
node in the container, the type of that device is checked.  For each device of
the proper type (the same type as is managed by the device helper), tracing is
enabled.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on the basis of node ID and device ID as well as
with explicit \sphinxcode{\sphinxupquote{Ptr}}. Each \sphinxcode{\sphinxupquote{Node}} in the system has an integer node ID and
each device connected to a node has an integer device ID.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, you can enable pcap tracing for all devices in the system, with the
same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapAll}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Pcap Tracing Device Helper Filename Selection}
\label{\detokenize{tracing:pcap-tracing-device-helper-filename-selection}}
\sphinxAtStartPar
Implicit in the method descriptions above is the construction of a complete
filename by the implementation method. By convention, pcap traces in the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
system are of the form \sphinxcode{\sphinxupquote{\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.pcap}}

\sphinxAtStartPar
As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id; and every device will have an interface index (also called a device id)
relative to its node. By default, then, a pcap trace file created as a result
of enabling tracing on the first device of node 21 using the prefix “prefix”
would be \sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}21\sphinxhyphen{}1.pcap}}.

\sphinxAtStartPar
You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.  For
example, if you use the object name service to assign the name “server” to node
21, the resulting pcap trace file name will automatically become,
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}1.pcap}} and if you also assign the name “eth0” to the device,
your pcap file name will automatically pick this up and be called
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}eth0.pcap}}.

\sphinxAtStartPar
Finally, two of the methods shown above,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{explicitFilename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcap}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ndName}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{promiscuous}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{explicitFilename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
have a default parameter called \sphinxcode{\sphinxupquote{explicitFilename}}. When set to true, this
parameter disables the automatic filename completion mechanism and allows you to
create an explicit filename. This option is only available in the methods which
enable pcap tracing on a single device.

\sphinxAtStartPar
For example, in order to arrange for a device helper to create a single
promiscuous pcap capture file of a specific name (\sphinxcode{\sphinxupquote{my\sphinxhyphen{}pcap\sphinxhyphen{}file.pcap}}) on a
given device, one could:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZhy{}pcap\PYGZhy{}file.pcap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first \sphinxcode{\sphinxupquote{true}} parameter enables promiscuous mode traces and the second
tells the helper to interpret the \sphinxcode{\sphinxupquote{prefix}} parameter as a complete filename.


\subsubsection{Ascii Tracing Device Helpers}
\label{\detokenize{tracing:ascii-tracing-device-helpers}}
\sphinxAtStartPar
The behavior of the ASCII trace helper \sphinxcode{\sphinxupquote{mixin}} is substantially similar to
the pcap version. Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you want to
follow the discussion while looking at real code.

\sphinxAtStartPar
The class \sphinxcode{\sphinxupquote{AsciiTraceHelperForDevice}} adds the high level functionality for
using ASCII tracing to a device helper class. As in the pcap case, every device
must implement a single virtual method inherited from the ASCII trace
\sphinxcode{\sphinxupquote{mixin}}.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiInternal}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The signature of this method reflects the device\sphinxhyphen{}centric view of the situation
at this level; and also the fact that the helper may be writing to a shared
output stream. All of the public ASCII\sphinxhyphen{}trace\sphinxhyphen{}related methods inherited from
class \sphinxcode{\sphinxupquote{AsciiTraceHelperForDevice}} reduce to calling this single device\sphinxhyphen{}
dependent implementation method. For example, the lowest level ASCII trace
methods,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will call the device implementation of \sphinxcode{\sphinxupquote{EnableAsciiInternal}} directly,
providing either a valid prefix or stream.  All other public ASCII tracing
methods will build on these low\sphinxhyphen{}level functions to provide additional user\sphinxhyphen{}level
functionality. What this means to the user is that all device helpers in the
system will have all of the ASCII trace methods available; and these methods
will all work in the same way across devices if the devices implement
\sphinxcode{\sphinxupquote{EnablAsciiInternal}} correctly.


\paragraph{Ascii Tracing Device Helper Methods}
\label{\detokenize{tracing:ascii-tracing-device-helper-methods}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ndName}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ndName}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{nodeid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{deviceid}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAscii}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{nodeid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{deviceid}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiAll}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiAll}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{TraceHelperForDevice}} to
find the details of these methods; but to summarize …

\sphinxAtStartPar
There are twice as many methods available for ASCII tracing as there were for
pcap tracing. This is because, in addition to the pcap\sphinxhyphen{}style model where traces
from each unique node/device pair are written to a unique file, we support a
model in which trace information for many node/device pairs is written to a
common file.  This means that the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node\textgreater{}\sphinxhyphen{}\textless{}device\textgreater{} file name generation
mechanism is replaced by a mechanism to refer to a common file; and the number
of API methods is doubled to allow all combinations.

\sphinxAtStartPar
Just as in pcap tracing, you can enable ASCII tracing on a particular
node/net\sphinxhyphen{}device pair by providing a \sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} to an \sphinxcode{\sphinxupquote{EnableAscii}}
method. The \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} is implicit since the net device must belong to
exactly one \sphinxcode{\sphinxupquote{Node}}. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, no trace contexts are written to the ASCII trace file since they
would be redundant. The system will pick the file name to be created using the
same rules as described in the pcap section, except that the file will have the
suffix “.tr” instead of “.pcap”.

\sphinxAtStartPar
If you want to enable ASCII tracing on more than one net device and have all
traces sent to a single file, you can do that as well by using an object to
refer to a single file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd1}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd2}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nd1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nd2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, trace contexts are written to the ASCII trace file since they
are required to disambiguate traces from the two devices.  Note that since the
user is completely specifying the file name, the string should include the “.tr”
for consistency.

\sphinxAtStartPar
You can enable ASCII tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an
\sphinxcode{\sphinxupquote{EnablePcap}} method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} is looked up from the name
string.  Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit since the named net device must
belong to exactly one \sphinxcode{\sphinxupquote{Node}}.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in two files named \sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}client\sphinxhyphen{}eth0.tr}} and
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}eth0.tr}} with traces for each device in the respective trace
file. Since all of the EnableAscii functions are overloaded to take a stream
wrapper, you can use that form as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a single trace file called \sphinxcode{\sphinxupquote{trace\sphinxhyphen{}file\sphinxhyphen{}name.tr}} that
contains all of the trace events for both devices. The events would be
disambiguated by trace context strings.

\sphinxAtStartPar
You can enable ASCII tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NetDeviceContainer}}. For each \sphinxcode{\sphinxupquote{NetDevice}} in the container the
type is checked. For each device of the proper type (the same type as is managed
by the device helper), tracing is enabled. Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit
since the found net device must belong to exactly one \sphinxcode{\sphinxupquote{Node}}.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable ascii tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} its
attached \sphinxcode{\sphinxupquote{NetDevices}} are iterated.  For each \sphinxcode{\sphinxupquote{NetDevice}} attached to each
node in the container, the type of that device is checked.  For each device of
the proper type (the same type as is managed by the device helper), tracing is
enabled.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

\sphinxAtStartPar
You can enable pcap tracing on the basis of node ID and device ID as well as
with explicit \sphinxcode{\sphinxupquote{Ptr}}. Each \sphinxcode{\sphinxupquote{Node}} in the system has an integer node ID and
each device connected to a node has an integer device ID.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course, the traces can be combined into a single file as shown above.

\sphinxAtStartPar
Finally, you can enable pcap tracing for all devices in the system, with the
same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiAll}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a number of ASCII trace files being created, one for
every device in the system of the type managed by the helper. All of these
files will follow the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining
all of the traces into a single file is accomplished similarly to the examples
above.


\paragraph{Ascii Tracing Device Helper Filename Selection}
\label{\detokenize{tracing:ascii-tracing-device-helper-filename-selection}}
\sphinxAtStartPar
Implicit in the prefix\sphinxhyphen{}style method descriptions above is the construction of
the complete filenames by the implementation method. By convention, ASCII traces
in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system are of the form \sphinxcode{\sphinxupquote{\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr}}.

\sphinxAtStartPar
As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id; and every device will have an interface index (also called a device id)
relative to its node.  By default, then, an ASCII trace file created as a result
of enabling tracing on the first device of node 21, using the prefix “prefix”,
would be \sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}21\sphinxhyphen{}1.tr}}.

\sphinxAtStartPar
You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.  For
example, if you use the object name service to assign the name “server” to node
21, the resulting ASCII trace file name will automatically become,
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}1.tr}} and if you also assign the name “eth0” to the device,
your ASCII trace file name will automatically pick this up and be called
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}eth0.tr}}.


\subsubsection{Pcap Tracing Protocol Helpers}
\label{\detokenize{tracing:pcap-tracing-protocol-helpers}}
\sphinxAtStartPar
The goal of these \sphinxcode{\sphinxupquote{mixins}} is to make it easy to add a consistent pcap trace
facility to protocols. We want all of the various flavors of pcap tracing to
work the same across all protocols, so the methods of these helpers are
inherited by stack helpers. Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you
want to follow the discussion while looking at real code.

\sphinxAtStartPar
In this section we will be illustrating the methods as applied to the protocol
\sphinxcode{\sphinxupquote{Ipv4}}.  To specify traces in similar protocols, just substitute the
appropriate type.  For example, use a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv6\textgreater{}}} instead of a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}}
and call \sphinxcode{\sphinxupquote{EnablePcapIpv6}} instead of \sphinxcode{\sphinxupquote{EnablePcapIpv4}}.

\sphinxAtStartPar
The class \sphinxcode{\sphinxupquote{PcapHelperForIpv4}} provides the high level functionality for using
pcap tracing in the \sphinxcode{\sphinxupquote{Ipv4}} protocol.  Each protocol helper enabling these
methods must implement a single virtual method inherited from this class.  There
will be a separate implementation for \sphinxcode{\sphinxupquote{Ipv6}}, for example, but the only
difference will be in the method names and signatures.  Different method names
are required to disambiguate class \sphinxcode{\sphinxupquote{Ipv4}} from \sphinxcode{\sphinxupquote{Ipv6}} which are both derived
from class \sphinxcode{\sphinxupquote{Object}}, and methods that share the same signature.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4Internal}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The signature of this method reflects the protocol and interface\sphinxhyphen{}centric view of
the situation at this level. All of the public methods inherited from class
\sphinxcode{\sphinxupquote{PcapHelperForIpv4}} reduce to calling this single device\sphinxhyphen{}dependent
implementation method.  For example, the lowest level pcap method,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will call the device implementation of \sphinxcode{\sphinxupquote{EnablePcapIpv4Internal}} directly.  All
other public pcap tracing methods build on this implementation to provide
additional user\sphinxhyphen{}level functionality. What this means to the user is that all
protocol helpers in the system will have all of the pcap trace methods
available; and these methods will all work in the same way across protocols if
the helper implements \sphinxcode{\sphinxupquote{EnablePcapIpv4Internal}} correctly.


\paragraph{Pcap Tracing Protocol Helper Methods}
\label{\detokenize{tracing:pcap-tracing-protocol-helper-methods}}
\sphinxAtStartPar
These methods are designed to be in one\sphinxhyphen{}to\sphinxhyphen{}one correspondence with the \sphinxcode{\sphinxupquote{Node}}\sphinxhyphen{}
and \sphinxcode{\sphinxupquote{NetDevice}}\sphinxhyphen{} centric versions of the device versions. Instead of
\sphinxcode{\sphinxupquote{Node}} and \sphinxcode{\sphinxupquote{NetDevice}} pair constraints, we use protocol and interface
constraints.

\sphinxAtStartPar
Note that just like in the device version, there are six methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ipv4Name}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ipv4InterfaceContainer}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{nodeid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnablePcapIpv4All}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{PcapHelperForIpv4}} to find
the details of these methods; but to summarize …

\sphinxAtStartPar
You can enable pcap tracing on a particular protocol/interface pair by providing
a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} and \sphinxcode{\sphinxupquote{interface}} to an \sphinxcode{\sphinxupquote{EnablePcap}} method.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an \sphinxcode{\sphinxupquote{EnablePcap}}
method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} is looked up from the name string.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{serverIPv4}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{serverIpv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on a collection of protocol/interface pairs by
providing an \sphinxcode{\sphinxupquote{Ipv4InterfaceContainer}}. For each \sphinxcode{\sphinxupquote{Ipv4}} / interface pair in
the container the protocol type is checked. For each protocol of the proper type
(the same type as is managed by the device helper), tracing is enabled for the
corresponding interface.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{devices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{deviceHelper}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ipv4AddressHelper}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{;}
\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.1.1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4InterfaceContainer}\PYG{+w}{ }\PYG{n}{interfaces}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{interfaces}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on a collection of protocol/interface pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} the
appropriate protocol is found. For each protocol, its interfaces are enumerated
and tracing is enabled on the resulting pairs. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable pcap tracing on the basis of node ID and interface as well. In
this case, the node\sphinxhyphen{}id is translated to a \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} and the appropriate
protocol is looked up in the node. The resulting protocol and interface are used
to specify the resulting trace source.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, you can enable pcap tracing for all interfaces in the system, with
associated protocol being the same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4All}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Pcap Tracing Protocol Helper Filename Selection}
\label{\detokenize{tracing:pcap-tracing-protocol-helper-filename-selection}}
\sphinxAtStartPar
Implicit in all of the method descriptions above is the construction of the
complete filenames by the implementation method. By convention, pcap traces
taken for devices in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system are of the form \sphinxcode{\sphinxupquote{\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node
id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.pcap}}. In the case of protocol traces, there is a one\sphinxhyphen{}to\sphinxhyphen{}one
correspondence between protocols and \sphinxcode{\sphinxupquote{Nodes}}. This is because protocol
\sphinxcode{\sphinxupquote{Objects}} are aggregated to \sphinxcode{\sphinxupquote{Node Objects}}. Since there is no global
protocol id in the system, we use the corresponding node id in file naming.
Therefore there is a possibility for file name collisions in automatically
chosen trace file names. For this reason, the file name convention is changed
for protocol traces.

\sphinxAtStartPar
As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id. Since there is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence between protocol instances
and node instances we use the node id. Each interface has an interface id
relative to its protocol. We use the convention “\textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}i\textless{}interface
id\textgreater{}.pcap” for trace file naming in protocol helpers.

\sphinxAtStartPar
Therefore, by default, a pcap trace file created as a result of enabling tracing
on interface 1 of the Ipv4 protocol of node 21 using the prefix “prefix”
would be “prefix\sphinxhyphen{}n21\sphinxhyphen{}i1.pcap”.

\sphinxAtStartPar
You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.
For example, if you use the object name service to assign the name “serverIpv4”
to the Ptr\textless{}Ipv4\textgreater{} on node 21, the resulting pcap trace file name will
automatically become, “prefix\sphinxhyphen{}nserverIpv4\sphinxhyphen{}i1.pcap”.


\subsubsection{Ascii Tracing Protocol Helpers}
\label{\detokenize{tracing:ascii-tracing-protocol-helpers}}
\sphinxAtStartPar
The behavior of the ASCII trace helpers is substantially similar to the pcap
case.  Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you want to follow the
discussion while looking at real code.

\sphinxAtStartPar
In this section we will be illustrating the methods as applied to the protocol
\sphinxcode{\sphinxupquote{Ipv4}}. To specify traces in similar protocols, just substitute the
appropriate type. For example, use a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv6\textgreater{}}} instead of a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}}
and call \sphinxcode{\sphinxupquote{EnableAsciiIpv6}} instead of \sphinxcode{\sphinxupquote{EnableAsciiIpv4}}.

\sphinxAtStartPar
The class \sphinxcode{\sphinxupquote{AsciiTraceHelperForIpv4}} adds the high level functionality for
using ASCII tracing to a protocol helper. Each protocol that enables these
methods must implement a single virtual method inherited from this class.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4Internal}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}
\PYG{+w}{                                     }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The signature of this method reflects the protocol\sphinxhyphen{} and interface\sphinxhyphen{}centric view
of the situation at this level; and also the fact that the helper may be writing
to a shared output stream.  All of the public methods inherited from class
\sphinxcode{\sphinxupquote{PcapAndAsciiTraceHelperForIpv4}} reduce to calling this single device\sphinxhyphen{}
dependent implementation method. For example, the lowest level ascii trace
methods,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will call the device implementation of \sphinxcode{\sphinxupquote{EnableAsciiIpv4Internal}} directly,
providing either the prefix or the stream. All other public ascii tracing
methods will build on these low\sphinxhyphen{}level functions to provide additional user\sphinxhyphen{}level
functionality. What this means to the user is that all device helpers in the
system will have all of the ascii trace methods available; and these methods
will all work in the same way across protocols if the protocols implement
\sphinxcode{\sphinxupquote{EnablAsciiIpv4Internal}} correctly.


\paragraph{Ascii Tracing Device Helper Methods}
\label{\detokenize{tracing:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ipv4Name}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{ipv4Name}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ipv4InterfaceContainer}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ipv4InterfaceContainer}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{nodeid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{deviceid}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{nodeid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4All}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EnableAsciiIpv4All}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{PcapAndAsciiHelperForIpv4}}
to find the details of these methods; but to summarize …

\sphinxAtStartPar
There are twice as many methods available for ASCII tracing as there were for
pcap tracing. This is because, in addition to the pcap\sphinxhyphen{}style model where traces
from each unique protocol/interface pair are written to a unique file, we
support a model in which trace information for many protocol/interface pairs is
written to a common file. This means that the \textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}interface\textgreater{}
file name generation mechanism is replaced by a mechanism to refer to a common
file; and the number of API methods is doubled to allow all combinations.

\sphinxAtStartPar
Just as in pcap tracing, you can enable ASCII tracing on a particular
protocol/interface pair by providing a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} and an \sphinxcode{\sphinxupquote{interface}} to an
\sphinxcode{\sphinxupquote{EnableAscii}} method.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, no trace contexts are written to the ASCII trace file since they
would be redundant. The system will pick the file name to be created using the
same rules as described in the pcap section, except that the file will have the
suffix “.tr” instead of “.pcap”.

\sphinxAtStartPar
If you want to enable ASCII tracing on more than one interface and have all
traces sent to a single file, you can do that as well by using an object to
refer to a single file. We have already something similar to this in the “cwnd”
example above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{protocol1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{protocol2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{protocol1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{protocol2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, trace contexts are written to the ASCII trace file since they are
required to disambiguate traces from the two interfaces. Note that since the
user is completely specifying the file name, the string should include the “.tr”
for consistency.

\sphinxAtStartPar
You can enable ASCII tracing on a particular protocol by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an \sphinxcode{\sphinxupquote{EnablePcap}}
method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} is looked up from the name string.  The \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} in
the resulting filenames is implicit since there is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence
between protocol instances and nodes, For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in two files named “prefix\sphinxhyphen{}nnode1Ipv4\sphinxhyphen{}i1.tr” and
“prefix\sphinxhyphen{}nnode2Ipv4\sphinxhyphen{}i1.tr” with traces for each interface in the respective
trace file. Since all of the EnableAscii functions are overloaded to take a
stream wrapper, you can use that form as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a single trace file called “trace\sphinxhyphen{}file\sphinxhyphen{}name.tr” that
contains all of the trace events for both interfaces. The events would be
disambiguated by trace context strings.

\sphinxAtStartPar
You can enable ASCII tracing on a collection of protocol/interface pairs by
providing an \sphinxcode{\sphinxupquote{Ipv4InterfaceContainer}}. For each protocol of the proper type
(the same type as is managed by the device helper), tracing is enabled for the
corresponding interface.  Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit since there is a
one\sphinxhyphen{}to\sphinxhyphen{}one correspondence between each protocol and its node. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{devices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{deviceHelper}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ipv4AddressHelper}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{;}
\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.1.1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4InterfaceContainer}\PYG{+w}{ }\PYG{n}{interfaces}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{interfaces}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}i\textless{}interface\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{devices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{deviceHelper}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ipv4AddressHelper}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{;}
\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.1.1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4InterfaceContainer}\PYG{+w}{ }\PYG{n}{interfaces}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stream}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{interfaces}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can enable ASCII tracing on a collection of protocol/interface pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} the
appropriate protocol is found.  For each protocol, its interfaces are enumerated
and tracing is enabled on the resulting pairs. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

\sphinxAtStartPar
You can enable pcap tracing on the basis of node ID and device ID as well. In
this case, the node\sphinxhyphen{}id is translated to a \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} and the appropriate
protocol is looked up in the node.  The resulting protocol and interface are
used to specify the resulting trace source.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course, the traces can be combined into a single file as shown above.

\sphinxAtStartPar
Finally, you can enable ASCII tracing for all interfaces in the system, with
associated protocol being the same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4All}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would result in a number of ASCII trace files being created, one for
every interface in the system related to a protocol of the type managed by the
helper. All of these files will follow the \textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}i\textless{}interface.tr
convention. Combining all of the traces into a single file is accomplished
similarly to the examples above.


\paragraph{Ascii Tracing Device Helper Filename Selection}
\label{\detokenize{tracing:id2}}
\sphinxAtStartPar
Implicit in the prefix\sphinxhyphen{}style method descriptions above is the construction of
the complete filenames by the implementation method. By convention, ASCII traces
in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system are of the form “\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr.”

\sphinxAtStartPar
As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id. Since there is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence between protocols and nodes
we use to node\sphinxhyphen{}id to identify the protocol identity. Every interface on a given
protocol will have an interface index (also called simply an interface) relative
to its protocol. By default, then, an ASCII trace file created as a result of
enabling tracing on the first device of node 21, using the prefix “prefix”,
would be “prefix\sphinxhyphen{}n21\sphinxhyphen{}i1.tr”. Use the prefix to disambiguate multiple protocols
per node.

\sphinxAtStartPar
You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.
For example, if you use the object name service to assign the name “serverIpv4”
to the protocol on node 21, and also specify interface one, the resulting ASCII
trace file name will automatically become, “prefix\sphinxhyphen{}nserverIpv4\sphinxhyphen{}1.tr”.


\subsection{Tracing implementation details}
\label{\detokenize{tracing:tracing-implementation-details}}
\sphinxstepscope


\section{Data Collection}
\label{\detokenize{data-collection:data-collection}}\label{\detokenize{data-collection::doc}}
\sphinxAtStartPar
This chapter describes the ns\sphinxhyphen{}3 Data Collection Framework (DCF), which
provides capabilities to obtain data generated by models in the simulator,
to perform on\sphinxhyphen{}line reduction and data processing, and to marshal raw
or transformed data into various output formats.

\sphinxAtStartPar
The framework presently supports standalone ns\sphinxhyphen{}3 runs that don’t rely on
any external program execution control.  The objects provided by the
DCF may be hooked to \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources to enable data processing.

\sphinxAtStartPar
The source code for the classes lives in the directory \sphinxcode{\sphinxupquote{src/stats}}.

\sphinxAtStartPar
This chapter is organized as follows.  First, an overview of the architecture
is presented.  Next, the helpers for these classes are presented; this
initial treatment should allow basic use of the data collection framework
for many use cases.  Users who wish to produce output outside of the
scope of the current helpers, or who wish to create their own data
collection objects, should read the remainder of the chapter, which
goes into detail about all of the basic DCF object types and provides
low\sphinxhyphen{}level coding examples.

\sphinxstepscope


\subsection{Design}
\label{\detokenize{data-collection-overview:design}}\label{\detokenize{data-collection-overview::doc}}
\sphinxAtStartPar
The DCF consists of three basic classes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Probe} is a mechanism to instrument and control the output of
simulation data that is used to monitor interesting events. It
produces output in the form of one or more \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources.
Probe objects are hooked up to one or more trace \sphinxstyleemphasis{sinks} (called
\sphinxstyleemphasis{Collectors}), which process samples on\sphinxhyphen{}line and prepare them for
output.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Collector} consumes the data generated by one or more Probe objects.
It performs transformations on the data, such as normalization, reduction, and
the computation of basic statistics. Collector objects do not produce
data that is directly output by the ns\sphinxhyphen{}3 run; instead, they output data
downstream to another type of object, called \sphinxstyleemphasis{Aggregator}, which performs
that function.  Typically, Collectors output their data in the form of
trace sources as well, allowing collectors to be chained in series.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Aggregator} is the end point of the data collected by a network of Probes and Collectors.
The main responsibility of the Aggregator is to marshal data and their
corresponding metadata, into different output
formats such as plain text files, spreadsheet files, or databases.

\end{itemize}

\sphinxAtStartPar
All three of these classes provide the capability to dynamically turn themselves on or off throughout a simulation.

\sphinxAtStartPar
Any standalone \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation run that uses the DCF will typically create
at least one instance of each of the three classes above.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{dcf-overview}.pdf}
\caption{Data Collection Framework overview}\label{\detokenize{data-collection-overview:id1}}\label{\detokenize{data-collection-overview:dcf-overview}}\end{figure}

\sphinxAtStartPar
The overall flow of data processing is depicted in {\hyperref[\detokenize{data-collection-overview:dcf-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Collection Framework overview}}}}.  On
the left side, a running \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation is depicted.  In the course
of running the simulation, data is made available by models through
trace sources, or via other means.  The diagram depicts that probes
can be connected to these trace sources to receive data asynchronously,
or probes can poll for data.  Data is then passed to a collector object
that transforms the data.  Finally, an aggregator can be connected
to the outputs of the collector, to generate plots, files, or databases.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{dcf-overview-with-aggregation}.pdf}
\caption{Data Collection Framework aggregation}\label{\detokenize{data-collection-overview:id2}}\label{\detokenize{data-collection-overview:dcf-overview-with-aggregation}}\end{figure}

\sphinxAtStartPar
A variation on the above figure is provided
in {\hyperref[\detokenize{data-collection-overview:dcf-overview-with-aggregation}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Collection Framework aggregation}}}}.
This second figure illustrates that the DCF objects may be chained
together in a manner that downstream objects take inputs from multiple
upstream objects.  The figure conceptually shows that multiple probes
may generate output that is fed into a single collector; as an example,
a collector that outputs a ratio of two counters would typically acquire
each counter data from separate probes.  Multiple collectors can also
feed into a single aggregator, which (as its name implies) may collect
a number of data streams for inclusion into a single plot, file, or
database.

\sphinxstepscope


\subsection{Data Collection Helpers}
\label{\detokenize{data-collection-helpers:data-collection-helpers}}\label{\detokenize{data-collection-helpers::doc}}
\sphinxAtStartPar
The full flexibility of the data collection framework is provided by
the interconnection of probes, collectors, and aggregators.  Performing
all of these interconnections leads to many configuration statements
in user programs.  For ease of use, some of the most common operations
can be combined and encapsulated in helper functions.  In addition,
some statements involving \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources do not have Python
bindings, due to limitations in the bindings.


\subsubsection{Data Collection Helpers Overview}
\label{\detokenize{data-collection-helpers:data-collection-helpers-overview}}
\sphinxAtStartPar
In this section, we provide an overview of some helper classes that
have been created to ease the configuration of the data collection
framework for some common use cases.  The helpers allow users to form
common operations with only a few statements in their C++ or Python
programs.  But, this ease of use comes at the cost of significantly
less flexibility than low\sphinxhyphen{}level configuration can provide, and the
need to explicitly code support for new Probe types into the helpers
(to work around an issue described below).

\sphinxAtStartPar
The emphasis on the current helpers is to marshal data out of \sphinxstyleemphasis{ns\sphinxhyphen{}3}
trace sources into gnuplot plots or text files, without a high degree
of output customization or statistical processing (initially).  Also,
the use is constrained to the available probe types in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  Later
sections of this documentation will go into more detail about creating
new Probe types, as well as details about hooking together Probes,
Collectors, and Aggregators in custom arrangements.

\sphinxAtStartPar
To date, two Data Collection helpers have been implemented:
\begin{itemize}
\item {} 
\sphinxAtStartPar
GnuplotHelper

\item {} 
\sphinxAtStartPar
FileHelper

\end{itemize}


\subsubsection{GnuplotHelper}
\label{\detokenize{data-collection-helpers:gnuplothelper}}
\sphinxAtStartPar
The GnuplotHelper is a helper class for producing output files used to
make gnuplots.  The overall goal is to provide the ability for users
to quickly make plots from data exported in \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources.  By
default, a minimal amount of data transformation is performed; the
objective is to generate plots with as few (default) configuration
statements as possible.


\paragraph{GnuplotHelper Overview}
\label{\detokenize{data-collection-helpers:gnuplothelper-overview}}
\sphinxAtStartPar
The GnuplotHelper will create 3 different files at the end of the
simulation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A space separated gnuplot data file

\item {} 
\sphinxAtStartPar
A gnuplot control file

\item {} 
\sphinxAtStartPar
A shell script to generate the gnuplot

\end{itemize}

\sphinxAtStartPar
There are two configuration statements that are needed to produce plots.
The first statement configures the plot (filename, title, legends, and
output type, where the output type defaults to PNG if unspecified):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{ConfigurePlot}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{outputFileNameWithoutExtension}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{xLegend}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{yLegend}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{terminalType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The second statement hooks the trace source of interest:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{PlotProbe}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{typeId}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{path}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{probeTraceSource}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The arguments are as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
typeId:  The \sphinxstyleemphasis{ns\sphinxhyphen{}3} TypeId of the Probe

\item {} 
\sphinxAtStartPar
path:  The path in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration namespace to one or more trace sources

\item {} 
\sphinxAtStartPar
probeTraceSource:  Which output of the probe (itself a trace source) should be plotted

\item {} 
\sphinxAtStartPar
title:  The title to associate with the dataset(s) (in the gnuplot legend)

\end{itemize}

\sphinxAtStartPar
A variant on the PlotProbe above is to specify a fifth optional argument
that controls where in the plot the key (legend) is placed.

\sphinxAtStartPar
A fully worked example (from \sphinxcode{\sphinxupquote{seventh.cc}}) is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the gnuplot helper.}
\PYG{n}{GnuplotHelper}\PYG{+w}{ }\PYG{n}{plotHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the plot.}
\PYG{c+c1}{// Configure the plot.  The first argument is the file name prefix}
\PYG{c+c1}{// for the output files generated.  The second, third, and fourth}
\PYG{c+c1}{// arguments are, respectively, the plot title, x\PYGZhy{}axis, and y\PYGZhy{}axis labels}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{ConfigurePlot}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count vs. Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time(Seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Specify the probe type, trace source path (in configuration namespace), and}
\PYG{c+c1}{// probe output trace source (\PYGZdq{}OutputBytes\PYGZdq{}) to plot.  The fourth argument}
\PYG{c+c1}{// specifies the name of the data series label on the plot.  The last}
\PYG{c+c1}{// argument formats the plot by specifying where the key should be placed.}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{PlotProbe}\PYG{p}{(}\PYG{n}{probeType}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{tracePath}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}BELOW}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the \sphinxcode{\sphinxupquote{probeType}} and \sphinxcode{\sphinxupquote{tracePath}} are as follows (for IPv4):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{probeType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{tracePath}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The probeType is a key parameter for this helper to work.  This TypeId
must be registered in the system, and the signature on the Probe’s trace
sink must match that of the trace source it is being hooked to.  Probe
types are pre\sphinxhyphen{}defined for a number of data types corresponding to \sphinxstyleemphasis{ns\sphinxhyphen{}3}
traced values, and for a few other trace source signatures such as the
‘Tx’ trace source of \sphinxcode{\sphinxupquote{ns3::Ipv4L3Protocol}} class.

\sphinxAtStartPar
Note that the trace source path specified may contain wildcards.
In this case, multiple
datasets are plotted on one plot; one for each matched path.

\sphinxAtStartPar
The main output produced will be three files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{seventh}\PYG{o}{\PYGZhy{}}\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{n}{byte}\PYG{o}{\PYGZhy{}}\PYG{n}{count}\PYG{p}{.}\PYG{n}{dat}
\PYG{n}{seventh}\PYG{o}{\PYGZhy{}}\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{n}{byte}\PYG{o}{\PYGZhy{}}\PYG{n}{count}\PYG{p}{.}\PYG{n}{plt}
\PYG{n}{seventh}\PYG{o}{\PYGZhy{}}\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{n}{byte}\PYG{o}{\PYGZhy{}}\PYG{n}{count}\PYG{p}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, users can either hand edit the .plt file for further
customizations, or just run it through gnuplot.  Running
\sphinxtitleref{sh seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count.sh} simply runs the plot through gnuplot,
as shown below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{seventh-packet-byte-count}.png}
\caption{2\sphinxhyphen{}D Gnuplot Created by seventh.cc Example.}\label{\detokenize{data-collection-helpers:id3}}\label{\detokenize{data-collection-helpers:seventh-packet-byte-count}}\end{figure}

\sphinxAtStartPar
It can be seen that the key elements (legend, title, legend placement,
xlabel, ylabel, and path for the data) are all placed on the plot.
Since there were two matches to the configuration path provided, the
two data series are shown:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Packet Byte Count\sphinxhyphen{}0 corresponds to /NodeList/0/\$ns3::Ipv4L3Protocol/Tx

\item {} 
\sphinxAtStartPar
Packet Byte Count\sphinxhyphen{}1 corresponds to /NodeList/1/\$ns3::Ipv4L3Protocol/Tx

\end{itemize}


\paragraph{GnuplotHelper ConfigurePlot}
\label{\detokenize{data-collection-helpers:gnuplothelper-configureplot}}
\sphinxAtStartPar
The GnuplotHelper’s \sphinxcode{\sphinxupquote{ConfigurePlot()}} function can be used
to configure plots.

\sphinxAtStartPar
It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{ConfigurePlot}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{outputFileNameWithoutExtension}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{xLegend}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{yLegend}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{terminalType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
outputFileNameWithoutExtension
&
\sphinxAtStartPar
Name of gnuplot related files
to write with no extension.
\\
\sphinxhline
\sphinxAtStartPar
title
&
\sphinxAtStartPar
Plot title string to use for
this plot.
\\
\sphinxhline
\sphinxAtStartPar
xLegend
&
\sphinxAtStartPar
The legend for the x
horizontal axis.
\\
\sphinxhline
\sphinxAtStartPar
yLegend
&
\sphinxAtStartPar
The legend for the y
vertical axis.
\\
\sphinxhline
\sphinxAtStartPar
terminalType
&
\sphinxAtStartPar
Terminal type setting string
for output.  The default
terminal type is “png”.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
The GnuplotHelper’s \sphinxcode{\sphinxupquote{ConfigurePlot()}} function configures plot
related parameters for this gnuplot helper so
that it will create a space separated gnuplot data file named
outputFileNameWithoutExtension + “.dat”, a gnuplot control file
named outputFileNameWithoutExtension + “.plt”, and a shell script
to generate the gnuplot named outputFileNameWithoutExtension +
“.sh”.

\sphinxAtStartPar
An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{ConfigurePlot}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count vs. Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time(Seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{GnuplotHelper PlotProbe}
\label{\detokenize{data-collection-helpers:gnuplothelper-plotprobe}}
\sphinxAtStartPar
The GnuplotHelper’s \sphinxcode{\sphinxupquote{PlotProbe()}} function can be used
to plot values generated by probes.

\sphinxAtStartPar
It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{PlotProbe}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{typeId}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{path}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{probeTraceSource}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{,}
\PYG{+w}{               }\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KeyLocation}\PYG{+w}{ }\PYG{n}{keyLocation}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}INSIDE}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
typeId
&
\sphinxAtStartPar
The type ID for the probe
created by this helper.
\\
\sphinxhline
\sphinxAtStartPar
path
&
\sphinxAtStartPar
Config path to access the
trace source.
\\
\sphinxhline
\sphinxAtStartPar
probeTraceSource
&
\sphinxAtStartPar
The probe trace source to
access.
\\
\sphinxhline
\sphinxAtStartPar
title
&
\sphinxAtStartPar
The title to be associated
to this dataset
\\
\sphinxhline
\sphinxAtStartPar
keyLocation
&
\sphinxAtStartPar
The location of the key in
the plot.  The default
location is inside.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
The GnuplotHelper’s \sphinxcode{\sphinxupquote{PlotProbe()}} function
plots a dataset generated by hooking the \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source with a
probe created by the helper, and then plotting the values from the
probeTraceSource.
The dataset will have the provided title, and will consist of
the ‘newValue’ at each timestamp.

\sphinxAtStartPar
If the config path has more than one match in the system because
there is a wildcard, then one dataset for each match will
be plotted.  The dataset titles will be suffixed with the matched
characters for each of the wildcards in the config path,
separated by spaces.  For example, if the proposed dataset title
is the string “bytes”, and there are two wildcards in the path,
then dataset titles like “bytes\sphinxhyphen{}0 0” or “bytes\sphinxhyphen{}12 9” will be
possible as labels for the datasets that are plotted.

\sphinxAtStartPar
An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used (with
variable substitution) as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{PlotProbe}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}BELOW}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Other Examples}
\label{\detokenize{data-collection-helpers:other-examples}}

\subparagraph{Gnuplot Helper Example}
\label{\detokenize{data-collection-helpers:gnuplot-helper-example}}
\sphinxAtStartPar
A slightly simpler example than the \sphinxcode{\sphinxupquote{seventh.cc}} example can be
found in \sphinxcode{\sphinxupquote{src/stats/examples/gnuplot\sphinxhyphen{}helper\sphinxhyphen{}example.cc}}.  The
following 2\sphinxhyphen{}D gnuplot was created using the example.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gnuplot-helper-example}.png}
\caption{2\sphinxhyphen{}D Gnuplot Created by gnuplot\sphinxhyphen{}helper\sphinxhyphen{}example.cc Example.}\label{\detokenize{data-collection-helpers:id4}}\label{\detokenize{data-collection-helpers:id1}}\end{figure}

\sphinxAtStartPar
In this example, there is an Emitter object that increments
its counter according to a Poisson process and then emits the counter’s
value as a trace source.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{emitter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that because there are no wildcards in the path
used below, only 1 datastream was drawn in the plot.
This single datastream in the plot is simply labeled
“Emitter Count”, with no extra suffixes like one would
see if there were wildcards in the path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the gnuplot helper.}
\PYG{n}{GnuplotHelper}\PYG{+w}{ }\PYG{n}{plotHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the plot.}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{ConfigurePlot}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gnuplot\PYGZhy{}helper\PYGZhy{}example}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Emitter Counts vs. Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time(Seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Emitter Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot the values generated by the probe.  The path that we provide}
\PYG{c+c1}{// helps to disambiguate the source of the trace.}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{PlotProbe}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Uinteger32Probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Emitter Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}INSIDE}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{FileHelper}
\label{\detokenize{data-collection-helpers:filehelper}}
\sphinxAtStartPar
The FileHelper is a helper class used to put data values into a file.
The overall goal is to provide the ability for users
to quickly make formatted text files from data exported in \sphinxstyleemphasis{ns\sphinxhyphen{}3}
trace sources.  By default, a minimal amount of data transformation is
performed; the objective is to generate files with as few (default)
configuration statements as possible.


\paragraph{FileHelper Overview}
\label{\detokenize{data-collection-helpers:filehelper-overview}}
\sphinxAtStartPar
The FileHelper will create 1 or more text files at the end of the
simulation.

\sphinxAtStartPar
The FileHelper can create 4 different types of text files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Formatted

\item {} 
\sphinxAtStartPar
Space separated (the default)

\item {} 
\sphinxAtStartPar
Comma separated

\item {} 
\sphinxAtStartPar
Tab separated

\end{itemize}

\sphinxAtStartPar
Formatted files use C\sphinxhyphen{}style format strings and the sprintf() function
to print their values in the file being written.

\sphinxAtStartPar
The following text file with 2 columns of formatted values named
\sphinxcode{\sphinxupquote{seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}0.txt}} was created using more new
code that was added to the original \sphinxstyleemphasis{ns\sphinxhyphen{}3} Tutorial example’s code.
Only the first 10 lines of this file are shown here for brevity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time (Seconds) = 1.000e+00    Packet Byte Count = 40
Time (Seconds) = 1.004e+00    Packet Byte Count = 40
Time (Seconds) = 1.004e+00    Packet Byte Count = 576
Time (Seconds) = 1.009e+00    Packet Byte Count = 576
Time (Seconds) = 1.009e+00    Packet Byte Count = 576
Time (Seconds) = 1.015e+00    Packet Byte Count = 512
Time (Seconds) = 1.017e+00    Packet Byte Count = 576
Time (Seconds) = 1.017e+00    Packet Byte Count = 544
Time (Seconds) = 1.025e+00    Packet Byte Count = 576
Time (Seconds) = 1.025e+00    Packet Byte Count = 544

...
\end{sphinxVerbatim}

\sphinxAtStartPar
The following different text file with 2 columns of formatted
values named \sphinxcode{\sphinxupquote{seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}1.txt}} was also
created using the same new code that was added to the original
\sphinxstyleemphasis{ns\sphinxhyphen{}3} Tutorial example’s code.  Only the first 10 lines of this
file are shown here for brevity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time (Seconds) = 1.002e+00    Packet Byte Count = 40
Time (Seconds) = 1.007e+00    Packet Byte Count = 40
Time (Seconds) = 1.013e+00    Packet Byte Count = 40
Time (Seconds) = 1.020e+00    Packet Byte Count = 40
Time (Seconds) = 1.028e+00    Packet Byte Count = 40
Time (Seconds) = 1.036e+00    Packet Byte Count = 40
Time (Seconds) = 1.045e+00    Packet Byte Count = 40
Time (Seconds) = 1.053e+00    Packet Byte Count = 40
Time (Seconds) = 1.061e+00    Packet Byte Count = 40
Time (Seconds) = 1.069e+00    Packet Byte Count = 40

...
\end{sphinxVerbatim}

\sphinxAtStartPar
The new code that was added to produce the two text files is below.
More details about this API will be covered in a later section.

\sphinxAtStartPar
Note that because there were 2 matches for the wildcard in the path,
2 separate text files were created.  The first text file, which is
named “seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}0.txt”, corresponds to the
wildcard match with the “*” replaced with “0”.  The second text file,
which is named “seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}1.txt”, corresponds to
the wildcard match with the “*” replaced with “1”.  Also, note that
the function call to \sphinxcode{\sphinxupquote{WriteProbe()}} will give an error message if
there are no matches for a path that contains wildcards.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the file helper.}
\PYG{n}{FileHelper}\PYG{+w}{ }\PYG{n}{fileHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the file to be written.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{ConfigureFile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for this formatted output file.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{Set2dFormat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds) = \PYGZpc{}.3e}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Packet Byte Count = \PYGZpc{}.0f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the values generated by the probe.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{WriteProbe}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{FileHelper ConfigureFile}
\label{\detokenize{data-collection-helpers:filehelper-configurefile}}
\sphinxAtStartPar
The FileHelper’s \sphinxcode{\sphinxupquote{ConfigureFile()}} function can be used
to configure text files.

\sphinxAtStartPar
It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{ConfigureFile}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{outputFileNameWithoutExtension}\PYG{p}{,}
\PYG{+w}{                   }\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FileType}\PYG{+w}{ }\PYG{n}{fileType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SPACE\PYGZus{}SEPARATED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
outputFileNameWithoutExtension
&
\sphinxAtStartPar
Name of output file to write
with no extension.
\\
\sphinxhline
\sphinxAtStartPar
fileType
&
\sphinxAtStartPar
Type of file to write.  The
default type of file is space
separated.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
The FileHelper’s \sphinxcode{\sphinxupquote{ConfigureFile()}} function configures text file
related parameters for the file helper so that
it will create a file named outputFileNameWithoutExtension plus
possible extra information from wildcard matches plus “.txt” with
values printed as specified by fileType.  The default file type
is space\sphinxhyphen{}separated.

\sphinxAtStartPar
An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{ConfigureFile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{FileHelper WriteProbe}
\label{\detokenize{data-collection-helpers:filehelper-writeprobe}}
\sphinxAtStartPar
The FileHelper’s \sphinxcode{\sphinxupquote{WriteProbe()}} function can be used
to write values generated by probes to text files.

\sphinxAtStartPar
It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{WriteProbe}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{typeId}\PYG{p}{,}
\PYG{+w}{                }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{path}\PYG{p}{,}
\PYG{+w}{                }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{probeTraceSource}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Argument
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
typeId
&
\sphinxAtStartPar
The type ID for the probe
to be created.
\\
\sphinxhline
\sphinxAtStartPar
path
&
\sphinxAtStartPar
Config path to access the
trace source.
\\
\sphinxhline
\sphinxAtStartPar
probeTraceSource
&
\sphinxAtStartPar
The probe trace source to
access.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxAtStartPar
The FileHelper’s \sphinxcode{\sphinxupquote{WriteProbe()}} function
creates output text files generated by hooking the ns\sphinxhyphen{}3 trace source
with a probe created by the helper, and then writing the values from the
probeTraceSource. The output file names will have the text stored
in the member variable  m\_outputFileNameWithoutExtension plus “.txt”,
and will consist of the ‘newValue’ at each timestamp.

\sphinxAtStartPar
If the config path has more than one match in the system because
there is a wildcard, then one output file for each match
will be created.  The output file names will contain the text in
m\_outputFileNameWithoutExtension plus the matched characters for
each of the wildcards in the config path, separated by dashes,
plus “.txt”.  For example, if the value in
m\_outputFileNameWithoutExtension is the string
“packet\sphinxhyphen{}byte\sphinxhyphen{}count”, and there are two wildcards in the path,
then output file names like “packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}0\sphinxhyphen{}0.txt” or
“packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}12\sphinxhyphen{}9.txt” will be possible as names for the
files that will be created.

\sphinxAtStartPar
An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{WriteProbe}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Other Examples}
\label{\detokenize{data-collection-helpers:id2}}

\subparagraph{File Helper Example}
\label{\detokenize{data-collection-helpers:file-helper-example}}
\sphinxAtStartPar
A slightly simpler example than the \sphinxcode{\sphinxupquote{seventh.cc}} example can be
found in \sphinxcode{\sphinxupquote{src/stats/examples/file\sphinxhyphen{}helper\sphinxhyphen{}example.cc}}.
This example only uses the FileHelper.

\sphinxAtStartPar
The following text file with 2 columns of formatted values named
\sphinxcode{\sphinxupquote{file\sphinxhyphen{}helper\sphinxhyphen{}example.txt}} was created using the example.
Only the first 10 lines of this file are shown here for brevity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time (Seconds) = 0.203  Count = 1
Time (Seconds) = 0.702  Count = 2
Time (Seconds) = 1.404  Count = 3
Time (Seconds) = 2.368  Count = 4
Time (Seconds) = 3.364  Count = 5
Time (Seconds) = 3.579  Count = 6
Time (Seconds) = 5.873  Count = 7
Time (Seconds) = 6.410  Count = 8
Time (Seconds) = 6.472  Count = 9
...
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, there is an Emitter object that increments
its counter according to a Poisson process and then emits the counter’s
value as a trace source.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{emitter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that because there are no wildcards in the path
used below, only 1 text file was created.
This single text file is simply named
“file\sphinxhyphen{}helper\sphinxhyphen{}example.txt”, with no extra suffixes like
you would see if there were wildcards in the path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the file helper.}
\PYG{n}{FileHelper}\PYG{+w}{ }\PYG{n}{fileHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the file to be written.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{ConfigureFile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}helper\PYGZhy{}example}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                         }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for this formatted output file.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{Set2dFormat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds) = \PYGZpc{}.3e}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Count = \PYGZpc{}.0f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the values generated by the probe.  The path that we}
\PYG{c+c1}{// provide helps to disambiguate the source of the trace.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{WriteProbe}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Uinteger32Probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                      }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Scope and Limitations}
\label{\detokenize{data-collection-helpers:scope-and-limitations}}
\sphinxAtStartPar
Currently, only these Probes have been implemented and connected
to the GnuplotHelper and to the FileHelper:
\begin{itemize}
\item {} 
\sphinxAtStartPar
BooleanProbe

\item {} 
\sphinxAtStartPar
DoubleProbe

\item {} 
\sphinxAtStartPar
Uinteger8Probe

\item {} 
\sphinxAtStartPar
Uinteger16Probe

\item {} 
\sphinxAtStartPar
Uinteger32Probe

\item {} 
\sphinxAtStartPar
TimeProbe

\item {} 
\sphinxAtStartPar
PacketProbe

\item {} 
\sphinxAtStartPar
ApplicationPacketProbe

\item {} 
\sphinxAtStartPar
Ipv4PacketProbe

\end{itemize}

\sphinxAtStartPar
These Probes, therefore, are the only TypeIds available to be used
in \sphinxcode{\sphinxupquote{PlotProbe()}} and \sphinxcode{\sphinxupquote{WriteProbe()}}.

\sphinxAtStartPar
In the next few sections, we cover each of the fundamental object
types (Probe, Collector, and Aggregator) in more detail, and show
how they can be connected together using lower\sphinxhyphen{}level API.

\sphinxstepscope


\subsection{Probes}
\label{\detokenize{probe:probes}}\label{\detokenize{probe::doc}}
\sphinxAtStartPar
This section details the functionalities provided by the Probe class
to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation, and gives examples on how to code them in a
program. This section is meant for users interested in developing
simulations with the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tools and using the Data Collection
Framework, of which the Probe class is a part, to generate data output
with their simulation’s results.


\subsubsection{Probe Overview}
\label{\detokenize{probe:probe-overview}}
\sphinxAtStartPar
A Probe object is supposed to be connected to a variable from the
simulation whose values throughout the experiment are relevant to the user.
The Probe will record what were values assumed by the variable throughout
the simulation and pass such data to another member of the Data Collection
Framework.  While it is out of this section’s scope to discuss what happens
after the Probe produces its output, it is sufficient to say that, by the
end of the simulation, the user will have detailed information about what
values were stored inside the variable being probed during the simulation.

\sphinxAtStartPar
Typically, a Probe is connected to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source.  In this manner,
whenever the trace source exports a new value, the Probe consumes the
value (and exports it downstream to another object via its own trace source).

\sphinxAtStartPar
The Probe can be thought of as kind of a filter on trace sources.  The
main reasons for possibly hooking to a Probe rather than directly to a
trace source are as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Probes may be dynamically turned on and off during the simulation
with calls to \sphinxcode{\sphinxupquote{Enable()}} and \sphinxcode{\sphinxupquote{Disable()}}.  For example, the
outputting of data may be turned off during the simulation warmup
phase.

\item {} 
\sphinxAtStartPar
Probes may perform operations on the data to extract values from more
complicated structures; for instance, outputting the packet size value
from a received ns3::Packet.

\item {} 
\sphinxAtStartPar
Probes register a name in the ns3::Config namespace (using
\sphinxcode{\sphinxupquote{Names::Add()}}) so that other objects may refer to them.

\item {} 
\sphinxAtStartPar
Probes provide a static method that allows one to manipulate a Probe
by name, such as what is done in ns2measure \sphinxcite{probe:cic06}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Stat}\PYG{o}{:}\PYG{o}{:}\PYG{n}{put}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZus{}metric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ID}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The ns\sphinxhyphen{}3 equivalent of the above ns2measure code is, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DoubleProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetValueByPath}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/path/to/probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\paragraph{Creation}
\label{\detokenize{probe:creation}}
\sphinxAtStartPar
Note that a Probe base class object can not be created because it
is an abstract base class, i.e. it has pure virtual functions that
have not been implemented.  An object of type DoubleProbe,
which is a subclass of the Probe class, will be created here to
show what needs to be done.

\sphinxAtStartPar
One declares a DoubleProbe in dynamic memory by using the smart pointer class
(Ptr\textless{}T\textgreater{}). To create a DoubleProbe in dynamic memory with smart pointers, one
just needs to call the \sphinxstyleemphasis{ns\sphinxhyphen{}3} method \sphinxcode{\sphinxupquote{CreateObject()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{myprobe}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The declaration above creates DoubleProbes using the default values for its
attributes.  There are four attributes in the DoubleProbe class; two in the
base class object DataCollectionObject, and two in the Probe base class:
\begin{itemize}
\item {} 
\sphinxAtStartPar
“Name” (DataCollectionObject), a StringValue

\item {} 
\sphinxAtStartPar
“Enabled” (DataCollectionObject), a BooleanValue

\item {} 
\sphinxAtStartPar
“Start” (Probe), a TimeValue

\item {} 
\sphinxAtStartPar
“Stop” (Probe), a TimeValue

\end{itemize}

\sphinxAtStartPar
One can set such attributes at object creation by using the following
method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{myprobe}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObjectWithAttributes}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myprobe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enabled}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{BooleanValue}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Start}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Stop}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1000.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Start and Stop are Time variables which determine the interval of action
of the Probe. The Probe will only output data if the current time of the
Simulation is inside of that interval.  The special time value of 0 seconds
for Stop will disable this attribute (i.e. keep the Probe on for the whole
simulation).  Enabled is a flag that turns the
Probe on or off, and must be set to true for the Probe to export data.
The Name is the object’s name in the DCF framework.


\paragraph{Importing and exporting data}
\label{\detokenize{probe:importing-and-exporting-data}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources are strongly typed, so the mechanisms for hooking
Probes to a trace source and for exporting data belong to its
subclasses.  For instance, the default distribution of \sphinxstyleemphasis{ns\sphinxhyphen{}3} provides
a class DoubleProbe that is designed to hook to a trace source
exporting a double value.  We’ll next detail the operation of the
DoubleProbe, and then discuss how other Probe classes may be defined
by the user.


\subsubsection{DoubleProbe Overview}
\label{\detokenize{probe:doubleprobe-overview}}
\sphinxAtStartPar
The DoubleProbe connects to a double\sphinxhyphen{}valued \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source, and itself
exports a different double\sphinxhyphen{}valued \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source.

\sphinxAtStartPar
The following code, drawn from
\sphinxcode{\sphinxupquote{src/stats/examples/double\sphinxhyphen{}probe\sphinxhyphen{}example.cc}}, shows the basic
operations of plumbing the DoubleProbe into a simulation, where it is
probing a Counter exported by an emitter object (class Emitter).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{emitter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{probe1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Connect the probe to the emitter\PYGZsq{}s Counter}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{connected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByObject}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following code is probing the same Counter exported by the same
emitter object.  This DoubleProbe, however, is using a path in the
configuration namespace to make the connection.  Note that the emitter
registered itself in the configuration namespace after it was created;
otherwise, the ConnectByPath would not work.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{probe2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Note, no return value is checked here}
\PYG{n}{probe2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByPath}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next DoubleProbe shown that is shown below will have its value set using
its path in the configuration namespace.  Note that this time the
DoubleProbe registered itself in the configuration namespace after it was
created.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{probe3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// We must add it to the config database}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Probes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{probe3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The emitter’s Count() function is now able to set the value for this DoubleProbe as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{Emitter::Count}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{  }\PYG{n}{m\PYGZus{}counter}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{DoubleProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetValueByPath}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m\PYGZus{}counter}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above example shows how the code calling the Probe does not have to
have an explicit reference to the Probe, but can direct the value
setting through the Config namespace.  This is similar in functionality
to the \sphinxtitleref{Stat::Put} method introduced by ns2measure paper \sphinxcite{probe:cic06}, and allows
users to temporarily insert Probe statements like \sphinxtitleref{printf} statements within
existing \sphinxstyleemphasis{ns\sphinxhyphen{}3} models.  Note that in order to be able to use the DoubleProbe in this example like this, 2 things were necessary:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the stats module header file was included in the example .cc file

\item {} 
\sphinxAtStartPar
the example was made dependent on the stats module in its CMakeLists.txt file.

\end{enumerate}

\sphinxAtStartPar
Analogous things need to be done in order to add other Probes in other places in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} code base.

\sphinxAtStartPar
The values for the DoubleProbe can also be set using the function
DoubleProbe::SetValue(), while the values for the DoubleProbe can be gotten
using the function DoubleProbe::GetValue().

\sphinxAtStartPar
The DoubleProbe exports double values in its “Output” trace source;
a downstream object can hook a trace sink (NotifyViaProbe) to this as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnect}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyViaProbe}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Other probes}
\label{\detokenize{probe:other-probes}}
\sphinxAtStartPar
Besides the DoubleProbe, the following Probes are also available:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Uinteger8Probe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting an uint8\_t.

\item {} 
\sphinxAtStartPar
Uinteger16Probe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting an uint16\_t.

\item {} 
\sphinxAtStartPar
Uinteger32Probe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting an uint32\_t.

\item {} 
\sphinxAtStartPar
PacketProbe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting a packet.

\item {} 
\sphinxAtStartPar
ApplicationPacketProbe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting a packet and a socket address.

\item {} 
\sphinxAtStartPar
Ipv4PacketProbe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting a packet, an IPv4 object, and an interface.

\end{itemize}


\subsubsection{Creating new Probe types}
\label{\detokenize{probe:creating-new-probe-types}}
\sphinxAtStartPar
To create a new Probe type, you need to perform the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Be sure that your new Probe class is derived from the Probe base class.

\item {} 
\sphinxAtStartPar
Be sure that the pure virtual functions that your new Probe class
inherits from the Probe base class are implemented.

\item {} 
\sphinxAtStartPar
Find an existing Probe class that uses a trace source that is
closest in type to the type of trace source your Probe will be
using.

\item {} 
\sphinxAtStartPar
Copy that existing Probe class’s header file (.h) and implementation
file (.cc) to two new files with names matching your new Probe.

\item {} 
\sphinxAtStartPar
Replace the types, arguments, and variables in the copied files with
the appropriate type for your Probe.

\item {} 
\sphinxAtStartPar
Make necessary modifications to make the code compile and to make it
behave as you would like.

\end{itemize}


\subsubsection{Examples}
\label{\detokenize{probe:examples}}
\sphinxAtStartPar
Two examples will be discussed in detail here:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Double Probe Example

\item {} 
\sphinxAtStartPar
IPv4 Packet Plot Example

\end{itemize}


\paragraph{Double Probe Example}
\label{\detokenize{probe:double-probe-example}}
\sphinxAtStartPar
The double probe example has been discussed previously.  The example
program can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/double\sphinxhyphen{}probe\sphinxhyphen{}example.cc}}.  To
summarize what occurs in this program, there is an emitter that
exports a counter that increments according to a Poisson process.  In
particular, two ways of emitting data are shown:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
through a traced variable hooked to one Probe:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TracedValue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}counter}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// normally this would be integer type}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
through a counter whose value is posted to a second Probe, referenced by its name in the Config system:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{Emitter::Count}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}DEBUG}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counting at }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Now}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{GetSeconds}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{m\PYGZus{}counter}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{DoubleProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetValueByPath}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m\PYGZus{}counter}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{n}{m\PYGZus{}var}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetValue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{Emitter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Count}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Let’s look at the Probe more carefully.  Probes can receive their values
in a multiple ways:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
by the Probe accessing the trace source directly and connecting
a trace sink to it

\item {} 
\sphinxAtStartPar
by the Probe accessing the trace source through the config namespace
and connecting a trace sink to it

\item {} 
\sphinxAtStartPar
by the calling code explicitly calling the Probe’s \sphinxtitleref{SetValue()} method

\item {} 
\sphinxAtStartPar
by the calling code explicitly calling \sphinxtitleref{SetValueByPath (“/path/through/Config/namespace”, …)}

\end{enumerate}

\sphinxAtStartPar
The first two techniques are expected to be the most common.  Also in the
example, the hooking of a normal callback function is shown,
as is typically done in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  This callback function is not associated
with a Probe object.  We’ll call this case 0) below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a function to test hooking a raw function to the trace source}
\PYG{k+kt}{void}
\PYG{n+nf}{NotifyViaTraceSource}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{oldVal}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{newVal}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}DEBUG}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{context: }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{context}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ old }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{oldVal}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ new }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{newVal}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
First, the emitter needs to be setup:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{emitter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// The Emitter object is not associated with an ns\PYGZhy{}3 node, so}
\PYG{c+c1}{// it won\PYGZsq{}t get started automatically, so we need to do this ourselves}
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{Emitter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The various DoubleProbes interact with the emitter in the example as
shown below.

\sphinxAtStartPar
Case 0):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// The below shows typical functionality without a probe}
\PYG{c+c1}{// (connect a sink function to a trace source)}
\PYG{c+c1}{//}
\PYG{n}{connected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{emitter}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnect}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample context}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyViaTraceSource}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG}\PYG{p}{(}\PYG{n}{connected}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trace source not connected}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
case 1):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Probe1 will be hooked directly to the Emitter trace source object}
\PYG{c+c1}{//}

\PYG{c+c1}{// probe1 will be hooked to the Emitter trace source}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{probe1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// the probe\PYGZsq{}s name can serve as its context in the tracing}
\PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ObjectProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Connect the probe to the emitter\PYGZsq{}s Counter}
\PYG{n}{connected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByObject}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG}\PYG{p}{(}\PYG{n}{connected}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trace source not connected to probe1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
case 2):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Probe2 will be hooked to the Emitter trace source object by}
\PYG{c+c1}{// accessing it by path name in the Config database}
\PYG{c+c1}{//}

\PYG{c+c1}{// Create another similar probe; this will hook up via a Config path}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{probe2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{probe2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PathProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Note, no return value is checked here}
\PYG{n}{probe2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByPath}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
case 4)(case 3 is not shown in this example):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Probe3 will be called by the emitter directly through the}
\PYG{c+c1}{// static method SetValueByPath().}
\PYG{c+c1}{//}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{probe3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// We must add it to the config database}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Probes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{probe3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
And finally, the example shows how the probes can be hooked to
generate output:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// The probe itself should generate output.  The context that we provide}
\PYG{c+c1}{// to this probe (in this case, the probe name) will help to disambiguate}
\PYG{c+c1}{// the source of the trace}
\PYG{n}{connected}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnect}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                                 }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Probes/StaticallyAccessedProbe/Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                                 }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyViaProbe}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG}\PYG{p}{(}\PYG{n}{connected}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trace source not .. connected to probe3 Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
The following callback is hooked to the Probe in this example for
illustrative purposes; normally, the Probe would be hooked to a
Collector object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a function to test hooking it to the probe output}
\PYG{k+kt}{void}
\PYG{n+nf}{NotifyViaProbe}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{context}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{oldVal}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{newVal}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}DEBUG}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{context: }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{context}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ old }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{oldVal}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ new }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{newVal}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{IPv4 Packet Plot Example}
\label{\detokenize{probe:ipv4-packet-plot-example}}
\sphinxAtStartPar
The IPv4 packet plot example is based on the fifth.cc example from the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
Tutorial.  It can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/ipv4\sphinxhyphen{}packet\sphinxhyphen{}plot\sphinxhyphen{}example.cc}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      node 0                 node 1
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|    ns\PYGZhy{}3 TCP    |    |    ns\PYGZhy{}3 TCP    |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|    10.1.1.1    |    |    10.1.1.2    |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
| point\PYGZhy{}to\PYGZhy{}point |    | point\PYGZhy{}to\PYGZhy{}point |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
        |                     |
        +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}

\sphinxAtStartPar
We’ll just look at the Probe, as it illustrates that Probes may also
unpack values from structures (in this case, packets) and report
those values as trace source outputs, rather than just passing through
the same type of data.

\sphinxAtStartPar
There are other aspects of this example that will be explained later in
the documentation.  The two types of data that are exported are the packet
itself (\sphinxtitleref{Output}) and a count of the number of bytes in the packet
(\sphinxtitleref{OutputBytes}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}
\PYG{n+nf}{Ipv4PacketProbe::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Probe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4PacketProbe}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddTraceSource}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The packet plus its IPv4 object and interface that serve as the output for this probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{MakeTraceSourceAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Ipv4PacketProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}output}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddTraceSource}\PYG{p}{(}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The number of bytes in the packet}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                     }\PYG{n}{MakeTraceSourceAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Ipv4PacketProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}outputBytes}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
When the Probe’s trace sink gets a packet, if the Probe is enabled, then
it will output the packet on its \sphinxtitleref{Output} trace source, but it will also
output the number of bytes on the \sphinxtitleref{OutputBytes} trace source.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{Ipv4PacketProbe::TraceSink}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{packet}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{(}\PYG{k}{this}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{packet}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{IsEnabled}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}packet}\PYG{+w}{    }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{packet}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}ipv4}\PYG{+w}{      }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}interface}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}output}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ipv4}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{      }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{packetSizeNew}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}outputBytes}\PYG{p}{(}\PYG{n}{m\PYGZus{}packetSizeOld}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{packetSizeNew}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}packetSizeOld}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{packetSizeNew}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{References}
\label{\detokenize{probe:references}}
\sphinxstepscope


\subsection{Collectors}
\label{\detokenize{collector:collectors}}\label{\detokenize{collector::doc}}
\sphinxAtStartPar
This section is a placeholder to detail the functionalities provided by
the Collector
class to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation, and gives examples on how to code them
in a program.

\sphinxAtStartPar
\sphinxstylestrong{Note:} As of ns\sphinxhyphen{}3.18, Collectors are still under development and
not yet provided as part of the framework.

\sphinxstepscope


\subsection{Aggregators}
\label{\detokenize{aggregator:aggregators}}\label{\detokenize{aggregator::doc}}
\sphinxAtStartPar
This section details the functionalities provided by the Aggregator
class to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation. This section is meant for users
interested in developing simulations with the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tools and using
the Data Collection Framework, of which the Aggregator class is a
part, to generate data output with their simulation’s results.


\subsubsection{Aggregator Overview}
\label{\detokenize{aggregator:aggregator-overview}}
\sphinxAtStartPar
An Aggregator object is supposed to be hooked to one or more trace
sources in order to receive input. Aggregators are the end point of
the data collected by the network of Probes and Collectors during the
simulation.  It is the Aggregator’s job to take these values and
transform them into their final output format such as plain text
files, spreadsheet files, plots, or databases.

\sphinxAtStartPar
Typically, an aggregator is connected to one or more Collectors.  In
this manner, whenever the Collectors’ trace sources export new values,
the Aggregator can process the value so that it can be used in the
final output format where the data values will reside after the
simulation.

\sphinxAtStartPar
Note the following about Aggregators:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Aggregators may be dynamically turned on and off during the
simulation with calls to \sphinxcode{\sphinxupquote{Enable()}} and \sphinxcode{\sphinxupquote{Disable()}}.  For
example, the aggregating of data may be turned off during the
simulation warmup phase, which means those values won’t be included
in the final output medium.

\item {} 
\sphinxAtStartPar
Aggregators receive data from Collectors via callbacks. When a
Collector is associated to an aggregator, a call to TraceConnect is
made to establish the Aggregator’s trace sink method as a callback.

\end{itemize}

\sphinxAtStartPar
To date, two Aggregators have been implemented:
\begin{itemize}
\item {} 
\sphinxAtStartPar
GnuplotAggregator

\item {} 
\sphinxAtStartPar
FileAggregator

\end{itemize}


\subsubsection{GnuplotAggregator}
\label{\detokenize{aggregator:gnuplotaggregator}}
\sphinxAtStartPar
The GnuplotAggregator produces output files used to make gnuplots.

\sphinxAtStartPar
The GnuplotAggregator will create 3 different files at the end of the
simulation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A space separated gnuplot data file

\item {} 
\sphinxAtStartPar
A gnuplot control file

\item {} 
\sphinxAtStartPar
A shell script to generate the gnuplot

\end{itemize}


\paragraph{Creation}
\label{\detokenize{aggregator:creation}}
\sphinxAtStartPar
An object of type GnuplotAggregator will be created here to show what needs
to be done.

\sphinxAtStartPar
One declares a GnuplotAggregator in dynamic memory by using the smart
pointer class (Ptr\textless{}T\textgreater{}). To create a GnuplotAggregator in dynamic
memory with smart pointers, one just needs to call the \sphinxstyleemphasis{ns\sphinxhyphen{}3} method
\sphinxcode{\sphinxupquote{CreateObject()}}.  The following code from
\sphinxcode{\sphinxupquote{src/stats/examples/gnuplot\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}} shows
how to do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileNameWithoutExtension}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gnuplot\PYGZhy{}aggregator}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Create an aggregator.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{aggregator}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{  }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{fileNameWithoutExtension}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first argument for the constructor, fileNameWithoutExtension, is
the name of the gnuplot related files to write with no extension.
This GnuplotAggregator will create a space separated gnuplot data file
named “gnuplot\sphinxhyphen{}aggregator.dat”, a gnuplot control file named
“gnuplot\sphinxhyphen{}aggregator.plt”, and a shell script to generate the gnuplot
named + “gnuplot\sphinxhyphen{}aggregator.sh”.

\sphinxAtStartPar
The gnuplot that is created can have its key in 4 different locations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
No key

\item {} 
\sphinxAtStartPar
Key inside the plot (the default)

\item {} 
\sphinxAtStartPar
Key above the plot

\item {} 
\sphinxAtStartPar
Key below the plot

\end{itemize}

\sphinxAtStartPar
The following gnuplot key location enum values are allowed to specify the key’s position:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{KeyLocation}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NO\PYGZus{}KEY}\PYG{p}{,}
\PYG{+w}{  }\PYG{n}{KEY\PYGZus{}INSIDE}\PYG{p}{,}
\PYG{+w}{  }\PYG{n}{KEY\PYGZus{}ABOVE}\PYG{p}{,}
\PYG{+w}{  }\PYG{n}{KEY\PYGZus{}BELOW}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If it was desired to have the key below rather than the default position of inside, then you could do the following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetKeyLocation}\PYG{p}{(}\PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}BELOW}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Examples}
\label{\detokenize{aggregator:examples}}
\sphinxAtStartPar
One example will be discussed in detail here:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Gnuplot Aggregator Example

\end{itemize}


\subparagraph{Gnuplot Aggregator Example}
\label{\detokenize{aggregator:gnuplot-aggregator-example}}
\sphinxAtStartPar
An example that exercises the GnuplotAggregator can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/gnuplot\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}}.

\sphinxAtStartPar
The following 2\sphinxhyphen{}D gnuplot was created using the example.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gnuplot-aggregator}.png}
\caption{2\sphinxhyphen{}D Gnuplot Created by gnuplot\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc Example.}\label{\detokenize{aggregator:id3}}\label{\detokenize{aggregator:gnuplot-aggregator}}\end{figure}

\sphinxAtStartPar
This code from the example shows how to construct the
GnuplotAggregator as was discussed above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Create2dPlot}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileNameWithoutExtension}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gnuplot\PYGZhy{}aggregator}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotTitle}\PYG{+w}{                }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Gnuplot Aggregator Plot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotXAxisHeading}\PYG{+w}{         }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time(seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotYAxisHeading}\PYG{+w}{         }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Double Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotDatasetLabel}\PYG{+w}{         }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{datasetContext}\PYG{+w}{           }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dataset/Context/String}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Create an aggregator.}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{aggregator}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{    }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{fileNameWithoutExtension}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Various GnuplotAggregator attributes are set including the 2\sphinxhyphen{}D dataset
that will be plotted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Set the aggregator\PYGZsq{}s properties.}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetTerminal}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetLegend}\PYG{p}{(}\PYG{n}{plotXAxisHeading}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{plotYAxisHeading}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Add a data set to the aggregator.}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Add2dDataset}\PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{plotDatasetLabel}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// aggregator must be turned on}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Enable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, the 2\sphinxhyphen{}D values are calculated, and each one is individually
written to the GnuplotAggregator using the \sphinxcode{\sphinxupquote{Write2d()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
\PYG{+w}{      }\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{c+c1}{//                   2}
\PYG{+w}{      }\PYG{c+c1}{//     value  =  time   .}
\PYG{+w}{      }\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+c1}{// Add this point to the plot.}
\PYG{+w}{      }\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Write2d}\PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+c1}{// Disable logging of data for the aggregator.}
\PYG{+w}{  }\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Disable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{FileAggregator}
\label{\detokenize{aggregator:fileaggregator}}
\sphinxAtStartPar
The FileAggregator sends the values it receives to a file.

\sphinxAtStartPar
The FileAggregator can create 4 different types of files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Formatted

\item {} 
\sphinxAtStartPar
Space separated (the default)

\item {} 
\sphinxAtStartPar
Comma separated

\item {} 
\sphinxAtStartPar
Tab separated

\end{itemize}

\sphinxAtStartPar
Formatted files use C\sphinxhyphen{}style format strings and the sprintf() function
to print their values in the file being written.


\paragraph{Creation}
\label{\detokenize{aggregator:id1}}
\sphinxAtStartPar
An object of type FileAggregator will be created here to show what needs
to be done.

\sphinxAtStartPar
One declares a FileAggregator in dynamic memory by using the smart
pointer class (Ptr\textless{}T\textgreater{}). To create a FileAggregator in dynamic memory
with smart pointers, one just needs to call the \sphinxstyleemphasis{ns\sphinxhyphen{}3} method
CreateObject.  The following code from
\sphinxcode{\sphinxupquote{src/stats/examples/file\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}} shows how
to do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileName}\PYG{+w}{       }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}aggregator\PYGZhy{}formatted\PYGZhy{}values.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Create an aggregator that will have formatted values.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{aggregator}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{  }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{fileName}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first argument for the constructor, filename, is the name of the
file to write; the second argument, fileType, is type of file to
write. This FileAggregator will create a file named
“file\sphinxhyphen{}aggregator\sphinxhyphen{}formatted\sphinxhyphen{}values.txt” with its values printed as
specified by fileType, i.e., formatted in this case.

\sphinxAtStartPar
The following file type enum values are allowed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{FileType}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{FORMATTED}\PYG{p}{,}
\PYG{+w}{  }\PYG{n}{SPACE\PYGZus{}SEPARATED}\PYG{p}{,}
\PYG{+w}{  }\PYG{n}{COMMA\PYGZus{}SEPARATED}\PYG{p}{,}
\PYG{+w}{  }\PYG{n}{TAB\PYGZus{}SEPARATED}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Examples}
\label{\detokenize{aggregator:id2}}
\sphinxAtStartPar
One example will be discussed in detail here:
\begin{itemize}
\item {} 
\sphinxAtStartPar
File Aggregator Example

\end{itemize}


\subparagraph{File Aggregator Example}
\label{\detokenize{aggregator:file-aggregator-example}}
\sphinxAtStartPar
An example that exercises the FileAggregator can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/file\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}}.

\sphinxAtStartPar
The following text file with 2 columns of values separated by commas
was created using the example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{,}\PYG{l+m+mi}{25}
\PYG{l+m+mi}{\PYGZhy{}4}\PYG{p}{,}\PYG{l+m+mi}{16}
\PYG{l+m+mi}{\PYGZhy{}3}\PYG{p}{,}\PYG{l+m+mi}{9}
\PYG{l+m+mi}{\PYGZhy{}2}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}
\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{16}
\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{25}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code from the example shows how to construct the
FileAggregator as was discussed above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{CreateCommaSeparatedFile}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileName}\PYG{+w}{       }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}aggregator\PYGZhy{}comma\PYGZhy{}separated.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{datasetContext}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dataset/Context/String}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Create an aggregator.}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{aggregator}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{    }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{fileName}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{COMMA\PYGZus{}SEPARATED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
FileAggregator attributes are set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// aggregator must be turned on}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Enable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, the 2\sphinxhyphen{}D values are calculated, and each one is individually
written to the FileAggregator using the \sphinxcode{\sphinxupquote{Write2d()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
\PYG{+w}{      }\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{c+c1}{//                   2}
\PYG{+w}{      }\PYG{c+c1}{//     value  =  time   .}
\PYG{+w}{      }\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+c1}{// Add this point to the plot.}
\PYG{+w}{      }\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Write2d}\PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+c1}{// Disable logging of data for the aggregator.}
\PYG{+w}{  }\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Disable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following text file with 2 columns of formatted values was also
created using the example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.000e+00}\PYG{+w}{  }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{25}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}4.000e+00}\PYG{+w}{  }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{16}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}3.000e+00}\PYG{+w}{  }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{9}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}2.000e+00}\PYG{+w}{  }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{4}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}1.000e+00}\PYG{+w}{  }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.000e+00}\PYG{+w}{   }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.000e+00}\PYG{+w}{   }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{2.000e+00}\PYG{+w}{   }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{4}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{3.000e+00}\PYG{+w}{   }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{9}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{4.000e+00}\PYG{+w}{   }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{16}
\PYG{n}{Time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{5.000e+00}\PYG{+w}{   }\PYG{n}{Value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{25}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code from the example shows how to construct the
FileAggregator as was discussed above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{CreateFormattedFile}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileName}\PYG{+w}{       }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}aggregator\PYGZhy{}formatted\PYGZhy{}values.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{datasetContext}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dataset/Context/String}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Create an aggregator that will have formatted values.}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{aggregator}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{    }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{fileName}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
FileAggregator attributes are set, including the C\sphinxhyphen{}style format string
to use.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Set the format for the values.}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Set2dFormat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time = \PYGZpc{}.3e}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Value = \PYGZpc{}.0f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// aggregator must be turned on}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Enable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, the 2\sphinxhyphen{}D values are calculated, and each one is individually
written to the FileAggregator using the \sphinxcode{\sphinxupquote{Write2d()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{time}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
\PYG{+w}{      }\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{c+c1}{//                   2}
\PYG{+w}{      }\PYG{c+c1}{//     value  =  time   .}
\PYG{+w}{      }\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{time}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+c1}{// Add this point to the plot.}
\PYG{+w}{      }\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Write2d}\PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{time}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+c1}{// Disable logging of data for the aggregator.}
\PYG{+w}{  }\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Disable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstepscope


\subsection{Adaptors}
\label{\detokenize{adaptor:adaptors}}\label{\detokenize{adaptor::doc}}
\sphinxAtStartPar
This section details the functionalities provided by the Adaptor
class to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation. This section is meant for users
interested in developing simulations with the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tools and using
the Data Collection Framework, of which the Adaptor class is a
part, to generate data output with their simulation’s results.

\sphinxAtStartPar
Note:  the term ‘adaptor’ may also be spelled ‘adapter’; we chose
the spelling aligned with the C++ standard.


\subsubsection{Adaptor Overview}
\label{\detokenize{adaptor:adaptor-overview}}
\sphinxAtStartPar
An Adaptor is used to make connections between different types of DCF
objects.

\sphinxAtStartPar
To date, one Adaptor has been implemented:
\begin{itemize}
\item {} 
\sphinxAtStartPar
TimeSeriesAdaptor

\end{itemize}


\subsubsection{Time Series Adaptor}
\label{\detokenize{adaptor:time-series-adaptor}}
\sphinxAtStartPar
The TimeSeriesAdaptor lets Probes connect directly to Aggregators
without needing any Collector in between.

\sphinxAtStartPar
Both of the implemented DCF helpers utilize TimeSeriesAdaptors
in order to take probed values of different types and output the
current time plus the value with both converted to doubles.

\sphinxAtStartPar
The role of the TimeSeriesAdaptor class is that of an adaptor, which
takes raw\sphinxhyphen{}valued probe data of different types and outputs a tuple of
two double values.  The first is a timestamp, which may be set to
different resolutions (e.g. Seconds, Milliseconds, etc.) in the future
but which is presently hardcoded to Seconds.
The second is the conversion of a non\sphinxhyphen{}double
value to a double value (possibly with loss of precision).

\sphinxstepscope


\subsection{Scope/Limitations}
\label{\detokenize{scope-and-limitations:scope-limitations}}\label{\detokenize{scope-and-limitations::doc}}
\sphinxAtStartPar
This section discusses the scope and limitations of the Data
Collection Framework.

\sphinxAtStartPar
Currently, only these Probes have been implemented in DCF:
\begin{itemize}
\item {} 
\sphinxAtStartPar
BooleanProbe

\item {} 
\sphinxAtStartPar
DoubleProbe

\item {} 
\sphinxAtStartPar
Uinteger8Probe

\item {} 
\sphinxAtStartPar
Uinteger16Probe

\item {} 
\sphinxAtStartPar
Uinteger32Probe

\item {} 
\sphinxAtStartPar
TimeProbe

\item {} 
\sphinxAtStartPar
PacketProbe

\item {} 
\sphinxAtStartPar
ApplicationPacketProbe

\item {} 
\sphinxAtStartPar
Ipv4PacketProbe

\end{itemize}

\sphinxAtStartPar
Currently, no Collectors are available in the DCF, although a
BasicStatsCollector is under development.

\sphinxAtStartPar
Currently, only these Aggregators have been implemented in DCF:
\begin{itemize}
\item {} 
\sphinxAtStartPar
GnuplotAggregator

\item {} 
\sphinxAtStartPar
FileAggregator

\end{itemize}

\sphinxAtStartPar
Currently, only this Adaptor has been implemented in DCF:

\sphinxAtStartPar
Time\sphinxhyphen{}Series Adaptor.


\subsubsection{Future Work}
\label{\detokenize{scope-and-limitations:future-work}}
\sphinxAtStartPar
This section discusses the future work to be done on the Data
Collection Framework.

\sphinxAtStartPar
Here are some things that still need to be done:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Hook up more trace sources in \sphinxstyleemphasis{ns\sphinxhyphen{}3} code to get more values out of the simulator.

\item {} 
\sphinxAtStartPar
Implement more types of Probes than there currently are.

\item {} 
\sphinxAtStartPar
Implement more than just the single current 2\sphinxhyphen{}D Collector, BasicStatsCollector.

\item {} 
\sphinxAtStartPar
Implement more Aggregators.

\item {} 
\sphinxAtStartPar
Implement more than just Adaptors.

\end{itemize}

\sphinxstepscope


\section{Statistical Framework}
\label{\detokenize{statistics:statistical-framework}}\label{\detokenize{statistics::doc}}
\sphinxAtStartPar
This chapter outlines work on simulation data collection and the
statistical framework for ns\sphinxhyphen{}3.

\sphinxAtStartPar
The source code for the statistical framework lives in the directory
\sphinxcode{\sphinxupquote{src/stats}}.


\subsection{Goals}
\label{\detokenize{statistics:goals}}
\sphinxAtStartPar
Primary objectives for this effort are the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Provide functionality to record, calculate, and present data and statistics for analysis of network simulations.

\item {} 
\sphinxAtStartPar
Boost simulation performance by reducing the need to generate extensive trace logs in order to collect data.

\item {} 
\sphinxAtStartPar
Enable simulation control via online statistics, e.g. terminating simulations or repeating trials.

\end{itemize}

\sphinxAtStartPar
Derived sub\sphinxhyphen{}goals and other target features include the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Integration with the existing ns\sphinxhyphen{}3 tracing system as the basic instrumentation framework of the internal simulation engine, e.g. network stacks, net devices, and channels.

\item {} 
\sphinxAtStartPar
Enabling users to utilize the statistics framework without requiring use of the tracing system.

\item {} 
\sphinxAtStartPar
Helping users create, aggregate, and analyze data over multiple trials.

\item {} 
\sphinxAtStartPar
Support for user created instrumentation, e.g. of application specific events and measures.

\item {} 
\sphinxAtStartPar
Low memory and CPU overhead when the package is not in use.

\item {} 
\sphinxAtStartPar
Leveraging existing analysis and output tools as much as possible.  The framework may provide some basic statistics, but the focus is on collecting data and making it accessible for manipulation in established tools.

\item {} 
\sphinxAtStartPar
Eventual support for distributing independent replications is important but not included in the first round of features.

\end{itemize}


\subsection{Overview}
\label{\detokenize{statistics:overview}}
\sphinxAtStartPar
The statistics framework includes the following features:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The core framework and two basic data collectors: A counter, and a min/max/avg/total observer.

\item {} 
\sphinxAtStartPar
Extensions of those to easily work with times and packets.

\item {} 
\sphinxAtStartPar
Plaintext output formatted for \sphinxhref{http://www.omnetpp.org}{OMNet++}.

\item {} 
\sphinxAtStartPar
Database output using \sphinxhref{http://www.sqlite.org}{SQLite}, a standalone, lightweight, high performance SQL engine.

\item {} 
\sphinxAtStartPar
Mandatory and open ended metadata for describing and working with runs.

\item {} 
\sphinxAtStartPar
An example based on the notional experiment of examining the properties of NS\sphinxhyphen{}3’s default ad hoc WiFi performance.  It incorporates the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Constructs of a two node ad hoc WiFi network, with the nodes a parameterized distance apart.

\item {} 
\sphinxAtStartPar
UDP traffic source and sink applications with slightly different behavior and measurement hooks than the stock classes.

\item {} 
\sphinxAtStartPar
Data collection from the NS\sphinxhyphen{}3 core via existing trace signals, in particular data on frames transmitted and received by the WiFi MAC objects.

\item {} 
\sphinxAtStartPar
Instrumentation of custom applications by connecting new trace signals to the stat framework, as well as via direct updates.  Information is recorded about total packets sent and received, bytes transmitted, and end\sphinxhyphen{}to\sphinxhyphen{}end delay.

\item {} 
\sphinxAtStartPar
An example of using packet tags to track end\sphinxhyphen{}to\sphinxhyphen{}end delay.

\item {} 
\sphinxAtStartPar
A simple control script which runs a number of trials of the experiment at varying distances and queries the resulting database to produce a graph using GNUPlot.

\end{itemize}

\end{itemize}


\subsection{To\sphinxhyphen{}Do}
\label{\detokenize{statistics:to-do}}
\sphinxAtStartPar
High priority items include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Inclusion of online statistics code, e.g. for memory efficient confidence intervals.

\item {} 
\sphinxAtStartPar
Provisions in the data collectors for terminating runs, i.e. when a threshold or confidence is met.

\item {} 
\sphinxAtStartPar
Data collectors for logging samples over time, and output to the various formats.

\item {} 
\sphinxAtStartPar
Demonstrate writing simple cyclic event glue to regularly poll some value.

\end{itemize}

\sphinxAtStartPar
Each of those should prove straightforward to incorporate in the current framework.


\subsection{Approach}
\label{\detokenize{statistics:approach}}
\sphinxAtStartPar
The framework is based around the following core principles:
\begin{itemize}
\item {} 
\sphinxAtStartPar
One experiment trial is conducted by one instance of a simulation program, whether in parallel or serially.

\item {} 
\sphinxAtStartPar
A control script executes instances of the simulation, varying parameters as necessary.

\item {} 
\sphinxAtStartPar
Data is collected and stored for plotting and analysis using external scripts and existing tools.

\item {} 
\sphinxAtStartPar
Measures within the ns\sphinxhyphen{}3 core are taken by connecting the stat framework to existing trace signals.

\item {} 
\sphinxAtStartPar
Trace signals or direct manipulation of the framework may be used to instrument custom simulation code.

\end{itemize}

\sphinxAtStartPar
Those basic components of the framework and their interactions are depicted in the following figure.

\noindent\sphinxincludegraphics{{Stat-framework-arch}.png}


\subsection{Example}
\label{\detokenize{statistics:example}}
\sphinxAtStartPar
This section goes through the process of constructing an experiment in the framework and producing data for analysis (graphs) from it, demonstrating the structure and API along the way.


\subsubsection{Question}
\label{\detokenize{statistics:question}}
\sphinxAtStartPar
‘’What is the (simulated) performance of ns\sphinxhyphen{}3’s WiFi NetDevices (using the default settings)?  How far apart can wireless nodes be in a simulation before they cannot communicate reliably?’’
\begin{itemize}
\item {} 
\sphinxAtStartPar
Hypothesis: Based on knowledge of real life performance, the nodes should communicate reasonably well to at least 100m apart.  Communication beyond 200m shouldn’t be feasible.

\end{itemize}

\sphinxAtStartPar
Although not a very common question in simulation contexts, this is an important property of which simulation developers should have a basic understanding.  It is also a common study done on live hardware.


\subsubsection{Simulation Program}
\label{\detokenize{statistics:simulation-program}}
\sphinxAtStartPar
The first thing to do in implementing this experiment is developing the simulation program.  The code for this example can be found in \sphinxcode{\sphinxupquote{examples/stats/wifi\sphinxhyphen{}example\sphinxhyphen{}sim.cc}}.  It does the following main steps.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Declaring parameters and parsing the command line using \sphinxcode{\sphinxupquote{ns3::CommandLine}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{distance}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{50.0}\PYG{p}{;}
\PYG{n}{string}\PYG{+w}{ }\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OMNet++}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string}\PYG{+w}{ }\PYG{n}{experiment}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wifi\PYGZhy{}distance\PYGZhy{}test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string}\PYG{+w}{ }\PYG{n}{strategy}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wifi\PYGZhy{}default}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string}\PYG{+w}{ }\PYG{n}{runID}\PYG{p}{;}

\PYG{n}{CommandLine}\PYG{+w}{ }\PYG{n+nf}{cmd}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}FILE\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{distance}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{   }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Distance apart to place nodes(in meters).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{distance}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{format}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{     }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Format to use for data output.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{             }\PYG{n}{format}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{experiment}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Identifier for experiment.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{                 }\PYG{n}{experiment}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{strategy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{   }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Identifier for strategy.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{                   }\PYG{n}{strategy}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{run}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{        }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Identifier for run.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{                        }\PYG{n}{runID}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Creating nodes and network stacks using \sphinxcode{\sphinxupquote{ns3::NodeContainer}}, \sphinxcode{\sphinxupquote{ns3::WiFiHelper}}, and \sphinxcode{\sphinxupquote{ns3::InternetStackHelper}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{;}
\PYG{n}{nodes}\PYG{p}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{WifiHelper}\PYG{+w}{ }\PYG{n}{wifi}\PYG{p}{;}
\PYG{n}{wifi}\PYG{p}{.}\PYG{n}{SetMac}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::AdhocWifiMac}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wifi}\PYG{p}{.}\PYG{n}{SetPhy}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::WifiPhy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NetDeviceContainer}\PYG{+w}{ }\PYG{n}{nodeDevices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{wifi}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{InternetStackHelper}\PYG{+w}{ }\PYG{n}{internet}\PYG{p}{;}
\PYG{n}{internet}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4AddressHelper}\PYG{+w}{ }\PYG{n}{ipAddrs}\PYG{p}{;}
\PYG{n}{ipAddrs}\PYG{p}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{192.168.0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ipAddrs}\PYG{p}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{nodeDevices}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Positioning the nodes using \sphinxcode{\sphinxupquote{ns3::MobilityHelper}}.  By default the nodes have static mobility and won’t move, but must be positioned the given distance apart.  There are several ways to do this; it is done here using \sphinxcode{\sphinxupquote{ns3::ListPositionAllocator}}, which draws positions from a given list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MobilityHelper}\PYG{+w}{ }\PYG{n}{mobility}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ListPositionAllocator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{positionAlloc}\PYG{+w}{ }\PYG{o}{=}
\PYG{+w}{  }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ListPositionAllocator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{positionAlloc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{positionAlloc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{distance}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mobility}\PYG{p}{.}\PYG{n}{SetPositionAllocator}\PYG{p}{(}\PYG{n}{positionAlloc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mobility}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Installing a traffic generator and a traffic sink.  The stock \sphinxcode{\sphinxupquote{Applications}} could be used, but the example includes custom objects in \sphinxcode{\sphinxupquote{src/test/test02\sphinxhyphen{}apps.(cc|h)}}.  These have a simple behavior, generating a given number of packets spaced at a given interval.  As there is only one of each they are installed manually; for a larger set the \sphinxcode{\sphinxupquote{ns3::ApplicationHelper}} class could be used.  The commented\sphinxhyphen{}out \sphinxcode{\sphinxupquote{Config::Set}} line changes the destination of the packets, set to broadcast by default in this example.  Note that in general WiFi may have different performance for broadcast and unicast frames due to different rate control and MAC retransmission policies.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{appSource}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{NodeList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetNode}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Sender}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sender}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Sender}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{appSource}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddApplication}\PYG{p}{(}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sender}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{appSink}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{NodeList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetNode}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Receiver}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{receiver}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Receiver}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{appSink}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddApplication}\PYG{p}{(}\PYG{n}{receiver}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{receiver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//  Config::Set(\PYGZdq{}/NodeList/*/ApplicationList/*/\PYGZdl{}Sender/Destination\PYGZdq{},}
\PYG{c+c1}{//              Ipv4AddressValue(\PYGZdq{}192.168.0.2\PYGZdq{}));}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Configuring the data and statistics to be collected.  The basic paradigm is that an \sphinxcode{\sphinxupquote{ns3::DataCollector}} object is created to hold information about this particular run, to which observers and calculators are attached to actually generate data.  Importantly, run information includes labels for the ‘’experiment’’, ‘’strategy’’, ‘’input’’, and ‘’run’’.  These are used to later identify and easily group data from multiple trials.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The experiment is the study of which this trial is a member.  Here it is on WiFi performance and distance.

\item {} 
\sphinxAtStartPar
The strategy is the code or parameters being examined in this trial.  In this example it is fixed, but an obvious extension would be to investigate different WiFi bit rates, each of which would be a different strategy.

\item {} 
\sphinxAtStartPar
The input is the particular problem given to this trial.  Here it is simply the distance between the two nodes.

\item {} 
\sphinxAtStartPar
The runID is a unique identifier for this trial with which it’s information is tagged for identification in later analysis.  If no run ID is given the example program makes a (weak) run ID using the current time.

\end{itemize}

\sphinxAtStartPar
Those four pieces of metadata are required, but more may be desired.  They may be added to the record using the \sphinxcode{\sphinxupquote{ns3::DataCollector::AddMetadata()}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DataCollector}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{DescribeRun}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strategy}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{input}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{runID}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{AddMetadata}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{author}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tjkopena}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Actual observation and calculating is done by \sphinxcode{\sphinxupquote{ns3::DataCalculator}} objects, of which several different types exist.  These are created by the simulation program, attached to reporting or sampling code, and then registered with the \sphinxcode{\sphinxupquote{ns3::DataCollector}} so they will be queried later for their output.  One easy observation mechanism is to use existing trace sources, for example to instrument objects in the ns\sphinxhyphen{}3 core without changing their code.  Here a counter is attached directly to a trace signal in the WiFi MAC layer on the target node.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PacketCounterCalculator}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{totalRx}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{PacketCounterCalculator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{totalRx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetKey}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wifi\PYGZhy{}rx\PYGZhy{}frames}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Connect}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/1/DeviceList/*/\PYGZdl{}ns3::WifiNetDevice/Rx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                }\PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{PacketCounterCalculator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FrameUpdate}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{totalRx}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{AddDataCalculator}\PYG{p}{(}\PYG{n}{totalRx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Calculators may also be manipulated directly.  In this example, a counter is created and passed to the traffic sink application to be updated when packets are received.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{CounterCalculator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{appRx}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{CounterCalculator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{appRx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetKey}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{receiver\PYGZhy{}rx\PYGZhy{}packets}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{receiver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetCounter}\PYG{p}{(}\PYG{n}{appRx}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{AddDataCalculator}\PYG{p}{(}\PYG{n}{appRx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To increment the count, the sink’s packet processing code then calls one of the calculator’s update methods.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}calc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Update}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The program includes several other examples as well, using both the primitive calculators such as \sphinxcode{\sphinxupquote{ns3::CounterCalculator}} and those adapted for observing packets and times.  In \sphinxcode{\sphinxupquote{src/test/test02\sphinxhyphen{}apps.(cc|h)}} it also creates a simple custom tag which it uses to track end\sphinxhyphen{}to\sphinxhyphen{}end delay for generated packets, reporting results to a \sphinxcode{\sphinxupquote{ns3::TimeMinMaxAvgTotalCalculator}} data calculator.

\item {} 
\sphinxAtStartPar
Running the simulation, which is very straightforward once constructed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Generating either \sphinxhref{http://www.omnetpp.org}{OMNet++} or \sphinxhref{http://www.sqlite.org}{SQLite} output, depending on the command line arguments.  To do this a \sphinxcode{\sphinxupquote{ns3::DataOutputInterface}} object is created and configured.  The specific type of this will determine the output format.  This object is then given the \sphinxcode{\sphinxupquote{ns3::DataCollector}} object which it interrogates to produce the output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DataOutputInterface}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{output}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{format}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OMNet++}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating OMNet++ formatted data output.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{output}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{OmnetDataOutput}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{   ifdef STAT\PYGZus{}USE\PYGZus{}DB}
\PYG{+w}{    }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating SQLite formatted data output.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{output}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{SqliteDataOutput}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{   endif}
\PYG{p}{\PYGZcb{}}

\PYG{n}{output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Output}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Freeing any memory used by the simulation.  This should come at the end of the main function for the example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\paragraph{Logging}
\label{\detokenize{statistics:logging}}
\sphinxAtStartPar
To see what the example program, applications, and stat framework are doing in detail, set the \sphinxcode{\sphinxupquote{NS\_LOG}} variable appropriately.  The following will provide copious output from all three.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{export}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}WiFiDistanceExperiment:WiFiDistanceApps
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this slows down the simulation extraordinarily.


\paragraph{Sample Output}
\label{\detokenize{statistics:sample-output}}
\sphinxAtStartPar
Compiling and simply running the test program will append \sphinxhref{http://www.omnetpp.org}{OMNet++} formatted output such as the following to \sphinxcode{\sphinxupquote{data.sca}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
run run\PYGZhy{}1212239121

attr experiment \PYGZdq{}wifi\PYGZhy{}distance\PYGZhy{}test\PYGZdq{}
attr strategy \PYGZdq{}wifi\PYGZhy{}default\PYGZdq{}
attr input \PYGZdq{}50\PYGZdq{}
attr description \PYGZdq{}\PYGZdq{}

attr \PYGZdq{}author\PYGZdq{} \PYGZdq{}tjkopena\PYGZdq{}

scalar wifi\PYGZhy{}tx\PYGZhy{}frames count 30
scalar wifi\PYGZhy{}rx\PYGZhy{}frames count 30
scalar sender\PYGZhy{}tx\PYGZhy{}packets count 30
scalar receiver\PYGZhy{}rx\PYGZhy{}packets count 30
scalar tx\PYGZhy{}pkt\PYGZhy{}size count 30
scalar tx\PYGZhy{}pkt\PYGZhy{}size total 1920
scalar tx\PYGZhy{}pkt\PYGZhy{}size average 64
scalar tx\PYGZhy{}pkt\PYGZhy{}size max 64
scalar tx\PYGZhy{}pkt\PYGZhy{}size min 64
scalar delay count 30
scalar delay total 5884980ns
scalar delay average 196166ns
scalar delay max 196166ns
scalar delay min 196166ns
\end{sphinxVerbatim}


\subsubsection{Control Script}
\label{\detokenize{statistics:control-script}}
\sphinxAtStartPar
In order to automate data collection at a variety of inputs (distances), a simple Bash script is used to execute a series of simulations.  It can be found at \sphinxcode{\sphinxupquote{examples/stats/wifi\sphinxhyphen{}example\sphinxhyphen{}db.sh}}.  The script is meant to be run from the \sphinxcode{\sphinxupquote{examples/stats/}} directory.

\sphinxAtStartPar
The script runs through a set of distances, collecting the results into an \sphinxhref{http://www.sqlite.org}{SQLite} database.  At each distance five trials are conducted to give a better picture of expected performance.  The entire experiment takes only a few dozen seconds to run on a low end machine as there is no output during the simulation and little traffic is generated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}

\PYG{n+nv}{DISTANCES}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}25 50 75 100 125 145 147 150 152 155 157 160 162 165 167 170 172 175 177 180\PYGZdq{}}
\PYG{n+nv}{TRIALS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}1 2 3 4 5\PYGZdq{}}

\PYG{n+nb}{echo}\PYG{+w}{ }WiFi\PYG{+w}{ }Experiment\PYG{+w}{ }Example

\PYG{k}{if}\PYG{+w}{ }\PYG{o}{[}\PYG{+w}{ }\PYGZhy{}e\PYG{+w}{ }data.db\PYG{+w}{ }\PYG{o}{]}
\PYG{k}{then}
\PYG{+w}{  }\PYG{n+nb}{echo}\PYG{+w}{ }Kill\PYG{+w}{ }data.db?
\PYG{+w}{  }\PYG{n+nb}{read}\PYG{+w}{ }ANS
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{o}{[}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}ANS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}yes\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}o\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}ANS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}y\PYGZdq{}}\PYG{+w}{ }\PYG{o}{]}
\PYG{+w}{  }\PYG{k}{then}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }Deleting\PYG{+w}{ }database
\PYG{+w}{    }rm\PYG{+w}{ }data.db
\PYG{+w}{  }\PYG{k}{fi}
\PYG{k}{fi}

\PYG{k}{for}\PYG{+w}{ }trial\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}TRIALS}
\PYG{k}{do}
\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }distance\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}DISTANCES}
\PYG{+w}{  }\PYG{k}{do}
\PYG{+w}{    }\PYG{n+nb}{echo}\PYG{+w}{ }Trial\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}trial},\PYG{+w}{ }distance\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}distance}
\PYG{+w}{    }./bin/test02\PYG{+w}{ }\PYGZhy{}\PYGZhy{}format\PYG{o}{=}db\PYG{+w}{ }\PYGZhy{}\PYGZhy{}distance\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}distance}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}run\PYG{o}{=}run\PYGZhy{}\PYG{n+nv}{\PYGZdl{}distance}\PYGZhy{}\PYG{n+nv}{\PYGZdl{}trial}
\PYG{+w}{  }\PYG{k}{done}
\PYG{k}{done}
\end{sphinxVerbatim}


\subsubsection{Analysis and Conclusion}
\label{\detokenize{statistics:analysis-and-conclusion}}
\sphinxAtStartPar
Once all trials have been conducted, the script executes a simple SQL query over the database using the \sphinxhref{http://www.sqlite.org}{SQLite} command line program.  The query computes average packet loss in each set of trials associated with each distance.  It does not take into account different strategies, but the information is present in the database to make some simple extensions and do so.  The collected data is then passed to GNUPlot for graphing.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMD}\PYG{o}{=}\PYG{l+s+ss}{\PYGZdq{}select exp.input,avg(100\PYGZhy{}((rx.value*100)/tx.value)) \PYGZbs{}}
\PYG{l+s+ss}{    from Singletons rx, Singletons tx, Experiments exp \PYGZbs{}}
\PYG{l+s+ss}{    where rx.run = tx.run AND \PYGZbs{}}
\PYG{l+s+ss}{          rx.run = exp.run AND \PYGZbs{}}
\PYG{l+s+ss}{          rx.name=\PYGZsq{}receiver\PYGZhy{}rx\PYGZhy{}packets\PYGZsq{} AND \PYGZbs{}}
\PYG{l+s+ss}{          tx.name=\PYGZsq{}sender\PYGZhy{}tx\PYGZhy{}packets\PYGZsq{} \PYGZbs{}}
\PYG{l+s+ss}{    group by exp.input \PYGZbs{}}
\PYG{l+s+ss}{    order by abs(exp.input) ASC;\PYGZdq{}}

\PYG{n}{sqlite3}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{noheader}\PYG{+w}{ }\PYG{k}{data}\PYG{p}{.}\PYG{n}{db}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}\PYGZdl{}CMD\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{wifi}\PYG{o}{\PYGZhy{}}\PYG{k}{default}\PYG{p}{.}\PYG{k}{data}
\PYG{n}{sed}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}s/|/   /\PYGZdq{}}\PYG{+w}{ }\PYG{n}{wifi}\PYG{o}{\PYGZhy{}}\PYG{k}{default}\PYG{p}{.}\PYG{k}{data}
\PYG{n}{gnuplot}\PYG{+w}{ }\PYG{n}{wifi}\PYG{o}{\PYGZhy{}}\PYG{n}{example}\PYG{p}{.}\PYG{n}{gnuplot}
\end{sphinxVerbatim}

\sphinxAtStartPar
The GNUPlot script found at \sphinxcode{\sphinxupquote{examples/stats/wifi\sphinxhyphen{}example.gnuplot}} simply defines the output format and some basic formatting for the graph.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{+w}{ }terminal\PYG{+w}{ }postscript\PYG{+w}{ }portrait\PYG{+w}{ }enhanced\PYG{+w}{ }lw\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Helvetica\PYGZdq{}}\PYG{+w}{ }\PYG{l+m}{14}

\PYG{n+nb}{set}\PYG{+w}{ }size\PYG{+w}{ }\PYG{l+m}{1}.0,\PYG{+w}{ }\PYG{l+m}{0}.66

\PYG{c+c1}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nb}{set}\PYG{+w}{ }out\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}wifi\PYGZhy{}default.eps\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}set title \PYGZdq{}Packet Loss Over Distance\PYGZdq{}}
\PYG{n+nb}{set}\PYG{+w}{ }xlabel\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Distance (m) \PYGZhy{}\PYGZhy{}\PYGZhy{} average of 5 trials per point\PYGZdq{}}
\PYG{n+nb}{set}\PYG{+w}{ }xrange\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{0}:200\PYG{o}{]}
\PYG{n+nb}{set}\PYG{+w}{ }ylabel\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{} Packet Loss\PYGZdq{}}
\PYG{n+nb}{set}\PYG{+w}{ }yrange\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{0}:110\PYG{o}{]}

plot\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}wifi\PYGZhy{}default.data\PYGZdq{}}\PYG{+w}{ }with\PYG{+w}{ }lines\PYG{+w}{ }title\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}WiFi Defaults\PYGZdq{}}
\end{sphinxVerbatim}


\paragraph{End Result}
\label{\detokenize{statistics:end-result}}
\sphinxAtStartPar
The resulting graph provides no evidence that the default WiFi model’s performance is necessarily unreasonable and lends some confidence to an at least token faithfulness to reality.  More importantly, this simple investigation has been carried all the way through using the statistical framework.  Success!

\noindent\sphinxincludegraphics{{Wifi-default}.png}

\sphinxstepscope


\section{Helpers}
\label{\detokenize{helpers:helpers}}\label{\detokenize{helpers::doc}}
\sphinxAtStartPar
The above chapters introduced you to various \sphinxstyleemphasis{ns\sphinxhyphen{}3} programming concepts such as
smart pointers for reference\sphinxhyphen{}counted memory management, attributes, namespaces,
callbacks, etc. Users who work at this low\sphinxhyphen{}level API can interconnect \sphinxstyleemphasis{ns\sphinxhyphen{}3}
objects with fine granularity. However, a simulation program written entirely
using the low\sphinxhyphen{}level API would be quite long and tedious to code. For this
reason, a separate so\sphinxhyphen{}called “helper API” has been overlaid on the core \sphinxstyleemphasis{ns\sphinxhyphen{}3}
API. If you have read the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tutorial, you will already be familiar with the
helper API, since it is the API that new users are typically introduced to
first.  In this chapter, we introduce the design philosophy of the helper API
and contrast it to the low\sphinxhyphen{}level API. If you become a heavy user of \sphinxstyleemphasis{ns\sphinxhyphen{}3}, you
will likely move back and forth between these APIs even in the same program.

\sphinxAtStartPar
The helper API has a few goals:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the rest of \sphinxcode{\sphinxupquote{src/}} has no dependencies on the helper API; anything that can
be done with the helper API can be coded also at the low\sphinxhyphen{}level API

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Containers:} Often simulations will need to do a number of identical
actions to groups of objects. The helper API makes heavy use of containers of
similar objects to which similar or identical operations can be performed.

\item {} 
\sphinxAtStartPar
The helper API is not generic; it does not strive to maximize code reuse. So,
programming constructs such as polymorphism and templates that achieve code
reuse are not as prevalent. For instance, there are separate CsmaNetDevice
helpers and PointToPointNetDevice helpers but they do not derive from a
common NetDevice base class.

\item {} 
\sphinxAtStartPar
The helper API typically works with stack\sphinxhyphen{}allocated (vs. heap\sphinxhyphen{}allocated)
objects. For some programs, \sphinxstyleemphasis{ns\sphinxhyphen{}3} users may not need to worry about any low
level Object Create or Ptr handling; they can make do with containers of
objects and stack\sphinxhyphen{}allocated helpers that operate on them.

\end{enumerate}

\sphinxAtStartPar
The helper API is really all about making \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs easier to write and
read, without taking away the power of the low\sphinxhyphen{}level interface. The rest of this
chapter provides some examples of the programming conventions of the helper API.

\sphinxstepscope


\section{Making Plots using the Gnuplot Class}
\label{\detokenize{gnuplot:making-plots-using-the-gnuplot-class}}\label{\detokenize{gnuplot::doc}}
\sphinxAtStartPar
There are 2 common methods to make a plot using \sphinxstyleemphasis{ns\sphinxhyphen{}3} and gnuplot (\sphinxurl{http://www.gnuplot.info}):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Create a gnuplot control file using \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class.

\item {} 
\sphinxAtStartPar
Create a gnuplot data file using values generated by \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\end{enumerate}

\sphinxAtStartPar
This section is about method 1, i.e. it is about how to make a plot using \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class.  If you are interested in method 2, see the “A Real Example” subsection under the “Tracing” section in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxhref{https://www.nsnam.org/docs/tutorial/html/index.html}{Tutorial}.


\subsection{Creating Plots Using the Gnuplot Class}
\label{\detokenize{gnuplot:creating-plots-using-the-gnuplot-class}}
\sphinxAtStartPar
The following steps must be taken in order to create a plot using \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Modify your code so that is uses the Gnuplot class and its functions.

\item {} 
\sphinxAtStartPar
Run your code so that it creates a gnuplot control file.

\item {} 
\sphinxAtStartPar
Call gnuplot with the name of the gnuplot control file.

\item {} 
\sphinxAtStartPar
View the graphics file that was produced in your favorite graphics viewer.

\end{enumerate}

\sphinxAtStartPar
See the code from the example plots that are discussed below for details on step 1.


\subsection{An Example Program that Uses the Gnuplot Class}
\label{\detokenize{gnuplot:an-example-program-that-uses-the-gnuplot-class}}
\sphinxAtStartPar
An example program that uses \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class can be found here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src/stats/examples/gnuplot\PYGZhy{}example.cc
\end{sphinxVerbatim}

\sphinxAtStartPar
In order to run this example, do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }src/stats/examples/gnuplot\PYGZhy{}example
\end{sphinxVerbatim}

\sphinxAtStartPar
This should produce the following gnuplot control files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plot\PYGZhy{}2d.plt
plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.plt
plot\PYGZhy{}3d.plt
\end{sphinxVerbatim}

\sphinxAtStartPar
In order to process these gnuplot control files, do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }gnuplot\PYG{+w}{ }plot\PYGZhy{}2d.plt
\PYGZdl{}\PYG{+w}{ }gnuplot\PYG{+w}{ }plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.plt
\PYGZdl{}\PYG{+w}{ }gnuplot\PYG{+w}{ }plot\PYGZhy{}3d.plt
\end{sphinxVerbatim}

\sphinxAtStartPar
This should produce the following graphics files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plot\PYGZhy{}2d.png
plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.png
plot\PYGZhy{}3d.png
\end{sphinxVerbatim}

\sphinxAtStartPar
You can view these graphics files in your favorite graphics viewer.  If you have gimp installed on your machine, for example, you can do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }gimp\PYG{+w}{ }plot\PYGZhy{}2d.png
\PYGZdl{}\PYG{+w}{ }gimp\PYG{+w}{ }plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.png
\PYGZdl{}\PYG{+w}{ }gimp\PYG{+w}{ }plot\PYGZhy{}3d.png
\end{sphinxVerbatim}


\subsection{An Example 2\sphinxhyphen{}Dimensional Plot}
\label{\detokenize{gnuplot:an-example-2-dimensional-plot}}
\sphinxAtStartPar
The following 2\sphinxhyphen{}Dimensional plot

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{plot-2d}.png}
\end{figure}

\sphinxAtStartPar
was created using the following code from gnuplot\sphinxhyphen{}example.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZhy{}2d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{graphicsFileName}\PYG{+w}{        }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotFileName}\PYG{+w}{            }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotTitle}\PYG{+w}{               }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Plot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{dataTitle}\PYG{+w}{               }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the plot and set its title.}
\PYG{n}{Gnuplot}\PYG{+w}{ }\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{graphicsFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the graphics file, which the plot file will create when it}
\PYG{c+c1}{// is used with Gnuplot, be a PNG file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTerminal}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for each axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetLegend}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{X Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the range for the x axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xrange [\PYGZhy{}6:+6]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the dataset, set its title, and make the points be}
\PYG{c+c1}{// plotted along with connecting lines.}
\PYG{n}{Gnuplot2dDataset}\PYG{+w}{ }\PYG{n}{dataset}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{dataTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetStyle}\PYG{p}{(}\PYG{n}{Gnuplot2dDataset}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LINES\PYGZus{}POINTS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}

\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
\PYG{+w}{    }\PYG{c+c1}{//}
\PYG{+w}{    }\PYG{c+c1}{//            2}
\PYG{+w}{    }\PYG{c+c1}{//     y  =  x   .}
\PYG{+w}{    }\PYG{c+c1}{//}
\PYG{+w}{    }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Add this point.}
\PYG{+w}{    }\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Add the dataset to the plot.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AddDataset}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Open the plot file.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{+w}{ }\PYG{n+nf}{plotFile}\PYG{p}{(}\PYG{n}{plotFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the plot file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{GenerateOutput}\PYG{p}{(}\PYG{n}{plotFile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Close the plot file.}
\PYG{n}{plotFile}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{An Example 2\sphinxhyphen{}Dimensional Plot with Error Bars}
\label{\detokenize{gnuplot:an-example-2-dimensional-plot-with-error-bars}}
\sphinxAtStartPar
The following 2\sphinxhyphen{}Dimensional plot with error bars in the x and y directions

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{plot-2d-with-error-bars}.png}
\end{figure}

\sphinxAtStartPar
was created using the following code from gnuplot\sphinxhyphen{}example.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{graphicsFileName}\PYG{+w}{        }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotFileName}\PYG{+w}{            }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotTitle}\PYG{+w}{               }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Plot With Error Bars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{dataTitle}\PYG{+w}{               }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Data With Error Bars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the plot and set its title.}
\PYG{n}{Gnuplot}\PYG{+w}{ }\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{graphicsFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the graphics file, which the plot file will create when it}
\PYG{c+c1}{// is used with Gnuplot, be a PNG file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTerminal}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for each axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetLegend}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{X Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the range for the x axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xrange [\PYGZhy{}6:+6]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the dataset, set its title, and make the points be}
\PYG{c+c1}{// plotted with no connecting lines.}
\PYG{n}{Gnuplot2dDataset}\PYG{+w}{ }\PYG{n}{dataset}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{dataTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetStyle}\PYG{p}{(}\PYG{n}{Gnuplot2dDataset}\PYG{o}{:}\PYG{o}{:}\PYG{n}{POINTS}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the dataset have error bars in both the x and y directions.}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetErrorBars}\PYG{p}{(}\PYG{n}{Gnuplot2dDataset}\PYG{o}{:}\PYG{o}{:}\PYG{n}{XY}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{xErrorDelta}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{yErrorDelta}\PYG{p}{;}

\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
\PYG{+w}{    }\PYG{c+c1}{//}
\PYG{+w}{    }\PYG{c+c1}{//            2}
\PYG{+w}{    }\PYG{c+c1}{//     y  =  x   .}
\PYG{+w}{    }\PYG{c+c1}{//}
\PYG{+w}{    }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Make the uncertainty in the x direction be constant and make}
\PYG{+w}{    }\PYG{c+c1}{// the uncertainty in the y direction be a constant fraction of}
\PYG{+w}{    }\PYG{c+c1}{// y\PYGZsq{}s value.}
\PYG{+w}{    }\PYG{n}{xErrorDelta}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{yErrorDelta}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{0.1}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// Add this point with uncertainties in both the x and y}
\PYG{+w}{    }\PYG{c+c1}{// direction.}
\PYG{+w}{    }\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{xErrorDelta}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{yErrorDelta}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Add the dataset to the plot.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AddDataset}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Open the plot file.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{+w}{ }\PYG{n+nf}{plotFile}\PYG{p}{(}\PYG{n}{plotFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the plot file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{GenerateOutput}\PYG{p}{(}\PYG{n}{plotFile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Close the plot file.}
\PYG{n}{plotFile}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{An Example 3\sphinxhyphen{}Dimensional Plot}
\label{\detokenize{gnuplot:an-example-3-dimensional-plot}}
\sphinxAtStartPar
The following 3\sphinxhyphen{}Dimensional plot

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{plot-3d}.png}
\end{figure}

\sphinxAtStartPar
was created using the following code from gnuplot\sphinxhyphen{}example.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZhy{}3d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{graphicsFileName}\PYG{+w}{        }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotFileName}\PYG{+w}{            }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fileNameWithNoExtension}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{plotTitle}\PYG{+w}{               }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3\PYGZhy{}D Plot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{dataTitle}\PYG{+w}{               }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3\PYGZhy{}D Data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the plot and set its title.}
\PYG{n}{Gnuplot}\PYG{+w}{ }\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{graphicsFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the graphics file, which the plot file will create when it}
\PYG{c+c1}{// is used with Gnuplot, be a PNG file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTerminal}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Rotate the plot 30 degrees around the x axis and then rotate the}
\PYG{c+c1}{// plot 120 degrees around the new z axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set view 30, 120, 1.0, 1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the zero for the z\PYGZhy{}axis be in the x\PYGZhy{}axis and y\PYGZhy{}axis plane.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set ticslevel 0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for each axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xlabel \PYGZsq{}X Values\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set ylabel \PYGZsq{}Y Values\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set zlabel \PYGZsq{}Z Values\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the ranges for the x and y axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xrange [\PYGZhy{}5:+5]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set yrange [\PYGZhy{}5:+5]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the dataset, set its title, and make the points be}
\PYG{c+c1}{// connected by lines.}
\PYG{n}{Gnuplot3dDataset}\PYG{+w}{ }\PYG{n}{dataset}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetTitle}\PYG{p}{(}\PYG{n}{dataTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetStyle}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{with lines}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{;}

\PYG{c+c1}{// Create the 3\PYGZhy{}D dataset.}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{\PYGZhy{}5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// Calculate the 3\PYGZhy{}D surface}
\PYG{+w}{        }\PYG{c+c1}{//}
\PYG{+w}{        }\PYG{c+c1}{//            2      2}
\PYG{+w}{        }\PYG{c+c1}{//     z  =  x   *  y   .}
\PYG{+w}{        }\PYG{c+c1}{//}
\PYG{+w}{        }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// Add this point.}
\PYG{+w}{        }\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// The blank line is necessary at the end of each x value\PYGZsq{}s data}
\PYG{+w}{    }\PYG{c+c1}{// points for the 3\PYGZhy{}D surface grid to work.}
\PYG{+w}{    }\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{AddEmptyLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Add the dataset to the plot.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AddDataset}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Open the plot file.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{+w}{ }\PYG{n+nf}{plotFile}\PYG{p}{(}\PYG{n}{plotFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the plot file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{GenerateOutput}\PYG{p}{(}\PYG{n}{plotFile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Close the plot file.}
\PYG{n}{plotFile}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Using Python to Run \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{python:using-python-to-run-ns3}}\label{\detokenize{python::doc}}
\sphinxAtStartPar
Python bindings allow the C++ code in \sphinxstyleemphasis{ns\sphinxhyphen{}3} to be called from Python.

\sphinxAtStartPar
This chapter shows you how to create a Python script that can run \sphinxstyleemphasis{ns\sphinxhyphen{}3} and also the process of creating Python bindings for a C++ \sphinxstyleemphasis{ns\sphinxhyphen{}3} module.

\sphinxAtStartPar
Python bindings are also needed to run the Pyviz visualizer.


\subsection{Introduction}
\label{\detokenize{python:introduction}}
\sphinxAtStartPar
Python bindings provide support for importing \sphinxstyleemphasis{ns\sphinxhyphen{}3} model libraries as Python
modules.  Coverage of most of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} C++ API is provided.  The intent
has been to allow the programmer to write complete simulation scripts in
Python, to allow integration of \sphinxstyleemphasis{ns\sphinxhyphen{}3} with other Python tools and workflows.
The intent is not to provide a different language choice to author new
\sphinxstyleemphasis{ns\sphinxhyphen{}3} models implemented in Python.

\sphinxAtStartPar
As of ns\sphinxhyphen{}3.37 release or later,
Python bindings for \sphinxstyleemphasis{ns\sphinxhyphen{}3} use a tool called Cppyy (\sphinxurl{https://cppyy.readthedocs.io/en/latest/})
to create a Python module from the C++ libraries built by CMake. The Python bindings that Cppyy
uses are built at runtime, by importing the C++ libraries and headers for each \sphinxstyleemphasis{ns\sphinxhyphen{}3} module.
This means that even if the C++ API changes, the Python bindings will adapt to them
without requiring any preprocessing or scanning.

\sphinxAtStartPar
If a user is not interested in Python, no action is needed; the Python bindings
are only built on\sphinxhyphen{}demand by Cppyy, and only if the user enables them in the
configuration of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
Due to an \sphinxhref{https://github.com/wlav/cppyy/issues/150}{upstream limitation with Cppyy}, Python bindings do not work on macOS machines with Apple silicon (M1 and M2 processors).

\sphinxAtStartPar
Prior to ns\sphinxhyphen{}3.37, the previous Python bindings framework was based on
\sphinxhref{https://github.com/gjcarneiro/pybindgen}{Pybindgen}.


\subsection{An Example Python Script that Runs \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{python:an-example-python-script-that-runs-ns3}}
\sphinxAtStartPar
Here is some example code that is written in Python and that runs \sphinxstyleemphasis{ns\sphinxhyphen{}3}, which is written in C++.  This Python example can be found in \sphinxcode{\sphinxupquote{examples/tutorial/first.py}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ns} \PYG{k+kn}{import} \PYG{n}{ns}

\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LogComponentEnable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UdpEchoClientApplication}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LogComponentEnable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UdpEchoServerApplication}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}

\PYG{n}{nodes} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{NodeContainer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{nodes}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{pointToPoint} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{point\PYGZus{}to\PYGZus{}point}\PYG{o}{.}\PYG{n}{PointToPointHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pointToPoint}\PYG{o}{.}\PYG{n}{SetDeviceAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DataRate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5Mbps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pointToPoint}\PYG{o}{.}\PYG{n}{SetChannelAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Delay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2ms}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{devices} \PYG{o}{=} \PYG{n}{pointToPoint}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{stack} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{InternetStackHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{stack}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{address} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{Ipv4AddressHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{address}\PYG{o}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Address}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.1.1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Mask}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{255.255.255.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{interfaces} \PYG{o}{=} \PYG{n}{address}\PYG{o}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}

\PYG{n}{echoServer} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{applications}\PYG{o}{.}\PYG{n}{UdpEchoServerHelper}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}

\PYG{n}{serverApps} \PYG{o}{=} \PYG{n}{echoServer}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{address} \PYG{o}{=} \PYG{n}{interfaces}\PYG{o}{.}\PYG{n}{GetAddress}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ConvertTo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{echoClient} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{applications}\PYG{o}{.}\PYG{n}{UdpEchoClientHelper}\PYG{p}{(}\PYG{n}{address}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MaxPackets}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Interval}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PacketSize}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{clientApps} \PYG{o}{=} \PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clientApps}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clientApps}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Running Python Scripts}
\label{\detokenize{python:running-python-scripts}}
\sphinxAtStartPar
For users that want to change upstream modules in C++ and got a copy of
ns\sphinxhyphen{}3 by Git cloning the ns\sphinxhyphen{}3\sphinxhyphen{}dev repository, or downloaded the
ns3\sphinxhyphen{}allinone package, or is using bake, continue to the next section.

\sphinxAtStartPar
\sphinxtitleref{Note: models implemented in Python are not available from C++. If you want
your model to be available for both C++ and Python users, you must implement
it in C++.}

\sphinxAtStartPar
For users that want to exclusively run simulation scenarios and implement
simple modules in python, jump to the {\hyperref[\detokenize{python:using-the-pip-wheel}]{\sphinxcrossref{Using the pip wheel}}} section.


\subsubsection{Using the bindings from the ns\sphinxhyphen{}3 source}
\label{\detokenize{python:using-the-bindings-from-the-ns-3-source}}
\sphinxAtStartPar
The main prerequisite is to install \sphinxtitleref{cppyy}, with version no later than 2.4.2.
Depending on how you may manage
Python extensions, the installation instructions may vary, but you can first
check if it installed by seeing if the \sphinxtitleref{cppyy} module can be
successfully imported and the version is no later than 2.4.2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }python3
Python\PYG{+w}{ }\PYG{l+m}{3}.8.10\PYG{+w}{ }\PYG{o}{(}default,\PYG{+w}{ }Jun\PYG{+w}{ }\PYG{l+m}{22}\PYG{+w}{ }\PYG{l+m}{2022},\PYG{+w}{ }\PYG{l+m}{20}:18:18\PYG{o}{)}
\PYG{o}{[}GCC\PYG{+w}{ }\PYG{l+m}{9}.4.0\PYG{o}{]}\PYG{+w}{ }on\PYG{+w}{ }linux
Type\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}help\PYGZdq{}},\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}copyright\PYGZdq{}},\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}credits\PYGZdq{}}\PYG{+w}{ }or\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}license\PYGZdq{}}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }more\PYG{+w}{ }information.
\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYG{+w}{ }import\PYG{+w}{ }cppyy
\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYG{+w}{ }print\PYG{o}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}s\PYGZdq{}}\PYG{+w}{ }\PYGZpc{}\PYG{+w}{ }cppyy.\PYGZus{}\PYGZus{}version\PYG{o}{)}
\PYG{l+m}{2}.4.2
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
If not, you may try to install via \sphinxtitleref{pip} or whatever other manager you are
using; e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }python3\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}user\PYG{+w}{ }\PYG{n+nv}{cppyy}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{2}.4.2
\end{sphinxVerbatim}

\sphinxAtStartPar
First, we need to enable the build of Python bindings:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}python\PYGZhy{}bindings
\end{sphinxVerbatim}

\sphinxAtStartPar
Other options such as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}examples}} may be passed to the above command.
ns3 contains some options that automatically update the python path to find the ns3 module.
To run example programs, there are two ways to use ns3 to take care of this.  One is to run a ns3 shell; e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }shell
\PYGZdl{}\PYG{+w}{ }python3\PYG{+w}{ }examples/wireless/mixed\PYGZhy{}wired\PYGZhy{}wireless.py
\end{sphinxVerbatim}

\sphinxAtStartPar
and the other is to use the ‘run’ option to ns3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }examples/wireless/mixed\PYGZhy{}wired\PYGZhy{}wireless.py
\end{sphinxVerbatim}

\sphinxAtStartPar
Use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}build}} option to run the program without invoking a project rebuild.
This option may be useful to improve execution time when running the same program
repeatedly but with different arguments, such as from scripts.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}build\PYG{+w}{ }examples/wireless/mixed\PYGZhy{}wired\PYGZhy{}wireless.py
\end{sphinxVerbatim}

\sphinxAtStartPar
To run a python script under the C debugger:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }shell
\PYGZdl{}\PYG{+w}{ }gdb\PYG{+w}{ }\PYGZhy{}\PYGZhy{}args\PYG{+w}{ }python3\PYG{+w}{ }examples/wireless/mixed\PYGZhy{}wired\PYGZhy{}wireless.py
\end{sphinxVerbatim}

\sphinxAtStartPar
To run your own Python script that calls \sphinxstyleemphasis{ns\sphinxhyphen{}3} and that has this path, \sphinxcode{\sphinxupquote{/path/to/your/example/my\sphinxhyphen{}script.py}}, do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }shell
\PYGZdl{}\PYG{+w}{ }python3\PYG{+w}{ }/path/to/your/example/my\PYGZhy{}script.py
\end{sphinxVerbatim}


\subsubsection{Using the pip wheel}
\label{\detokenize{python:using-the-pip-wheel}}
\sphinxAtStartPar
Starting from ns\sphinxhyphen{}3.38, we provide a pip wheel for Python users using Linux.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}user\PYG{+w}{ }ns3
\end{sphinxVerbatim}

\sphinxAtStartPar
You can select a specific ns\sphinxhyphen{}3 version by specifying the wheel version.
Specifying a nonexistent version will result in an error message listing the available versions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}user\PYG{+w}{ }\PYG{n+nv}{ns3}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37
Defaulting\PYG{+w}{ }to\PYG{+w}{ }user\PYG{+w}{ }installation\PYG{+w}{ }because\PYG{+w}{ }normal\PYG{+w}{ }site\PYGZhy{}packages\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }writeable
ERROR:\PYG{+w}{ }Could\PYG{+w}{ }not\PYG{+w}{ }find\PYG{+w}{ }a\PYG{+w}{ }version\PYG{+w}{ }that\PYG{+w}{ }satisfies\PYG{+w}{ }the\PYG{+w}{ }requirement\PYG{+w}{ }\PYG{n+nv}{ns3}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37\PYG{+w}{ }\PYG{o}{(}from\PYG{+w}{ }versions:\PYG{+w}{ }\PYG{l+m}{3}.37.post415\PYG{o}{)}
ERROR:\PYG{+w}{ }No\PYG{+w}{ }matching\PYG{+w}{ }distribution\PYG{+w}{ }found\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{n+nv}{ns3}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37
\end{sphinxVerbatim}

\sphinxAtStartPar
You can also specify you want at least a specific version (e.g. which shipped a required feature).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}user\PYG{+w}{ }ns3\PYGZgt{}\PYG{o}{=}\PYG{l+m}{3}.37
Defaulting\PYG{+w}{ }to\PYG{+w}{ }user\PYG{+w}{ }installation\PYG{+w}{ }because\PYG{+w}{ }normal\PYG{+w}{ }site\PYGZhy{}packages\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }writeable
Requirement\PYG{+w}{ }already\PYG{+w}{ }satisfied:\PYG{+w}{ }\PYG{n+nv}{ns3}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37.post415\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }/home/username/.local/lib/python3.10/site\PYGZhy{}packages\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{3}.37.post415\PYG{o}{)}
Requirement\PYG{+w}{ }already\PYG{+w}{ }satisfied:\PYG{+w}{ }cppyy\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }/home/username/.local/lib/python3.10/site\PYGZhy{}packages\PYG{+w}{ }\PYG{o}{(}from\PYG{+w}{ }\PYG{n+nv}{ns3}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37.post415\PYG{o}{)}\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{2}.4.2\PYG{o}{)}
Requirement\PYG{+w}{ }already\PYG{+w}{ }satisfied:\PYG{+w}{ }cppyy\PYGZhy{}backend\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{1}.14.10\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }/home/username/.local/lib/python3.10/site\PYGZhy{}packages\PYG{+w}{ }\PYG{o}{(}from\PYG{+w}{ }cppyy\PYGZhy{}\PYGZgt{}ns3\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37.post415\PYG{o}{)}\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{1}.14.10\PYG{o}{)}
Requirement\PYG{+w}{ }already\PYG{+w}{ }satisfied:\PYG{+w}{ }\PYG{n+nv}{CPyCppyy}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{1}.12.12\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }/home/username/.local/lib/python3.10/site\PYGZhy{}packages\PYG{+w}{ }\PYG{o}{(}from\PYG{+w}{ }cppyy\PYGZhy{}\PYGZgt{}ns3\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37.post415\PYG{o}{)}\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{1}.12.12\PYG{o}{)}
Requirement\PYG{+w}{ }already\PYG{+w}{ }satisfied:\PYG{+w}{ }cppyy\PYGZhy{}cling\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{6}.27.1\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }/home/username/.local/lib/python3.10/site\PYGZhy{}packages\PYG{+w}{ }\PYG{o}{(}from\PYG{+w}{ }cppyy\PYGZhy{}\PYGZgt{}ns3\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37.post415\PYG{o}{)}\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{6}.27.1\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To check if the pip wheel was installed, use the pip freeze command to list the installed packages,
then grep ns3 to filter the line of interest.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }freeze\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }grep\PYG{+w}{ }ns3
\PYG{n+nv}{ns3}\PYG{o}{=}\PYG{o}{=}\PYG{l+m}{3}.37.post415
\end{sphinxVerbatim}

\sphinxAtStartPar
The available versions are also listed on the Pypi page for the \sphinxhref{https://pypi.org/project/ns3/\#history}{ns3 wheel}.

\sphinxAtStartPar
After installing it, you can start using ns\sphinxhyphen{}3 right away. For example, using the following script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ns} \PYG{k+kn}{import} \PYG{n}{ns}

\PYG{n}{ns}\PYG{o}{.}\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{cppdef}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{        using namespace ns3;}

\PYG{l+s+s2}{        Callback\PYGZlt{}void,Ptr\PYGZlt{}const Packet\PYGZgt{},const Address\PYGZam{},const Address\PYGZam{}\PYGZgt{}}
\PYG{l+s+s2}{        make\PYGZus{}sinktrace\PYGZus{}callback(void(*func)(Ptr\PYGZlt{}Packet\PYGZgt{},Address,Address))}
\PYG{l+s+s2}{        }\PYG{l+s+s2}{\PYGZob{}}
\PYG{l+s+s2}{            return MakeCallback(func);}
\PYG{l+s+s2}{        \PYGZcb{}}
\PYG{l+s+s2}{    }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the trace callback}
\PYG{k}{def} \PYG{n+nf}{SinkTracer}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{:} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{Packet}\PYG{p}{,} \PYG{n}{src\PYGZus{}address}\PYG{p}{:} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{,} \PYG{n}{dst\PYGZus{}address}\PYG{p}{:} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{At }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Now}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetSeconds}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{.0f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{s, }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{dst\PYGZus{}address}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ received packet}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ with }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{packet}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}deref\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetSerializedSize}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ bytes from }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{src\PYGZus{}address}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create two nodes}
\PYG{n}{csmaNodes} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{NodeContainer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{csmaNodes}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Connect the two nodes}
\PYG{n}{csma} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{csma}\PYG{o}{.}\PYG{n}{CsmaHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{csma}\PYG{o}{.}\PYG{n}{SetChannelAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DataRate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{100Mbps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{csma}\PYG{o}{.}\PYG{n}{SetChannelAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Delay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{NanoSeconds}\PYG{p}{(}\PYG{l+m+mi}{6560}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{csmaDevices} \PYG{o}{=} \PYG{n}{csma}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{csmaNodes}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Install the internet stack}
\PYG{n}{stack} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{InternetStackHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{stack}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{csmaNodes}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Assign Ipv4 addresses}
\PYG{n}{address} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{Ipv4AddressHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{address}\PYG{o}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Address}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.1.2.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Mask}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{255.255.255.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{csmaInterfaces} \PYG{o}{=} \PYG{n}{address}\PYG{o}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{csmaDevices}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Setup applications}
\PYG{n}{echoServer} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{applications}\PYG{o}{.}\PYG{n}{UdpEchoServerHelper}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}

\PYG{n}{serverApps} \PYG{o}{=} \PYG{n}{echoServer}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{csmaNodes}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{echoClient} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{applications}\PYG{o}{.}\PYG{n}{UdpEchoClientHelper}\PYG{p}{(}\PYG{n}{csmaInterfaces}\PYG{o}{.}\PYG{n}{GetAddress}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ConvertTo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MaxPackets}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Interval}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PacketSize}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{clientApps} \PYG{o}{=} \PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{csmaNodes}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clientApps}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clientApps}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Populate routing tables}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{Ipv4GlobalRoutingHelper}\PYG{o}{.}\PYG{n}{PopulateRoutingTables}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Setup the trace callback}
\PYG{n}{sinkTraceCallback} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{make\PYGZus{}sinktrace\PYGZus{}callback}\PYG{p}{(}\PYG{n}{SinkTracer}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}deref\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{TraceConnectWithoutContext}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RxWithAddresses}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sinkTraceCallback}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} Set the simulation duration to 11 seconds}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Run the simulator}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Which should print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
At\PYG{+w}{ }2s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }3s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }4s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }5s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }6s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }7s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }8s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
At\PYG{+w}{ }9s,\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}00:00:00:00:09:00:00\PYGZsq{}}\PYG{+w}{ }received\PYG{+w}{ }packet\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+m}{60}\PYG{+w}{ }bytes\PYG{+w}{ }from\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}04\PYGZhy{}07\PYGZhy{}0a:01:02:02:01:c0:00\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{Caveats}
\label{\detokenize{python:caveats}}
\sphinxAtStartPar
Some of the limitations of the Cppyy\sphinxhyphen{}based bindings are listed here.


\subsubsection{Incomplete Coverage}
\label{\detokenize{python:incomplete-coverage}}
\sphinxAtStartPar
First of all, keep in mind that not 100\% of the API is supported in Python.  Some of the reasons are:


\paragraph{Memory\sphinxhyphen{}management issues}
\label{\detokenize{python:memory-management-issues}}
\sphinxAtStartPar
Some of the APIs involve pointers, which require knowledge of what kind of memory passing semantics (who owns what memory).
Such knowledge is not part of the function signatures, and is either documented or sometimes not even documented.
You may need to workaround these issues by instantiating variables on the C++ side with a Just\sphinxhyphen{}In\sphinxhyphen{}Time (JIT) compiled function.

\sphinxAtStartPar
For example, when handling command\sphinxhyphen{}line arguments, we could set additional parameters like in the following code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the ns\PYGZhy{}3 C++ modules with Cppyy}
\PYG{k+kn}{from} \PYG{n+nn}{ns} \PYG{k+kn}{import} \PYG{n}{ns}

\PYG{c+c1}{\PYGZsh{} To pass the addresses of the Python variables to c++, we need to use ctypes}
\PYG{k+kn}{from} \PYG{n+nn}{ctypes} \PYG{k+kn}{import} \PYG{n}{c\PYGZus{}bool}\PYG{p}{,} \PYG{n}{c\PYGZus{}int}\PYG{p}{,} \PYG{n}{c\PYGZus{}double}\PYG{p}{,} \PYG{n}{c\PYGZus{}char\PYGZus{}p}\PYG{p}{,} \PYG{n}{create\PYGZus{}string\PYGZus{}buffer}
\PYG{n}{verbose} \PYG{o}{=} \PYG{n}{c\PYGZus{}bool}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{nCsma} \PYG{o}{=} \PYG{n}{c\PYGZus{}int}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{throughputKbps} \PYG{o}{=} \PYG{n}{c\PYGZus{}double}\PYG{p}{(}\PYG{l+m+mf}{3.1415}\PYG{p}{)}
\PYG{n}{BUFFLEN} \PYG{o}{=} \PYG{l+m+mi}{4096}
\PYG{n}{outputFileBuffer} \PYG{o}{=} \PYG{n}{create\PYGZus{}string\PYGZus{}buffer}\PYG{p}{(}\PYG{l+s+sa}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default\PYGZus{}output\PYGZus{}file.xml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{BUFFLEN}\PYG{p}{)}
\PYG{n}{outputFile} \PYG{o}{=} \PYG{n}{c\PYGZus{}char\PYGZus{}p}\PYG{p}{(}\PYG{n}{outputFileBuffer}\PYG{o}{.}\PYG{n}{raw}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Cppyy will transform the ctype types into the appropriate reference or raw pointers}
\PYG{n}{cmd} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{CommandLine}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}}\PYG{p}{)}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{verbose}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tell echo applications to log if true}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{verbose}\PYG{p}{)}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nCsma}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Number of extra CSMA nodes/devices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nCsma}\PYG{p}{)}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{throughputKbps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Throughput of nodes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{throughputKbps}\PYG{p}{)}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outputFile}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Output file name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{outputFile}\PYG{p}{,} \PYG{n}{BUFFLEN}\PYG{p}{)}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Printing values of the different ctypes passed as arguments post parsing}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Verbose:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nCsma:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nCsma}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{throughputKbps:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{throughputKbps}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outputFile:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{outputFile}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the variables are passed as references or raw pointers. Reassigning them on the Python side
(e.g. \sphinxcode{\sphinxupquote{verbose = verbose.value}}) can result in the Python garbage collector destroying the object
since its only reference has been overwritten, allowing the garbage collector to reclaim that memory space.
The C++ side will then have a dangling reference to the variable, which can be overwritten with
unexpected values, which can be read later, causing ns\sphinxhyphen{}3 to behave erratically due to the memory corruption.

\sphinxAtStartPar
String values are problematic since Python and C++ string lifetimes are handled differently.
To workaround that, we need to use null\sphinxhyphen{}terminated C strings (\sphinxcode{\sphinxupquote{char*}}) to exchange strings between
the bindings and ns\sphinxhyphen{}3 module libraries. However, C strings are particularly dangerous, since
overwriting the null\sphinxhyphen{}terminator can also result in memory corruption. When passing a C string, remember
to allocate a large buffer and perform bounds checking whenever possible. The CommandLine::AddValue
variant for \sphinxcode{\sphinxupquote{char*}} performs bounds checking and aborts the execution in case the parsed value
does not fit in the buffer. Make sure to pass the complete size of the buffer, including the null terminator.

\sphinxAtStartPar
There is an example below demonstrating how the memory corruption could happen in case there was
no bounds checking in CommandLine::AddValue variant for \sphinxcode{\sphinxupquote{char*}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ns} \PYG{k+kn}{import} \PYG{n}{ns}
\PYG{k+kn}{from} \PYG{n+nn}{ctypes} \PYG{k+kn}{import} \PYG{n}{c\PYGZus{}char\PYGZus{}p}\PYG{p}{,} \PYG{n}{c\PYGZus{}char}\PYG{p}{,} \PYG{n}{create\PYGZus{}string\PYGZus{}buffer}\PYG{p}{,} \PYG{n}{byref}\PYG{p}{,} \PYG{n}{cast}

\PYG{c+c1}{\PYGZsh{} The following buffer represent the memory contents}
\PYG{c+c1}{\PYGZsh{} of a program containing two adjacent C strings}
\PYG{c+c1}{\PYGZsh{} This could be the result of two subsequent variables}
\PYG{c+c1}{\PYGZsh{} on the stack or dynamically allocated}
\PYG{n}{memoryContents} \PYG{o}{=} \PYG{n}{create\PYGZus{}string\PYGZus{}buffer}\PYG{p}{(}\PYG{l+s+sa}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SHORT\PYGZus{}STRING\PYGZus{}CONTENTS}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s+sa}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DoNotWriteHere\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{l+s+sa}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{lenShortString} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s+sa}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SHORT\PYGZus{}STRING\PYGZus{}CONTENTS}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} In the next lines, we pick pointers to these two C strings}
\PYG{n}{shortStringBuffer} \PYG{o}{=} \PYG{n}{cast}\PYG{p}{(}\PYG{n}{byref}\PYG{p}{(}\PYG{n}{memoryContents}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c\PYGZus{}char\PYGZus{}p}\PYG{p}{)}
\PYG{n}{victimBuffer} \PYG{o}{=} \PYG{n}{cast}\PYG{p}{(}\PYG{n}{byref}\PYG{p}{(}\PYG{n}{memoryContents}\PYG{p}{,} \PYG{n}{lenShortString}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c\PYGZus{}char\PYGZus{}p}\PYG{p}{)}

\PYG{n}{cmd} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{CommandLine}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} in the real implementation, the buffer size of 21+1 bytes containing SHORT\PYGZus{}STRING\PYGZus{}CONTENTS\PYGZbs{}0 is passed}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shortString}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shortStringBuffer}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Memory contents before the memory corruption}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Full Memory contents}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{memoryContents}\PYG{o}{.}\PYG{n}{raw}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shortStringBuffer contents: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shortStringBuffer}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{victimBuffer contents: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{victimBuffer}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The following block should print to the terminal.}
\PYG{c+c1}{\PYGZsh{} Note that the strings are correctly}
\PYG{c+c1}{\PYGZsh{} identified due to the null terminator (\PYGZbs{}x00)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Memory contents before the memory corruption}
\PYG{c+c1}{\PYGZsh{} Full Memory contents b\PYGZsq{}SHORT\PYGZus{}STRING\PYGZus{}CONTENTS\PYGZbs{}x00DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}\PYGZbs{}x00\PYGZbs{}x00\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} shortStringBuffer size=21, contents: b\PYGZsq{}SHORT\PYGZus{}STRING\PYGZus{}CONTENTS\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} victimBuffer size=75, contents: b\PYGZsq{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Write a very long string to a small buffer of size lenShortString = 22}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}shortString=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{OkToWrite}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{*}\PYG{n}{lenShortString}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{n}{lenShortString}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CORRUPTED\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Memory contents after the memory corruption}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Full Memory contents}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{memoryContents}\PYG{o}{.}\PYG{n}{raw}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{shortStringBuffer contents: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shortStringBuffer}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{victimBuffer contents: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{victimBuffer}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The following block should print to the terminal.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Memory contents after the memory corruption}
\PYG{c+c1}{\PYGZsh{} Full Memory contents b\PYGZsq{}OkToWriteOkToWriteOkToCORRUPTED\PYGZus{}CORRUPTED\PYGZus{}CORRUPTED\PYGZus{}\PYGZbs{}x00oNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}\PYGZbs{}x00\PYGZbs{}x00\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} shortStringBuffer size=52, contents: b\PYGZsq{}OkToWriteOkToWriteOkToCORRUPTED\PYGZus{}CORRUPTED\PYGZus{}CORRUPTED\PYGZus{}\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} victimBuffer size=30, contents: b\PYGZsq{}CORRUPTED\PYGZus{}CORRUPTED\PYGZus{}CORRUPTED\PYGZus{}\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Note that shortStringBuffer invaded the victimBuffer since the}
\PYG{c+c1}{\PYGZsh{} string being written was bigger than the shortStringBuffer.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Since no bounds checks were performed, the adjacent memory got}
\PYG{c+c1}{\PYGZsh{} overwritten and both buffers are now corrupted.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} We also have a memory leak of the final block in the memory}
\PYG{c+c1}{\PYGZsh{} \PYGZsq{}oNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}DoNotWriteHere\PYGZus{}\PYGZbs{}x00\PYGZbs{}x00\PYGZsq{}, caused}
\PYG{c+c1}{\PYGZsh{} by the null terminator written at the middle of the victimBuffer.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you find a segmentation violation, be sure to wait for the stacktrace provided by Cppyy
and try to find the root cause of the issue. If you have multiple cores, the number of
stacktraces will correspond to the number of threads being executed by Cppyy. To limit them,
define the environment variable \sphinxtitleref{OPENBLAS\_NUM\_THREADS=1}.


\paragraph{Operators}
\label{\detokenize{python:operators}}
\sphinxAtStartPar
Cppyy may fail to map C++ operators due to the implementation style used by \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
This happens for the fundamental type \sphinxtitleref{Time}. To provide the expected behavior, we
redefine these operators from the Python side during the setup of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} bindings
module (\sphinxtitleref{ns\sphinxhyphen{}3\sphinxhyphen{}dev/bindings/python/ns\_\_init\_\_.py}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Redefine Time operators}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{cppdef}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{    using namespace ns3;}
\PYG{l+s+s2}{    bool Time\PYGZus{}ge(Time\PYGZam{} a, Time\PYGZam{} b)}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{ return a \PYGZgt{}= b;\PYGZcb{}}
\PYG{l+s+s2}{    bool Time\PYGZus{}eq(Time\PYGZam{} a, Time\PYGZam{} b)}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{ return a == b;\PYGZcb{}}
\PYG{l+s+s2}{    bool Time\PYGZus{}ne(Time\PYGZam{} a, Time\PYGZam{} b)}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{ return a != b;\PYGZcb{}}
\PYG{l+s+s2}{    bool Time\PYGZus{}le(Time\PYGZam{} a, Time\PYGZam{} b)}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{ return a \PYGZlt{}= b;\PYGZcb{}}
\PYG{l+s+s2}{    bool Time\PYGZus{}gt(Time\PYGZam{} a, Time\PYGZam{} b)}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{ return a \PYGZgt{} b;\PYGZcb{}}
\PYG{l+s+s2}{    bool Time\PYGZus{}lt(Time\PYGZam{} a, Time\PYGZam{} b)}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{ return a \PYGZlt{} b;\PYGZcb{}}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Time}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}ge\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{Time\PYGZus{}ge}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Time}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{Time\PYGZus{}eq}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Time}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}ne\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{Time\PYGZus{}ne}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Time}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}le\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{Time\PYGZus{}le}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Time}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}gt\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{Time\PYGZus{}gt}
\PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Time}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}lt\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{cppyy}\PYG{o}{.}\PYG{n}{gbl}\PYG{o}{.}\PYG{n}{Time\PYGZus{}lt}
\end{sphinxVerbatim}

\sphinxAtStartPar
A different operator used by \sphinxstyleemphasis{ns\sphinxhyphen{}3} is \sphinxtitleref{operator Address()}, used to
convert different types of Addresses into the generic type Address.
This is not supported by Cppyy and requires explicit conversion.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Explicitly convert the InetSocketAddress to Address using InetSocketAddress.ConvertTo()}
\PYG{n}{sink}\PYG{o}{.}\PYG{n}{Bind}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{InetSocketAddress}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Address}\PYG{o}{.}\PYG{n}{GetAny}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ConvertTo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Most of the missing APIs can be wrapped, given enough time, patience, and expertise, and will likely be wrapped if bug reports are submitted.
However, don’t file a bug report saying “bindings are incomplete”, because the project does not have maintainers to maintain every API.


\subsubsection{Tracing}
\label{\detokenize{python:tracing}}
\sphinxAtStartPar
Callback based tracing is not yet properly supported for Python, as new \sphinxstyleemphasis{ns\sphinxhyphen{}3} API needs to be provided for this to be supported.

\sphinxAtStartPar
Pcap file writing is supported via the normal API.

\sphinxAtStartPar
ASCII tracing is supported via the normal C++ API translated to Python.
However, ASCII tracing requires the creation of an ostream object to pass into the ASCII tracing methods.
In Python, the C++ std::ofstream has been minimally wrapped to allow this.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ascii} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{ofstream}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wifi\PYGZhy{}ap.tr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the file}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{YansWifiPhyHelper}\PYG{o}{.}\PYG{n}{EnableAsciiAll}\PYG{p}{(}\PYG{n}{ascii}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ascii}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} close the file}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is one caveat: you must not allow the file object to be garbage collected while \sphinxstyleemphasis{ns\sphinxhyphen{}3} is still using it.
That means that the ‘ascii’ variable above must not be allowed to go out of scope or else the program will crash.


\subsection{Working with Python Bindings}
\label{\detokenize{python:working-with-python-bindings}}

\subsubsection{Overview}
\label{\detokenize{python:overview}}
\sphinxAtStartPar
The python bindings are generated into an ‘ns’ namespace.  Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ns} \PYG{k+kn}{import} \PYG{n}{ns}
\PYG{n}{n1} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Node}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ns} \PYG{k+kn}{import}\PYG{o}{*}
\PYG{n}{n1} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Node}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The best way to explore the bindings is to look at the various example
programs provided in \sphinxstyleemphasis{ns\sphinxhyphen{}3}; some C++ examples have a corresponding Python
example.  There is no structured documentation for the Python bindings
like there is Doxygen for the C++ API, but the Doxygen can be consulted
to understand how the C++ API works.

\sphinxAtStartPar
To inspect what function and classes are available, you can use
the \sphinxcode{\sphinxupquote{dir}} function. Examples below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYG{+w}{ }print\PYG{o}{(}dir\PYG{o}{(}ns.Simulator\PYG{o}{)}\PYG{o}{)}
\PYG{o}{[}\PYG{l+s+s1}{\PYGZsq{}Cancel\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Destroy\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetContext\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetDelayLeft\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetEventCount\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetImplementation\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetMaximumSimulationTime\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetSystemId\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsExpired\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsFinished\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}NO\PYGZus{}CONTEXT\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Now\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Remove\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Run\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Schedule\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ScheduleDestroy\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ScheduleNow\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ScheduleWithContext\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}SetImplementation\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}SetScheduler\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Stop\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}assign\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}bool\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}delattr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}destruct\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dir\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dispatch\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}format\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}ge\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}getattribute\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}gt\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}hash\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}subclass\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}invert\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}le\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}lt\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}module\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}ne\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}neg\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}pos\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}python\PYGZus{}owns\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}radd\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}ex\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reshape\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rmul\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rsub\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rtruediv\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}setattr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}sizeof\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}smartptr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}sub\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}subclasshook\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}truediv\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}weakref\PYGZus{}\PYGZus{}\PYGZsq{}}\PYG{o}{]}
\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYG{+w}{ }print\PYG{o}{(}dir\PYG{o}{(}ns.DefaultSimulatorImpl\PYG{o}{)}\PYG{o}{)}
\PYG{o}{[}\PYG{l+s+s1}{\PYGZsq{}AggregateObject\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Cancel\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Destroy\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Dispose\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetAggregateIterator\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetAttribute\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetAttributeFailSafe\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetContext\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetDelayLeft\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetEventCount\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetInstanceTypeId\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetMaximumSimulationTime\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetObject\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetReferenceCount\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetSystemId\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetTypeId\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Initialize\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsExpired\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsFinished\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsInitialized\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Now\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}PreEventHook\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Ref\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Remove\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Run\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Schedule\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ScheduleDestroy\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ScheduleNow\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ScheduleWithContext\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}SetAttribute\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}SetAttributeFailSafe\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}SetScheduler\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Stop\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}TraceConnect\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}TraceConnectWithoutContext\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}TraceDisconnect\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}TraceDisconnectWithoutContext\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Unref\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}assign\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}bool\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}delattr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}destruct\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dir\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dispatch\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}format\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}ge\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}getattribute\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}gt\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}hash\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}subclass\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}invert\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}le\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}lt\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}module\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}ne\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}neg\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}pos\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}python\PYGZus{}owns\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}radd\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}ex\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reshape\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rmul\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rsub\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rtruediv\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}setattr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}sizeof\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}smartptr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}sub\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}subclasshook\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}truediv\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}weakref\PYGZus{}\PYGZus{}\PYGZsq{}}\PYG{o}{]}
\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYG{+w}{ }print\PYG{o}{(}dir\PYG{o}{(}ns.Time\PYG{o}{)}\PYG{o}{)}
\PYG{o}{[}\PYG{l+s+s1}{\PYGZsq{}AUTO\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}As\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Compare\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}D\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}FS\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}From\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}FromDouble\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}FromInteger\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetDays\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetDouble\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetFemtoSeconds\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetHours\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetInteger\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetMicroSeconds\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetMilliSeconds\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetMinutes\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetNanoSeconds\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetPicoSeconds\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetResolution\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetSeconds\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetTimeStep\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}GetYears\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}H\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsNegative\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsPositive\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsStrictlyNegative\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsStrictlyPositive\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}IsZero\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}LAST\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}MIN\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}MS\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Max\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Min\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}NS\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}PS\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}RoundTo\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}S\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}SetResolution\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}StaticInit\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}To\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ToDouble\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ToInteger\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}US\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Y\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}assign\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}bool\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}delattr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}destruct\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dir\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}dispatch\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}format\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}ge\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}getattribute\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}gt\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}hash\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}subclass\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}invert\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}le\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}lt\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}module\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}ne\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}neg\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}pos\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}python\PYGZus{}owns\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}radd\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}ex\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}reshape\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rmul\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rsub\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}rtruediv\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}setattr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}sizeof\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}smartptr\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}sub\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}subclasshook\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}truediv\PYGZus{}\PYGZus{}\PYGZsq{}},\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}weakref\PYGZus{}\PYGZus{}\PYGZsq{}}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
To get more information about expected arguments, you can use the \sphinxcode{\sphinxupquote{help}}
function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{}\PYG{+w}{ }help\PYG{o}{(}ns.DefaultSimulatorImpl\PYG{o}{)}
class\PYG{+w}{ }DefaultSimulatorImpl\PYG{o}{(}SimulatorImpl\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{  }Method\PYG{+w}{ }resolution\PYG{+w}{ }order:
\PYG{p}{|}\PYG{+w}{      }DefaultSimulatorImpl
\PYG{p}{|}\PYG{+w}{      }SimulatorImpl
\PYG{p}{|}\PYG{+w}{      }Object
\PYG{p}{|}\PYG{+w}{      }SimpleRefCount\PYGZlt{}ns3::Object,ns3::ObjectBase,ns3::ObjectDeleter\PYGZgt{}
\PYG{p}{|}\PYG{+w}{      }ObjectBase
\PYG{p}{|}\PYG{+w}{      }cppyy.gbl.CPPInstance
\PYG{p}{|}\PYG{+w}{      }builtins.object
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }Methods\PYG{+w}{ }defined\PYG{+w}{ }here:
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }Cancel\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }void\PYG{+w}{ }ns3::DefaultSimulatorImpl::Cancel\PYG{o}{(}const\PYG{+w}{ }ns3::EventId\PYG{p}{\PYGZam{}}\PYG{+w}{ }id\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }Destroy\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }void\PYG{+w}{ }ns3::DefaultSimulatorImpl::Destroy\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }GetContext\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }unsigned\PYG{+w}{ }int\PYG{+w}{ }ns3::DefaultSimulatorImpl::GetContext\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }GetDelayLeft\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }ns3::Time\PYG{+w}{ }ns3::DefaultSimulatorImpl::GetDelayLeft\PYG{o}{(}const\PYG{+w}{ }ns3::EventId\PYG{p}{\PYGZam{}}\PYG{+w}{ }id\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }GetEventCount\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }unsigned\PYG{+w}{ }long\PYG{+w}{ }ns3::DefaultSimulatorImpl::GetEventCount\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }GetMaximumSimulationTime\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }ns3::Time\PYG{+w}{ }ns3::DefaultSimulatorImpl::GetMaximumSimulationTime\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }GetSystemId\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }unsigned\PYG{+w}{ }int\PYG{+w}{ }ns3::DefaultSimulatorImpl::GetSystemId\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }GetTypeId\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }static\PYG{+w}{ }ns3::TypeId\PYG{+w}{ }ns3::DefaultSimulatorImpl::GetTypeId\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }IsExpired\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }bool\PYG{+w}{ }ns3::DefaultSimulatorImpl::IsExpired\PYG{o}{(}const\PYG{+w}{ }ns3::EventId\PYG{p}{\PYGZam{}}\PYG{+w}{ }id\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }IsFinished\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }bool\PYG{+w}{ }ns3::DefaultSimulatorImpl::IsFinished\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }Now\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }ns3::Time\PYG{+w}{ }ns3::DefaultSimulatorImpl::Now\PYG{o}{(}\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }Remove\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }void\PYG{+w}{ }ns3::DefaultSimulatorImpl::Remove\PYG{o}{(}const\PYG{+w}{ }ns3::EventId\PYG{p}{\PYGZam{}}\PYG{+w}{ }id\PYG{o}{)}
\PYG{p}{|}
\PYG{p}{|}\PYG{+w}{  }Run\PYG{o}{(}...\PYG{o}{)}
\PYG{p}{|}\PYG{+w}{      }void\PYG{+w}{ }ns3::DefaultSimulatorImpl::Run\PYG{o}{(}\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{Pip wheel packaging}
\label{\detokenize{python:pip-wheel-packaging}}
\sphinxAtStartPar
This section is meant exclusively for ns\sphinxhyphen{}3 maintainers and ns\sphinxhyphen{}3
users that want to redistribute their work as wheels for python.

\sphinxAtStartPar
The packaging process is defined in the following GitLab job.
The job is split into blocks explained below.

\sphinxAtStartPar
The manylinux image provides an old glibc compatible with most modern Linux
distributions, resulting on a pip wheel that is compatible across distributions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{.manylinux\PYGZhy{}pip\PYGZhy{}wheel}\PYG{p}{:}
\PYG{+w}{  }\PYG{n+nt}{image}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{quay.io/pypa/manylinux\PYGZus{}2\PYGZus{}28\PYGZus{}x86\PYGZus{}64}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then we install the required toolchain and dependencies necessary for both
ns\sphinxhyphen{}3 (e.g. libxml2, gsl, sqlite, gtk, etc) and for the bindings and packaging
(e.g. setuptools, wheel, auditwheel, cmake\sphinxhyphen{}build\sphinxhyphen{}extension, cppyy).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Install minimal toolchain}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{yum}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{install}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}y}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{libxml2\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{gsl\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{sqlite\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{gtk3\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{boost\PYGZhy{}devel}
\PYG{c+c1}{\PYGZsh{} Create Python venv}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{venv}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./venv}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{.}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./venv/bin/activate}
\PYG{c+c1}{\PYGZsh{} Upgrade the pip version to reuse the pre\PYGZhy{}build cppyy}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{pip}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{install}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{pip}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}\PYGZhy{}upgrade}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{pip}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{install}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{setuptools}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{setuptools\PYGZus{}scm}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}\PYGZhy{}upgrade}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{pip}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{install}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{wheel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{auditwheel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{cmake\PYGZhy{}build\PYGZhy{}extension}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{cppyy}
\end{sphinxVerbatim}

\sphinxAtStartPar
The project is then configured loading the configuration settings defined
in the \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/setup.py}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Configure and build wheel}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{setup.py}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{bdist\PYGZus{}wheel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{build\PYGZus{}ext}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdq{}\PYGZhy{}DNS3\PYGZus{}USE\PYGZus{}LIB64=TRUE\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, we have a wheel that only works in the current system,
since external libraries are not shipped.

\sphinxAtStartPar
Auditwheel needs to be called resolve and copy external libraries
that we need to ship along the ns\sphinxhyphen{}3 module libraries (e.g. libxml2, sqlite3,
gtk, gsl, etc). However, we need to prevent auditwheel from shipping copies of
the libraries built by the ns\sphinxhyphen{}3 project. A list of excluded libraries is generated
by the script \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/build\sphinxhyphen{}support/pip\sphinxhyphen{}wheel/auditwheel\sphinxhyphen{}exclude\sphinxhyphen{}list.py}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{export}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{EXCLUDE\PYGZus{}INTERNAL\PYGZus{}LIBRARIES=`\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./build\PYGZhy{}support/pip\PYGZhy{}wheel/auditwheel\PYGZhy{}exclude\PYGZhy{}list.py`}
\PYG{c+c1}{\PYGZsh{} Bundle in shared libraries that were not explicitly packaged or depended upon}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{auditwheel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{repair}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./dist/*whl}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}L}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{/lib64}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}EXCLUDE\PYGZus{}INTERNAL\PYGZus{}LIBRARIES}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, we should have our final wheel ready, but we need to check if it works
before submitting it to Pypi servers.

\sphinxAtStartPar
We first clean the environment and uninstall the packages previously installed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Clean the build directory}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./ns3}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{clean}
\PYG{c+c1}{\PYGZsh{} Clean up the environment}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{deactivate}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{rm}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}R}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./venv}
\PYG{c+c1}{\PYGZsh{} Delete toolchain to check if required headers/libraries were really packaged}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{yum}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{remove}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}y}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{libxml2\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{gsl\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{sqlite\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{gtk3\PYGZhy{}devel}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{boost\PYGZhy{}devel}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then we can install our newly built wheel and test it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Install wheel}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{pip}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{install}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./wheelhouse/*whl}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}m}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{pip}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{install}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{matplotlib}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{numpy}
\PYG{c+c1}{\PYGZsh{} Test the bindings}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./utils/python\PYGZhy{}unit\PYGZhy{}tests.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/realtime/realtime\PYGZhy{}udp\PYGZhy{}echo.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/routing/simple\PYGZhy{}routing\PYGZhy{}ping6.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/tutorial/first.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/tutorial/second.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/tutorial/third.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/wireless/wifi\PYGZhy{}ap.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./examples/wireless/mixed\PYGZhy{}wired\PYGZhy{}wireless.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/bridge/examples/csma\PYGZhy{}bridge.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/brite/examples/brite\PYGZhy{}generic\PYGZhy{}example.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/core/examples/sample\PYGZhy{}simulator.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/core/examples/sample\PYGZhy{}rng\PYGZhy{}plot.py}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZhy{}\PYGZhy{}not\PYGZhy{}blocking}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/click/examples/nsclick\PYGZhy{}simple\PYGZhy{}lan.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/flow\PYGZhy{}monitor/examples/wifi\PYGZhy{}olsr\PYGZhy{}flowmon.py}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/flow\PYGZhy{}monitor/examples/flowmon\PYGZhy{}parse\PYGZhy{}results.py}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{output.xml}
\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{\PYGZdl{}PYTHON}\PYG{l+lScalar+lScalarPlain}{ }\PYG{l+lScalar+lScalarPlain}{./src/openflow/examples/openflow\PYGZhy{}switch.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
If all programs finish normally, the bindings are working as expected,
and will be saved as an artifact.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{artifacts}\PYG{p}{:}
\PYG{+w}{  }\PYG{n+nt}{paths}\PYG{p}{:}
\PYG{+w}{    }\PYG{p+pIndicator}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{wheelhouse/*.whl}
\end{sphinxVerbatim}

\sphinxAtStartPar
One can use \sphinxcode{\sphinxupquote{gitlab\sphinxhyphen{}ci\sphinxhyphen{}local}} to build the pip wheels locally. After that, the wheels
will be stored in \sphinxcode{\sphinxupquote{.gitlab\sphinxhyphen{}ci\sphinxhyphen{}local/artifacts/manylinux\sphinxhyphen{}pip\sphinxhyphen{}wheel\sphinxhyphen{}py3Lg10/wheelhouse}}
(for Python 3.10).

\sphinxAtStartPar
The wheel names are based on the number of commits since the latest release.
For example, a wheel built 415 after the release 3.37 will be named
\sphinxcode{\sphinxupquote{ns3\sphinxhyphen{}3.37.post415\sphinxhyphen{}cp310\sphinxhyphen{}cp310\sphinxhyphen{}manylinux\_2\_28\_x86\_64.whl}}.

\sphinxAtStartPar
The wheel name (\sphinxcode{\sphinxupquote{ns3}}) is defined in the \sphinxcode{\sphinxupquote{/ns\sphinxhyphen{}3\sphinxhyphen{}dev/setup.cfg}} file, and that
name should match the build prefix specified in \sphinxcode{\sphinxupquote{/ns\sphinxhyphen{}3\sphinxhyphen{}dev/setup.py}} file.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{cp310\sphinxhyphen{}cp310}} indicates that this wheel is compatible from Python 3.10 and up to Python 3.10.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{manylinux\_2\_28}} indicates that this is a manylinux wheel targeting glibc 2.28.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{x86\_64}} indicates that this is a 64\sphinxhyphen{}bit build targeting Intel/AMD processors.

\sphinxAtStartPar
After packaging, we can either deploy that wheel locally or upload the wheel to Pypi for general availability.


\subsection{Local deployment}
\label{\detokenize{python:local-deployment}}
\sphinxAtStartPar
To deploy a wheel locally, simply share the wheel file across the desired machines.
Then install the wheel and its dependencies running the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }*.whl
\end{sphinxVerbatim}


\subsection{Publishing the pip wheel via Pypi}
\label{\detokenize{python:publishing-the-pip-wheel-via-pypi}}
\sphinxAtStartPar
Publishing a pip wheel requires a \sphinxhref{https://pypi.org/account/register/}{Pypi} account.

\sphinxAtStartPar
After creating your account, install \sphinxhref{https://twine.readthedocs.io/en/stable/}{Twine}, an utility to upload the wheel to Pypi.

\sphinxAtStartPar
Then run twine to upload the wheel to the Pypi servers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }twine\PYG{+w}{ }upload\PYG{+w}{ }.gitlab\PYGZhy{}ci\PYGZhy{}local/artifacts/manylinux\PYGZhy{}pip\PYGZhy{}wheel\PYGZhy{}py3Lg10/wheelhouse/*.whl
\end{sphinxVerbatim}

\sphinxAtStartPar
Enter your Pypi username and password as requested.

\sphinxAtStartPar
Your wheel should be up and running. Give it a try just to make sure.

\sphinxAtStartPar
For the upstream pip wheel, try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }ns3
\PYGZdl{}\PYG{+w}{ }python3\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}from ns import ns; print(ns.Simulator.Now())\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Historical Information}
\label{\detokenize{python:historical-information}}
\sphinxAtStartPar
If you are a developer and need more background information on \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Python bindings,
please see the \sphinxhref{http://www.nsnam.org/wiki/NS-3\_Python\_Bindings}{Python Bindings wiki page}.
Please note, however, that some information on that page is stale.

\sphinxstepscope


\chapter{Developer Tools}
\label{\detokenize{develop:developer-tools}}\label{\detokenize{develop::doc}}
\sphinxAtStartPar
This chapter describes the development ecosystem generally used to create new modules.

\sphinxstepscope


\section{Working with Git as a user}
\label{\detokenize{working-with-git:working-with-git-as-a-user}}\label{\detokenize{working-with-git:working-with-git}}\label{\detokenize{working-with-git::doc}}
\sphinxAtStartPar
The ns\sphinxhyphen{}3 project used Mercurial in the past as its source code control system, but it has moved to Git in December 2018. Git is a VCS like Mercurial, Subversion or CVS, and it is used to maintain many open\sphinxhyphen{}source (and closed\sphinxhyphen{}source) projects. While Git and mercurial have a lot of common properties, if you are new to Git you should read first an introduction to it. The most up\sphinxhyphen{}to\sphinxhyphen{}date guide is the Git Book, at \sphinxurl{https://git-scm.com/book/en/v2/Getting-Started-Git-Basics}.

\sphinxAtStartPar
The ns\sphinxhyphen{}3 project is officially hosted on GitLab.com at \sphinxurl{https://gitlab.com/nsnam/}.  For convenience and historical reasons, ns\sphinxhyphen{}3\sphinxhyphen{}dev mirrors are currently posted on Bitbucket.com and GitHub.com, and kept in sync with the official repository periodically via cron jobs.  We recommend that users who have been working from one of these mirrors repoint their remotes so that they pull origin or upstream from GitLab.com (see below explanation about how to configure remotes).

\sphinxAtStartPar
This section of the manual provides common tips for both users and maintainers. Since the first part is shared, in this manual section we will start with a personal repository and then explain what to do in some typical cases. ns\sphinxhyphen{}3 users often combine ns\sphinxhyphen{}3\sphinxhyphen{}dev with other repositories (netanim, apps from the app store).  This manual chapter does not cover this use case; it only focuses on the single ns\sphinxhyphen{}3\sphinxhyphen{}dev repository.  See other project documentation such as the ns\sphinxhyphen{}3 tutorial for descriptions on bundled releases distributed as source archives, or on the bake build tool for managing multiple repositories.  The guidelines listed below also largely pertain to the user who is using (and cloning) bake from the GitLab.com repository.


\subsection{ns\sphinxhyphen{}3’s Git workflow in a nutshell}
\label{\detokenize{working-with-git:ns-3-s-git-workflow-in-a-nutshell}}
\sphinxAtStartPar
Experienced Git users will not necessarily need instruction on how to set up personal repositories (below).  However, they should be aware of the project’s workflow:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The main repository’s \sphinxcode{\sphinxupquote{master}} branch is the main development branch.  The project maintains only this one branch and strives to maintain a mostly linear history on it.

\item {} 
\sphinxAtStartPar
Releases are made by creating a branch from the \sphinxcode{\sphinxupquote{master}} branch and tagging the branch with the release number when ready, and then merging the release branch back to the \sphinxcode{\sphinxupquote{master}} branch.  Releases can be identified by a Git tag, and a modified \sphinxcode{\sphinxupquote{VERSION}} file in the branch.  However, the modified \sphinxcode{\sphinxupquote{VERSION}} file is not merged back to \sphinxcode{\sphinxupquote{master}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
If a hotfix release must be made to update a past release, a new hotfix support branch will be created by branching from the tip of the last relevant release.  Changesets from \sphinxcode{\sphinxupquote{master}} branch (such as bug fixes) may be cherry\sphinxhyphen{}picked to the hotfix branch.  The hotfix release is tagged with the hotfix version number, and merged back to the \sphinxcode{\sphinxupquote{master}} branch.

\end{itemize}

\item {} 
\sphinxAtStartPar
Merges to the ns\sphinxhyphen{}3 \sphinxcode{\sphinxupquote{master}} branch are fast forwarded when possible, and commits can be squashed as appropriate, to maintain a clean linear history.  Merge commits can be avoided in simple cases.
\begin{itemize}
\item {} 
\sphinxAtStartPar
More complicated merges might not be able to be fast forwarded, with the result that there will be a merge commit upon the merge.

\end{itemize}

\item {} 
\sphinxAtStartPar
Maintainers can commit obvious non\sphinxhyphen{}critical fixes (documentation improvements, typos etc.) directly into the \sphinxcode{\sphinxupquote{master}} branch.  Users who are not maintainers can create GitLab.com Merge Requests for small items such as these, for maintainers to review.

\item {} 
\sphinxAtStartPar
Maintainers can directly commit bug fixes to their maintained modules without review/approval by other maintainers, although a review phase is recommended for non\sphinxhyphen{}trivial fixes.  Larger commits that touch multiple modules should be reviewed and approved by the set of affected maintainers.

\item {} 
\sphinxAtStartPar
When proposing code (new features, bug fixes, etc.) for a module maintained by someone else, the typical workflow will be to fork the \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} repository, create a local feature branch on your fork, and use GitLab.com to generate a Merge Request towards \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} when ready.  The Merge Request will then be reviewed, and in response to changes requested or comments from maintainers, authors are are asked to modify their feature branch and rebase to the tip of \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} as needed.

\end{itemize}


\subsection{Setup of a personal repository}
\label{\detokenize{working-with-git:setup-of-a-personal-repository}}
\sphinxAtStartPar
We will provide two ways, one anonymous (but will impede the creation of merge requests) and the other, preferred, that include forking the repository through the GitLab.com web interface.


\subsubsection{Directly cloning ns\sphinxhyphen{}3\sphinxhyphen{}dev}
\label{\detokenize{working-with-git:directly-cloning-ns-3-dev}}\label{\detokenize{working-with-git:id1}}
\sphinxAtStartPar
If you go to the official ns\sphinxhyphen{}3\sphinxhyphen{}dev page, hosted at \sphinxurl{https://gitlab.com/nsnam/ns-3-dev}, you can find a button that says \sphinxcode{\sphinxupquote{Clone}}. If you are not logged in, then you will see only the option of cloning the repository through HTTPS, with this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }clone\PYG{+w}{ }https://gitlab.com/nsnam/ns\PYGZhy{}3\PYGZhy{}dev.git
\end{sphinxVerbatim}

\sphinxAtStartPar
If this command exits successfully, you will have a newly created \sphinxtitleref{ns\sphinxhyphen{}3\sphinxhyphen{}dev} directory with all the source code.


\subsubsection{Forking ns\sphinxhyphen{}3\sphinxhyphen{}dev on GitLab.com}
\label{\detokenize{working-with-git:forking-ns-3-dev-on-gitlab-com}}
\sphinxAtStartPar
Assume that you are the user \sphinxstyleemphasis{john} on GitLab.com and that you want to create a new repository that is synced with nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Log into GitLab.com

\item {} 
\sphinxAtStartPar
Navigate to \sphinxurl{https://gitlab.com/nsnam/ns-3-dev}

\item {} 
\sphinxAtStartPar
In the top\sphinxhyphen{}right corner of the page, click \sphinxcode{\sphinxupquote{Fork}}.

\end{enumerate}

\sphinxAtStartPar
Note that you may only do this once; if you try to fork again, Gitlab will take you to the page of the original fork. So, if you are planning to maintain two or more separate forks (for example, one for your private work, another for maintenance, etc.), you are doing a mistake. Instead, you should add these forks as a remote of your existing directory (see below for adding remotes). Usually, it is a good thing to add the maintainer’s repository as remotes, because it can happen that “bleeding edge” features will appear there before landing in ns\sphinxhyphen{}3\sphinxhyphen{}dev.

\sphinxAtStartPar
For more information on forking with Gilab, there is plenty of visual documentation (\sphinxurl{https://docs.gitlab.com/ee/user/project/repository/forking\_workflow.html}). To work with your forked repository, you have two ways: one is a clean clone while the other is meant to re\sphinxhyphen{}use an existing ns\sphinxhyphen{}3 Git repository.


\paragraph{Clone your forked repository on your machine}
\label{\detokenize{working-with-git:clone-your-forked-repository-on-your-machine}}
\sphinxAtStartPar
Git is a distributed versioning system. This means that \sphinxstyleemphasis{nobody} will touch your personal repository, until you do something. Please note that every gitlab user has, at least, two repositories: the first is represented by the repository hosted on gitlab servers, which will be called in the following \sphinxcode{\sphinxupquote{origin}}. Then, you have your clone on your machine. This means that you could have many clones, on different machines, which points to \sphinxcode{\sphinxupquote{origin}}.

\sphinxAtStartPar
To clone the newly created fork to your system, go to the homepage of your fork (that should be in the form \sphinxtitleref{https://gitlab.com/your\sphinxhyphen{}user\sphinxhyphen{}name/ns\sphinxhyphen{}3\sphinxhyphen{}dev}) and click the \sphinxtitleref{Clone} button. Then, go to your computer’s terminal, and issue the command (please refer to \sphinxurl{https://docs.gitlab.com/ee/gitlab-basics/command-line-commands.html\#clone-your-project} for more documentation):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }clone\PYG{+w}{ }https://gitlab.com/your\PYGZhy{}user\PYGZhy{}name/ns\PYGZhy{}3\PYGZhy{}dev
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }ns\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example we used the HTTPS address because in some place the git + ssh address is blocked by firewalls. If you are not under this constraint, it is recommended to use the git + ssh address to avoid the username/password typing at each request.


\paragraph{Naming conventions}
\label{\detokenize{working-with-git:naming-conventions}}
\sphinxAtStartPar
Git is able to fetch and push changes to several repositories, each of them is called \sphinxcode{\sphinxupquote{remote}}. With time, you probably will have many remotes, each one with many branches. To avoid confusion, it is recommended to give meaningful names to the remotes. Following the Git terminology, we will use \sphinxcode{\sphinxupquote{origin}} to indicate the ns\sphinxhyphen{}3\sphinxhyphen{}dev repository in your personal namespace (your forked version, server\sphinxhyphen{}side) and \sphinxcode{\sphinxupquote{upstream}} to indicate the ns\sphinxhyphen{}3\sphinxhyphen{}dev repository in the nsnam namespace, server\sphinxhyphen{}side.


\subsection{Add the official ns\sphinxhyphen{}3 repository as remote upstream}
\label{\detokenize{working-with-git:add-the-official-ns-3-repository-as-remote-upstream}}
\sphinxAtStartPar
You could have already used Git in the past, and therefore already having a ns\sphinxhyphen{}3 Git repository somewhere. Or, instead, you could have it cloned for the first time in the step above. In both cases, when you fork/clone a repository, your history is no more bound to the repository itself. At this point, it is your duty to sync your fork with the original repository. The first remote repository we have encountered is \sphinxcode{\sphinxupquote{origin}}; we must add the official ns\sphinxhyphen{}3 repo as another remote repository:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }remote\PYG{+w}{ }add\PYG{+w}{ }upstream\PYG{+w}{ }https://gitlab.com/nsnam/ns\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

\sphinxAtStartPar
With the command above, we added a remote repository, named upstream, which links to the official ns\sphinxhyphen{}3 repo. To show your remote repositories:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }remote\PYG{+w}{ }show
\end{sphinxVerbatim}

\sphinxAtStartPar
To see what \sphinxcode{\sphinxupquote{origin}} is linking to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }remote\PYG{+w}{ }show\PYG{+w}{ }origin
\end{sphinxVerbatim}

\sphinxAtStartPar
Many options are available; please refer to the Git manual for more.


\subsection{Add your forked repository as remote}
\label{\detokenize{working-with-git:add-your-forked-repository-as-remote}}
\sphinxAtStartPar
If you were a user of the old github mirror, you probably have an existing Git repository installed somewhere. In your case, it is not necessary to clone your fork and to port all your work in the new directory; you can add the fork as new remote:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }remote\PYG{+w}{ }rename\PYG{+w}{ }origin\PYG{+w}{ }old\PYGZhy{}origin
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }remote\PYG{+w}{ }add\PYG{+w}{ }origin\PYG{+w}{ }https://gitlab.com/your\PYGZhy{}user\PYGZhy{}name/ns\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

\sphinxAtStartPar
After these two commands, you will have a remote, named origin, that points
to your forked repository on gitlab.


\subsection{Keep in sync your repository with latest ns\sphinxhyphen{}3\sphinxhyphen{}dev updates}
\label{\detokenize{working-with-git:keep-in-sync-your-repository-with-latest-ns-3-dev-updates}}
\sphinxAtStartPar
We assume, from now to the end of this document, that you will not make commits on top of the master branch. It should be kept clean from \sphinxstyleemphasis{any} personal modifications: all the works must be done in branches. Therefore, to move the current HEAD of the master branch to the latest commit in ns\sphinxhyphen{}3\sphinxhyphen{}dev, you should do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }master
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }fetch\PYG{+w}{ }upstream
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }pull\PYG{+w}{ }upstream\PYG{+w}{ }master
\end{sphinxVerbatim}

\sphinxAtStartPar
If you tried a pull which resulted in a conflict and you would like to start over, you can recover with Git reset (but this never happens if you do not commit over master).


\subsection{Start a new branch to do some work}
\label{\detokenize{working-with-git:start-a-new-branch-to-do-some-work}}
\sphinxAtStartPar
Look at the available branches:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }branch\PYG{+w}{ }\PYGZhy{}a
\end{sphinxVerbatim}

\sphinxAtStartPar
you should see something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*\PYG{+w}{ }master
\PYG{+w}{  }remotes/origin/master
\PYG{+w}{  }remotes/upstream/master
\end{sphinxVerbatim}

\sphinxAtStartPar
The branch master is your local master branch; remotes/origin/master point at the master branch on your repository located in the Gitlab server, while remotes/nsnam/master points to the official master branch.

\sphinxAtStartPar
Before entering in details on how to create a new branch, we have to explain why it is recommended to do it. First of all, if you put all your work in a separate branch, you can easily see the diff between ns\sphinxhyphen{}3 mainline and your feature branch (with \sphinxcode{\sphinxupquote{git diff master}}). Also, you can integrate more easily the upstream advancements in your work, and when you wish, you can create a \sphinxstyleemphasis{conflict\sphinxhyphen{}free} merge request, that will ease the maintainer’s job in reviewing your work.

\sphinxAtStartPar
To create a new branch, starting from master, the command is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }master
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }\PYGZhy{}b\PYG{+w}{ }\PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
To switch between branches, remove the \sphinxhyphen{}b option. You should now see:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }branch\PYG{+w}{ }\PYGZhy{}a
\PYG{+w}{ }*\PYG{+w}{ }master
\PYG{+w}{  }\PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\PYG{+w}{  }remotes/origin/master
\PYG{+w}{  }remotes/upstream/master
\end{sphinxVerbatim}


\subsection{Edit and commit the modifications}
\label{\detokenize{working-with-git:edit-and-commit-the-modifications}}
\sphinxAtStartPar
After you edit some file, you should commit the difference. As a policy, Git users love small and incremental patches. So, commit early, and commit often: you could rewrite your history later.

\sphinxAtStartPar
Suppose we edited \sphinxcode{\sphinxupquote{src/internet/model/tcp\sphinxhyphen{}socket\sphinxhyphen{}base.cc}}. With Git status, we can see the repository status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }status
\PYG{+w}{   }On\PYG{+w}{ }branch\PYG{+w}{ }tcp\PYGZhy{}next
\PYG{+w}{   }Your\PYG{+w}{ }branch\PYG{+w}{ }is\PYG{+w}{ }up\PYGZhy{}to\PYGZhy{}date\PYG{+w}{ }with\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}mirror/tcp\PYGZhy{}next\PYGZsq{}}.
\PYG{+w}{   }Changes\PYG{+w}{ }not\PYG{+w}{ }staged\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }commit:
\PYG{+w}{     }modified:\PYG{+w}{   }src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
\end{sphinxVerbatim}

\sphinxAtStartPar
and we can see the edits with git diff:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git diff

nat@miyamoto \PYGZti{}/Work/ns\PYGZhy{}3\PYGZhy{}dev\PYGZhy{}git (tcp\PYGZhy{}next)\PYGZdl{} git diff
diff \PYGZhy{}\PYGZhy{}git i/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc w/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
index 1bf0f69..e2298b0 100644
\PYGZhy{}\PYGZhy{}\PYGZhy{} i/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
+++ w/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
@@ \PYGZhy{}1439,6 +1439,10 @@ TcpSocketBase::ReceivedAck (Ptr\PYGZlt{}Packet\PYGZgt{} packet, const TcpHeader\PYGZam{} tcpHeader)
       // There is a DupAck
       ++m\PYGZus{}dupAckCount;

+      // I\PYGZsq{}m introducing a subtle bug!
+
+      m\PYGZus{}tcb\PYGZhy{}\PYGZgt{}m\PYGZus{}cWnd = m\PYGZus{}tcb\PYGZhy{}\PYGZgt{}m\PYGZus{}ssThresh;
+
       if (m\PYGZus{}tcb\PYGZhy{}\PYGZgt{}m\PYGZus{}congState == TcpSocketState::CA\PYGZus{}OPEN)
         \PYGZob{}
           // From Open we go Disorder
\end{sphinxVerbatim}

\sphinxAtStartPar
To create a commit, select the file you want to add to the commit with git add:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }add\PYG{+w}{ }src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
\end{sphinxVerbatim}

\sphinxAtStartPar
and then commit the result:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}My new TCP broken\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course, it would be better to have some rules for the commit message: they will be reported in the next subsection.


\subsubsection{Commit message guidelines}
\label{\detokenize{working-with-git:commit-message-guidelines}}
\sphinxAtStartPar
The commit title should not go over the 80 char limit. It should be prefixed by the name of the module you are working on, and if it fixes a bug, it should reference it in the commit title. For instance, a good commit title would be:
\begin{quote}

\sphinxAtStartPar
tcp: My new TCP broken
\end{quote}

\sphinxAtStartPar
Another example is:
\begin{quote}

\sphinxAtStartPar
tcp: (fixes \#2322) Corrected the uint32\_t wraparound during recovery
\end{quote}

\sphinxAtStartPar
In the body message, try to explain what the problem was, and how you resolved that. If it is a new feature, try to describe it at a very high level, and highlight any modifications that changed the behaviour or the interface towards the users or other modules.


\subsubsection{Commit log}
\label{\detokenize{working-with-git:commit-log}}
\sphinxAtStartPar
You can see the history of the commits with git log. To show a particular commit, copy the sha\sphinxhyphen{}id and use \sphinxcode{\sphinxupquote{git show \textless{}sha\sphinxhyphen{}id\textgreater{}}}. The ID is unique, so it can be referenced in emails or in issues. The next step is useful if you plan to contribute back your changes, but also to keep your feature branch updated with the latest changes from ns\sphinxhyphen{}3\sphinxhyphen{}dev.


\subsection{Rebase your branch on top of master}
\label{\detokenize{working-with-git:rebase-your-branch-on-top-of-master}}
\sphinxAtStartPar
Meanwhile you were busy with your branch, the upstream master could have changed. To rebase your work with the now new master, first of all sync your master branch (pulling the upstream/master branch into your local master branch) as explained before; then

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }\PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }rebase\PYG{+w}{ }master
\end{sphinxVerbatim}

\sphinxAtStartPar
The last command will rewind your work, update the HEAD of your branch to the actual master, and then re\sphinxhyphen{}apply all your work. If some of your work conflicts with the actual master, you will be asked to fix these conflicts if automatic merge fails.


\subsection{Pushing your changes to origin}
\label{\detokenize{working-with-git:pushing-your-changes-to-origin}}
\sphinxAtStartPar
After you have done some work on a branch, if you would like to share it with others, there is nothing better than pushing your work to your origin repository, on Gitlab servers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }\PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }push\PYG{+w}{ }origin\PYG{+w}{ }\PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{git push}} command can be used every time you need to push something from your computer to a remote repository, except when you propose changes to the main ns\sphinxhyphen{}3\sphinxhyphen{}dev repository: your changes must pass a review stage.

\sphinxAtStartPar
Please note that for older Git version, the push command looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}u\PYG{+w}{ }origin\PYG{+w}{ }\PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\end{sphinxVerbatim}


\subsection{Submit work for review}
\label{\detokenize{working-with-git:submit-work-for-review}}
\sphinxAtStartPar
After you push your branch to origin, you can follow the instructions here \sphinxurl{https://docs.gitlab.com/ee/user/project/merge\_requests/creating\_merge\_requests.html}
to create a merge request.

\sphinxAtStartPar
It is strongly suggested to rebase your branch on top of upstream/master (or master, if you kept it synced) before submitting your work.
This helps reviewing the code changes proposed in the branch. merge it without conflicts, and it increase the speed of the GitLab CI.


\subsubsection{GitLab CI (Continuous Integration)}
\label{\detokenize{working-with-git:gitlab-ci-continuous-integration}}
\sphinxAtStartPar
GitLab provides a CI (Continuous Integration) feature. Shortly put, after every push the code is built and tests are run in one of the GitLab servers.

\sphinxAtStartPar
Merge requests are expected to pass the CI, as is to not generate errors or warnings during compilation, to have all the tests passing, and to not generate warnings on the documentation.
Hence, the CI is very important for the workflow. However, sometimes running the Ci is superfluous, for example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You are in the middle of some work (and perhaps you know that there are errors),

\item {} 
\sphinxAtStartPar
Your changes are not tested by the CI (e.g., changes to the AUTHORS),

\item {} 
\sphinxAtStartPar
Etc.

\end{itemize}

\sphinxAtStartPar
In these cases it is useful to skip the CI to save time, CI runners quota, and energy. This is possible by using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}o ci.skip}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}o\PYG{+w}{ }ci.skip
\end{sphinxVerbatim}


\subsubsection{GitLab CI optimization}
\label{\detokenize{working-with-git:gitlab-ci-optimization}}
\sphinxAtStartPar
The GitLab Ci jobs are optimized to take advantage of caches (this is done automatically).

\sphinxAtStartPar
In order to take full advantage of the caches, it is suggested to rebase your branches on top of upstream/master (or your own ‘master’ branch if you keep it synced with the latest commits from upstream/master).


\subsection{Porting patches from mercurial repositories to Git}
\label{\detokenize{working-with-git:porting-patches-from-mercurial-repositories-to-git}}
\sphinxAtStartPar
\sphinxstyleemphasis{Placeholder section; please improve it.}


\section{Working with Git as a maintainer}
\label{\detokenize{working-with-git:working-with-git-as-a-maintainer}}
\sphinxAtStartPar
As a maintainer, you are a person who has write access to the main nsnam repository. You could push your own work (without passing from code review) or push someone else’s work. Let’s investigate the two cases.


\subsection{Pushing your own work}
\label{\detokenize{working-with-git:pushing-your-own-work}}
\sphinxAtStartPar
Since you have been added to the Developer list on Gitlab (if not, please open an issue) you can use the git + ssh address when adding nsnam as remote. Once you have done that, you can do your modifications to a local branch, then update the master to point to the latest changes of the nsnam repo, and then:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }master
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }pull\PYG{+w}{ }upstream\PYG{+w}{ }master
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }merge\PYG{+w}{ }\PYG{o}{[}your\PYGZus{}branch\PYGZus{}name\PYG{o}{]}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }push\PYG{+w}{ }upstream\PYG{+w}{ }master
\end{sphinxVerbatim}

\sphinxAtStartPar
Please note that if you want to keep track of your branch, you can use as command \sphinxcode{\sphinxupquote{git merge \sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}ff {[}your\_branch\_name{]}}}. It is always recommended to rebase your branch before merging, to have a clean history. That is not a requirement, though: Git perfectly handles a master with parallel merged branches.


\subsection{Review and merge someone else’s work}
\label{\detokenize{working-with-git:review-and-merge-someone-else-s-work}}
\sphinxAtStartPar
Gitlab.com has a plenty of documentation on how to handle merge requests. Please take a look here: \sphinxurl{https://docs.gitlab.com/ee/user/project/merge\_requests/creating\_merge\_requests.html}.

\sphinxAtStartPar
If you are committing a patch from someone else, and it is not coming through a Merge Request process, you can use the \textendash{}author=’’ argument to ‘git commit’ to assign authorship to another email address (such as we have done in the past with the Mercurial \sphinxhyphen{}u option).


\subsection{Making a release}
\label{\detokenize{working-with-git:making-a-release}}
\sphinxAtStartPar
As stated above, the project has adopted a workflow to aim for a mostly
linear history on a single \sphinxcode{\sphinxupquote{master}} branch.  Releases are branches from
this \sphinxcode{\sphinxupquote{master}} branch but the branches themselves are not long\sphinxhyphen{}lived;
the release branches are merged back to \sphinxcode{\sphinxupquote{master}} in a special way.  However,
the release branches can be checked out by using the Git tag facility;
a named release such as ‘ns\sphinxhyphen{}3.30’ can be checked out on a branch by specifying
the release name ‘ns\sphinxhyphen{}3.30’ (or ‘ns\sphinxhyphen{}3.30.1’ etc.).

\sphinxAtStartPar
A compact way to represent a Git history is the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}graph\PYG{+w}{ }\PYGZhy{}\PYGZhy{}decorate\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline\PYG{+w}{ }\PYGZhy{}\PYGZhy{}all
\end{sphinxVerbatim}

\sphinxAtStartPar
At the point just before the ns\sphinxhyphen{}3.34 release, the log looked like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*\PYG{+w}{ }9df8ef4\PYG{+w}{ }\PYG{o}{(}HEAD\PYG{+w}{ }\PYGZhy{}\PYGZgt{}\PYG{+w}{ }master\PYG{o}{)}\PYG{+w}{ }doc:\PYG{+w}{ }Update\PYG{+w}{ }ns\PYGZhy{}3\PYG{+w}{ }version\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }tutorial\PYG{+w}{ }examples
*\PYG{+w}{ }9319cdd\PYG{+w}{ }\PYG{o}{(}origin/master,\PYG{+w}{ }origin/HEAD\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }CHANGES.html\PYG{+w}{ }and\PYG{+w}{ }RELEASE\PYGZus{}NOTES
*\PYG{+w}{ }8da68b5\PYG{+w}{ }wifi:\PYG{+w}{ }Fix\PYG{+w}{ }typo\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }channel\PYG{+w}{ }access\PYG{+w}{ }manager\PYG{+w}{ }\PYG{n+nb}{test}
\end{sphinxVerbatim}

\sphinxAtStartPar
We want the release to create a small branch that is merged (in a special
way) back to the mainline, yielding something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*\PYG{+w}{ }4b27025\PYG{+w}{ }\PYG{o}{(}master\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }release\PYG{+w}{ }files\PYG{+w}{ }to\PYG{+w}{ }start\PYG{+w}{ }next\PYG{+w}{ }release
*\PYG{+w}{   }fd075f6\PYG{+w}{ }Merge\PYG{+w}{ }ns\PYGZhy{}3.34\PYGZhy{}release\PYG{+w}{ }branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }3fab3cf\PYG{+w}{ }\PYG{o}{(}HEAD,\PYG{+w}{ }tag:\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }availability\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }c50aaf7\PYG{+w}{ }Update\PYG{+w}{ }VERSION\PYG{+w}{ }and\PYG{+w}{ }documentation\PYG{+w}{ }tags\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{+w}{ }release
\PYG{p}{|}/
*\PYG{+w}{ }9df8ef4\PYG{+w}{ }doc:\PYG{+w}{ }Update\PYG{+w}{ }ns\PYGZhy{}3\PYG{+w}{ }version\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }tutorial\PYG{+w}{ }examples
*\PYG{+w}{ }9319cdd\PYG{+w}{ }\PYG{o}{(}origin/master,\PYG{+w}{ }origin/HEAD\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }CHANGES.html\PYG{+w}{ }and\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\end{sphinxVerbatim}

\sphinxAtStartPar
The first commit on the release branch changes the ‘3\sphinxhyphen{}dev’ string in VERSION
and the various documentation conf.py files to ‘3.34’.  The second commit
on the release branch updates RELEASE\_NOTES to state the URL of the release.

\sphinxAtStartPar
Starting with commit 9df8ef4, the following steps were taken to create the
ns\sphinxhyphen{}3.34 release.  First, this commit hash ‘9df8ef4’ will be used later in
the merge process.

\sphinxAtStartPar
First, create a new release branch locally:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }\PYGZhy{}b\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.34\PYGZhy{}release\PYGZsq{}}
Switched\PYG{+w}{ }to\PYG{+w}{ }a\PYG{+w}{ }new\PYG{+w}{ }branch\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.34\PYGZhy{}release\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We change the VERSION field from ‘3\sphinxhyphen{}dev’ to ‘3.34’:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/3\PYGZhy{}dev/3.34/g\PYGZsq{}}\PYG{+w}{ }VERSION
\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }VERSION
\PYG{l+m}{3}.34
\end{sphinxVerbatim}

\sphinxAtStartPar
We next change the file conf.py in the contributing, tutorial, manual, and models directories
to change the strings ‘ns\sphinxhyphen{}3\sphinxhyphen{}dev’ to ns\sphinxhyphen{}3.34.

\sphinxAtStartPar
When you are done, the ‘git diff \textendash{}stat’ command should show:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
VERSION\PYG{+w}{                         }\PYG{p}{|}\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }+\PYGZhy{}
doc/contributing/source/conf.py\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }++\PYGZhy{}\PYGZhy{}
doc/manual/source/conf.py\PYG{+w}{       }\PYG{p}{|}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }++\PYGZhy{}\PYGZhy{}
doc/models/source/conf.py\PYG{+w}{       }\PYG{p}{|}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }++\PYGZhy{}\PYGZhy{}
doc/tutorial/source/conf.py\PYG{+w}{     }\PYG{p}{|}\PYG{+w}{ }\PYG{l+m}{4}\PYG{+w}{ }++\PYGZhy{}\PYGZhy{}
\PYG{l+m}{5}\PYG{+w}{ }files\PYG{+w}{ }changed,\PYG{+w}{ }\PYG{l+m}{9}\PYG{+w}{ }insertions\PYG{o}{(}+\PYG{o}{)},\PYG{+w}{ }\PYG{l+m}{9}\PYG{+w}{ }deletions\PYG{o}{(}\PYGZhy{}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Make a commit of these files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}a\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Update VERSION and documentation tags for ns\PYGZhy{}3.34 release\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, make the following change to RELEASE\_NOTES.md and commit it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}Release\PYG{+w}{ }\PYG{l+m}{3}\PYGZhy{}dev
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
+Release\PYG{+w}{ }\PYG{l+m}{3}.34
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
+
+\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYG{+w}{ }Availability
+
+This\PYG{+w}{ }release\PYG{+w}{ }is\PYG{+w}{ }available\PYG{+w}{ }from:
+\PYGZlt{}https://www.nsnam.org/release/ns\PYGZhy{}allinone\PYGZhy{}3.34.tar.bz2\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Commit this change:
\begin{quote}

\sphinxAtStartPar
\$ git commit \sphinxhyphen{}m”Update availability in RELEASE\_NOTES.md” RELEASE\_NOTES.md
\end{quote}

\sphinxAtStartPar
Finally, add a Git annotated tag:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }tag\PYG{+w}{ }\PYGZhy{}a\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.34\PYGZsq{}}\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}ns\PYGZhy{}3.34 release\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, let’s merge back to \sphinxcode{\sphinxupquote{master}}.  However, we want to avoid touching
the \sphinxcode{\sphinxupquote{VERSION}} and \sphinxcode{\sphinxupquote{conf.py}} files on \sphinxcode{\sphinxupquote{master}}; we want the RELEASE\_NOTES
change and new tag.  We can accomplish this with a special merge as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }master
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }merge\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}commit\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}ff\PYG{+w}{ }ns\PYGZhy{}3.34\PYGZhy{}release
Automatic\PYG{+w}{ }merge\PYG{+w}{ }went\PYG{+w}{ }well\PYG{p}{;}\PYG{+w}{ }stopped\PYG{+w}{ }before\PYG{+w}{ }committing\PYG{+w}{ }as\PYG{+w}{ }requested
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, we want to reset VERSION to the previous string, which existed before
we branched.  We can use \sphinxcode{\sphinxupquote{git reset}} on this file and then finish the merge.
Recall its commit hash of \sphinxcode{\sphinxupquote{9df8ef4}} from above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }reset\PYG{+w}{ }9df8ef4\PYG{+w}{ }VERSION
Unstaged\PYG{+w}{ }changes\PYG{+w}{ }after\PYG{+w}{ }reset:
M\PYG{+w}{ }VERSION
\PYGZdl{}\PYG{+w}{ }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/3.34/3\PYGZhy{}dev/g\PYGZsq{}}\PYG{+w}{ }VERSION
\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }VERSION
\PYG{l+m}{3}\PYGZhy{}dev
\end{sphinxVerbatim}

\sphinxAtStartPar
Repeat the above resets and change back to \sphinxcode{\sphinxupquote{3\sphinxhyphen{}dev}} for each conf.py file.

\sphinxAtStartPar
Finally, commit the branch and delete our local release branch.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Merge ns\PYGZhy{}3.34\PYGZhy{}release branch\PYGZdq{}}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }branch\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }ns\PYGZhy{}3.34\PYGZhy{}release
\end{sphinxVerbatim}

\sphinxAtStartPar
The Git history now looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}graph\PYG{+w}{ }\PYGZhy{}\PYGZhy{}decorate\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline\PYG{+w}{ }\PYGZhy{}\PYGZhy{}all
*\PYG{+w}{   }fd075f6\PYG{+w}{ }\PYG{o}{(}HEAD\PYG{+w}{ }\PYGZhy{}\PYGZgt{}\PYG{+w}{ }master\PYG{o}{)}\PYG{+w}{ }Merge\PYG{+w}{ }ns\PYGZhy{}3.34\PYGZhy{}release\PYG{+w}{ }branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }3fab3cf\PYG{+w}{ }\PYG{o}{(}HEAD,\PYG{+w}{ }tag:\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }availability\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }c50aaf7\PYG{+w}{ }Update\PYG{+w}{ }VERSION\PYG{+w}{ }and\PYG{+w}{ }documentation\PYG{+w}{ }tags\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{+w}{ }release
\PYG{p}{|}/
*\PYG{+w}{ }9df8ef4\PYG{+w}{ }doc:\PYG{+w}{ }Update\PYG{+w}{ }ns\PYGZhy{}3\PYG{+w}{ }version\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }tutorial\PYG{+w}{ }examples
*\PYG{+w}{ }9319cdd\PYG{+w}{ }\PYG{o}{(}origin/master,\PYG{+w}{ }origin/HEAD\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }CHANGES.html\PYG{+w}{ }and\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\end{sphinxVerbatim}

\sphinxAtStartPar
This may now be pushed to \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} and development can continue.

\sphinxAtStartPar
\sphinxstylestrong{Important:}  When pushing to the remote, don’t forget to push the tags:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}\PYGZhy{}follow\PYGZhy{}tags
\end{sphinxVerbatim}

\sphinxAtStartPar
Future users who want to check out the ns\sphinxhyphen{}3.34 release will do something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }\PYGZhy{}b\PYG{+w}{ }my\PYGZhy{}local\PYGZhy{}ns\PYGZhy{}3.34\PYG{+w}{ }ns\PYGZhy{}3.34
Switched\PYG{+w}{ }to\PYG{+w}{ }a\PYG{+w}{ }new\PYG{+w}{ }branch\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}my\PYGZhy{}local\PYGZhy{}ns\PYGZhy{}3.34\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Note:}  It is a good idea to avoid naming the new branch the same as the tag
name; in this case, ‘ns\sphinxhyphen{}3.34’.

\sphinxAtStartPar
Let’s assume now that master evolves with new features and bugfixes.  They
are committed to \sphinxcode{\sphinxupquote{master}} on \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} as usual:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }master
...\PYG{+w}{ }\PYG{o}{(}some\PYG{+w}{ }changes\PYG{o}{)}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}make some changes\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}a
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}d\PYGZsq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }d
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }add\PYG{+w}{ }d
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Add new feature\PYGZdq{}}\PYG{+w}{ }d
...\PYG{+w}{ }\PYG{o}{(}some\PYG{+w}{ }more\PYG{+w}{ }changes\PYG{o}{)}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}some more changes\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}a
...\PYG{+w}{ }\PYG{o}{(}now\PYG{+w}{ }fix\PYG{+w}{ }a\PYG{+w}{ }really\PYG{+w}{ }important\PYG{+w}{ }bug\PYG{o}{)}
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}abc\PYGZsq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }a
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Fix missing abc bug on file a\PYGZdq{}}\PYG{+w}{ }a
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the tree looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}graph\PYG{+w}{ }\PYGZhy{}\PYGZhy{}decorate\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline\PYG{+w}{ }\PYGZhy{}\PYGZhy{}all
*\PYG{+w}{ }ee37d41\PYG{+w}{ }\PYG{o}{(}HEAD\PYG{+w}{ }\PYGZhy{}\PYGZgt{}\PYG{+w}{ }master\PYG{o}{)}\PYG{+w}{ }Fix\PYG{+w}{ }missing\PYG{+w}{ }abc\PYG{+w}{ }bug\PYG{+w}{ }on\PYG{+w}{ }file\PYG{+w}{ }a
*\PYG{+w}{ }9a3432a\PYG{+w}{ }some\PYG{+w}{ }more\PYG{+w}{ }changes
*\PYG{+w}{ }ba28d6d\PYG{+w}{ }Add\PYG{+w}{ }new\PYG{+w}{ }feature
*\PYG{+w}{ }e50015a\PYG{+w}{ }make\PYG{+w}{ }some\PYG{+w}{ }changes
*\PYG{+w}{   }fd075f6\PYG{+w}{ }Merge\PYG{+w}{ }ns\PYGZhy{}3.34\PYGZhy{}release\PYG{+w}{ }branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }3fab3cf\PYG{+w}{ }\PYG{o}{(}tag:\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }availability\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }c50aaf7\PYG{+w}{ }Update\PYG{+w}{ }VERSION\PYG{+w}{ }and\PYG{+w}{ }documentation\PYG{+w}{ }tags\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{+w}{ }release
\PYG{p}{|}/
*\PYG{+w}{ }9df8ef4\PYG{+w}{ }doc:\PYG{+w}{ }Update\PYG{+w}{ }ns\PYGZhy{}3\PYG{+w}{ }version\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }tutorial\PYG{+w}{ }examples
*\PYG{+w}{ }9319cdd\PYG{+w}{ }Update\PYG{+w}{ }CHANGES.html\PYG{+w}{ }and\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s assume that the changeset \sphinxcode{\sphinxupquote{ee37d41}} is considered important to fix in
the ns\sphinxhyphen{}3.34 release, but we don’t want the other changes introduced since then.
The solution will be to create a new branch for a hotfix release, and follow
similar steps.  The branch for the hotfix should come from commit \sphinxcode{\sphinxupquote{3fab3cf}},
and should cherry\sphinxhyphen{}pick commit \sphinxcode{\sphinxupquote{ee37d41}} (which may require merge if it
doesn’t apply cleanly), and then the hotfix branch can be tagged and merged
as was done before.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }\PYGZhy{}b\PYG{+w}{ }ns\PYGZhy{}3.34.1\PYGZhy{}release\PYG{+w}{ }ns\PYGZhy{}3.34
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }cherry\PYGZhy{}pick\PYG{+w}{ }ee37d41
...\PYG{+w}{ }\PYG{o}{(}resolve\PYG{+w}{ }any\PYG{+w}{ }conflicts\PYG{o}{)}
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }add\PYG{+w}{ }a
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit
\PYGZdl{}\PYG{+w}{ }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/3.34/3.34.1/g\PYGZsq{}}\PYG{+w}{ }VERSION
\PYGZdl{}\PYG{+w}{ }cat\PYG{+w}{ }VERSION
\PYG{l+m}{3}.34.1
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Update VERSION to 3.34.1\PYGZdq{}}\PYG{+w}{ }VERSION
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }tag\PYG{+w}{ }\PYGZhy{}a\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.34.1\PYGZsq{}}\PYG{+w}{ }\PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}ns\PYGZhy{}3.34.1 release\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the merge:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }checkout\PYG{+w}{ }master
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }merge\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}commit\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}ff\PYG{+w}{ }ns\PYGZhy{}3.34.1\PYGZhy{}release
\end{sphinxVerbatim}

\sphinxAtStartPar
This time we may see something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Auto\PYGZhy{}merging\PYG{+w}{ }a
CONFLICT\PYG{+w}{ }\PYG{o}{(}content\PYG{o}{)}:\PYG{+w}{ }Merge\PYG{+w}{ }conflict\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }a
Auto\PYGZhy{}merging\PYG{+w}{ }VERSION
CONFLICT\PYG{+w}{ }\PYG{o}{(}content\PYG{o}{)}:\PYG{+w}{ }Merge\PYG{+w}{ }conflict\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }VERSION
Automatic\PYG{+w}{ }merge\PYG{+w}{ }failed\PYG{p}{;}\PYG{+w}{ }fix\PYG{+w}{ }conflicts\PYG{+w}{ }and\PYG{+w}{ }\PYG{k}{then}\PYG{+w}{ }commit\PYG{+w}{ }the\PYG{+w}{ }result.
\end{sphinxVerbatim}

\sphinxAtStartPar
And we can then do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }reset\PYG{+w}{ }ee37d41\PYG{+w}{ }a
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }reset\PYG{+w}{ }ee37d41\PYG{+w}{ }VERSION
\end{sphinxVerbatim}

\sphinxAtStartPar
Which leaves us with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Unstaged\PYG{+w}{ }changes\PYG{+w}{ }after\PYG{+w}{ }reset:
M\PYG{+w}{ }VERSION
M\PYG{+w}{ }a
\end{sphinxVerbatim}

\sphinxAtStartPar
We can next hand\sphinxhyphen{}edit these files to restore them to original state, so that:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }status
On\PYG{+w}{ }branch\PYG{+w}{ }master
Your\PYG{+w}{ }branch\PYG{+w}{ }is\PYG{+w}{ }ahead\PYG{+w}{ }of\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}origin/master\PYGZsq{}}\PYG{+w}{ }by\PYG{+w}{ }\PYG{l+m}{8}\PYG{+w}{ }commits.
\PYG{+w}{  }\PYG{o}{(}use\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}git push\PYGZdq{}}\PYG{+w}{ }to\PYG{+w}{ }publish\PYG{+w}{ }your\PYG{+w}{ }\PYG{n+nb}{local}\PYG{+w}{ }commits\PYG{o}{)}

All\PYG{+w}{ }conflicts\PYG{+w}{ }fixed\PYG{+w}{ }but\PYG{+w}{ }you\PYG{+w}{ }are\PYG{+w}{ }still\PYG{+w}{ }merging.
\PYG{+w}{  }\PYG{o}{(}use\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}git commit\PYGZdq{}}\PYG{+w}{ }to\PYG{+w}{ }conclude\PYG{+w}{ }merge\PYG{o}{)}

\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }commit
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }branch\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }ns\PYGZhy{}3.34.1\PYGZhy{}release
\end{sphinxVerbatim}

\sphinxAtStartPar
The new log should show something like the below, with parallel Git
history paths until the merge back again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}graph\PYG{+w}{ }\PYGZhy{}\PYGZhy{}decorate\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline\PYG{+w}{ }\PYGZhy{}\PYGZhy{}all
*\PYG{+w}{   }815ce6e\PYG{+w}{ }\PYG{o}{(}HEAD\PYG{+w}{ }\PYGZhy{}\PYGZgt{}\PYG{+w}{ }master\PYG{o}{)}\PYG{+w}{ }Merge\PYG{+w}{ }branch\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.34.1\PYGZhy{}release\PYGZsq{}}
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }12a29ca\PYG{+w}{ }\PYG{o}{(}tag:\PYG{+w}{ }ns\PYGZhy{}3.34.1\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }VERSION\PYG{+w}{ }to\PYG{+w}{ }\PYG{l+m}{3}.34.1
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }21ebdbf\PYG{+w}{ }Fix\PYG{+w}{ }missing\PYG{+w}{ }abc\PYG{+w}{ }bug\PYG{+w}{ }on\PYG{+w}{ }file\PYG{+w}{ }a
*\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }ee37d41\PYG{+w}{ }Fix\PYG{+w}{ }missing\PYG{+w}{ }abc\PYG{+w}{ }bug\PYG{+w}{ }on\PYG{+w}{ }file\PYG{+w}{ }a
*\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }9a3432a\PYG{+w}{ }some\PYG{+w}{ }more\PYG{+w}{ }changes
*\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }ba28d6d\PYG{+w}{ }Add\PYG{+w}{ }new\PYG{+w}{ }feature
*\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }e50015a\PYG{+w}{ }make\PYG{+w}{ }some\PYG{+w}{ }changes
*\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{   }fd075f6\PYG{+w}{ }Merge\PYG{+w}{ }ns\PYGZhy{}3.34\PYGZhy{}release\PYG{+w}{ }branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{} }\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|}\PYG{+w}{ }\PYG{p}{|}/
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }3fab3cf\PYG{+w}{ }\PYG{o}{(}tag:\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{o}{)}\PYG{+w}{ }Update\PYG{+w}{ }availability\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }RELEASE\PYGZus{}NOTES
\PYG{p}{|}\PYG{+w}{ }*\PYG{+w}{ }c50aaf7\PYG{+w}{ }Update\PYG{+w}{ }VERSION\PYG{+w}{ }and\PYG{+w}{ }documentation\PYG{+w}{ }tags\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }ns\PYGZhy{}3.34\PYG{+w}{ }release
\PYG{p}{|}/
*\PYG{+w}{ }9df8ef4\PYG{+w}{ }doc:\PYG{+w}{ }Update\PYG{+w}{ }ns\PYGZhy{}3\PYG{+w}{ }version\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }tutorial\PYG{+w}{ }examples
*\PYG{+w}{ }9319cdd\PYG{+w}{ }Update\PYG{+w}{ }CHANGES.html\PYG{+w}{ }and\PYG{+w}{ }RELEASE\PYGZus{}NOTES

\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }push\PYG{+w}{ }origin\PYG{+w}{ }master:master\PYG{+w}{ }\PYGZhy{}\PYGZhy{}follow\PYGZhy{}tags
\end{sphinxVerbatim}

\sphinxAtStartPar
And we can continue to commit on top of master going forward.  The two
tags should be found in the \sphinxcode{\sphinxupquote{git tag}} output (among other tags):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }tag
ns\PYGZhy{}3.34
ns\PYGZhy{}3.34.1
\end{sphinxVerbatim}

\sphinxstepscope


\section{Working with CMake}
\label{\detokenize{working-with-cmake:working-with-cmake}}\label{\detokenize{working-with-cmake:id1}}\label{\detokenize{working-with-cmake::doc}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} project used Waf build system in the past, but it has moved to
CMake for the ns\sphinxhyphen{}3.36 release.

\sphinxAtStartPar
CMake is very verbose and commands can be very long for basic operations.

\sphinxAtStartPar
The wrapper script \sphinxcode{\sphinxupquote{ns3}} hides most of verbosity from CMake and provide a
Waf\sphinxhyphen{}like interface for command\sphinxhyphen{}line users.

\sphinxAtStartPar
It is the recommended way to work on \sphinxstyleemphasis{ns\sphinxhyphen{}3}, except if you are using an
IDE that supports projects that can be generated with CMake or CMake projects.

\sphinxAtStartPar
Here is a non\sphinxhyphen{}exhaustive list of IDEs that can be used:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Support CMake projects:
\begin{itemize}
\item {} 
\sphinxAtStartPar
JetBrains’s \sphinxhref{https://www.jetbrains.com/clion/}{CLion}

\item {} 
\sphinxAtStartPar
Microsoft \sphinxhref{https://visualstudio.microsoft.com/}{Visual Studio} and Visual Studio \sphinxhref{https://code.visualstudio.com/Download}{Code}

\end{itemize}

\item {} 
\sphinxAtStartPar
Supported IDEs via \sphinxhref{https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html}{CMake generated} projects:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Apple’s \sphinxhref{https://developer.apple.com/xcode/}{XCode} : \sphinxcode{\sphinxupquote{ns3 configure \sphinxhyphen{}G Xcode}}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.codeblocks.org/}{CodeBlocks} : \sphinxcode{\sphinxupquote{ns3 configure \sphinxhyphen{}G "CodeBlocks \sphinxhyphen{} Ninja"}}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.eclipse.org/cdt/}{Eclipse} CDT4 : \sphinxcode{\sphinxupquote{ns3 configure \sphinxhyphen{}G "Eclipse CDT4 \sphinxhyphen{} Ninja"}}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Note: Ninja was used for brevity.
Both CodeBlocks and Eclipse have additional \sphinxhref{https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html}{generator options}.

\sphinxAtStartPar
General instructions on how to setup and use IDEs are available
in the Tutorial and will not be detailed here.


\subsection{Configuring the project}
\label{\detokenize{working-with-cmake:configuring-the-project}}
\sphinxAtStartPar
After getting the code, either cloning the ns\sphinxhyphen{}3\sphinxhyphen{}dev repository or
downloading the release tarball, you will need to configure the
project to work on it.

\sphinxAtStartPar
There are two ways to configure the project: the easiest way
is using the \sphinxcode{\sphinxupquote{ns3}} script and the other way directly with CMake.


\subsubsection{Configuring the project with \sphinxstyleliteralintitle{\sphinxupquote{ns3}}}
\label{\detokenize{working-with-cmake:configuring-the-project-with-ns3}}
\sphinxAtStartPar
Navigate to the ns\sphinxhyphen{}3\sphinxhyphen{}dev directory, then run \sphinxcode{\sphinxupquote{./ns3 configure \sphinxhyphen{}\sphinxhyphen{}help}} to
print the configuration options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} cd ns\PYGZhy{}3\PYGZhy{}dev}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{}help}
\PYG{g+go}{usage: ns3 configure [\PYGZhy{}h] [\PYGZhy{}d \PYGZob{}debug,release,optimized\PYGZcb{}] [\PYGZhy{}G G]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}cxx\PYGZhy{}standard CXX\PYGZus{}STANDARD] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}asserts]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}asserts] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}examples] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}logs]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}logs] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}tests] [\PYGZhy{}\PYGZhy{}enable\PYGZhy{}verbose]}
\PYG{g+go}{                   [\PYGZhy{}\PYGZhy{}disable\PYGZhy{}verbose]}
\PYG{g+go}{                   ...}

\PYG{g+go}{positional arguments:}
\PYG{g+go}{  configure}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit}
\PYG{g+go}{  \PYGZhy{}d \PYGZob{}debug,release,optimized\PYGZcb{}, \PYGZhy{}\PYGZhy{}build\PYGZhy{}profile \PYGZob{}debug,release,optimized\PYGZcb{}}
\PYG{g+go}{                        Build profile}
\PYG{g+go}{  \PYGZhy{}G G                  CMake generator (e.g.}
\PYG{g+go}{                        https://cmake.org/cmake/help/latest/manual/cmake\PYGZhy{}}
\PYG{g+go}{                        generators.7.html)}
\PYG{g+go}{  ...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note: the command output was trimmed to the most used options.

\sphinxAtStartPar
To configure \sphinxstyleemphasis{ns\sphinxhyphen{}3} in release mode, while enabling examples and tests,
run \sphinxcode{\sphinxupquote{./ns3 configure \sphinxhyphen{}d release \sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}examples \sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}tests}}.
To check what underlying commands dare being executed, add the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 \PYGZhy{}\PYGZhy{}dry\PYGZhy{}run configure \PYGZhy{}d release \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests}
\PYG{g+go}{The following commands would be executed:}
\PYG{g+go}{mkdir cmake\PYGZhy{}cache}
\PYG{g+go}{cd cmake\PYGZhy{}cache; /usr/bin/cmake \PYGZhy{}DCMAKE\PYGZus{}BUILD\PYGZus{}TYPE=release \PYGZhy{}DNS3\PYGZus{}NATIVE\PYGZus{}OPTIMIZATIONS=OFF \PYGZhy{}DNS3\PYGZus{}EXAMPLES=ON \PYGZhy{}DNS3\PYGZus{}TESTS=ON \PYGZhy{}G Unix Makefiles .. ; cd ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we run it for real:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}d release \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CCache is enabled. Precompiled headers are disabled by default.}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} The CXX compiler identification is GNU 11.2.0}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} The C compiler identification is GNU 11.2.0}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Detecting CXX compiler ABI info}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Detecting CXX compiler ABI info \PYGZhy{} done}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Check for working CXX compiler: /usr/bin/c++ \PYGZhy{} skipped}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Detecting CXX compile features}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Detecting CXX compile features \PYGZhy{} done}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Processing src/wifi}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Processing src/wimax}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Summary of optional ns\PYGZhy{}3 features:}
\PYG{g+go}{Build profile                 : release}
\PYG{g+go}{Build directory               : /ns\PYGZhy{}3\PYGZhy{}dev/build}
\PYG{g+go}{...}
\PYG{g+go}{Examples                      : ON}
\PYG{g+go}{...}
\PYG{g+go}{Tests                         : ON}
\PYG{g+go}{Threading Primitives          : ON}


\PYG{g+go}{Modules configured to be built:}
\PYG{g+go}{antenna                   aodv                      applications}
\PYG{g+go}{bridge                    buildings                 config\PYGZhy{}store}
\PYG{g+go}{core                      csma                      csma\PYGZhy{}layout}
\PYG{g+go}{...}
\PYG{g+go}{wifi                      wimax}

\PYG{g+go}{Modules that cannot be built:}
\PYG{g+go}{brite                     click                     openflow}
\PYG{g+go}{visualizer}


\PYG{g+go}{\PYGZhy{}\PYGZhy{} Configuring done}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating done}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Build files have been written to: /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache}
\PYG{g+go}{Finished executing the following commands:}
\PYG{g+go}{mkdir cmake\PYGZhy{}cache}
\PYG{g+go}{cd cmake\PYGZhy{}cache; /usr/bin/cmake \PYGZhy{}DCMAKE\PYGZus{}BUILD\PYGZus{}TYPE=release \PYGZhy{}DNS3\PYGZus{}NATIVE\PYGZus{}OPTIMIZATIONS=OFF \PYGZhy{}DNS3\PYGZus{}EXAMPLES=ON \PYGZhy{}DNS3\PYGZus{}TESTS=ON \PYGZhy{}G Unix Makefiles .. ; cd ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that CCache is automatically used (if installed) for your convenience.

\sphinxAtStartPar
The summary with enabled feature shows both the \sphinxcode{\sphinxupquote{release}} build type, along with
enabled examples and tests.

\sphinxAtStartPar
Below is a list of enabled modules and modules that cannot be built.

\sphinxAtStartPar
At the end, notice we print the same commands from \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}}. This is done
to familiarize Waf users with CMake and how the options names changed.

\sphinxAtStartPar
The mapping of the \sphinxcode{\sphinxupquote{ns3}} build profiles into the CMake build types is the following:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{4}}
\sphinxstyletheadfamily \sphinxAtStartPar
Equivalent build profiles
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\sphinxhline\sphinxmultirow{2}{2}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{4}}
\sphinxstyletheadfamily \sphinxAtStartPar
\sphinxcode{\sphinxupquote{ns3 \sphinxhyphen{}\sphinxhyphen{}build\sphinxhyphen{}profile}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \sphinxAtStartPar
CMake
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Equivalent GCC compiler flags
\\
\sphinxcline{2-4}\sphinxfixclines{4}\sphinxtablestrut{2}&\sphinxstyletheadfamily 
\sphinxAtStartPar
CMAKE\_BUILD\_TYPE
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Additional flags
&\sphinxstyletheadfamily \\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
debug
&
\sphinxAtStartPar
debug
&&
\sphinxAtStartPar
\sphinxhyphen{}g
\\
\sphinxhline
\sphinxAtStartPar
default
&
\sphinxAtStartPar
default
&&
\sphinxAtStartPar
\sphinxhyphen{}O2 \sphinxhyphen{}g
\\
\sphinxhline
\sphinxAtStartPar
release
&
\sphinxAtStartPar
release
&&
\sphinxAtStartPar
\sphinxhyphen{}O3
\\
\sphinxhline
\sphinxAtStartPar
optimized
&
\sphinxAtStartPar
release
&
\sphinxAtStartPar
\sphinxhyphen{}DNS3\_NATIVE\_OPTIMIZATIONS=ON
&
\sphinxAtStartPar
\sphinxhyphen{}O3 \sphinxhyphen{}march=native \sphinxhyphen{}mtune=native
\\
\sphinxhline
\sphinxAtStartPar
minsizerel
&
\sphinxAtStartPar
minsizerel
&&
\sphinxAtStartPar
\sphinxhyphen{}Os
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
In addition to setting compiler flags each build type also controls whether certain features are enabled or not:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ns3 \sphinxhyphen{}\sphinxhyphen{}build\sphinxhyphen{}profile}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS3\_ASSERT}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS3\_LOG}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS3\_WARNINGS\_AS\_ERRORS}}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
debug
&
\sphinxAtStartPar
ON
&
\sphinxAtStartPar
ON
&
\sphinxAtStartPar
ON
\\
\sphinxhline
\sphinxAtStartPar
default
&
\sphinxAtStartPar
ON
&
\sphinxAtStartPar
ON
&
\sphinxAtStartPar
OFF
\\
\sphinxhline
\sphinxAtStartPar
release
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
\\
\sphinxhline
\sphinxAtStartPar
optimized
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
\\
\sphinxhline
\sphinxAtStartPar
minsizerel
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS3\_ASSERT}} and \sphinxcode{\sphinxupquote{NS\_LOG}} control whether the assert or logging macros
are functional or compiled out.
\sphinxcode{\sphinxupquote{NS3\_WARNINGS\_AS\_ERRORS}} controls whether compiler warnings are treated
as errors and stop the build, or whether they are only warnings and
allow the build to continue.


\subsubsection{Configuring the project with CMake}
\label{\detokenize{working-with-cmake:configuring-the-project-with-cmake}}
\sphinxAtStartPar
Navigate to the ns\sphinxhyphen{}3\sphinxhyphen{}dev directory, create a CMake cache folder,
navigate to it and run \sphinxhref{https://cmake.org/cmake/help/latest/manual/cmake.1.html}{CMake} pointing to the ns\sphinxhyphen{}3\sphinxhyphen{}dev folder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} cd ns\PYGZhy{}3\PYGZhy{}dev}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} mkdir cmake\PYGZhy{}cache}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} cd cmake\PYGZhy{}cache}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can pass additional arguments to the CMake command, to configure it. To change variable values,
you should use the \sphinxhyphen{}D option followed by the variable name.

\sphinxAtStartPar
As an example, the build type is stored in the variable named \sphinxhref{https://cmake.org/cmake/help/latest/variable/CMAKE\_BUILD\_TYPE.html}{CMAKE\_BUILD\_TYPE}. Setting it to one
of the CMake build types shown in the table below will change compiler settings associated with those
build types and output executable and libraries names, which will receive a suffix.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
CMAKE\_BUILD\_TYPE
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxhref{https://github.com/Kitware/CMake/blob/master/Modules/Compiler/GNU.cmake}{Effects (g++)}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
DEBUG
&
\sphinxAtStartPar
\sphinxhyphen{}g
\\
\sphinxhline
\sphinxAtStartPar
DEFAULT
&
\sphinxAtStartPar
\sphinxhyphen{}O2 \sphinxhyphen{}g \sphinxhyphen{}DNDEBUG
\\
\sphinxhline
\sphinxAtStartPar
RELWITHDEBINFO
&
\sphinxAtStartPar
\sphinxhyphen{}O2 \sphinxhyphen{}g \sphinxhyphen{}DNDEBUG
\\
\sphinxhline
\sphinxAtStartPar
RELEASE
&
\sphinxAtStartPar
\sphinxhyphen{}O3 \sphinxhyphen{}DNDEBUG
\\
\sphinxhline
\sphinxAtStartPar
MINSIZEREL
&
\sphinxAtStartPar
\sphinxhyphen{}Os \sphinxhyphen{}DNDEBUG
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
You can set the build type with the following command, which assumes your terminal is inside the cache folder
created previously.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake \PYGZhy{}DCMAKE\PYGZus{}BUILD\PYGZus{}TYPE=DEBUG ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
Another common option to change is the \sphinxhref{https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html}{generator}, which is the real underlying build system called by CMake.
There are many generators supported by CMake, including the ones listed in the table below.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{T}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Generators
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
MinGW Makefiles
\\
\sphinxhline
\sphinxAtStartPar
Unix Makefiles
\\
\sphinxhline
\sphinxAtStartPar
MSYS Makefiles
\\
\sphinxhline
\sphinxAtStartPar
CodeBlocks \sphinxhyphen{} \sphinxstyleemphasis{one of the previous Makefiles}
\\
\sphinxhline
\sphinxAtStartPar
Eclipse CDT4 \sphinxhyphen{} \sphinxstyleemphasis{one of the previous Makefiles}
\\
\sphinxhline
\sphinxAtStartPar
Ninja
\\
\sphinxhline
\sphinxAtStartPar
Xcode
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
To change the generator, you will need to pass one of these generators with the \sphinxhyphen{}G option. For example, if we
prefer Ninja to Makefiles, which are the default, we need to run the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake \PYGZhy{}G Ninja ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
This command may fail if there are different generator files in the same CMake cache folder. It is recommended to clean up
the CMake cache folder, then recreate it and reconfigure setting the generator in the first run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cd ..}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} rm \PYGZhy{}R cmake\PYGZhy{}cache \PYGZam{}\PYGZam{} mkdir cmake\PYGZhy{}cache \PYGZam{}\PYGZam{} cd cmake\PYGZhy{}cache}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake \PYGZhy{}DCMAKE\PYGZus{}BUILD\PYGZus{}TYPE=release \PYGZhy{}G Ninja ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
After configuring for the first time, settings will be initialized to their
default values, and then you can use the \sphinxcode{\sphinxupquote{ccmake}} command to manually change them:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} ccmake .}
\PYG{g+go}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE                 release}
\PYG{g+go}{CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX             /usr/local}
\PYG{g+go}{NS3\PYGZus{}ASSERT                       OFF}
\PYG{g+go}{...}
\PYG{g+go}{NS3\PYGZus{}EXAMPLES                     ON}
\PYG{g+go}{...}
\PYG{g+go}{NS3\PYGZus{}LOG                          OFF}
\PYG{g+go}{NS3\PYGZus{}TESTS                        ON}
\PYG{g+go}{NS3\PYGZus{}VERBOSE                      OFF}
\PYG{g+go}{...}

\PYG{g+go}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE: Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel ...}
\PYG{g+go}{Keys: [enter] Edit an entry [d] Delete an entry                                                                                             CMake Version 3.22.1}
\PYG{g+go}{      [l] Show log output   [c] Configure}
\PYG{g+go}{      [h] Help              [q] Quit without generating}
\PYG{g+go}{      [t] Toggle advanced mode (currently off)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After moving the cursor and setting the desired values, type \sphinxcode{\sphinxupquote{c}} to configure CMake.

\sphinxAtStartPar
If you prefer doing everything with a non\sphinxhyphen{}interactive command, look at the main \sphinxcode{\sphinxupquote{CMakeLists.txt}}
file in the ns\sphinxhyphen{}3\sphinxhyphen{}dev directory. It contains most of the option flags and their default values.
To enable both examples and tests, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake \PYGZhy{}DNS3\PYGZus{}EXAMPLES=ON \PYGZhy{}DNS3\PYGZus{}TESTS=ON ..}
\end{sphinxVerbatim}


\subsection{Manually refresh the CMake cache}
\label{\detokenize{working-with-cmake:manually-refresh-the-cmake-cache}}\label{\detokenize{working-with-cmake:id2}}
\sphinxAtStartPar
After the project has been configured, calling \sphinxcode{\sphinxupquote{CMake}} will
{\hyperref[\detokenize{working-with-cmake:manually-refresh-the-cmake-cache}]{\sphinxcrossref{\DUrole{std,std-ref}{refresh the CMake cache}}}}.
The refresh is required to discover new targets: libraries, executables and/or modules
that were created since the last run.

\sphinxAtStartPar
The refresh is done by running the CMake command from the CMake cache folder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
Previous settings stored in the CMakeCache.txt will be preserved, while new modules will be
scanned and targets will be added.

\sphinxAtStartPar
The cache can also be refreshed with the \sphinxcode{\sphinxupquote{ns3}} wrapper script:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure}
\end{sphinxVerbatim}


\subsection{Building the project}
\label{\detokenize{working-with-cmake:building-the-project}}
\sphinxAtStartPar
There are three ways of building the project:
using the \sphinxcode{\sphinxupquote{ns3}} script, calling \sphinxcode{\sphinxupquote{CMake}} and
calling the underlying build system (e.g. Ninja) directly.
The last way is omitted, since each underlying build system
has its own unique command\sphinxhyphen{}line syntax.


\subsubsection{Building the project with \sphinxstyleliteralintitle{\sphinxupquote{ns3}}}
\label{\detokenize{working-with-cmake:building-the-project-with-ns3}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ns3}} wrapper script makes life easier for command line users, accepting module names without
the \sphinxcode{\sphinxupquote{lib}} prefix and scratch files without the \sphinxcode{\sphinxupquote{scratch\_}} prefix. The following command can
be used to build the entire project:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build}
\end{sphinxVerbatim}

\sphinxAtStartPar
To build specific targets, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build target\PYGZus{}name}
\end{sphinxVerbatim}


\subsubsection{Building the project with CMake}
\label{\detokenize{working-with-cmake:building-the-project-with-cmake}}
\sphinxAtStartPar
The build process of targets (either libraries, executables or custom tasks) can be done
invoking CMake build. To build all the targets, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake \PYGZhy{}\PYGZhy{}build .}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice the single dot now refers to the \sphinxcode{\sphinxupquote{cmake\sphinxhyphen{}cache}} directory, where the underlying
build system files are stored (referred inside CMake as \sphinxcode{\sphinxupquote{PROJECT\_BINARY\_DIR}} or
\sphinxcode{\sphinxupquote{CMAKE\_BINARY\_DIR}}, which have slightly different uses if working with sub\sphinxhyphen{}projects).

\sphinxAtStartPar
To build specific targets, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake \PYGZhy{}\PYGZhy{}build . \PYGZhy{}\PYGZhy{}target target\PYGZus{}name}
\end{sphinxVerbatim}

\sphinxAtStartPar
Where target\_name is a valid target name. Module libraries are prefixed with \sphinxcode{\sphinxupquote{lib}} (e.g. libcore),
executables from the scratch folder are prefixed with \sphinxcode{\sphinxupquote{scratch\_}} (e.g. scratch\_scratch\sphinxhyphen{}simulator).
Executables targets have their source file name without the “.cc” prefix
(e.g. sample\sphinxhyphen{}simulator.cc =\textgreater{} sample\sphinxhyphen{}simulator).


\subsection{Adding a new module}
\label{\detokenize{working-with-cmake:adding-a-new-module}}
\sphinxAtStartPar
Adding a module is the only case where
{\hyperref[\detokenize{working-with-cmake:manually-refresh-the-cmake-cache}]{\sphinxcrossref{\DUrole{std,std-ref}{manually refreshing the CMake cache}}}} is required.

\sphinxAtStartPar
More information on how to create a new module are provided in {\hyperref[\detokenize{new-modules:adding-a-new-module-to-ns3}]{\sphinxcrossref{\DUrole{std,std-ref}{Adding a New Module to ns\sphinxhyphen{}3}}}}.


\subsection{Migrating a Waf module to CMake}
\label{\detokenize{working-with-cmake:migrating-a-waf-module-to-cmake}}
\sphinxAtStartPar
If your module does not have external dependencies, porting is very easy.
Start by copying the module Wscript, rename them to CMakeLists.txt and then open it.

\sphinxAtStartPar
We are going to use the aodv module as an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{build}\PYG{p}{(}\PYG{n}{bld}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{module} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{internet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wifi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
  \PYG{n}{module}\PYG{o}{.}\PYG{n}{includes} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{module}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}id\PYGZhy{}cache.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}dpd.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}rtable.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}rqueue.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}packet.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}neighbor.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}routing\PYGZhy{}protocol.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/aodv\PYGZhy{}helper.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{p}{]}

  \PYG{n}{aodv\PYGZus{}test} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}module\PYGZus{}test\PYGZus{}library}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{aodv\PYGZus{}test}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/aodv\PYGZhy{}id\PYGZhy{}cache\PYGZhy{}test\PYGZhy{}suite.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/aodv\PYGZhy{}test\PYGZhy{}suite.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/aodv\PYGZhy{}regression.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/bug\PYGZhy{}772.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/loopback.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{p}{]}

  \PYG{c+c1}{\PYGZsh{} Tests encapsulating example programs should be listed here}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{bld}\PYG{o}{.}\PYG{n}{env}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ENABLE\PYGZus{}EXAMPLES}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{aodv\PYGZus{}test}\PYG{o}{.}\PYG{n}{source}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}
      \PYG{c+c1}{\PYGZsh{}   \PYGZsq{}test/aodv\PYGZhy{}examples\PYGZhy{}test\PYGZhy{}suite.cc\PYGZsq{},}
          \PYG{p}{]}\PYG{p}{)}

  \PYG{n}{headers} \PYG{o}{=} \PYG{n}{bld}\PYG{p}{(}\PYG{n}{features}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ns3header}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{headers}\PYG{o}{.}\PYG{n}{module} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{headers}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}id\PYGZhy{}cache.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}dpd.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}rtable.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}rqueue.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}packet.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}neighbor.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/aodv\PYGZhy{}routing\PYGZhy{}protocol.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/aodv\PYGZhy{}helper.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{p}{]}

  \PYG{k}{if} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{env}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ENABLE\PYGZus{}EXAMPLES}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
      \PYG{n}{bld}\PYG{o}{.}\PYG{n}{recurse}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{examples}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

  \PYG{n}{bld}\PYG{o}{.}\PYG{n}{ns3\PYGZus{}python\PYGZus{}bindings}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can see the module name is \sphinxcode{\sphinxupquote{aodv}} and it depends on the \sphinxcode{\sphinxupquote{internet}} and the \sphinxcode{\sphinxupquote{wifi}} libraries,
plus the lists of files (\sphinxcode{\sphinxupquote{module.source}}, \sphinxcode{\sphinxupquote{headers.source}} and \sphinxcode{\sphinxupquote{module\_test.source}}).

\sphinxAtStartPar
This translates to the following CMake lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{aodv}\PYG{+w}{ }\PYG{c}{\PYGZsh{} aodv module, which can later be linked to examples and modules with \PYGZdl{}\PYGZob{}libaodv\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{c}{\PYGZsh{} equivalent to module.source}
\PYG{+w}{    }\PYG{l+s}{helper/aodv\PYGZhy{}helper.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}dpd.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}id\PYGZhy{}cache.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}neighbor.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}packet.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}routing\PYGZhy{}protocol.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}rqueue.cc}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}rtable.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{c}{\PYGZsh{} equivalent to headers.source}
\PYG{+w}{    }\PYG{l+s}{helper/aodv\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}dpd.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}id\PYGZhy{}cache.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}neighbor.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}packet.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}routing\PYGZhy{}protocol.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}rqueue.h}
\PYG{+w}{    }\PYG{l+s}{model/aodv\PYGZhy{}rtable.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} depends on internet and wifi,}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libwifi}\PYG{o}{\PYGZcb{}}\PYG{+w}{     }\PYG{c}{\PYGZsh{} but both are prefixed with lib in CMake}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}\PYG{+w}{ }\PYG{c}{\PYGZsh{} equivalent to module\PYGZus{}test.source}
\PYG{+w}{    }\PYG{l+s}{test/aodv\PYGZhy{}id\PYGZhy{}cache\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/aodv\PYGZhy{}regression.cc}
\PYG{+w}{    }\PYG{l+s}{test/aodv\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/loopback.cc}
\PYG{+w}{    }\PYG{l+s}{test/bug\PYGZhy{}772.cc}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If your module depends on external libraries, check the section
{\hyperref[\detokenize{working-with-cmake:linking-third-party-libraries}]{\sphinxcrossref{Linking third\sphinxhyphen{}party libraries}}}.

\sphinxAtStartPar
Python bindings are generated at runtime for all built modules
if NS3\_PYTHON\_BINDINGS is enabled.

\sphinxAtStartPar
Next, we need to port the examples wscript. Repeat the copy, rename and open
steps. We should have something like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{build}\PYG{p}{(}\PYG{n}{bld}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{obj} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}program}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                 \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wifi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{internet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{internet\PYGZhy{}apps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{obj}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv.cc}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This means we create an example named \sphinxcode{\sphinxupquote{aodv}} which depends on \sphinxcode{\sphinxupquote{wifi}}, \sphinxcode{\sphinxupquote{internet}},
\sphinxcode{\sphinxupquote{aodv}} and \sphinxcode{\sphinxupquote{internet\sphinxhyphen{}apps}} module, and has a single source file \sphinxcode{\sphinxupquote{aodv.cc}}.
This translates into the following CMake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib\PYGZus{}example}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{aodv}\PYG{+w}{ }\PYG{c}{\PYGZsh{} example named aodv}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{aodv.cc}\PYG{+w}{ }\PYG{c}{\PYGZsh{} single source file aodv.cc}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{c}{\PYGZsh{} depends on wifi, internet, aodv and internet\PYGZhy{}apps}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libwifi}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libaodv}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet\PYGZhy{}apps}\PYG{o}{\PYGZcb{}}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Migrating definitions, compilation and linking options}
\label{\detokenize{working-with-cmake:migrating-definitions-compilation-and-linking-options}}
\sphinxAtStartPar
If your Waf modules had additional definitions, compilation or linking flags,
you also need to translate them to CMake. The easiest way to accomplish that
is using the CMake counterparts \sphinxstyleemphasis{BEFORE} defining your target.

\sphinxAtStartPar
If you, for example, had the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conf}\PYG{o}{.}\PYG{n}{env}\PYG{o}{.}\PYG{n}{append\PYGZus{}value}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CXXFLAGS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}fopenmp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}I/usr/local/include/e2sim}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{conf}\PYG{o}{.}\PYG{n}{env}\PYG{o}{.}\PYG{n}{append\PYGZus{}value}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CXXDEFINES}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LAPACK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LUSOLVER=LAPACK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{conf}\PYG{o}{.}\PYG{n}{env}\PYG{o}{.}\PYG{n}{append\PYGZus{}value}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LINKFLAGS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}llapack}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}L/usr/local/src/GoToBLAS2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}lblas}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}Lsrc/common}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}lthyme}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{conf}\PYG{o}{.}\PYG{n}{env}\PYG{o}{.}\PYG{n}{append\PYGZus{}value}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LIB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e2sim}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You would need to replace it with the following counterparts:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} The settings below will impact all future target declarations}
\PYG{c}{\PYGZsh{} in the current subdirectory and its subdirectories}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} a.k.a. the module, its examples and tests will have the definitions,}
\PYG{c}{\PYGZsh{} compilation options and will be linked to the specified libraries}
\PYG{n+nb}{add\PYGZus{}compile\PYGZus{}options}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}fopenmp}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} CXXFLAGS counterpart}
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{l+s}{/usr/local/include/e2sim}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} CXXFLAGS \PYGZhy{}I counterpart}
\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}DLAPACK}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}DLUSOLVER=LAPACK}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} CXXDEFINES counterpart}
\PYG{n+nb}{link\PYGZus{}directories}\PYG{p}{(}\PYG{l+s}{/usr/local/src/GoToBLAS2}\PYG{+w}{ }\PYG{l+s}{src/common}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} LINKFLAGS \PYGZhy{}L counterpart}
\PYG{n+nb}{link\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{lapack}\PYG{+w}{ }\PYG{l+s}{blas}\PYG{+w}{ }\PYG{l+s}{thyme}\PYG{+w}{ }\PYG{l+s}{e2sim}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} LINKFLAGS \PYGZhy{}l or LIB counterpart}

\PYG{c}{\PYGZsh{} Target definition after changing settings}
\PYG{n+nb}{build\PYGZus{}lib\PYGZus{}example}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{hypothetical\PYGZhy{}module}
\PYG{+w}{    }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{hypothetical\PYGZhy{}module\PYGZhy{}source.cc}
\PYG{+w}{    }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} depends on wifi, internet, aodv and internet\PYGZhy{}apps modules}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libwifi}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libaodv}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet\PYGZhy{}apps}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} and lapack, blas, thyme, e2sim external libraries}
\PYG{+w}{  }\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Running programs}
\label{\detokenize{working-with-cmake:running-programs}}
\sphinxAtStartPar
Running programs with the \sphinxcode{\sphinxupquote{ns3}} wrapper script is pretty simple. To run the
scratch program produced by \sphinxcode{\sphinxupquote{scratch/scratch\sphinxhyphen{}simulator.cc}}, you need the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 run scratch\PYGZhy{}simulator \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}build}} indicates that the program should only be executed, and not built
before execution.

\sphinxAtStartPar
To familiarize users with CMake, \sphinxcode{\sphinxupquote{ns3}} can also print the underlying CMake
and command line commands used by adding the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}} flag.
Removing the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}build}} flag and adding \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}} to the same example,
produces the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 \PYGZhy{}\PYGZhy{}dry\PYGZhy{}run run scratch\PYGZhy{}simulator}
\PYG{g+go}{The following commands would be executed:}
\PYG{g+go}{cd cmake\PYGZhy{}cache; cmake \PYGZhy{}\PYGZhy{}build . \PYGZhy{}j 15 \PYGZhy{}\PYGZhy{}target scratch\PYGZus{}scratch\PYGZhy{}simulator ; cd ..}
\PYG{g+go}{export PATH=\PYGZdl{}PATH:\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib}
\PYG{g+go}{export PYTHONPATH=\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/bindings/python}
\PYG{g+go}{export LD\PYGZus{}LIBRARY\PYGZus{}PATH=\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib}
\PYG{g+go}{./build/scratch/ns3\PYGZhy{}dev\PYGZhy{}scratch\PYGZhy{}simulator}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the CMake build command line, notice the scratch\sphinxhyphen{}simulator has a \sphinxcode{\sphinxupquote{scratch\_}} prefix.
That is true for all the CMake scratch targets. This is done to guarantee globally unique names.
Similarly, library\sphinxhyphen{}related targets have \sphinxcode{\sphinxupquote{lib}} as a prefix (e.g. \sphinxcode{\sphinxupquote{libcore}}, \sphinxcode{\sphinxupquote{libnetwork}}).

\sphinxAtStartPar
The next few lines exporting variables guarantee the executable can find python dependencies
(\sphinxcode{\sphinxupquote{PYTHONPATH}}) and linked libraries (\sphinxcode{\sphinxupquote{LD\_LIBRARY\_PATH}} and \sphinxcode{\sphinxupquote{PATH}} on Unix\sphinxhyphen{}like, and
\sphinxcode{\sphinxupquote{PATH}} on Windows). This is not necessary in platforms that support \sphinxhref{https://cmake.org/cmake/help/latest/variable/CMAKE\_BUILD\_RPATH.html}{RPATH}.

\sphinxAtStartPar
Notice that when the scratch\sphinxhyphen{}simulator program is called on the last line, it has
a \sphinxcode{\sphinxupquote{ns3\sphinxhyphen{}\textless{}version\textgreater{}}} prefix and could also have a build type suffix.
This is valid for all libraries and executables, but omitted in \sphinxcode{\sphinxupquote{ns3}} for simplicity.

\sphinxAtStartPar
Debugging can be done with GDB. Again, we have the two ways to run the program.
Using the \sphinxcode{\sphinxupquote{ns3}} wrapper:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 run scratch\PYGZhy{}simulator \PYGZhy{}\PYGZhy{}no\PYGZhy{}build \PYGZhy{}\PYGZhy{}gdb}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or directly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} export PATH=\PYGZdl{}PATH:\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} export PYTHONPATH=\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/bindings/python}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} export LD\PYGZus{}LIBRARY\PYGZus{}PATH=\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} gdb ../build/scratch/ns3\PYGZhy{}dev\PYGZhy{}scratch\PYGZhy{}simulator}
\end{sphinxVerbatim}


\subsection{Modifying files}
\label{\detokenize{working-with-cmake:modifying-files}}
\sphinxAtStartPar
As CMake is not a build system on itself, but a meta build system, it requires
frequent refreshes, also known as reconfigurations. Those refreshes are triggered
automatically in the following cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Changes in linked libraries

\item {} 
\sphinxAtStartPar
Changes in the CMake code

\item {} 
\sphinxAtStartPar
Header changes

\item {} 
\sphinxAtStartPar
Header/source file name changes

\item {} 
\sphinxAtStartPar
Module name changes

\end{itemize}

\sphinxAtStartPar
The following sections will detail some of these cases assuming a hypothetical module defined below.
Notice that the build\_lib is the fundamental piece of every \sphinxstyleemphasis{ns\sphinxhyphen{}3} module, while user\sphinxhyphen{}settable
options and external libraries checking are optional.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{hypothetical}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{  }\PYG{l+s}{helper/hypothetical\PYGZhy{}helper.cc}
\PYG{+w}{                }\PYG{l+s}{model/hypothetical.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{helper/hypothetical\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{model/hypothetical.h}
\PYG{+w}{    }\PYG{l+s}{model/colliding\PYGZhy{}header.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Module name changes}
\label{\detokenize{working-with-cmake:module-name-changes}}
\sphinxAtStartPar
Changing the module name requires changing the value of \sphinxcode{\sphinxupquote{LIBNAME}}.
In the following example the name of the module seen previously is
changed from \sphinxcode{\sphinxupquote{hypothetical}} to \sphinxcode{\sphinxupquote{new\sphinxhyphen{}hypothetical\sphinxhyphen{}name}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}hypothetical\PYGZhy{}name}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the module was already scanned, saving the changes and trying to build will trigger the
automatic CMake refresh. Otherwise, reconfigure the project to
{\hyperref[\detokenize{working-with-cmake:manually-refresh-the-cmake-cache}]{\sphinxcrossref{\DUrole{std,std-ref}{manually refresh it}}}}.


\subsubsection{Header/source file name changes}
\label{\detokenize{working-with-cmake:header-source-file-name-changes}}
\sphinxAtStartPar
Assuming the hypothetical module defined previously has a header name that collides
with a header of a different module.

\sphinxAtStartPar
The name of the \sphinxcode{\sphinxupquote{colliding\sphinxhyphen{}header.h}} can be changed via the filesystem to
\sphinxcode{\sphinxupquote{non\sphinxhyphen{}colliding\sphinxhyphen{}header.h}}, and the \sphinxcode{\sphinxupquote{CMakeLists.txt}} path needs to be updated to match
the new name. Some IDEs can do this automatically through refactoring tools.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}hypothetical\PYGZhy{}name}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}
\PYG{+w}{      }\PYG{l+s}{helper/hypothetical\PYGZhy{}helper.h}
\PYG{+w}{      }\PYG{l+s}{model/hypothetical.h}
\PYG{+w}{      }\PYG{l+s}{model/non\PYGZhy{}colliding\PYGZhy{}header.h}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Linking \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules}
\label{\detokenize{working-with-cmake:linking-ns3-modules}}
\sphinxAtStartPar
Adding a dependency to another \sphinxstyleemphasis{ns\sphinxhyphen{}3} module just requires adding \sphinxcode{\sphinxupquote{\$\{lib\$\{modulename\}\}}}
to the \sphinxcode{\sphinxupquote{LIBRARIES\_TO\_LINK}} list, where modulename contains the value of the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
module which will be depended upon.

\sphinxAtStartPar
Note: All \sphinxstyleemphasis{ns\sphinxhyphen{}3} module libraries are prefixed with \sphinxcode{\sphinxupquote{lib}},
as CMake requires unique global target names.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now \PYGZdl{}\PYGZob{}libnew\PYGZhy{}hypothetical\PYGZhy{}name\PYGZcb{} will depend on both core and internet modules}
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}hypothetical\PYGZhy{}name}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Linking third\sphinxhyphen{}party libraries}
\label{\detokenize{working-with-cmake:linking-third-party-libraries}}\label{\detokenize{working-with-cmake:id3}}
\sphinxAtStartPar
Depending on a third\sphinxhyphen{}party library is a bit more complicated as we have multiple
ways to handle that within CMake.

\sphinxAtStartPar
Here is a short version on how to find and use third\sphinxhyphen{}party libraries
that should work in most cases:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} DEPENDENCY\PYGZus{}NAME is used as a prefix to variables set by the find\PYGZus{}external\PYGZus{}library macro}
\PYG{c}{\PYGZsh{} HEADER\PYGZus{}NAME(S) is(are) the name(s) of the header(s) you want to include}
\PYG{c}{\PYGZsh{} LIBRARY\PYGZus{}NAME(S) is(are) the name(s) of the library(ies) you want to link}
\PYG{c}{\PYGZsh{} SEARCH\PYGZus{}PATHS are the custom paths you can give if your library is not on a system path}
\PYG{n+nb}{find\PYGZus{}external\PYGZus{}library}\PYG{p}{(}\PYG{l+s}{DEPENDENCY\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{SQLite3}
\PYG{+w}{                      }\PYG{l+s}{HEADER\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{sqlite3.h}
\PYG{+w}{                      }\PYG{l+s}{LIBRARY\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{sqlite3}
\PYG{+w}{                      }\PYG{l+s}{SEARCH\PYGZus{}PATHS}\PYG{+w}{ }\PYG{l+s}{/optional/search/path/to/custom/sqlite3/library}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If the header(s) and library(ies) are not found, a message will be printed during the configuration}
\PYG{c}{\PYGZsh{} If the header(s) and the library(ies) are found, we can use the information found by the buildsystem}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Notice that the contents of DEPENDENCY\PYGZus{}NAME became a prefix for the \PYGZus{}FOUND variable}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} The compiler will not be able to find the include that is not on}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} a system include path, unless we explicitly inform it}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} This is the equivalent of \PYGZhy{}I/optional/search/path/to/custom/sqlite3/include}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} and AFFECTS ALL the targets in the CURRENT DIRECTORY and ITS SUBDIRECTORIES}
\PYG{+w}{    }\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} The compiler should be able to locate the headers, but it still needs to be}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} informed of the libraries that should be linked}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} This is the equivalent of \PYGZhy{}l/optional/search/path/to/custom/sqlite3/library/libsqlite3.so}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} and AFFECTS ALL the targets in the CURRENT DIRECTORY and ITS SUBDIRECTORIES}
\PYG{+w}{    }\PYG{n+nb}{link\PYGZus{}libraries}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you do not want to link the library against all the targets
(executables and other libraries) use one of the following patterns.

\sphinxAtStartPar
\sphinxstylestrong{If the third\sphinxhyphen{}party library is required}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} if the third\PYGZhy{}party library is required}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} define your target}
\PYG{+w}{    }\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{        }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{example}
\PYG{+w}{        }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{        }\PYG{l+s}{...}
\PYG{+w}{    }\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} The LIBRARIES\PYGZus{}TO\PYGZus{}LINK will be translated into CMake\PYGZsq{}s}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} target\PYGZus{}link\PYGZus{}libraries(\PYGZdl{}\PYGZob{}libexample\PYGZcb{} PUBLIC \PYGZdl{}\PYGZob{}SQLite3\PYGZus{}LIBRARIES\PYGZcb{})}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} which is equivalent to \PYGZhy{}l\PYGZdl{}\PYGZob{}SQLite3\PYGZus{}LIBRARIES\PYGZcb{}}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{If the third\sphinxhyphen{}party library is optional}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}libraries}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}libraries}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} And then define your target}
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{example}
\PYG{+w}{    }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{sqlite\PYGZus{}libraries}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} variable can be empty}
\PYG{+w}{    }\PYG{l+s}{...}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
More details on how find\_external\_library works and the other
ways to import third\sphinxhyphen{}party libraries are presented next.

\sphinxAtStartPar
It is recommended to use a system package managers to install libraries,
but ns\sphinxhyphen{}3 also supports vcpkg and CPM. More information on how to
use them is available in {\hyperref[\detokenize{working-with-cmake:using-c-library-managers}]{\sphinxcrossref{Using C++ library managers}}}.


\paragraph{Linking third\sphinxhyphen{}party libraries without CMake or PkgConfig support}
\label{\detokenize{working-with-cmake:linking-third-party-libraries-without-cmake-or-pkgconfig-support}}\label{\detokenize{working-with-cmake:id4}}
\sphinxAtStartPar
When the third\sphinxhyphen{}party library you want to use do not export CMake files to use
\sphinxcode{\sphinxupquote{find\_package}} or PkgConfig files to use \sphinxcode{\sphinxupquote{pkg\_check\_modules}}, we need to
search for the headers and libraries manually. To simplify this process,
we include the macro \sphinxcode{\sphinxupquote{find\_external\_library}} that searches for libraries and
header include directories, exporting results similarly to \sphinxcode{\sphinxupquote{find\_package}}.

\sphinxAtStartPar
Here is how it works:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{find\PYGZus{}external\PYGZus{}library}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Parse arguments}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{options}\PYG{+w}{ }\PYG{l+s}{QUIET}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{oneValueArgs}\PYG{+w}{ }\PYG{l+s}{DEPENDENCY\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{HEADER\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{LIBRARY\PYGZus{}NAME}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{multiValueArgs}\PYG{+w}{ }\PYG{l+s}{HEADER\PYGZus{}NAMES}\PYG{+w}{ }\PYG{l+s}{LIBRARY\PYGZus{}NAMES}\PYG{+w}{ }\PYG{l+s}{PATH\PYGZus{}SUFFIXES}\PYG{+w}{ }\PYG{l+s}{SEARCH\PYGZus{}PATHS}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{cmake\PYGZus{}parse\PYGZus{}arguments}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}FIND\PYGZus{}LIB\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}options\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}oneValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}multiValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ARGN}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Set the external package/dependency name}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{name}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{FIND\PYGZus{}LIB\PYGZus{}DEPENDENCY\PYGZus{}NAME}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} We process individual and list of headers and libraries by transforming them}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} into lists}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{library\PYGZus{}names}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}FIND\PYGZus{}LIB\PYGZus{}LIBRARY\PYGZus{}NAME\PYGZcb{};\PYGZdl{}\PYGZob{}FIND\PYGZus{}LIB\PYGZus{}LIBRARY\PYGZus{}NAMES\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}names}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}FIND\PYGZus{}LIB\PYGZus{}HEADER\PYGZus{}NAME\PYGZcb{};\PYGZdl{}\PYGZob{}FIND\PYGZus{}LIB\PYGZus{}HEADER\PYGZus{}NAMES\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Just changing the parsed argument name back to something shorter}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{search\PYGZus{}paths}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{FIND\PYGZus{}LIB\PYGZus{}SEARCH\PYGZus{}PATHS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{path\PYGZus{}suffixes}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}FIND\PYGZus{}LIB\PYGZus{}PATH\PYGZus{}SUFFIXES\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{not\PYGZus{}found\PYGZus{}libraries}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{library\PYGZus{}dirs}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{libraries}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Paths and suffixes where libraries will be searched on}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{library\PYGZus{}search\PYGZus{}paths}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{search\PYGZus{}paths}\PYG{o}{\PYGZcb{}}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Search for libraries in ns\PYGZhy{}3\PYGZhy{}dev/build}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Search for libraries in the install directory (e.g. /usr/)}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}ENV\PYGZob{}}\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Search for libraries in LD\PYGZus{}LIBRARY\PYGZus{}PATH directories}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}ENV\PYGZob{}}\PYG{n+nv}{PATH}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Search for libraries in PATH directories}
\PYG{+w}{          }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{suffixes}\PYG{+w}{ }\PYG{l+s}{/build}\PYG{+w}{ }\PYG{l+s}{/lib}\PYG{+w}{ }\PYG{l+s}{/build/lib}\PYG{+w}{ }\PYG{l+s}{/}\PYG{+w}{ }\PYG{l+s}{/bin}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{path\PYGZus{}suffixes}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} For each of the library names in LIBRARY\PYGZus{}NAMES or LIBRARY\PYGZus{}NAME}
\PYG{+w}{  }\PYG{n+nb}{foreach}\PYG{p}{(}\PYG{l+s}{library}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library\PYGZus{}names}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} We mark this value is advanced not to pollute the configuration with}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ccmake with the cache variables used internally}
\PYG{+w}{    }\PYG{n+nb}{mark\PYGZus{}as\PYGZus{}advanced}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} We search for the library named \PYGZdl{}\PYGZob{}library\PYGZcb{} and store the results in}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}name\PYGZcb{}\PYGZus{}library\PYGZus{}internal\PYGZus{}\PYGZdl{}\PYGZob{}library\PYGZcb{}}
\PYG{+w}{    }\PYG{n+nb}{find\PYGZus{}library}\PYG{p}{(}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{HINTS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library\PYGZus{}search\PYGZus{}paths}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{PATH\PYGZus{}SUFFIXES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{suffixes}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: off}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Note: the PATH\PYGZus{}SUFFIXES above apply to *ALL* PATHS and HINTS Which}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} translates to CMake searching on standard library directories}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH, user\PYGZhy{}settable CMAKE\PYGZus{}PREFIX\PYGZus{}PATH or}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} CMAKE\PYGZus{}LIBRARY\PYGZus{}PATH and the directories listed above}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} e.g.  from Ubuntu 22.04 CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH =}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local;/usr;/;/usr/local;/usr/X11R6;/usr/pkg;/opt}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Searched directories without suffixes}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH\PYGZcb{}[0] = /usr/local/}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH\PYGZcb{}[1] = /usr}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH\PYGZcb{}[2] = /}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH\PYGZcb{}[6] = /opt}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}LD\PYGZus{}LIBRARY\PYGZus{}PATH\PYGZcb{}[0]}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}LD\PYGZus{}LIBRARY\PYGZus{}PATH\PYGZcb{}[m]}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Searched directories with suffixes include all of the directories above}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} plus all suffixes}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} PATH\PYGZus{}SUFFIXES /build /lib /build/lib / /bin \PYGZsh{} \PYGZdl{}\PYGZob{}path\PYGZus{}suffixes\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/build}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/lib}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/build/lib}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/bin}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: on}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Or enable NS3\PYGZus{}VERBOSE to print the searched paths}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} Print tested paths to the searched library and if it was found}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VERBOSE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{log\PYGZus{}find\PYGZus{}searched\PYGZus{}paths}\PYG{p}{(}
\PYG{+w}{              }\PYG{l+s}{TARGET\PYGZus{}TYPE}\PYG{+w}{ }\PYG{l+s}{Library}
\PYG{+w}{              }\PYG{l+s}{TARGET\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}RESULT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}PATHS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library\PYGZus{}search\PYGZus{}paths}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}SUFFIXES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{suffixes}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} After searching the library, the internal variable should have either the}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} absolute path to the library or the name of the variable appended with}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZhy{}NOTFOUND}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}\PYGZdl{}\PYGZob{}name\PYGZcb{}\PYGZus{}library\PYGZus{}internal\PYGZus{}\PYGZdl{}\PYGZob{}library\PYGZcb{}\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{STREQUAL}
\PYG{+w}{       }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}name\PYGZcb{}\PYGZus{}library\PYGZus{}internal\PYGZus{}\PYGZdl{}\PYGZob{}library\PYGZcb{}\PYGZhy{}NOTFOUND\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} We keep track of libraries that were not found}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{not\PYGZus{}found\PYGZus{}libraries}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} We get the name of the parent directory of the library and append the}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} library to a list of found libraries}
\PYG{+w}{      }\PYG{n+nb}{get\PYGZus{}filename\PYGZus{}component}\PYG{p}{(}
\PYG{+w}{        }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}dir\PYGZus{}internal}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}\PYGZob{}name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{        }\PYG{l+s}{DIRECTORY}
\PYG{+w}{      }\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} e.g. lib/openflow.(so|dll|dylib|a) \PYGZhy{}\PYGZgt{} lib}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{library\PYGZus{}dirs}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}\PYGZob{}name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}dir\PYGZus{}internal\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{libraries}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}\PYGZob{}name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}library\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endforeach}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} For each library that was found (e.g. /usr/lib/pthread.so), get their parent}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} directory (/usr/lib) and its parent (/usr)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{parent\PYGZus{}dirs}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{foreach}\PYG{p}{(}\PYG{l+s}{libdir}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library\PYGZus{}dirs}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{get\PYGZus{}filename\PYGZus{}component}\PYG{p}{(}\PYG{l+s}{parent\PYGZus{}libdir}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libdir}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{DIRECTORY}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{get\PYGZus{}filename\PYGZus{}component}\PYG{p}{(}\PYG{l+s}{parent\PYGZus{}parent\PYGZus{}libdir}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{parent\PYGZus{}libdir}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{DIRECTORY}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{parent\PYGZus{}dirs}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libdir}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{parent\PYGZus{}libdir}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{parent\PYGZus{}parent\PYGZus{}libdir}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endforeach}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} If we already found a library somewhere, limit the search paths for the header}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{parent\PYGZus{}dirs}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}search\PYGZus{}paths}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{parent\PYGZus{}dirs}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}skip\PYGZus{}system\PYGZus{}prefix}\PYG{+w}{ }\PYG{l+s}{NO\PYGZus{}CMAKE\PYGZus{}SYSTEM\PYGZus{}PATH}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}search\PYGZus{}paths}
\PYG{+w}{            }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{search\PYGZus{}paths}\PYG{o}{\PYGZcb{}}
\PYG{+w}{            }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Search for headers in ns\PYGZhy{}3\PYGZhy{}dev/build}
\PYG{+w}{            }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Search for headers in the install}
\PYG{+w}{            }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{not\PYGZus{}found\PYGZus{}headers}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{include\PYGZus{}dirs}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{foreach}\PYG{p}{(}\PYG{l+s}{header}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}names}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} The same way with libraries, we mark the internal variable as advanced not}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} to pollute ccmake configuration with variables used internally}
\PYG{+w}{    }\PYG{n+nb}{mark\PYGZus{}as\PYGZus{}advanced}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}header\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{suffixes}
\PYG{+w}{            }\PYG{l+s}{/build}
\PYG{+w}{            }\PYG{l+s}{/include}
\PYG{+w}{            }\PYG{l+s}{/build/include}
\PYG{+w}{            }\PYG{l+s}{/build/include/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}
\PYG{+w}{            }\PYG{l+s}{/include/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}
\PYG{+w}{            }\PYG{l+s}{/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}
\PYG{+w}{            }\PYG{l+s}{/}
\PYG{+w}{            }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{path\PYGZus{}suffixes}\PYG{o}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: off}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Here we search for the header file named \PYGZdl{}\PYGZob{}header\PYGZcb{} and store the result in}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}name\PYGZcb{}\PYGZus{}header\PYGZus{}internal\PYGZus{}\PYGZdl{}\PYGZob{}header\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} The same way we did with libraries, here we search on}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} CMAKE\PYGZus{}SYSTEM\PYGZus{}PREFIX\PYGZus{}PATH, along with user\PYGZhy{}settable \PYGZdl{}\PYGZob{}search\PYGZus{}paths\PYGZcb{}, the}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} parent directories from the libraries, CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY and}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} And again, for each of them, for every suffix listed /usr/local/build}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/include}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/build/include}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/build/include/\PYGZdl{}\PYGZob{}name\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} /usr/local/include/\PYGZdl{}\PYGZob{}name\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: on}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Or enable NS3\PYGZus{}VERBOSE to get the searched paths printed while configuring}

\PYG{+w}{    }\PYG{n+nb}{find\PYGZus{}file}\PYG{p}{(}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}header\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{HINTS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}search\PYGZus{}paths}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} directory (e.g. /usr/)}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}skip\PYGZus{}system\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{PATH\PYGZus{}SUFFIXES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{suffixes}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} Print tested paths to the searched header and if it was found}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VERBOSE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{log\PYGZus{}find\PYGZus{}searched\PYGZus{}paths}\PYG{p}{(}
\PYG{+w}{              }\PYG{l+s}{TARGET\PYGZus{}TYPE}\PYG{+w}{ }\PYG{l+s}{Header}
\PYG{+w}{              }\PYG{l+s}{TARGET\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}RESULT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}header\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}PATHS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}search\PYGZus{}paths}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}SUFFIXES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{suffixes}\PYG{o}{\PYGZcb{}}
\PYG{+w}{              }\PYG{l+s}{SEARCH\PYGZus{}SYSTEM\PYGZus{}PREFIX}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}skip\PYGZus{}system\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} If the header file was not found, append to the not\PYGZhy{}found list}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}\PYGZdl{}\PYGZob{}name\PYGZcb{}\PYGZus{}header\PYGZus{}internal\PYGZus{}\PYGZdl{}\PYGZob{}header\PYGZcb{}\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{STREQUAL}
\PYG{+w}{       }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}name\PYGZcb{}\PYGZus{}header\PYGZus{}internal\PYGZus{}\PYGZdl{}\PYGZob{}header\PYGZcb{}\PYGZhy{}NOTFOUND\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{not\PYGZus{}found\PYGZus{}headers}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} If the header file was found, get their directories and the parent of}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} their directories to add as include directories}
\PYG{+w}{      }\PYG{n+nb}{get\PYGZus{}filename\PYGZus{}component}\PYG{p}{(}
\PYG{+w}{        }\PYG{l+s}{header\PYGZus{}include\PYGZus{}dir}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}\PYGZob{}name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}header\PYGZus{}internal\PYGZus{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{DIRECTORY}
\PYG{+w}{      }\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} e.g. include/click/ (simclick.h) \PYGZhy{}\PYGZgt{} \PYGZsh{}include \PYGZlt{}simclick.h\PYGZgt{} should work}
\PYG{+w}{      }\PYG{n+nb}{get\PYGZus{}filename\PYGZus{}component}\PYG{p}{(}
\PYG{+w}{        }\PYG{l+s}{header\PYGZus{}include\PYGZus{}dir2}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}include\PYGZus{}dir}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{DIRECTORY}
\PYG{+w}{      }\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} e.g. include/(click) \PYGZhy{}\PYGZgt{} \PYGZsh{}include \PYGZlt{}click/simclick.h\PYGZgt{} should work}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{include\PYGZus{}dirs}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}include\PYGZus{}dir}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}include\PYGZus{}dir2}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endforeach}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Remove duplicate include directories}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{include\PYGZus{}dirs}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{REMOVE\PYGZus{}DUPLICATES}\PYG{+w}{ }\PYG{l+s}{include\PYGZus{}dirs}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} If we find both library and header, we export their values}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{l+s}{not\PYGZus{}found\PYGZus{}libraries\PYGZcb{}}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{l+s}{not\PYGZus{}found\PYGZus{}headers}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}include\PYGZus{}dirs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}LIBRARIES}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}libraries\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}HEADER}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}\PYGZob{}name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}header\PYGZus{}internal\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}FOUND}\PYG{+w}{ }\PYG{l+s}{TRUE}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{status\PYGZus{}message}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}find\PYGZus{}external\PYGZus{}library: \PYGZdl{}\PYGZob{}name\PYGZcb{} was found.\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}LIBRARIES}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}HEADER}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{name}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZus{}FOUND}\PYG{+w}{ }\PYG{l+s}{FALSE}\PYG{+w}{ }\PYG{l+s}{PARENT\PYGZus{}SCOPE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{status\PYGZus{}message}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}find\PYGZus{}external\PYGZus{}library: \PYGZdl{}\PYGZob{}name\PYGZcb{} was not found. Missing headers: \PYGZbs{}\PYGZdq{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{not\PYGZus{}found\PYGZus{}headers}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZbs{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{and}\PYG{+w}{ }\PYG{l+s}{missing}\PYG{+w}{ }\PYG{l+s}{libraries:}\PYG{+w}{ }\PYG{l+s}{\PYGZbs{}\PYGZdq{}\PYGZdl{}\PYGZob{}not\PYGZus{}found\PYGZus{}libraries\PYGZcb{}\PYGZbs{}\PYGZdq{}.\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{FIND\PYGZus{}LIB\PYGZus{}QUIET}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}status\PYGZus{}message\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Debugging why a header or a library cannot be found is fairly tricky.
For \sphinxcode{\sphinxupquote{find\_external\_library}} users, enabling the \sphinxcode{\sphinxupquote{NS3\_VERBOSE}} switch
will enable the logging of search path directories for both headers and
libraries.

\sphinxAtStartPar
Note: The logging provided by find\_external\_library is an alternative to
CMake’s own \sphinxcode{\sphinxupquote{CMAKE\_FIND\_DEBUG\_MODE=true}} introduced in CMake 3.17,
which gets used by \sphinxstyleemphasis{ALL} \sphinxcode{\sphinxupquote{find\_file}}, \sphinxcode{\sphinxupquote{find\_library}}, \sphinxcode{\sphinxupquote{find\_header}},
\sphinxcode{\sphinxupquote{find\_package}} and \sphinxcode{\sphinxupquote{find\_path}} calls throughout CMake and its modules.
If you are using a recent version of CMake, it is recommended to use
\sphinxhref{https://cmake.org/cmake/help/latest/variable/CMAKE\_FIND\_DEBUG\_MODE.html}{CMAKE\_FIND\_DEBUG\_MODE} instead.

\sphinxAtStartPar
A commented version of the Openflow module \sphinxcode{\sphinxupquote{CMakeLists.txt}} has an
example of \sphinxcode{\sphinxupquote{find\_external\_library}} usage.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Export a user option to specify the path to a custom}
\PYG{c}{\PYGZsh{} openflow build directory.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}WITH\PYGZus{}OPENFLOW}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{PATH}
\PYG{+w}{          }\PYG{l+s+s2}{\PYGZdq{}Build with Openflow support\PYGZdq{}}
\PYG{p}{)}
\PYG{c}{\PYGZsh{} We use this variable later in the ns\PYGZhy{}3\PYGZhy{}dev scope, but}
\PYG{c}{\PYGZsh{} the value would be lost if we saved it to the}
\PYG{c}{\PYGZsh{} parent scope ns\PYGZhy{}3\PYGZhy{}dev/src or ns\PYGZhy{}3\PYGZhy{}dev/contrib.}
\PYG{c}{\PYGZsh{} We set it as an INTERNAL CACHE variable to make it globally available.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}OPENFLOW}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}OFF\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}
\PYG{+w}{          }\PYG{l+s+s2}{\PYGZdq{}ON if Openflow is found\PYGZdq{}}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} This is the macro that searches for headers and libraries.}
\PYG{c}{\PYGZsh{} The DEPENDENCY\PYGZus{}NAME is the equivalent of the find\PYGZus{}package package name.}
\PYG{c}{\PYGZsh{} Resulting variables will be prefixed with DEPENDENCY\PYGZus{}NAME.}
\PYG{c}{\PYGZsh{} \PYGZhy{} openflow\PYGZus{}FOUND will be set to True if both headers and libraries}
\PYG{c}{\PYGZsh{}     were found and False otherwise}
\PYG{c}{\PYGZsh{} \PYGZhy{} openflow\PYGZus{}LIBRARIES will contain a list of absolute paths to the}
\PYG{c}{\PYGZsh{}     libraries named in LIBRARY\PYGZus{}NAME|LIBRARY\PYGZus{}NAMES}
\PYG{c}{\PYGZsh{} \PYGZhy{} openflow\PYGZus{}INCLUDE\PYGZus{}DIRS will contain a list of include directories that contain}
\PYG{c}{\PYGZsh{}     headers named in HEADER\PYGZus{}NAME|HEADER\PYGZus{}NAMES and directories that contain}
\PYG{c}{\PYGZsh{}     those directories.}
\PYG{c}{\PYGZsh{}     e.g. searching for core\PYGZhy{}module.h will return}
\PYG{c}{\PYGZsh{}     both ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3 and ns\PYGZhy{}3\PYGZhy{}dev/build/include,}
\PYG{c}{\PYGZsh{}     allowing users to include both \PYGZlt{}core\PYGZhy{}module.h\PYGZgt{} and \PYGZlt{}ns3/core\PYGZhy{}module.h\PYGZgt{}}
\PYG{c}{\PYGZsh{} If a user\PYGZhy{}settable variable was created, it can be searched too by}
\PYG{c}{\PYGZsh{} adding it to the SEARCH\PYGZus{}PATHS}
\PYG{n+nb}{find\PYGZus{}external\PYGZus{}library}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{DEPENDENCY\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{openflow}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{openflow.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARY\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{openflow}
\PYG{+w}{  }\PYG{l+s}{SEARCH\PYGZus{}PATHS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}WITH\PYGZus{}OPENFLOW}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} user\PYGZhy{}settable search path, empty by default}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} Before testing if the header and library were found \PYGZdl{}\PYGZob{}openflow\PYGZus{}FOUND\PYGZcb{},}
\PYG{c}{\PYGZsh{} test if openflow\PYGZus{}FOUND was defined}
\PYG{c}{\PYGZsh{} If openflow\PYGZus{}FOUND was not defined, the dependency name above doesn\PYGZsq{}t match}
\PYG{c}{\PYGZsh{} the tested values below}
\PYG{c}{\PYGZsh{} If openflow\PYGZus{}FOUND is set to FALSE, stop processing the module by returning}
\PYG{c}{\PYGZsh{} to the parent directory with return()}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{NOT}
\PYG{+w}{    }\PYG{l+s}{openflow\PYGZus{}FOUND}\PYG{p}{)}
\PYG{+w}{   }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{NOT}
\PYG{+w}{        }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{openflow\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Openflow was not found\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{return}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Check for the Boost header used by the openflow module}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{boost/static\PYGZus{}assert.hpp}
\PYG{+w}{  }\PYG{l+s}{BOOST\PYGZus{}STATIC\PYGZus{}ASSERT}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} Stop processing the module if it was not found}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}
\PYG{+w}{  }\PYG{l+s}{BOOST\PYGZus{}STATIC\PYGZus{}ASSERT}
\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Openflow requires Boost static\PYGZus{}assert.hpp\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{return}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Here we consume the include directories found by}
\PYG{c}{\PYGZsh{} find\PYGZus{}external\PYGZus{}library}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} This will make the following work:}
\PYG{c}{\PYGZsh{}  include\PYGZlt{}openflow/openflow.h\PYGZgt{}}
\PYG{c}{\PYGZsh{}  include\PYGZlt{}openflow.h\PYGZgt{}}
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{openflow\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Manually set definitions}
\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{\PYGZhy{}DNS3\PYGZus{}OPENFLOW}
\PYG{+w}{  }\PYG{l+s}{\PYGZhy{}DENABLE\PYGZus{}OPENFLOW}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set the cache variable indicating Openflow is enabled as}
\PYG{c}{\PYGZsh{} all dependencies were met}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}OPENFLOW}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}ON\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}
\PYG{+w}{          }\PYG{l+s+s2}{\PYGZdq{}ON if Openflow is found in NS3\PYGZus{}WITH\PYGZus{}OPENFLOW\PYGZdq{}}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} Additional compilation flag to ignore a specific warning}
\PYG{n+nb}{add\PYGZus{}compile\PYGZus{}options}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}Wno\PYGZhy{}stringop\PYGZhy{}truncation}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Call macro to create the module target}
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{openflow}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{helper/openflow\PYGZhy{}switch\PYGZhy{}helper.cc}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}interface.cc}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}switch\PYGZhy{}net\PYGZhy{}device.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{helper/openflow\PYGZhy{}switch\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}interface.h}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}switch\PYGZhy{}net\PYGZhy{}device.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{c}{\PYGZsh{} Here we consume the list of libraries}
\PYG{+w}{                    }\PYG{c}{\PYGZsh{} exported by find\PYGZus{}external\PYGZus{}library}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{openflow\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}\PYG{+w}{ }\PYG{l+s}{test/openflow\PYGZhy{}switch\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Linking third\sphinxhyphen{}party libraries using CMake’s find\_package}
\label{\detokenize{working-with-cmake:linking-third-party-libraries-using-cmake-s-find-package}}
\sphinxAtStartPar
Assume we have a module with optional features that rely on a third\sphinxhyphen{}party library
that provides a FindThirdPartyPackage.cmake. This \sphinxcode{\sphinxupquote{Find\$\{Package\}.cmake}} file can be distributed
by \sphinxhref{https://github.com/Kitware/CMake/tree/master/Modules}{CMake itself}, via library/package managers (APT, Pacman,
\sphinxhref{https://github.com/Microsoft/vcpkg\#using-vcpkg-with-cmake}{vcpkg}), or included to the project tree in the build\sphinxhyphen{}support/3rd\sphinxhyphen{}party directory.

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{find\_package(\$\{Package\})}} is called, the \sphinxcode{\sphinxupquote{Find\$\{Package\}.cmake}} file gets processed,
and multiple variables are set. There is no hard standard in the name of those variables, nor if
they should follow the modern CMake usage, where just linking to the library will include
associated header directories, forward compile flags and so on.

\sphinxAtStartPar
We assume the old CMake style is the one being used, which means we need to include the include
directories provided by the \sphinxcode{\sphinxupquote{Find\$\{Package\}.cmake module}}, usually exported as a variable
\sphinxcode{\sphinxupquote{\$\{Package\}\_INCLUDE\_DIRS}}, and get a list of libraries for that module so that they can be
added to the list of libraries to link of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules. Libraries are usually exported as
the variable \sphinxcode{\sphinxupquote{\$\{Package\}\_LIBRARIES}}.

\sphinxAtStartPar
As an example for the above, we use the Boost library
(excerpt from \sphinxcode{\sphinxupquote{macros\sphinxhyphen{}and\sphinxhyphen{}definitions.cmake}} and \sphinxcode{\sphinxupquote{src/core/CMakeLists.txt}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} https://cmake.org/cmake/help/v3.10/module/FindBoost.html?highlight=module\PYGZpc{}20find\PYGZsh{}module:FindBoost}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Boost}\PYG{p}{)}

\PYG{c}{\PYGZsh{} It is recommended to create either an empty list that is conditionally filled}
\PYG{c}{\PYGZsh{} and later included in the LIBRARIES\PYGZus{}TO\PYGZus{}LINK list unconditionally}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{boost\PYGZus{}libraries}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If Boost is found, Boost\PYGZus{}FOUND will be set to true, which we can then test}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{Boost\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} This will export Boost include directories to ALL subdirectories}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} of the current CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR}
\PYG{+w}{  }\PYG{c}{\PYGZsh{}}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} If calling this from the top\PYGZhy{}level directory (ns\PYGZhy{}3\PYGZhy{}dev), it will}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} be used by all contrib/src modules, examples, etc}
\PYG{+w}{  }\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{Boost\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} This is a trick for Boost}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Sometimes you want to check if specific Boost headers are available,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} but they would not be found if they\PYGZsq{}re not in system include directories}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}REQUIRED\PYGZus{}INCLUDES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{Boost\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} We get the list of Boost libraries and save them in the boost\PYGZus{}libraries list}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{boost\PYGZus{}libraries}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{Boost\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If Boost was found earlier, we will be able to check if Boost headers are available}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}boost/units/quantity.hpp\PYGZdq{}}
\PYG{+w}{  }\PYG{l+s}{HAVE\PYGZus{}BOOST\PYGZus{}UNITS\PYGZus{}QUANTITY}
\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}boost/units/systems/si.hpp\PYGZdq{}}
\PYG{+w}{  }\PYG{l+s}{HAVE\PYGZus{}BOOST\PYGZus{}UNITS\PYGZus{}SI}
\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{HAVE\PYGZus{}BOOST\PYGZus{}UNITS\PYGZus{}QUANTITY}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{HAVE\PYGZus{}BOOST\PYGZus{}UNITS\PYGZus{}SI}\PYG{o}{\PYGZcb{}}
\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Activate optional features that rely on Boost}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{\PYGZhy{}DHAVE\PYGZus{}BOOST}
\PYG{+w}{    }\PYG{l+s}{\PYGZhy{}DHAVE\PYGZus{}BOOST\PYGZus{}UNITS}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} In this case, the Boost libraries are header\PYGZhy{}only,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} but in case we needed real libraries, we could add}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} boost\PYGZus{}libraries to either the auxiliary libraries\PYGZus{}to\PYGZus{}link list}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} or the build\PYGZus{}lib\PYGZsq{}s LIBRARIES\PYGZus{}TO\PYGZus{}LINK list}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Boost Units have been found.\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{STATUS}
\PYG{+w}{      }\PYG{l+s+s2}{\PYGZdq{}Boost Units are an optional feature of length.cc.\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{Find\$\{Package\}.cmake}} does not exist in your module path, CMake will warn you that is the case.
If \sphinxcode{\sphinxupquote{\$\{Package\_FOUND\}}} is set to \sphinxcode{\sphinxupquote{False}}, other variables such as the ones related to libraries and
include directories might not be set, and can result in CMake failures to configure if used.

\sphinxAtStartPar
In case the \sphinxcode{\sphinxupquote{Find\$\{Package\}.cmake}} you need is not distributed by the upstream CMake project,
you can create your own and add it to \sphinxcode{\sphinxupquote{build\sphinxhyphen{}support/3rd\sphinxhyphen{}party}}. This directory is included
to the \sphinxcode{\sphinxupquote{CMAKE\_MODULE\_PATH}} variable, making it available for calls without needing to include
the file with the absolute path to it. To add more directories to the \sphinxcode{\sphinxupquote{CMAKE\_MODULE\_PATH}},
use the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Excerpt from build\PYGZhy{}support/macros\PYGZhy{}and\PYGZhy{}definitions.cmake}

\PYG{c}{\PYGZsh{} Add ns\PYGZhy{}3 custom modules to the module path}
\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{CMAKE\PYGZus{}MODULE\PYGZus{}PATH}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/build\PYGZhy{}support/custom\PYGZhy{}modules\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Add the 3rd\PYGZhy{}party modules to the module path}
\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{CMAKE\PYGZus{}MODULE\PYGZus{}PATH}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/build\PYGZhy{}support/3rd\PYGZhy{}party\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Add your new modules directory to the module path}
\PYG{c}{\PYGZsh{} (\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{} is /path/to/ns\PYGZhy{}3\PYGZhy{}dev/)}
\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{CMAKE\PYGZus{}MODULE\PYGZus{}PATH}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/build\PYGZhy{}support/new\PYGZhy{}modules\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
One of the custom Find files currently shipped by \sphinxstyleemphasis{ns\sphinxhyphen{}3} is the \sphinxcode{\sphinxupquote{FindGTK3.cmake}} file.
GTK3 requires Harfbuzz, which has its own \sphinxcode{\sphinxupquote{FindHarfBuzz.cmake}} file. Both of them
are in the \sphinxcode{\sphinxupquote{build\sphinxhyphen{}support/3rd\sphinxhyphen{}party}} directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} You don\PYGZsq{}t need to keep adding this, this is just a demonstration}
\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{CMAKE\PYGZus{}MODULE\PYGZus{}PATH}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/build\PYGZhy{}support/3rd\PYGZhy{}party\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If the user\PYGZhy{}settable NS3\PYGZus{}GTK3 is set, look for HarfBuzz and GTK}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}GTK3}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Use FindHarfBuzz.cmake to find HarfBuzz}
\PYG{+w}{  }\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{HarfBuzz}\PYG{+w}{ }\PYG{l+s}{QUIET}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} If HarfBuzz is not found}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{HarfBuzz\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Harfbuzz is required by GTK3 and was not found.\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} FindGTK3.cmake does some weird tricks and results in warnings,}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} that we can only suppress this way}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}SUPPRESS\PYGZus{}DEVELOPER\PYGZus{}WARNINGS}\PYG{+w}{ }\PYG{l+s}{1}\PYG{+w}{ }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{BOOL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} If HarfBuzz is found, search for GTK}
\PYG{+w}{    }\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{GTK3}\PYG{+w}{ }\PYG{l+s}{QUIET}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} Remove suppressions needed for quiet operations}
\PYG{+w}{    }\PYG{n+nb}{unset}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}SUPPRESS\PYGZus{}DEVELOPER\PYGZus{}WARNINGS}\PYG{+w}{ }\PYG{l+s}{CACHE}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} If GTK3 is not found, inform the user}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{GTK3\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GTK3 was not found. Continuing without it.\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} If an incompatible version is found, set the GTK3\PYGZus{}FOUND flag to false,}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} to make sure it won\PYGZsq{}t be used later}
\PYG{+w}{      }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{GTK3\PYGZus{}VERSION}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{VERSION\PYGZus{}LESS}\PYG{+w}{ }\PYG{l+s}{3.22}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{GTK3\PYGZus{}FOUND}\PYG{+w}{ }\PYG{l+s}{FALSE}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GTK3 found with incompatible version \PYGZdl{}\PYGZob{}GTK3\PYGZus{}VERSION\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{        }\PYG{c}{\PYGZsh{} A compatible GTK3 version was found}
\PYG{+w}{        }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GTK3 was found.\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The Stats module can use the same \sphinxcode{\sphinxupquote{find\_package}} macro to search for SQLite3.

\sphinxAtStartPar
Note: we currently use a custom macro to find Python3 and SQLite3 since
\sphinxcode{\sphinxupquote{FindPython3.cmake}} and \sphinxcode{\sphinxupquote{FindSQLite3.cmake}} were included in CMake 3.12 and 3.14.
More details on how to use the macro are listed in
{\hyperref[\detokenize{working-with-cmake:linking-third-party-libraries-without-cmake-or-pkgconfig-support}]{\sphinxcrossref{Linking third\sphinxhyphen{}party libraries without CMake or PkgConfig support}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Set enable flag to false before checking}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ENABLE\PYGZus{}SQLITE}\PYG{+w}{ }\PYG{l+s}{False}\PYG{p}{)}

\PYG{c}{\PYGZsh{} In this case, SQLite presence is only checked if the user sets}
\PYG{c}{\PYGZsh{} NS3\PYGZus{}SQLITE to ON, but your case may be different}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}SQLITE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} FindSQLite3.cmake is used by CMake to find SQLite3}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} QUIET flag silences most warnings from the module and let us write our own}
\PYG{+w}{  }\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{SQLite3}\PYG{+w}{ }\PYG{l+s}{QUIET}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} FindSQLite3.cmake was included in CMake 3.14}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} If SQLite3 was found, SQLite3\PYGZus{}FOUND will be set to True, otherwise to False}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ENABLE\PYGZus{}SQLITE}\PYG{+w}{ }\PYG{l+s}{True}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}SQLite was not found\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Here we declare empty lists, that only hold values if ENABLE\PYGZus{}SQLITE is set to ON}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}sources}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}header}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}libraries}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ENABLE\PYGZus{}SQLITE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} If SQLite was found, add the optional source files to the lists}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}sources}
\PYG{+w}{      }\PYG{l+s}{model/sqlite\PYGZhy{}data\PYGZhy{}output.cc}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}headers}
\PYG{+w}{      }\PYG{l+s}{model/sqlite\PYGZhy{}data\PYGZhy{}output.h}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Include the include directories containing the sqlite3.h header}
\PYG{+w}{  }\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Copy the list of sqlite3 libraries}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{sqlite\PYGZus{}libraries}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SQLite3\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} If the semaphore header is also found,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} append additional optional source files to}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} the sqlite sources and headers lists}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{HAVE\PYGZus{}SEMAPHORE\PYGZus{}H}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{list}\PYG{p}{(}
\PYG{+w}{      }\PYG{l+s}{APPEND}
\PYG{+w}{      }\PYG{l+s}{sqlite\PYGZus{}sources}
\PYG{+w}{      }\PYG{l+s}{model/sqlite\PYGZhy{}output.cc}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{list}\PYG{p}{(}
\PYG{+w}{      }\PYG{l+s}{APPEND}
\PYG{+w}{      }\PYG{l+s}{sqlite\PYGZus{}headers}
\PYG{+w}{      }\PYG{l+s}{model/sqlite\PYGZhy{}output.h}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Sources and headers file lists for stats are quite long,}
\PYG{c}{\PYGZsh{} so we use these auxiliary lists}
\PYG{c}{\PYGZsh{} The optional sqlite\PYGZus{}sources and sqlite\PYGZus{}headers can be empty or not}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{source\PYGZus{}files}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{sqlite\PYGZus{}sources}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{l+s}{model/uinteger\PYGZhy{}8\PYGZhy{}probe.cc}
\PYG{p}{)}

\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}files}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{sqlite\PYGZus{}headers}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{    }\PYG{l+s}{model/uinteger\PYGZhy{}8\PYGZhy{}probe.h}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create the stats module consuming source files}
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{stats}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{source\PYGZus{}files}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}files}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{c}{\PYGZsh{} Here we either have an empty list or}
\PYG{+w}{                    }\PYG{c}{\PYGZsh{} a list with the sqlite library}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{sqlite\PYGZus{}libraries}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}
\PYG{+w}{    }\PYG{l+s}{test/average\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/basic\PYGZhy{}data\PYGZhy{}calculators\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/double\PYGZhy{}probe\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/histogram\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Linking third\sphinxhyphen{}party libraries with PkgConfig support}
\label{\detokenize{working-with-cmake:linking-third-party-libraries-with-pkgconfig-support}}
\sphinxAtStartPar
Assume we have a module with optional features that rely on a third\sphinxhyphen{}party library
that uses PkgConfig. We can look for the PkgConfig module and add the optional
source files similarly to the previous cases, as shown in the example below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Include CMake script to use pkg\PYGZhy{}config}
\PYG{n+nb}{include}\PYG{p}{(}\PYG{l+s}{FindPkgConfig}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If pkg\PYGZhy{}config was found, search for library you want}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{PKG\PYGZus{}CONFIG\PYGZus{}FOUND}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{pkg\PYGZus{}check\PYGZus{}modules}\PYG{p}{(}\PYG{l+s}{THIRD\PYGZus{}PARTY}\PYG{+w}{ }\PYG{l+s}{libthird\PYGZhy{}party}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{third\PYGZus{}party\PYGZus{}sources}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{third\PYGZus{}party\PYGZus{}libs}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Set cached variable if both pkg\PYGZhy{}config and libthird\PYGZhy{}party are found}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{PKG\PYGZus{}CONFIG\PYGZus{}FOUND}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{l+s}{THIRD\PYGZus{}PARTY}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Include third\PYGZhy{}party include directories for}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} consumption of the current module and its examples}
\PYG{+w}{  }\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{THIRD\PYGZus{}PARTY\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Use exported CFLAGS required by the third\PYGZhy{}party library}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}compile\PYGZus{}options}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{THIRD\PYGZus{}PARTY\PYGZus{}CFLAGS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Copy the list of third\PYGZhy{}party libraries}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{third\PYGZus{}party\PYGZus{}libs}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{THIRD\PYGZus{}PARTY\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Add optional source files that depend on the third\PYGZhy{}party library}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{third\PYGZus{}party\PYGZus{}sources}\PYG{+w}{ }\PYG{l+s}{model/optional\PYGZhy{}feature.cc}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create module using the optional source files and libraries}
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{hypothetical}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{model/hypothetical.cc}
\PYG{+w}{               }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{third\PYGZus{}party\PYGZus{}sources}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{model/hypothetical.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{c}{\PYGZsh{} Here we either have an empty list or}
\PYG{+w}{                    }\PYG{c}{\PYGZsh{} a list with the third\PYGZhy{}party library}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{third\PYGZus{}party\PYGZus{}libs}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}
\PYG{+w}{    }\PYG{l+s}{test/hypothetical.cc}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Using C++ library managers}
\label{\detokenize{working-with-cmake:using-c-library-managers}}\label{\detokenize{working-with-cmake:id5}}
\sphinxAtStartPar
It is not rare to try using a library that is not available
on a certain platform or does not have a CMake\sphinxhyphen{}friendly
interface for us to use.

\sphinxAtStartPar
Some C++ package managers are fairly easy to use with CMake,
such as \sphinxhref{https://github.com/Microsoft/vcpkg\#using-vcpkg-with-cmake}{Vcpkg} and \sphinxhref{https://github.com/cpm-cmake/CPM.cmake}{CPM}.


\paragraph{vcpkg}
\label{\detokenize{working-with-cmake:id6}}
\sphinxAtStartPar
Vcpkg requires \sphinxcode{\sphinxupquote{git}}, \sphinxcode{\sphinxupquote{curl}}, \sphinxcode{\sphinxupquote{zip}}, \sphinxcode{\sphinxupquote{unzip}} and \sphinxcode{\sphinxupquote{tar}},
along with the default ns\sphinxhyphen{}3 dependencies. The setup downloads
and builds vcpkg from their Git repository. Telemetry is disabled
by default.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}VCPKG=ON}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: setting up support}
\PYG{g+go}{Cloning into \PYGZsq{}vcpkg\PYGZsq{}...}
\PYG{g+go}{Updating files: 100\PYGZpc{} (10376/10376), done.}
\PYG{g+go}{Downloading vcpkg\PYGZhy{}glibc...}
\PYG{g+go}{vcpkg package management program version 2023\PYGZhy{}07\PYGZhy{}19\PYGZhy{}814b7ec837b59f1c8778f72351c1dd7605983cd2}
\PYG{g+go}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Configuration will finish successfully.
For example, now we can try using the Armadillo library.
To do that, we use the following CMake statements:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Check this is not a fluke}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}
\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Armadillo was found? \PYGZdl{}\PYGZob{}ARMADILLO\PYGZus{}FOUND\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Reconfigure ns\sphinxhyphen{}3 to check if Armadillo is available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 configure}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: setting up support}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: folder already exists, skipping git download}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: already bootstrapped}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Could NOT find Armadillo (missing: ARMADILLO\PYGZus{}INCLUDE\PYGZus{}DIR)}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Armadillo was found? FALSE}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, no Armadillo found.
We can now use vcpkg to install it, using the CMake
function \sphinxcode{\sphinxupquote{add\_package(package\_name)}}. CMake
will then be able to find the installed package using \sphinxcode{\sphinxupquote{find\_package}}.

\sphinxAtStartPar
Note: some packages may require additional dependencies.
The Armadillo package requires \sphinxcode{\sphinxupquote{pkg\sphinxhyphen{}config}} and a fortran compiler.
You will be prompted with a CMake error when a missing dependency is found.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Install Armadillo and search for it again}
\PYG{n+nb}{add\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Installs Armadillo with vcpkg}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Loads vcpkg installation of Armadillo}
\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Armadillo was found? \PYGZdl{}\PYGZob{}ARMADILLO\PYGZus{}FOUND\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Sadly, we will need to reconfigure ns\sphinxhyphen{}3 from the scratch,
since CMake \sphinxcode{\sphinxupquote{find\_package}} caches are problematic.
Installing the packages can take a while, and it can look like it hanged.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 clean}
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}VCPKG=ON}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: setting up support}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: folder already exists, skipping git download}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: already bootstrapped}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: Armadillo will be installed}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: Armadillo was installed}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Armadillo was found? TRUE}
\end{sphinxVerbatim}

\sphinxAtStartPar
As shown above, the Armadillo library gets installed by vcpkg
and it can be found by CMake’s \sphinxcode{\sphinxupquote{find\_package}} function.
We can then use it for our targets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Install Armadillo}
\PYG{n+nb}{add\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Installs Armadillo with vcpkg}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Loads vcpkg installation of Armadillo}
\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Armadillo was found? \PYGZdl{}\PYGZob{}ARMADILLO\PYGZus{}FOUND\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Include and link Armadillo to targets}
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ARMADILLO\PYGZus{}INCLUDE\PYGZus{}DIRS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{n+nb}{link\PYGZus{}libraries}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ARMADILLO\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
An alternative to manually installing packages with \sphinxcode{\sphinxupquote{add\_package}} is
placing all packages into a \sphinxcode{\sphinxupquote{vcpkg.json}} file in the ns\sphinxhyphen{}3 main directory.
This mode is known as the “manifest mode” in the Vcpkg manual.
Packages there will be automatically installed at the beginning of the configuration.
More information about the manifest mode can be found in \sphinxhref{https://learn.microsoft.com/en-us/vcpkg/users/manifests}{vcpkg manifests} website.

\sphinxAtStartPar
Let us see an example of this mode starting with the \sphinxcode{\sphinxupquote{vcpkg.json}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n+nt}{\PYGZdq{}dependencies\PYGZdq{}}\PYG{p}{:}\PYG{+w}{ }\PYG{p}{[}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}sqlite3\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}eigen3\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}libxml2\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}gsl\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}boost\PYGZhy{}units\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
These are some of the optional dependencies used by the upstream ns\sphinxhyphen{}3 modules.
When configuring ns\sphinxhyphen{}3 with the Vcpkg support, we will see the following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 clean}
\PYG{g+go}{/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}VCPKG=ON}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: setting up support}
\PYG{g+go}{Cloning into \PYGZsq{}vcpkg\PYGZsq{}...}
\PYG{g+go}{Updating files: 100\PYGZpc{} (10434/10434), done.}
\PYG{g+go}{Downloading vcpkg\PYGZhy{}glibc...}
\PYG{g+go}{vcpkg package management program version 2023\PYGZhy{}08\PYGZhy{}02\PYGZhy{}6d13efa755f9b5e101712d210199e4139b4c29f6}

\PYG{g+go}{See LICENSE.txt for license information.}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: detected a vcpkg manifest file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg.json}
\PYG{g+go}{A suitable version of cmake was not found (required v3.27.1) Downloading portable cmake 3.27.1...}
\PYG{g+go}{Downloading cmake...}
\PYG{g+go}{https://github.com/Kitware/CMake/releases/download/v3.27.1/cmake\PYGZhy{}3.27.1\PYGZhy{}linux\PYGZhy{}x86\PYGZus{}64.tar.gz\PYGZhy{}\PYGZgt{}/ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/downloads/cmake\PYGZhy{}3.27.1\PYGZhy{}linux\PYGZhy{}x86\PYGZus{}64.tar.gz}
\PYG{g+go}{Extracting cmake...}
\PYG{g+go}{Detecting compiler hash for triplet x64\PYGZhy{}linux...}
\PYG{g+go}{The following packages will be built and installed:}
\PYG{g+go}{  * boost\PYGZhy{}array:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 1.82.0\PYGZsh{}2}
\PYG{g+go}{  ...}
\PYG{g+go}{  * boost\PYGZhy{}winapi:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 1.82.0\PYGZsh{}2}
\PYG{g+go}{    eigen3:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 3.4.0\PYGZsh{}2}
\PYG{g+go}{    gsl:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2.7.1\PYGZsh{}3}
\PYG{g+go}{  * libiconv:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 1.17\PYGZsh{}1}
\PYG{g+go}{  * liblzma:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 5.4.3\PYGZsh{}1}
\PYG{g+go}{    libxml2[core,iconv,lzma,zlib]:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2.10.3\PYGZsh{}1}
\PYG{g+go}{    sqlite3[core,json1]:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 3.42.0\PYGZsh{}1}
\PYG{g+go}{  * vcpkg\PYGZhy{}cmake:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2023\PYGZhy{}05\PYGZhy{}04}
\PYG{g+go}{  * vcpkg\PYGZhy{}cmake\PYGZhy{}config:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2022\PYGZhy{}02\PYGZhy{}06\PYGZsh{}1}
\PYG{g+go}{  * vcpkg\PYGZhy{}cmake\PYGZhy{}get\PYGZhy{}vars:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2023\PYGZhy{}03\PYGZhy{}02}
\PYG{g+go}{  * zlib:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 1.2.13}
\PYG{g+go}{Additional packages (*) will be modified to complete this operation.}
\PYG{g+go}{Restored 0 package(s) from /root/.cache/vcpkg/archives in 98.7 us. Use \PYGZhy{}\PYGZhy{}debug to see more details.}
\PYG{g+go}{Installing 1/58 boost\PYGZhy{}uninstall:x64\PYGZhy{}linux...}
\PYG{g+go}{...}
\PYG{g+go}{Installing 50/58 boost\PYGZhy{}units:x64\PYGZhy{}linux...}
\PYG{g+go}{Building boost\PYGZhy{}units:x64\PYGZhy{}linux...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Downloading https://github.com/boostorg/units/archive/boost\PYGZhy{}1.82.0.tar.gz \PYGZhy{}\PYGZgt{} boostorg\PYGZhy{}units\PYGZhy{}boost\PYGZhy{}1.82.0.tar.gz...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Extracting source /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/downloads/boostorg\PYGZhy{}units\PYGZhy{}boost\PYGZhy{}1.82.0.tar.gz}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Using source at /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/buildtrees/boost\PYGZhy{}units/src/ost\PYGZhy{}1.82.0\PYGZhy{}a9fdcc40b2.clean}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Copying headers}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Copying headers done}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/boost\PYGZhy{}units\PYGZus{}x64\PYGZhy{}linux/share/boost\PYGZhy{}units/usage}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/boost\PYGZhy{}units\PYGZus{}x64\PYGZhy{}linux/share/boost\PYGZhy{}units/copyright}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Performing post\PYGZhy{}build validation}
\PYG{g+go}{Stored binaries in 1 destinations in 276 ms.}
\PYG{g+go}{Elapsed time to handle boost\PYGZhy{}units:x64\PYGZhy{}linux: 3.8 s}
\PYG{g+go}{Installing 51/58 vcpkg\PYGZhy{}cmake\PYGZhy{}config:x64\PYGZhy{}linux...}
\PYG{g+go}{Building vcpkg\PYGZhy{}cmake\PYGZhy{}config:x64\PYGZhy{}linux...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/vcpkg\PYGZhy{}cmake\PYGZhy{}config\PYGZus{}x64\PYGZhy{}linux/share/vcpkg\PYGZhy{}cmake\PYGZhy{}config/vcpkg\PYGZus{}cmake\PYGZus{}config\PYGZus{}fixup.cmake}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/vcpkg\PYGZhy{}cmake\PYGZhy{}config\PYGZus{}x64\PYGZhy{}linux/share/vcpkg\PYGZhy{}cmake\PYGZhy{}config/vcpkg\PYGZhy{}port\PYGZhy{}config.cmake}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/vcpkg\PYGZhy{}cmake\PYGZhy{}config\PYGZus{}x64\PYGZhy{}linux/share/vcpkg\PYGZhy{}cmake\PYGZhy{}config/copyright}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Performing post\PYGZhy{}build validation}
\PYG{g+go}{Stored binaries in 1 destinations in 8.58 ms.}
\PYG{g+go}{Elapsed time to handle vcpkg\PYGZhy{}cmake\PYGZhy{}config:x64\PYGZhy{}linux: 144 ms}
\PYG{g+go}{Installing 52/58 eigen3:x64\PYGZhy{}linux...}
\PYG{g+go}{Building eigen3:x64\PYGZhy{}linux...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Downloading https://gitlab.com/libeigen/eigen/\PYGZhy{}/archive/3.4.0/eigen\PYGZhy{}3.4.0.tar.gz \PYGZhy{}\PYGZgt{} libeigen\PYGZhy{}eigen\PYGZhy{}3.4.0.tar.gz...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Extracting source /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/downloads/libeigen\PYGZhy{}eigen\PYGZhy{}3.4.0.tar.gz}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Applying patch remove\PYGZus{}configure\PYGZus{}checks.patch}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Applying patch fix\PYGZhy{}vectorized\PYGZhy{}reductions\PYGZhy{}half.patch}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Using source at /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/buildtrees/eigen3/src/3.4.0\PYGZhy{}74a8d62212.clean}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Configuring x64\PYGZhy{}linux}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Building x64\PYGZhy{}linux\PYGZhy{}dbg}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Building x64\PYGZhy{}linux\PYGZhy{}rel}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Fixing pkgconfig file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/eigen3\PYGZus{}x64\PYGZhy{}linux/lib/pkgconfig/eigen3.pc}
\PYG{g+go}{CMake Error at scripts/cmake/vcpkg\PYGZus{}find\PYGZus{}acquire\PYGZus{}program.cmake:163 (message):}
\PYG{g+go}{  Could not find pkg\PYGZhy{}config.  Please install it via your package manager:}

\PYG{g+go}{      sudo apt\PYGZhy{}get install pkg\PYGZhy{}config}
\PYG{g+go}{Call Stack (most recent call first):}
\PYG{g+go}{  scripts/cmake/vcpkg\PYGZus{}fixup\PYGZus{}pkgconfig.cmake:203 (vcpkg\PYGZus{}find\PYGZus{}acquire\PYGZus{}program)}
\PYG{g+go}{  ports/eigen3/portfile.cmake:30 (vcpkg\PYGZus{}fixup\PYGZus{}pkgconfig)}
\PYG{g+go}{  scripts/ports.cmake:147 (include)}


\PYG{g+go}{error: building eigen3:x64\PYGZhy{}linux failed with: BUILD\PYGZus{}FAILED}
\PYG{g+go}{Elapsed time to handle eigen3:x64\PYGZhy{}linux: 19 s}
\PYG{g+go}{Please ensure you\PYGZsq{}re using the latest port files with `git pull` and `vcpkg update`.}
\PYG{g+go}{Then check for known issues at:}
\PYG{g+go}{    https://github.com/microsoft/vcpkg/issues?q=is\PYGZpc{}3Aissue+is\PYGZpc{}3Aopen+in\PYGZpc{}3Atitle+eigen3}
\PYG{g+go}{You can submit a new issue at:}
\PYG{g+go}{    https://github.com/microsoft/vcpkg/issues/new?title=[eigen3]+Build+error\PYGZam{}body=Copy+issue+body+from+\PYGZpc{}2Fns\PYGZhy{}3\PYGZhy{}dev\PYGZpc{}2Fvcpkg\PYGZpc{}2Finstalled\PYGZpc{}2Fvcpkg\PYGZpc{}2Fissue\PYGZus{}body.md}

\PYG{g+go}{CMake Error at build\PYGZhy{}support/3rd\PYGZhy{}party/colored\PYGZhy{}messages.cmake:82 (\PYGZus{}message):}
\PYG{g+go}{  vcpkg: packages defined in the manifest failed to be installed}
\PYG{g+go}{Call Stack (most recent call first):}
\PYG{g+go}{  build\PYGZhy{}support/custom\PYGZhy{}modules/ns3\PYGZhy{}vcpkg\PYGZhy{}hunter.cmake:138 (message)}
\PYG{g+go}{  build\PYGZhy{}support/custom\PYGZhy{}modules/ns3\PYGZhy{}vcpkg\PYGZhy{}hunter.cmake:183 (setup\PYGZus{}vcpkg)}
\PYG{g+go}{  build\PYGZhy{}support/macros\PYGZhy{}and\PYGZhy{}definitions.cmake:743 (include)}
\PYG{g+go}{  CMakeLists.txt:149 (process\PYGZus{}options)}
\end{sphinxVerbatim}

\sphinxAtStartPar
As we can see above, the setup failed during the eigen3 setup due to a missing dependency.
In this case, pkg\sphinxhyphen{}config. We can install it using the system package manager and then
resume the ns\sphinxhyphen{}3 configuration.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} apt install \PYGZhy{}y pkg\PYGZhy{}config}
\PYG{g+go}{/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}VCPKG=ON}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: folder already exists, skipping git download}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: already bootstrapped}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: detected a vcpkg manifest file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg.json}
\PYG{g+go}{Detecting compiler hash for triplet x64\PYGZhy{}linux...}
\PYG{g+go}{The following packages will be built and installed:}
\PYG{g+go}{    eigen3:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 3.4.0\PYGZsh{}2}
\PYG{g+go}{    gsl:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2.7.1\PYGZsh{}3}
\PYG{g+go}{  * libiconv:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 1.17\PYGZsh{}1}
\PYG{g+go}{  * liblzma:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 5.4.3\PYGZsh{}1}
\PYG{g+go}{    libxml2[core,iconv,lzma,zlib]:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 2.10.3\PYGZsh{}1}
\PYG{g+go}{    sqlite3[core,json1]:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 3.42.0\PYGZsh{}1}
\PYG{g+go}{  * zlib:x64\PYGZhy{}linux \PYGZhy{}\PYGZgt{} 1.2.13}
\PYG{g+go}{Additional packages (*) will be modified to complete this operation.}
\PYG{g+go}{Restored 0 package(s) from /root/.cache/vcpkg/archives in 97.6 us. Use \PYGZhy{}\PYGZhy{}debug to see more details.}
\PYG{g+go}{Installing 1/7 eigen3:x64\PYGZhy{}linux...}
\PYG{g+go}{Building eigen3:x64\PYGZhy{}linux...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Using cached libeigen\PYGZhy{}eigen\PYGZhy{}3.4.0.tar.gz.}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Cleaning sources at /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/buildtrees/eigen3/src/3.4.0\PYGZhy{}74a8d62212.clean. Use \PYGZhy{}\PYGZhy{}editable to skip cleaning for the packages you specify.}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Extracting source /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/downloads/libeigen\PYGZhy{}eigen\PYGZhy{}3.4.0.tar.gz}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Applying patch remove\PYGZus{}configure\PYGZus{}checks.patch}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Applying patch fix\PYGZhy{}vectorized\PYGZhy{}reductions\PYGZhy{}half.patch}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Using source at /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/buildtrees/eigen3/src/3.4.0\PYGZhy{}74a8d62212.clean}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Configuring x64\PYGZhy{}linux}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Building x64\PYGZhy{}linux\PYGZhy{}dbg}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Building x64\PYGZhy{}linux\PYGZhy{}rel}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Fixing pkgconfig file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/eigen3\PYGZus{}x64\PYGZhy{}linux/lib/pkgconfig/eigen3.pc}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Fixing pkgconfig file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/eigen3\PYGZus{}x64\PYGZhy{}linux/debug/lib/pkgconfig/eigen3.pc}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/eigen3\PYGZus{}x64\PYGZhy{}linux/share/eigen3/copyright}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Performing post\PYGZhy{}build validation}
\PYG{g+go}{Stored binaries in 1 destinations in 1.7 s.}
\PYG{g+go}{Elapsed time to handle eigen3:x64\PYGZhy{}linux: 28 s}
\PYG{g+go}{Installing 2/7 gsl:x64\PYGZhy{}linux...}
\PYG{g+go}{...}
\PYG{g+go}{Installing 7/7 sqlite3:x64\PYGZhy{}linux...}
\PYG{g+go}{Building sqlite3[core,json1]:x64\PYGZhy{}linux...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Downloading https://sqlite.org/2023/sqlite\PYGZhy{}amalgamation\PYGZhy{}3420000.zip \PYGZhy{}\PYGZgt{} sqlite\PYGZhy{}amalgamation\PYGZhy{}3420000.zip...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Extracting source /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/downloads/sqlite\PYGZhy{}amalgamation\PYGZhy{}3420000.zip}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Applying patch fix\PYGZhy{}arm\PYGZhy{}uwp.patch}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Applying patch add\PYGZhy{}config\PYGZhy{}include.patch}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Using source at /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/buildtrees/sqlite3/src/on\PYGZhy{}3420000\PYGZhy{}e624a7f335.clean}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Configuring x64\PYGZhy{}linux}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Building x64\PYGZhy{}linux\PYGZhy{}dbg}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Building x64\PYGZhy{}linux\PYGZhy{}rel}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Fixing pkgconfig file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/sqlite3\PYGZus{}x64\PYGZhy{}linux/lib/pkgconfig/sqlite3.pc}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Fixing pkgconfig file: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/sqlite3\PYGZus{}x64\PYGZhy{}linux/debug/lib/pkgconfig/sqlite3.pc}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Installing: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/packages/sqlite3\PYGZus{}x64\PYGZhy{}linux/share/sqlite3/usage}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Performing post\PYGZhy{}build validation}
\PYG{g+go}{Stored binaries in 1 destinations in 430 ms.}
\PYG{g+go}{Elapsed time to handle sqlite3:x64\PYGZhy{}linux: 42 s}
\PYG{g+go}{Total install time: 2.5 min}
\PYG{g+go}{The package boost is compatible with built\PYGZhy{}in CMake targets:}

\PYG{g+go}{    find\PYGZus{}package(Boost REQUIRED [COMPONENTS \PYGZlt{}libs\PYGZgt{}...])}
\PYG{g+go}{    target\PYGZus{}link\PYGZus{}libraries(main PRIVATE Boost::boost Boost::\PYGZlt{}lib1\PYGZgt{} Boost::\PYGZlt{}lib2\PYGZgt{} ...)}

\PYG{g+go}{eigen3 provides CMake targets:}

\PYG{g+gp}{    \PYGZsh{} }this\PYG{+w}{ }is\PYG{+w}{ }heuristically\PYG{+w}{ }generated,\PYG{+w}{ }and\PYG{+w}{ }may\PYG{+w}{ }not\PYG{+w}{ }be\PYG{+w}{ }correct
\PYG{g+go}{    find\PYGZus{}package(Eigen3 CONFIG REQUIRED)}
\PYG{g+go}{    target\PYGZus{}link\PYGZus{}libraries(main PRIVATE Eigen3::Eigen)}

\PYG{g+go}{The package gsl is compatible with built\PYGZhy{}in CMake targets:}

\PYG{g+go}{    find\PYGZus{}package(GSL REQUIRED)}
\PYG{g+go}{    target\PYGZus{}link\PYGZus{}libraries(main PRIVATE GSL::gsl GSL::gslcblas)}

\PYG{g+go}{The package libxml2 is compatible with built\PYGZhy{}in CMake targets:}

\PYG{g+go}{    find\PYGZus{}package(LibXml2 REQUIRED)}
\PYG{g+go}{    target\PYGZus{}link\PYGZus{}libraries(main PRIVATE LibXml2::LibXml2)}

\PYG{g+go}{sqlite3 provides pkgconfig bindings.}
\PYG{g+go}{sqlite3 provides CMake targets:}

\PYG{g+go}{    find\PYGZus{}package(unofficial\PYGZhy{}sqlite3 CONFIG REQUIRED)}
\PYG{g+go}{    target\PYGZus{}link\PYGZus{}libraries(main PRIVATE unofficial::sqlite3::sqlite3)}

\PYG{g+go}{\PYGZhy{}\PYGZhy{} vcpkg: packages defined in the manifest were installed}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} find\PYGZus{}external\PYGZus{}library: SQLite3 was found.}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} LibXML2 was found.}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Found Boost: /ns\PYGZhy{}3\PYGZhy{}dev/vcpkg/installed/x64\PYGZhy{}linux/include (found version \PYGZdq{}1.82.0\PYGZdq{})}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Looking for include files boost/units/quantity.hpp, boost/units/systems/si.hpp}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Looking for include files boost/units/quantity.hpp, boost/units/systems/si.hpp \PYGZhy{} found}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Boost Units have been found.}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Summary of ns\PYGZhy{}3 settings:}
\PYG{g+go}{Build profile                 : default}
\PYG{g+go}{Build directory               : /ns\PYGZhy{}3\PYGZhy{}dev/build}
\PYG{g+go}{Build with runtime asserts    : ON}
\PYG{g+go}{...}
\PYG{g+go}{GNU Scientific Library (GSL)  : ON}
\PYG{g+go}{...}
\PYG{g+go}{LibXml2 support               : ON}
\PYG{g+go}{...}
\PYG{g+go}{SQLite support                : ON}
\PYG{g+go}{Eigen3 support                : ON}
\PYG{g+go}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
From the above, we can see that the headers and libraries installed by the packages
were correctly found by CMake and the optional features were successfully enabled.

\sphinxAtStartPar
Note: not every vcpkg package (also known as a port) obeys
the same pattern for usage. The user of the package needs
to look into the usage file of said port for instructions.
In the case of Armadillo, the corresponding file can be found
in \sphinxhref{https://github.com/microsoft/vcpkg/blob/master/ports/armadillo/usage}{Armadillo’s port on vcpkg}.

\sphinxAtStartPar
Vcpkg is installed to a \sphinxcode{\sphinxupquote{vcpkg}} directory inside the ns\sphinxhyphen{}3 main directory (e.g. \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev}}).
Packages installed via vcpkg are installed to \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/vcpkg/installed/\$\{VCPKG\_TRIPLET\}}},
which is automatically added to the \sphinxcode{\sphinxupquote{CMAKE\_PREFIX\_PATH}}, making headers, libraries, and
pkg\sphinxhyphen{}config and CMake packages discoverable via \sphinxcode{\sphinxupquote{find\_file}}, \sphinxcode{\sphinxupquote{find\_library}}, \sphinxcode{\sphinxupquote{find\_package}}
and \sphinxcode{\sphinxupquote{pkg\_check\_modules}}.


\paragraph{CPM}
\label{\detokenize{working-with-cmake:id7}}
\sphinxAtStartPar
\sphinxhref{https://github.com/cpm-cmake/CPM.cmake}{CPM} is a package manager made for CMake projects consuming CMake projects.
Some CMake projects however, create files during the installation step, which
is not supported by CPM, which treats the package as a CMake subproject that
we can then depend upon. CPM may require dependencies such as \sphinxcode{\sphinxupquote{git}} and \sphinxcode{\sphinxupquote{tar}},
depending on the package sources used.

\sphinxAtStartPar
Let’s see an example trying to find the Armadillo library via CMake.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Check this is not a fluke}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}
\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Armadillo was found? \PYGZdl{}\PYGZob{}ARMADILLO\PYGZus{}FOUND\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Reconfigure ns\sphinxhyphen{}3 to check if Armadillo is available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 configure}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Could NOT find Armadillo (missing: ARMADILLO\PYGZus{}INCLUDE\PYGZus{}DIR)}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Armadillo was found? FALSE}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, no Armadillo found.
We can now use CPM to install it, using the CMake
function \sphinxcode{\sphinxupquote{CPMAddPackage(package\_info)}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Install Armadillo and search for it again}
\PYG{n+nb}{CPMAddPackage}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{ARMADILLO}
\PYG{+w}{    }\PYG{l+s}{GIT\PYGZus{}TAG}\PYG{+w}{ }\PYG{l+s}{6cada351248c9a967b137b9fcb3d160dad7c709b}
\PYG{+w}{    }\PYG{l+s}{GIT\PYGZus{}REPOSITORY}\PYG{+w}{ }\PYG{l+s}{https://gitlab.com/conradsnicta/armadillo\PYGZhy{}code.git}
\PYG{p}{)}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Loads CPM installation of Armadillo}
\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Armadillo was found? \PYGZdl{}\PYGZob{}ARMADILLO\PYGZus{}FOUND\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Sadly, we will need to reconfigure ns\sphinxhyphen{}3 from the scratch,
since CMake \sphinxcode{\sphinxupquote{find\_package}} caches are problematic.
Installing the packages can take a while, and it can look like it hanged.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 clean}
\PYG{g+go}{\PYGZti{}\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}CPM=ON}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CPM: Adding package ARMADILLO@0 (6cada351248c9a967b137b9fcb3d160dad7c709b)}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** set cmake policy CMP0025 to NEW}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}CXX\PYGZus{}STANDARD = 11}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Configuring Armadillo 12.6.1}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** WARNING: variable \PYGZsq{}CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZsq{} is not empty; this may cause problems!}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Detected Clang 6.0 or newer}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} ARMA\PYGZus{}USE\PYGZus{}EXTERN\PYGZus{}RNG = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}SYSTEM\PYGZus{}NAME          = Linux}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}ID      = Clang}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}VERSION = 15.0.7}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}COMPILER\PYGZus{}IS\PYGZus{}GNUCXX   =}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** Options:}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} BUILD\PYGZus{}SHARED\PYGZus{}LIBS         = ON}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} OPENBLAS\PYGZus{}PROVIDES\PYGZus{}LAPACK  = OFF}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} ALLOW\PYGZus{}FLEXIBLAS\PYGZus{}LINUX     = ON}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} ALLOW\PYGZus{}OPENBLAS\PYGZus{}MACOS      = OFF}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} ALLOW\PYGZus{}BLAS\PYGZus{}LAPACK\PYGZus{}MACOS   = OFF}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} BUILD\PYGZus{}SMOKE\PYGZus{}TEST          = ON}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** Looking for external libraries}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Found OpenBLAS: /usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libopenblas.so}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Found BLAS: /usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libblas.so}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Found LAPACK: /usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/liblapack.so}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} FlexiBLAS\PYGZus{}FOUND = NO}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}       MKL\PYGZus{}FOUND = NO}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}  OpenBLAS\PYGZus{}FOUND = YES}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}     ATLAS\PYGZus{}FOUND = NO}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}      BLAS\PYGZus{}FOUND = YES}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}    LAPACK\PYGZus{}FOUND = YES}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** NOTE: found both OpenBLAS and BLAS; BLAS will not be used}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** NOTE: if OpenBLAS is known to provide LAPACK functions, recommend to}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** NOTE: rerun cmake with the OPENBLAS\PYGZus{}PROVIDES\PYGZus{}LAPACK option enabled:}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** NOTE: cmake \PYGZhy{}D OPENBLAS\PYGZus{}PROVIDES\PYGZus{}LAPACK=true .}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** If the OpenBLAS library is installed in}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** /usr/local/lib or /usr/local/lib64}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** make sure the run\PYGZhy{}time linker can find it.}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** On Linux systems this can be done by editing /etc/ld.so.conf}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** or modifying the LD\PYGZus{}LIBRARY\PYGZus{}PATH environment variable.}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Found ARPACK: /usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libarpack.so}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} ARPACK\PYGZus{}FOUND = YES}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Looking for SuperLU version 5}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Found SuperLU: /usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libsuperlu.so}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} SuperLU\PYGZus{}FOUND = YES}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} SuperLU\PYGZus{}INCLUDE\PYGZus{}DIR = /usr/include/superlu}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** Result of configuration:}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}WRAPPER    = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}LAPACK     = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}BLAS       = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}ATLAS      = false}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}ARPACK     = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}EXTERN\PYGZus{}RNG = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}USE\PYGZus{}SUPERLU    = true}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** Armadillo wrapper library will use the following libraries:}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** ARMA\PYGZus{}LIBS = /usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libopenblas.so;/usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/liblapack.so;/usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libarpack.so;/usr/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libsuperlu.so}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Copying /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}src/include/ to /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/tmp/include/}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/tmp/include/config.hpp}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}CXX\PYGZus{}FLAGS           =  \PYGZhy{}fsanitize=address,leak,undefined \PYGZhy{}O2}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}SHARED\PYGZus{}LINKER\PYGZus{}FLAGS =  \PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}no\PYGZhy{}as\PYGZhy{}needed}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}REQUIRED\PYGZus{}INCLUDES   = /usr/include;/usr/include/superlu}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX     = /usr}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}INSTALL\PYGZus{}LIBDIR     = lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}INSTALL\PYGZus{}INCLUDEDIR = include}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}INSTALL\PYGZus{}DATADIR    = share}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} CMAKE\PYGZus{}INSTALL\PYGZus{}BINDIR     = bin}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating \PYGZsq{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/ArmadilloConfig.cmake\PYGZsq{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating \PYGZsq{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/ArmadilloConfigVersion.cmake\PYGZsq{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating \PYGZsq{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/InstallFiles/ArmadilloConfig.cmake\PYGZsq{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating \PYGZsq{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/InstallFiles/ArmadilloConfigVersion.cmake\PYGZsq{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Copying /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}src/misc/ to /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/tmp/misc/}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Generating \PYGZsq{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}release/\PYGZus{}deps/armadillo\PYGZhy{}build/tmp/misc/armadillo.pc\PYGZsq{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} *** configuring smoke\PYGZus{}test}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} Armadillo was found? TRUE}
\PYG{g+go}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
As shown above, the Armadillo library gets installed by CPM
and it can be found by CMake’s \sphinxcode{\sphinxupquote{find\_package}} function.
Differently from other packages found via \sphinxcode{\sphinxupquote{find\_package}},
CPM creates native CMake targets from the subprojects.
In the case of Armadillo, the target is called \sphinxcode{\sphinxupquote{armadillo}},
which we can link to our targets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Install Armadillo}
\PYG{n+nb}{CPMAddPackage}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{ARMADILLO}
\PYG{+w}{    }\PYG{l+s}{GIT\PYGZus{}TAG}\PYG{+w}{ }\PYG{l+s}{6cada351248c9a967b137b9fcb3d160dad7c709b}
\PYG{+w}{    }\PYG{l+s}{GIT\PYGZus{}REPOSITORY}\PYG{+w}{ }\PYG{l+s}{https://gitlab.com/conradsnicta/armadillo\PYGZhy{}code.git}
\PYG{p}{)}
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Armadillo}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} Loads CPM installation of Armadillo}
\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Armadillo was found? \PYGZdl{}\PYGZob{}ARMADILLO\PYGZus{}FOUND\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} CPM is kind of jenky. It could get the ARMADILLO\PYGZus{}INCLUDE\PYGZus{}DIRS}
\PYG{c}{\PYGZsh{} from the ArmadilloConfig.cmake file in \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/\PYGZus{}deps/armadillo\PYGZhy{}build,}
\PYG{c}{\PYGZsh{} but it doesn\PYGZsq{}t... So add its include directories directly from the source directory}
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}BINARY\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/\PYGZus{}deps/armadillo\PYGZhy{}src/include}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Link to Armadillo and}
\PYG{n+nb}{link\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{armadillo}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note: using CPM can be challenging. Users are recommended
to look at \sphinxhref{https://github.com/cpm-cmake/CPM.cmake/wiki/More-Snippets}{CPM’s examples}.

\sphinxAtStartPar
For example, the libraries of installed packages will be placed by default in
the \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/build/lib}} directory. On the other hand, header placement depends
on how the CMake project was setup.

\sphinxAtStartPar
If the package CMakeLists.txt was made to build in\sphinxhyphen{}source, headers will be
along the source files, which will be placed in
\sphinxcode{\sphinxupquote{\$\{PROJECT\_BINARY\_DIR\}/\_deps/packageName\sphinxhyphen{}src}}. When configured with the
ns3 script, \sphinxcode{\sphinxupquote{PROJECT\_BINARY\_DIR corresponds}} to \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/cmake\sphinxhyphen{}cache}}.

\sphinxAtStartPar
If the package CMakeLists.txt copies the headers to an output directory
(like ns\sphinxhyphen{}3 does), it will be placed in
\sphinxcode{\sphinxupquote{\$\{PROJECT\_BINARY\_DIR\}/\_deps/packageName\sphinxhyphen{}build}},
possibly in an \sphinxcode{\sphinxupquote{include}} subdirectory.

\sphinxAtStartPar
In case it was configured to copy the headers to \sphinxcode{\sphinxupquote{\$\{CMAKE\_BINARY\_DIR\}/include}},
the headers will land on \sphinxcode{\sphinxupquote{\$\{PROJECT\_BINARY\_DIR\}/include}} of the most top\sphinxhyphen{}level
project. In our case, the top\sphinxhyphen{}level project is the NS3 project.

\sphinxAtStartPar
Since the packages get installed into the ns\sphinxhyphen{}3 cache directory
(\sphinxcode{\sphinxupquote{PROJECT\_BINARY\_DIR}}), using \sphinxcode{\sphinxupquote{./ns3 clean}} will delete them,
requiring them to be rebuilt.


\subsubsection{Inclusion of options}
\label{\detokenize{working-with-cmake:inclusion-of-options}}
\sphinxAtStartPar
There are two ways of managing module options: option switches or cached variables.
Both are present in the main CMakeLists.txt in the ns\sphinxhyphen{}3\sphinxhyphen{}dev directory and the
build\sphinxhyphen{}support/macros\sphinxhyphen{}and\sphinxhyphen{}definitions.cmake file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Here are examples of ON and OFF switches}
\PYG{c}{\PYGZsh{} option(}
\PYG{c}{\PYGZsh{}        NS3\PYGZus{}SWITCH \PYGZsh{} option switch prefixed with NS3\PYGZbs{}\PYGZus{}}
\PYG{c}{\PYGZsh{}        \PYGZdq{}followed by the description of what the option does\PYGZdq{}}
\PYG{c}{\PYGZsh{}        ON \PYGZsh{} and the default value for that option}
\PYG{c}{\PYGZsh{}        )}
\PYG{n+nb}{option}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}EXAMPLES}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Enable examples to be built\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}
\PYG{n+nb}{option}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}TESTS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Enable tests to be built\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Now here is how to let the user indicate a path}
\PYG{c}{\PYGZsh{} set( \PYGZsh{} declares a value}
\PYG{c}{\PYGZsh{}     NS3\PYGZus{}PREFIXED\PYGZus{}VALUE \PYGZsh{} stores the option value}
\PYG{c}{\PYGZsh{}     \PYGZdq{}\PYGZdq{} \PYGZsh{} default value is empty in this case}
\PYG{c}{\PYGZsh{}     CACHE \PYGZsh{} stores that NS3\PYGZus{}PREFIXED\PYGZus{}VALUE in the CMakeCache.txt file}
\PYG{c}{\PYGZsh{}     STRING \PYGZsh{} type of the cached variable}
\PYG{c}{\PYGZsh{}     \PYGZdq{}description of what this value is used for\PYGZdq{}}
\PYG{c}{\PYGZsh{}     )}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{PATH}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Directory to store built artifacts\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The last case are options that can only assume predefined values}
\PYG{c}{\PYGZsh{} First we cache the default option}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}INT64X64}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}INT128\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{STRING}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Int64x64 implementation\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Then set a cache property for the variable indicating it can assume}
\PYG{c}{\PYGZsh{} specific values}
\PYG{n+nb}{set\PYGZus{}property}\PYG{p}{(}\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{NS3\PYGZus{}INT64X64}\PYG{+w}{ }\PYG{l+s}{PROPERTY}\PYG{+w}{ }\PYG{l+s}{STRINGS}\PYG{+w}{ }\PYG{l+s}{INT128}\PYG{+w}{ }\PYG{l+s}{CAIRO}\PYG{+w}{ }\PYG{l+s}{DOUBLE}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
More details about these commands can be found in the following links:
\sphinxhref{https://cmake.org/cmake/help/latest/command/option.html}{option}, \sphinxhref{https://cmake.org/cmake/help/latest/command/set.html}{set}, \sphinxhref{https://cmake.org/cmake/help/latest/command/set\_property.html}{set\_property}.


\subsubsection{Changes in CMake macros and functions}
\label{\detokenize{working-with-cmake:changes-in-cmake-macros-and-functions}}
\sphinxAtStartPar
In order for CMake to feel more familiar to Waf users, a few macros and functions
were created.

\sphinxAtStartPar
The most frequently used macros them can be found in
\sphinxcode{\sphinxupquote{build\sphinxhyphen{}support/macros\sphinxhyphen{}and\sphinxhyphen{}definitions.cmake}}. This file includes build type checking,
compiler family and version checking, enabling and disabling features based
on user options, checking for dependencies of enabled features,
pre\sphinxhyphen{}compiling headers, filtering enabled/disabled modules and dependencies,
and more.


\paragraph{Executable macros}
\label{\detokenize{working-with-cmake:executable-macros}}
\sphinxAtStartPar
Creating an executable in CMake requires a few different macro calls.
Some of these calls are related to setting the target and built executable name,
indicating which libraries that should be linked to the executable,
where the executable should be placed after being built and installed.

\sphinxAtStartPar
Note that if you are trying to add a new example to your module, you should
look at the {\hyperref[\detokenize{working-with-cmake:build-lib-example}]{\sphinxcrossref{build\_lib\_example}}} macro section.

\sphinxAtStartPar
If you are trying to add a new example to \sphinxcode{\sphinxupquote{\textasciitilde{}/ns\sphinxhyphen{}3\sphinxhyphen{}dev/examples}}, you should
look at the {\hyperref[\detokenize{working-with-cmake:build-example}]{\sphinxcrossref{build\_example}}} macro section.

\sphinxAtStartPar
While both of the previously mentioned macros are meant to be used for examples,
in some cases additional utilities are required. Those utilities can be helpers,
such as the \sphinxcode{\sphinxupquote{raw\sphinxhyphen{}sock\sphinxhyphen{}creator}} in the \sphinxcode{\sphinxupquote{fd\sphinxhyphen{}net\sphinxhyphen{}device}} module, or benchmark
tools in the \sphinxcode{\sphinxupquote{\textasciitilde{}/ns\sphinxhyphen{}3\sphinxhyphen{}dev/utils}} directory. In those cases, the {\hyperref[\detokenize{working-with-cmake:build-exec}]{\sphinxcrossref{build\_exec}}}
macro is recommended instead of direct CMake calls.


\subparagraph{Executable macros: build\_exec}
\label{\detokenize{working-with-cmake:executable-macros-build-exec}}\label{\detokenize{working-with-cmake:build-exec}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{build\_exec}} macro bundles a series of direct CMake calls into a single macro.
The example below shows the creation of an executable named \sphinxcode{\sphinxupquote{example}}, that will
later receive a version prefix (e.g. \sphinxcode{\sphinxupquote{ns3.37\sphinxhyphen{}}}) and a build type suffix
(e.g. \sphinxcode{\sphinxupquote{\sphinxhyphen{}debug}}), resulting in an executable file named \sphinxcode{\sphinxupquote{ns3.37\sphinxhyphen{}example\sphinxhyphen{}debug}}.

\sphinxAtStartPar
The list of source and header files can be passed in the \sphinxcode{\sphinxupquote{SOURCE\_FILES}} and
\sphinxcode{\sphinxupquote{HEADER\_FILES}} arguments, followed by the \sphinxcode{\sphinxupquote{LIBRARIES\_TO\_LINK}} that will be linked
to the executable.

\sphinxAtStartPar
That executable will be saved by default to the \sphinxcode{\sphinxupquote{CMAKE\_RUNTIME\_OUTPUT\_DIRECTORY}}
(e.g. /ns\sphinxhyphen{}3\sphinxhyphen{}dev/build/bin). To change its destination, set \sphinxcode{\sphinxupquote{EXECUTABLE\_DIRECTORY\_PATH}}
to the desired path. The path is relative to the \sphinxcode{\sphinxupquote{CMAKE\_OUTPUT\_DIRECTORY}}
(e.g. /ns\sphinxhyphen{}3\sphinxhyphen{}dev/build).

\sphinxAtStartPar
In case this executable should be installed, set \sphinxcode{\sphinxupquote{INSTALL\_DIRECTORY\_PATH}} to the
desired destination. In case this value is empty, the executable will not be installed.
The path is relative to the \sphinxcode{\sphinxupquote{CMAKE\_INSTALL\_PREFIX}} (e.g. /usr).

\sphinxAtStartPar
To set custom compiler defines for that specific executable, defines can be passed
to the \sphinxcode{\sphinxupquote{DEFINITIONS}} argument.

\sphinxAtStartPar
Add the \sphinxcode{\sphinxupquote{STANDALONE}} option to prevent linking the \sphinxstyleemphasis{ns\sphinxhyphen{}3} static library
(\sphinxcode{\sphinxupquote{NS3\_STATIC}}) and single shared library (\sphinxcode{\sphinxupquote{NS3\_MONOLIB}}) to the executable.
This may be necessary in case the executable redefine symbols which are part
of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} library. This is the case for the fd\sphinxhyphen{}net\sphinxhyphen{}device creators and the tap\sphinxhyphen{}creator,
which include the source file \sphinxcode{\sphinxupquote{encode\sphinxhyphen{}decode.cc}}, which is also part of fd\sphinxhyphen{}net\sphinxhyphen{}device module
and tap\sphinxhyphen{}bridge module, respectively.

\sphinxAtStartPar
Finally, to ignore precompiled headers, include \sphinxcode{\sphinxupquote{IGNORE\_PCH}} to the list of parameters.
You can find more information about \sphinxcode{\sphinxupquote{IGNORE\_PCH}} at the {\hyperref[\detokenize{working-with-cmake:pch-side-effects}]{\sphinxcrossref{PCH side\sphinxhyphen{}effects}}} section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}exec}\PYG{p}{(}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} necessary}
\PYG{+w}{  }\PYG{l+s}{EXECNAME}\PYG{+w}{ }\PYG{l+s}{example}\PYG{+w}{                       }\PYG{c}{\PYGZsh{} executable name = example (plus version prefix and build type suffix)}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{example.cc}\PYG{+w}{ }\PYG{l+s}{example\PYGZhy{}complement.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{example.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}\PYG{+w}{           }\PYG{c}{\PYGZsh{} links to core}
\PYG{+w}{  }\PYG{l+s}{EXECUTABLE\PYGZus{}DIRECTORY\PYGZus{}PATH}\PYG{+w}{ }\PYG{l+s}{scratch}\PYG{+w}{          }\PYG{c}{\PYGZsh{} build/scratch}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} optional}
\PYG{+w}{  }\PYG{l+s}{EXECNAME\PYGZus{}PREFIX}\PYG{+w}{ }\PYG{l+s}{scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}}\PYG{+w}{ }\PYG{c}{\PYGZsh{} target name = scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}example}
\PYG{+w}{  }\PYG{l+s}{INSTALL\PYGZus{}DIRECTORY\PYGZus{}PATH}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}INSTALL\PYGZus{}BIN}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}\PYG{+w}{   }\PYG{c}{\PYGZsh{} e.g. /usr/bin/ns3.37\PYGZhy{}scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}example\PYGZhy{}debug}
\PYG{+w}{  }\PYG{l+s}{DEFINITIONS}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}DHAVE\PYGZus{}FEATURE=1}\PYG{+w}{           }\PYG{c}{\PYGZsh{} defines for this specific target}
\PYG{+w}{  }\PYG{l+s}{[STANDALONE]}\PYG{+w}{                           }\PYG{c}{\PYGZsh{} set in case you don\PYGZsq{}t want the executable to be linked to ns3\PYGZhy{}static/ns3\PYGZhy{}monolib}
\PYG{+w}{  }\PYG{l+s}{IGNORE\PYGZus{}PCH}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The same executable can be built by directly calling the following CMake macros:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{target\PYGZus{}prefix}\PYG{+w}{ }\PYG{l+s}{scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{target\PYGZus{}name}\PYG{+w}{ }\PYG{l+s}{example}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{output\PYGZus{}directory}\PYG{+w}{ }\PYG{l+s}{scratch}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Creates a target named \PYGZdq{}example\PYGZdq{} (target\PYGZus{}name) prefixed with \PYGZdq{}scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}\PYGZdq{} (target\PYGZus{}prefix)}
\PYG{c}{\PYGZsh{} e.g. scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}example}
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{example.cc}\PYG{+w}{ }\PYG{l+s}{example\PYGZhy{}complement.cc}\PYG{p}{)}
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create a variable with the target name prefixed with}
\PYG{c}{\PYGZsh{} the version and suffixed with the build profile suffix}
\PYG{c}{\PYGZsh{} e.g. ns3.37\PYGZhy{}scratch\PYGZus{}subdir\PYGZus{}prefix\PYGZus{}example\PYGZhy{}debug}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3\PYGZhy{}exec\PYGZhy{}outputname}\PYG{+w}{ }\PYG{l+s}{ns}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VER}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{build\PYGZus{}profile\PYGZus{}suffix}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Append the binary name to the executables list later written to the lock file,}
\PYG{c}{\PYGZsh{} which is consumed by the ns3 script and test.py}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3\PYGZhy{}execs}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}output\PYGZus{}directory\PYGZcb{}\PYGZdl{}\PYGZob{}ns3\PYGZhy{}exec\PYGZhy{}outputname\PYGZcb{};\PYGZdl{}\PYGZob{}ns3\PYGZhy{}execs\PYGZcb{}\PYGZdq{}}
\PYG{+w}{   }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}list of c++ executables\PYGZdq{}}
\PYG{p}{)}
\PYG{c}{\PYGZsh{} Modify the target properties to change the binary name to ns3\PYGZhy{}exec\PYGZhy{}outputname contents}
\PYG{c}{\PYGZsh{} and modify its output directory (e.g. scratch). The output directory is relative to the build directory.}
\PYG{n+nb}{set\PYGZus{}target\PYGZus{}properties}\PYG{p}{(}
\PYG{+w}{  }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{RUNTIME\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{output\PYGZus{}directory}\PYG{o}{\PYGZcb{}}
\PYG{+w}{             }\PYG{l+s}{RUNTIME\PYGZus{}OUTPUT\PYGZus{}NAME}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ns3\PYGZhy{}exec\PYGZhy{}outputname}\PYG{o}{\PYGZcb{}}
\PYG{p}{)}
\PYG{c}{\PYGZsh{} Create a dependency between the target and the all\PYGZhy{}test\PYGZhy{}targets}
\PYG{c}{\PYGZsh{} (used by ctest, coverage and doxygen targets)}
\PYG{n+nb}{add\PYGZus{}dependencies}\PYG{p}{(}\PYG{l+s}{all\PYGZhy{}test\PYGZhy{}targets}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create a dependency between the target and the timeTraceReport}
\PYG{c}{\PYGZsh{} (used by Clang TimeTrace to collect compilation statistics)}
\PYG{n+nb}{add\PYGZus{}dependencies}\PYG{p}{(}\PYG{l+s}{timeTraceReport}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} target used to track compilation time}

\PYG{c}{\PYGZsh{} Set target\PYGZhy{}specific compile definitions}
\PYG{n+nb}{target\PYGZus{}compile\PYGZus{}definitions}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{l+s}{definitions}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Check whether the target should reuse or not the precompiled headers}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}prefix}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{target\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{REUSE\PYGZus{}FROM}\PYG{+w}{ }\PYG{l+s}{stdlib\PYGZus{}pch\PYGZus{}exec}
\PYG{+w}{       }\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{Executable macros: build\_example}
\label{\detokenize{working-with-cmake:executable-macros-build-example}}\label{\detokenize{working-with-cmake:build-example}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{build\_example}} macro sets some of \sphinxcode{\sphinxupquote{build\_exec}}’s arguments based on the current
example directory (output directory) and adds the optional visualizer module as a dependency
in case it is enabled. It also performs dependency checking on the libraries passed.

\sphinxAtStartPar
In case one of the dependencies listed is not found, the example target will not be created.
If you are trying to add an example or a dependency to an existing example and it is not
listed by \sphinxcode{\sphinxupquote{./ns3 show targets}} or your IDE, check if all its dependencies were found.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{macro}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}example}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{options}\PYG{+w}{ }\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{oneValueArgs}\PYG{+w}{ }\PYG{l+s}{NAME}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{multiValueArgs}\PYG{+w}{ }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Parse arguments}
\PYG{+w}{  }\PYG{n+nb}{cmake\PYGZus{}parse\PYGZus{}arguments}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}EXAMPLE\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}options\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}oneValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}multiValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ARGN}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Filter examples out if they don\PYGZsq{}t contain one of the filtered in modules}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{foreach}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}module}\PYG{+w}{ }\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{filtered\PYGZus{}module}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{IN\PYGZus{}LIST}\PYG{+w}{ }\PYG{l+s}{EXAMPLE\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endforeach}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Check if any of the LIBRARIES\PYGZus{}TO\PYGZus{}LINK is missing to prevent configuration errors}
\PYG{+w}{  }\PYG{n+nb}{check\PYGZus{}for\PYGZus{}missing\PYGZus{}libraries}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{missing\PYGZus{}dependencies}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}EXAMPLE\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK\PYGZcb{}\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{l+s}{missing\PYGZus{}dependencies}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{filtered\PYGZus{}in}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Convert boolean into text to forward argument}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXAMPLE\PYGZus{}IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{+w}{ }\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Create example library with sources and headers}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: off}
\PYG{+w}{    }\PYG{n+nb}{build\PYGZus{}exec}\PYG{p}{(}
\PYG{+w}{      }\PYG{l+s}{EXECNAME}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXAMPLE\PYGZus{}NAME}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXAMPLE\PYGZus{}SOURCE\PYGZus{}FILES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXAMPLE\PYGZus{}HEADER\PYGZus{}FILES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXAMPLE\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{optional\PYGZus{}visualizer\PYGZus{}lib}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{EXECUTABLE\PYGZus{}DIRECTORY\PYGZus{}PATH}
\PYG{+w}{        }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}RUNTIME\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/examples/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{examplefolder}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: on}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endmacro}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
An example on how it is used can be found in \sphinxcode{\sphinxupquote{\textasciitilde{}/ns\sphinxhyphen{}3\sphinxhyphen{}dev/examples/tutorial/CMakeLists.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}example}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{first}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{first.cc}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libpoint\PYGZhy{}to\PYGZhy{}point}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libapplications}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} If visualizer is available, the macro will add the module to this list automatically}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} build\PYGZus{}exec\PYGZsq{}s EXECUTABLE\PYGZus{}DIRECTORY\PYGZus{}PATH will be set to build/examples/tutorial/}
\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Module macros}
\label{\detokenize{working-with-cmake:module-macros}}
\sphinxAtStartPar
Module macros are located in \sphinxcode{\sphinxupquote{build\sphinxhyphen{}support/custom\sphinxhyphen{}modules/ns3\sphinxhyphen{}module\sphinxhyphen{}macros.cmake}}.
This file contains macros defining a library (\sphinxcode{\sphinxupquote{build\_lib}}), the associated test library,
examples (\sphinxcode{\sphinxupquote{build\_lib\_example}}) and more. It also contains the macro that builds the
module header (\sphinxcode{\sphinxupquote{write\_module\_header}}) that includes all headers from the module
for user scripts.

\sphinxAtStartPar
These macros are responsible for easing the porting of modules from Waf to CMake.


\subparagraph{Module macros: build\_lib}
\label{\detokenize{working-with-cmake:module-macros-build-lib}}\label{\detokenize{working-with-cmake:build-lib}}
\sphinxAtStartPar
As \sphinxcode{\sphinxupquote{build\_lib}} is the most important of the macros, we detail what it does here,
block by block.

\sphinxAtStartPar
The first block declares the arguments received by the macro (in CMake, the
only difference is that a function has its own scope). Notice that there are
different types of arguments. Options that can only be set to ON/OFF.
Options are \sphinxcode{\sphinxupquote{OFF}} by default, and are set to \sphinxcode{\sphinxupquote{ON}} if the option name is added to
the arguments list (e.g. \sphinxcode{\sphinxupquote{build\_lib(... IGNORE\_PCH)}}).

\sphinxAtStartPar
Note: You can find more information about \sphinxcode{\sphinxupquote{IGNORE\_PCH}} at the {\hyperref[\detokenize{working-with-cmake:pch-side-effects}]{\sphinxcrossref{PCH side\sphinxhyphen{}effects}}} section.

\sphinxAtStartPar
One value arguments that receive a single value
(usually a string) and in this case used to receive the module name (\sphinxcode{\sphinxupquote{LIBNAME}}).

\sphinxAtStartPar
Multiple value arguments receive a list of values, which we use to parse lists
of source (for the module itself and for the module tests) and
header files, plus libraries that should be linked and module features.

\sphinxAtStartPar
The call to \sphinxcode{\sphinxupquote{cmake\_parse\_arguments}} will parse \sphinxcode{\sphinxupquote{\$\{ARGN\}}} into these values.
The variables containing the parsing results will be prefixed with \sphinxcode{\sphinxupquote{BLIB\_}}
(e.g. \sphinxcode{\sphinxupquote{LIBNAME}} \sphinxhyphen{}\textgreater{} \sphinxcode{\sphinxupquote{BLIB\_LIBNAME}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Argument parsing}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{options}\PYG{+w}{ }\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{oneValueArgs}\PYG{+w}{ }\PYG{l+s}{LIBNAME}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{multiValueArgs}\PYG{+w}{ }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{l+s}{TEST\PYGZus{}SOURCES}
\PYG{+w}{                    }\PYG{l+s}{DEPRECATED\PYGZus{}HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{MODULE\PYGZus{}ENABLED\PYGZus{}FEATURES}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{cmake\PYGZus{}parse\PYGZus{}arguments}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}BLIB\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}options\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}oneValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}multiValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ARGN}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the following block, we add modules in the src folder to a list
and modules in the contrib folder to a different list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Get path src/module or contrib/module}
\PYG{+w}{  }\PYG{n+nb}{string}\PYG{p}{(}\PYG{l+s}{REPLACE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{FOLDER}
\PYG{+w}{                }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Add library to a global list of libraries}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}FOLDER\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{MATCHES}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}src\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3\PYGZhy{}libs}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZcb{};\PYGZdl{}\PYGZob{}ns3\PYGZhy{}libs\PYGZcb{}\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}list of processed upstream modules\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3\PYGZhy{}contrib\PYGZhy{}libs}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZcb{};\PYGZdl{}\PYGZob{}ns3\PYGZhy{}contrib\PYGZhy{}libs\PYGZcb{}\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}list of processed contrib modules\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the following block, we check if we are working with Xcode, which does
not handle correctly CMake object libraries (.o files).

\sphinxAtStartPar
In other platforms,
we build an object file \sphinxcode{\sphinxupquote{add\_library(\$\{lib\$\{BLIB\_LIBNAME\}\sphinxhyphen{}obj\} OBJECT "\$\{BLIB\_SOURCE\_FILES\}...)}}
and a shared library \sphinxcode{\sphinxupquote{add\_library(\$\{lib\$\{BLIB\_LIBNAME\}\} SHARED ...)}}.

\sphinxAtStartPar
The object library contains the actual source files (\sphinxcode{\sphinxupquote{\$\{BLIB\_SOURCE\_FILES\}}}),
but is not linked, which mean we can reuse the object to build the static version of the libraries.
Notice the shared library uses the object file as its source files
\sphinxcode{\sphinxupquote{\$\textless{}TARGET\_OBJECTS:\$\{lib\$\{BLIB\_LIBNAME\}\sphinxhyphen{}obj\}}}.

\sphinxAtStartPar
Notice that we can also reuse precompiled headers created previously to speed up the
parsing phase of the compilation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{XCODE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Create object library with sources and headers, that will be used in}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} lib\PYGZhy{}ns3\PYGZhy{}static and the shared library}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}obj\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{OBJECT}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}SOURCE\PYGZus{}FILES\PYGZcb{}\PYGZdq{}}
\PYG{+w}{                                      }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}HEADER\PYGZus{}FILES\PYGZcb{}\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}

\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PRECOMPILE\PYGZus{}HEADERS\PYGZus{}ENABLED}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}obj\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{REUSE\PYGZus{}FROM}\PYG{+w}{ }\PYG{l+s}{stdlib\PYGZus{}pch}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} Create shared library with previously created object library (saving}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} compilation time for static libraries)}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{SHARED}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZlt{}}\PYG{n+nv}{TARGET\PYGZus{}OBJECTS:\PYGZdl{}\PYGZob{}lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZhy{}obj\PYGZcb{}}\PYG{o}{\PYGZgt{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Xcode and CMake don\PYGZsq{}t play well when using object libraries, so we have a}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} specific path for that}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{SHARED}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}SOURCE\PYGZus{}FILES\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PRECOMPILE\PYGZus{}HEADERS\PYGZus{}ENABLED}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{REUSE\PYGZus{}FROM}\PYG{+w}{ }\PYG{l+s}{stdlib\PYGZus{}pch}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the next code block, we create an alias to \sphinxcode{\sphinxupquote{libmodule}}, \sphinxcode{\sphinxupquote{ns3::libmodule}},
which can later be used when importing \sphinxstyleemphasis{ns\sphinxhyphen{}3} with CMake’s \sphinxcode{\sphinxupquote{find\_package(ns3)}}.

\sphinxAtStartPar
Then, we associate configured headers (\sphinxcode{\sphinxupquote{config\sphinxhyphen{}store\sphinxhyphen{}config}}, \sphinxcode{\sphinxupquote{core\sphinxhyphen{}config.h}} and
\sphinxcode{\sphinxupquote{version\sphinxhyphen{}defines.h}}) to the core module.

\sphinxAtStartPar
And finally associate all of the public headers of the module to that library,
to make sure CMake will be refreshed in case one of them changes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{l+s}{ns3::}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{ALIAS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Associate public headers with library for installation purposes}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{STREQUAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}core\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{config\PYGZus{}headers}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/config\PYGZhy{}store\PYGZhy{}config.h}
\PYG{+w}{                      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/core\PYGZhy{}config.h}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}ENABLE\PYGZus{}BUILD\PYGZus{}VERSION}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{config\PYGZus{}headers}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/version\PYGZhy{}defines.h}
\PYG{+w}{      }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set\PYGZus{}target\PYGZus{}properties}\PYG{p}{(}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{PROPERTIES}
\PYG{+w}{      }\PYG{l+s}{PUBLIC\PYGZus{}HEADER}
\PYG{+w}{      }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}HEADER\PYGZus{}FILES\PYGZcb{};\PYGZdl{}\PYGZob{}BLIB\PYGZus{}DEPRECATED\PYGZus{}HEADER\PYGZus{}FILES\PYGZcb{};\PYGZdl{}\PYGZob{}config\PYGZus{}headers\PYGZcb{};\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY\PYGZcb{}/\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZhy{}module.h\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the next code block, we make the library a dependency to the ClangAnalyzer’s time trace report,
which measures which step of compilation took most time and which files were responsible for that.

\sphinxAtStartPar
Then, the \sphinxstyleemphasis{ns\sphinxhyphen{}3} libraries are separated from non\sphinxhyphen{}\sphinxstyleemphasis{ns\sphinxhyphen{}3} libraries, that can be propagated or not
for libraries/executables linked to the current \sphinxstyleemphasis{ns\sphinxhyphen{}3} module being processed.

\sphinxAtStartPar
The default is propagating these third\sphinxhyphen{}party libraries and their include directories, but this
can be turned off by setting \sphinxcode{\sphinxupquote{NS3\_REEXPORT\_THIRD\_PARTY\_LIBRARIES=OFF}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}CLANG\PYGZus{}TIMETRACE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}dependencies}\PYG{p}{(}\PYG{l+s}{timeTraceReport}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Split ns and non\PYGZhy{}ns libraries to manage their propagation properly}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{non\PYGZus{}ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{foreach}\PYG{p}{(}\PYG{l+s}{library}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{remove\PYGZus{}lib\PYGZus{}prefix}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}library\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{module\PYGZus{}name}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} Check if the module exists in the ns\PYGZhy{}3 modules list}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} or if it is a 3rd\PYGZhy{}party library}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{module\PYGZus{}name}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{IN\PYGZus{}LIST}\PYG{+w}{ }\PYG{l+s}{ns3\PYGZhy{}all\PYGZhy{}enabled\PYGZhy{}modules}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{APPEND}\PYG{+w}{ }\PYG{l+s}{non\PYGZus{}ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{library}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{unset}\PYG{p}{(}\PYG{l+s}{module\PYGZus{}name}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endforeach}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}REEXPORT\PYGZus{}THIRD\PYGZus{}PARTY\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} ns\PYGZhy{}3 libraries are linked publicly, to make sure other modules can find}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} each other without being directly linked}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{exported\PYGZus{}libraries}\PYG{+w}{ }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} non\PYGZhy{}ns\PYGZhy{}3 libraries are linked privately, not propagating unnecessary}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} libraries such as pthread, librt, etc}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{private\PYGZus{}libraries}\PYG{+w}{ }\PYG{l+s}{PRIVATE}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{non\PYGZus{}ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} we don\PYGZsq{}t re\PYGZhy{}export included libraries from 3rd\PYGZhy{}party modules}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{exported\PYGZus{}include\PYGZus{}directories}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} we export everything by default when NS3\PYGZus{}REEXPORT\PYGZus{}THIRD\PYGZus{}PARTY\PYGZus{}LIBRARIES=ON}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{exported\PYGZus{}libraries}\PYG{+w}{ }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{non\PYGZus{}ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{private\PYGZus{}libraries}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} with NS3\PYGZus{}REEXPORT\PYGZus{}THIRD\PYGZus{}PARTY\PYGZus{}LIBRARIES, we export all 3rd\PYGZhy{}party library}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} include directories, allowing consumers of this module to include and link}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} the 3rd\PYGZhy{}party code with no additional setup}
\PYG{+w}{    }\PYG{n+nb}{get\PYGZus{}target\PYGZus{}includes}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{exported\PYGZus{}include\PYGZus{}directories}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{string}\PYG{p}{(}\PYG{l+s}{REPLACE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}I\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{exported\PYGZus{}include\PYGZus{}directories}
\PYG{+w}{                  }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}exported\PYGZus{}include\PYGZus{}directories\PYGZcb{}\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{string}\PYG{p}{(}\PYG{l+s}{REPLACE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY\PYGZcb{}/include\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{+w}{                  }\PYG{l+s}{exported\PYGZus{}include\PYGZus{}directories}
\PYG{+w}{                  }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}exported\PYGZus{}include\PYGZus{}directories\PYGZcb{}\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After the lists of libraries to link that should be exported (\sphinxcode{\sphinxupquote{PUBLIC}}) and
not exported (\sphinxcode{\sphinxupquote{PRIVATE}}) are built, we can link them with \sphinxcode{\sphinxupquote{target\_link\_libraries}}.

\sphinxAtStartPar
Next, we set the output name of the module library to \sphinxcode{\sphinxupquote{n3version\sphinxhyphen{}modulename}} (+ optional build suffix).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{exported\PYGZus{}libraries}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{private\PYGZus{}libraries}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} set output name of library}
\PYG{+w}{  }\PYG{n+nb}{set\PYGZus{}target\PYGZus{}properties}\PYG{p}{(}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{OUTPUT\PYGZus{}NAME}\PYG{+w}{ }\PYG{l+s}{ns}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VER}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{build\PYGZus{}profile\PYGZus{}suffix}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we export include directories, to let library consumers importing \sphinxstyleemphasis{ns\sphinxhyphen{}3} via CMake
use them just by linking to one of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} export include directories used by this library so that it can be used by}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} 3rd\PYGZhy{}party consumers of ns\PYGZhy{}3 using find\PYGZus{}package(ns3) this will automatically}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} add the build/include path to them, so that they can ns\PYGZhy{}3 headers with}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} \PYGZlt{}ns3/something.h\PYGZgt{}}
\PYG{+w}{  }\PYG{n+nb}{target\PYGZus{}include\PYGZus{}directories}\PYG{p}{(}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZlt{}}\PYG{n+nv}{BUILD\PYGZus{}INTERFACE:\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY\PYGZcb{}/include}\PYG{o}{\PYGZgt{}}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZlt{}}\PYG{n+nv}{INSTALL\PYGZus{}INTERFACE:include}\PYG{o}{\PYGZgt{}}
\PYG{+w}{    }\PYG{l+s}{INTERFACE}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{exported\PYGZus{}include\PYGZus{}directories}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We append the list of third\sphinxhyphen{}party/external libraries for each processed module,
and append a list of object libraries that can be later used for the static \sphinxstyleemphasis{ns\sphinxhyphen{}3} build.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3\PYGZhy{}external\PYGZhy{}libs}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}non\PYGZus{}ns\PYGZus{}libraries\PYGZus{}to\PYGZus{}link\PYGZcb{};\PYGZdl{}\PYGZob{}ns3\PYGZhy{}external\PYGZhy{}libs\PYGZcb{}\PYGZdq{}}
\PYG{+w}{      }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}
\PYG{+w}{            }\PYG{l+s+s2}{\PYGZdq{}list of non\PYGZhy{}ns libraries to link to NS3\PYGZus{}STATIC and NS3\PYGZus{}MONOLIB\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}STATIC}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{OR}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}MONOLIB}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{lib\PYGZhy{}ns3\PYGZhy{}static\PYGZhy{}objs}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZlt{}TARGET\PYGZus{}OBJECTS:\PYGZdl{}\PYGZob{}lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZhy{}obj\PYGZcb{}\PYGZgt{};\PYGZdl{}\PYGZob{}lib\PYGZhy{}ns3\PYGZhy{}static\PYGZhy{}objs\PYGZcb{}\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s}{CACHE}
\PYG{+w}{          }\PYG{l+s}{INTERNAL}
\PYG{+w}{          }\PYG{l+s+s2}{\PYGZdq{}list of object files from module used by NS3\PYGZus{}STATIC and NS3\PYGZus{}MONOLIB\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following block creates the \sphinxcode{\sphinxupquote{\$\{BLIB\_LIBNAME\}\sphinxhyphen{}module.h}} header for user scripts,
and copies header files from \sphinxcode{\sphinxupquote{src/module}} and \sphinxcode{\sphinxupquote{contrib/module}} to the \sphinxcode{\sphinxupquote{include/ns3}} directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Write a module header that includes all headers from that module}
\PYG{+w}{  }\PYG{n+nb}{write\PYGZus{}module\PYGZus{}header}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}HEADER\PYGZus{}FILES\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Copy all header files to outputfolder/include before each build}
\PYG{+w}{  }\PYG{n+nb}{copy\PYGZus{}headers\PYGZus{}before\PYGZus{}building\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}HEADER\PYGZus{}FILES\PYGZcb{}\PYGZdq{}}
\PYG{+w}{    }\PYG{l+s}{public}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{BLIB\PYGZus{}DEPRECATED\PYGZus{}HEADER\PYGZus{}FILES}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{copy\PYGZus{}headers\PYGZus{}before\PYGZus{}building\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}DEPRECATED\PYGZus{}HEADER\PYGZus{}FILES\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{deprecated}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following block creates the test library for the module currently being processed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Check if the module tests should be built}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{IN\PYGZus{}LIST}\PYG{+w}{ }\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Build tests if requested}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ENABLE\PYGZus{}TESTS}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{filtered\PYGZus{}in}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{LENGTH}\PYG{+w}{ }\PYG{l+s}{BLIB\PYGZus{}TEST\PYGZus{}SOURCES}\PYG{+w}{ }\PYG{l+s}{test\PYGZus{}source\PYGZus{}len}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZus{}source\PYGZus{}len}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{GREATER}\PYG{+w}{ }\PYG{l+s}{0}\PYG{p}{)}
\PYG{+w}{      }\PYG{c}{\PYGZsh{} Create BLIB\PYGZus{}LIBNAME of output library test of module}
\PYG{+w}{      }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{test}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{lib}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}test}\PYG{+w}{ }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3\PYGZhy{}libs\PYGZhy{}tests}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME\PYGZcb{}\PYGZcb{};\PYGZdl{}\PYGZob{}ns3\PYGZhy{}libs\PYGZhy{}tests\PYGZcb{}\PYGZdq{}}
\PYG{+w}{          }\PYG{l+s}{CACHE}\PYG{+w}{ }\PYG{l+s}{INTERNAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}list of test libraries\PYGZdq{}}
\PYG{+w}{      }\PYG{p}{)}

\PYG{+w}{      }\PYG{c}{\PYGZsh{} Create shared library containing tests of the module}
\PYG{+w}{      }\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{SHARED}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}TEST\PYGZus{}SOURCES\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{      }\PYG{c}{\PYGZsh{} Link test library to the module library}
\PYG{+w}{      }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}MONOLIB}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZhy{}ns3\PYGZhy{}monolib}\PYG{o}{\PYGZcb{}}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{o}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}
\PYG{+w}{          }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{          }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{o}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{set\PYGZus{}target\PYGZus{}properties}\PYG{p}{(}
\PYG{+w}{        }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{        }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{OUTPUT\PYGZus{}NAME}
\PYG{+w}{                  }\PYG{l+s}{ns}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VER}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}test}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{build\PYGZus{}profile\PYGZus{}suffix}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{p}{)}

\PYG{+w}{      }\PYG{n+nb}{target\PYGZus{}compile\PYGZus{}definitions}\PYG{p}{(}
\PYG{+w}{        }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{PRIVATE}\PYG{+w}{ }\PYG{l+s}{NS\PYGZus{}TEST\PYGZus{}SOURCEDIR=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}FOLDER\PYGZcb{}/test\PYGZdq{}}
\PYG{+w}{      }\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PRECOMPILE\PYGZus{}HEADERS\PYGZus{}ENABLED}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{test\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{REUSE\PYGZus{}FROM}\PYG{+w}{ }\PYG{l+s}{stdlib\PYGZus{}pch}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following block checks for examples subdirectories and add them to parse their
CMakeLists.txt file, creating the examples. It also scans for python examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Build lib examples if requested}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ENABLE\PYGZus{}EXAMPLES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{foreach}\PYG{p}{(}\PYG{l+s}{example\PYGZus{}folder}\PYG{+w}{ }\PYG{l+s}{example;examples}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{EXISTS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{example\PYGZus{}folder}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{EXISTS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{example\PYGZus{}folder}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/CMakeLists.txt}\PYG{p}{)}
\PYG{+w}{          }\PYG{n+nb}{add\PYGZus{}subdirectory}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{example\PYGZus{}folder}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{        }\PYG{n+nb}{scan\PYGZus{}python\PYGZus{}examples}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{example\PYGZus{}folder}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endforeach}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the next code block we add the library to the \sphinxcode{\sphinxupquote{ns3ExportTargets}}, later used for installation.
We also print an additional message the folder just finished being processed if \sphinxcode{\sphinxupquote{NS3\_VERBOSE}} is set to \sphinxcode{\sphinxupquote{ON}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Handle package export}
\PYG{+w}{  }\PYG{n+nb}{install}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{TARGETS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{EXPORT}\PYG{+w}{ }\PYG{l+s}{ns3ExportTargets}
\PYG{+w}{    }\PYG{l+s}{ARCHIVE}\PYG{+w}{ }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}INSTALL\PYGZus{}LIBDIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}
\PYG{+w}{    }\PYG{l+s}{LIBRARY}\PYG{+w}{ }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}INSTALL\PYGZus{}LIBDIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}
\PYG{+w}{    }\PYG{l+s}{PUBLIC\PYGZus{}HEADER}\PYG{+w}{ }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}INSTALL\PYGZus{}INCLUDEDIR\PYGZcb{}/ns3\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VERBOSE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Processed \PYGZdl{}\PYGZob{}FOLDER\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{Module macros: build\_lib\_example}
\label{\detokenize{working-with-cmake:module-macros-build-lib-example}}\label{\detokenize{working-with-cmake:build-lib-example}}
\sphinxAtStartPar
The second most important macro from a module author perspective is the \sphinxcode{\sphinxupquote{build\_lib\_example}}, which
builds the examples for their module. As with \sphinxcode{\sphinxupquote{build\_lib}} we explain what it does block\sphinxhyphen{}by\sphinxhyphen{}block.

\sphinxAtStartPar
In the first block, arguments are parsed and we check whether the current module is in the contrib
or the src folder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib\PYGZus{}example}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Argument parsing}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{options}\PYG{+w}{ }\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{oneValueArgs}\PYG{+w}{ }\PYG{l+s}{NAME}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{multiValueArgs}\PYG{+w}{ }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{cmake\PYGZus{}parse\PYGZus{}arguments}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}BLIB\PYGZus{}EXAMPLE\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}options\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}oneValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}multiValueArgs\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ARGN}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Get path src/module or contrib/module}
\PYG{+w}{  }\PYG{n+nb}{string}\PYG{p}{(}\PYG{l+s}{REPLACE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{FOLDER}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{get\PYGZus{}filename\PYGZus{}component}\PYG{p}{(}\PYG{l+s}{FOLDER}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{FOLDER}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{DIRECTORY}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then we check if the \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules required by the example are enabled to be built.
If the list \sphinxcode{\sphinxupquote{missing\_dependencies}} is empty, we create the example. Otherwise, we skip it.
The example can be linked to the current module (\sphinxcode{\sphinxupquote{\$\{lib\$\{BLIB\_EXAMPLE\_LIBNAME\}\}}}) and
other libraries to link (\sphinxcode{\sphinxupquote{\$\{BLIB\_EXAMPLE\_LIBRARIES\_TO\_LINK\}}}) and optionally to the visualizer
module (\sphinxcode{\sphinxupquote{\$\{optional\_visualizer\_lib\}}}).
If the visualizer module is not enabled, \sphinxcode{\sphinxupquote{optional\_visualizer\_lib}} is empty.

\sphinxAtStartPar
The example can also be linked to a single \sphinxstyleemphasis{ns\sphinxhyphen{}3} shared library (\sphinxcode{\sphinxupquote{lib\sphinxhyphen{}ns3\sphinxhyphen{}monolib}}) or
a single \sphinxstyleemphasis{ns\sphinxhyphen{}3} static library (\sphinxcode{\sphinxupquote{lib\sphinxhyphen{}ns3\sphinxhyphen{}static}}), if either \sphinxcode{\sphinxupquote{NS3\_MONOLIB=ON}} or \sphinxcode{\sphinxupquote{NS3\_STATIC=ON}}.
Note that both of these options are handled by the \sphinxcode{\sphinxupquote{build\_exec}} macro.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{function}\PYG{p}{(}\PYG{l+s}{build\PYGZus{}lib\PYGZus{}example}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} ...}
\PYG{+w}{  }\PYG{n+nb}{check\PYGZus{}for\PYGZus{}missing\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{missing\PYGZus{}dependencies}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}BLIB\PYGZus{}EXAMPLE\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK\PYGZcb{}\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Check if a module example should be built}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{IN\PYGZus{}LIST}\PYG{+w}{ }\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{p}{)}
\PYG{+w}{      }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{filtered\PYGZus{}in}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{l+s}{missing\PYGZus{}dependencies}\PYG{p}{)}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{filtered\PYGZus{}in}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{     }\PYG{c}{\PYGZsh{} Convert boolean into text to forward argument}
\PYG{+w}{     }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}EXAMPLE\PYGZus{}IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{       }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{+w}{ }\PYG{l+s}{IGNORE\PYGZus{}PCH}\PYG{p}{)}
\PYG{+w}{     }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{     }\PYG{c}{\PYGZsh{} Create executable with sources and headers}
\PYG{+w}{     }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: off}
\PYG{+w}{     }\PYG{n+nb}{build\PYGZus{}exec}\PYG{p}{(}
\PYG{+w}{       }\PYG{l+s}{EXECNAME}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}EXAMPLE\PYGZus{}NAME}\PYG{o}{\PYGZcb{}}
\PYG{+w}{       }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}EXAMPLE\PYGZus{}SOURCE\PYGZus{}FILES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{       }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}EXAMPLE\PYGZus{}HEADER\PYGZus{}FILES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{       }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}
\PYG{+w}{         }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{lib\PYGZdl{}\PYGZob{}BLIB\PYGZus{}EXAMPLE\PYGZus{}LIBNAME}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{BLIB\PYGZus{}EXAMPLE\PYGZus{}LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{o}{\PYGZcb{}}
\PYG{+w}{         }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{optional\PYGZus{}visualizer\PYGZus{}lib}\PYG{o}{\PYGZcb{}}
\PYG{+w}{       }\PYG{l+s}{EXECUTABLE\PYGZus{}DIRECTORY\PYGZus{}PATH}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}RUNTIME\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{FOLDER}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}
\PYG{+w}{       }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IGNORE\PYGZus{}PCH}\PYG{o}{\PYGZcb{}}
\PYG{+w}{     }\PYG{p}{)}
\PYG{+w}{     }\PYG{c}{\PYGZsh{} cmake\PYGZhy{}format: on}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endfunction}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The {\hyperref[\detokenize{working-with-cmake:build-exec}]{\sphinxcrossref{build\_exec}}} macro will also set resulting folder where the example will end up
after built (e.g. build/src/module/examples). It does that by forwarding the
\sphinxcode{\sphinxupquote{EXECUTABLE\_DIRECTORY\_PATH}} to the macro \sphinxcode{\sphinxupquote{set\_runtime\_outputdirectory}}, which also
adds the proper \sphinxstyleemphasis{ns\sphinxhyphen{}3} version prefix and build type suffix to the executable.

\sphinxAtStartPar
As with the module libraries, we can also reuse precompiled headers here to speed up
the parsing step of compilation.
You can find more information about \sphinxcode{\sphinxupquote{IGNORE\_PCH}} at the {\hyperref[\detokenize{working-with-cmake:pch-side-effects}]{\sphinxcrossref{PCH side\sphinxhyphen{}effects}}} section.


\paragraph{User options and header checking}
\label{\detokenize{working-with-cmake:user-options-and-header-checking}}
\sphinxAtStartPar
User\sphinxhyphen{}settable options should be prefixed with \sphinxcode{\sphinxupquote{NS3\_}}, otherwise
they will not be preserved by \sphinxcode{\sphinxupquote{./ns3 configure \sphinxhyphen{}\sphinxhyphen{}force\sphinxhyphen{}refresh}}.

\sphinxAtStartPar
After checking if the pre\sphinxhyphen{}requisites of the user\sphinxhyphen{}settable options
are met, set the same option now prefixed with \sphinxcode{\sphinxupquote{ENABLE\_}}. The
following example demonstrates this pattern:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Option() means the variable NS3\PYGZus{}GSL will be set to ON/OFF}
\PYG{c}{\PYGZsh{} The second argument is a comment explaining what this option does}
\PYG{c}{\PYGZsh{} The last argument is the default value for the user\PYGZhy{}settable option}
\PYG{n+nb}{option}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}GSL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Enable GSL related features\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set the ENABLE\PYGZbs{}\PYGZus{} counterpart to FALSE by default}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ENABLE\PYGZus{}GSL}\PYG{+w}{ }\PYG{l+s}{FALSE}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}GSL}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} If the user enabled GSL, check if GSL is available}
\PYG{+w}{  }\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{GSL}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{GSL\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ENABLE\PYGZus{}GSL}\PYG{+w}{ }\PYG{l+s}{TRUE}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GSL was requested by the user and was found\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GSL was not found and GSL features will continue disabled\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GSL features were not requested by the user\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Now the module can check for ENABLE\PYGZus{}GSL before being processed}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ENABLE\PYGZus{}GSL}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{return}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Or to enable optional features}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{gsl\PYGZus{}sources}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ENABLE\PYGZus{}GSL}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{gsl\PYGZus{}sources}\PYG{+w}{ }\PYG{l+s}{model/gsl\PYGZus{}features.cc}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here are examples of how to do the options and header checking,
followed by a header configuration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} We always set the ENABLE\PYGZbs{}\PYGZus{} counterpart of NS3\PYGZbs{}\PYGZus{} option to FALSE before checking}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} If this variable is created inside your module, use}
\PYG{c}{\PYGZsh{} set(ENABLE\PYGZus{}MPI FALSE CACHE INTERNAL \PYGZdq{}\PYGZdq{})}
\PYG{c}{\PYGZsh{} instead, to make it globally available}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ENABLE\PYGZus{}MPI}\PYG{+w}{ }\PYG{l+s}{FALSE}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If the user option switch is set to ON, we check}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}MPI}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Use find\PYGZus{}package to look for MPI}
\PYG{+w}{  }\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{MPI}\PYG{+w}{ }\PYG{l+s}{QUIET}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} If the package is optional, which is the case for MPI,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} we can proceed if it is not found}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{MPI\PYGZus{}FOUND}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}MPI was not found. Continuing without it.\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} If it is false, we add necessary C++ definitions (e.g. NS3\PYGZus{}MPI)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}MPI was found.\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}DNS3\PYGZus{}MPI}\PYG{p}{)}

\PYG{+w}{    }\PYG{c}{\PYGZsh{} Then set ENABLE\PYGZus{}MPI to TRUE, which can be used to check}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} if NS3\PYGZus{}MPI is enabled AND MPI was found}
\PYG{+w}{    }\PYG{c}{\PYGZsh{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} If this variable is created inside your module, use}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} set(ENABLE\PYGZus{}MPI TRUE CACHE INTERNAL \PYGZdq{}\PYGZdq{})}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} instead, to make it globally available}
\PYG{+w}{    }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ENABLE\PYGZus{}MPI}\PYG{+w}{ }\PYG{l+s}{TRUE}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} ...}

\PYG{c}{\PYGZsh{} These two standard CMake modules allow for header and function checking}
\PYG{n+nb}{include}\PYG{p}{(}\PYG{l+s}{CheckIncludeFileCXX}\PYG{p}{)}
\PYG{n+nb}{include}\PYG{p}{(}\PYG{l+s}{CheckFunctionExists}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Check for required headers and functions,}
\PYG{c}{\PYGZsh{} set flags on the right argument if header in the first argument is found}
\PYG{c}{\PYGZsh{} if they are not found, a warning is emitted}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}stdint.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}STDINT\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}inttypes.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}INTTYPES\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}sys/types.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}SYS\PYGZus{}TYPES\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}stat.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}SYS\PYGZus{}STAT\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}dirent.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}DIRENT\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}stdlib.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}STDLIB\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}signal.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}SIGNAL\PYGZus{}H\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}include\PYGZus{}file\PYGZus{}cxx}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}netpacket/packet.h\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}PACKETH\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}function\PYGZus{}exists}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}getenv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}HAVE\PYGZus{}GETENV\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This is the CMake command to open up a file template (in this case a header}
\PYG{c}{\PYGZsh{} passed as the first argument), then fill its fields with values stored in}
\PYG{c}{\PYGZsh{} CMake variables and save the resulting file to the target destination}
\PYG{c}{\PYGZsh{} (in the second argument)}
\PYG{n+nb}{configure\PYGZus{}file}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{build\PYGZhy{}support/core\PYGZhy{}config\PYGZhy{}template.h}
\PYG{+w}{  }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}HEADER\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/core\PYGZhy{}config.h}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The configure\_file command is not very clear by itself, as you do not know which
values are being used. So we need to check the template.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef NS3\PYGZus{}CORE\PYGZus{}CONFIG\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NS3\PYGZus{}CORE\PYGZus{}CONFIG\PYGZus{}H}

\PYG{c+c1}{// Defined if HAVE\PYGZus{}UINT128\PYGZus{}T is defined in CMake}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine   HAVE\PYGZus{}UINT128\PYGZus{}T}
\PYG{c+c1}{// Set to 1 if HAVE\PYGZus{}\PYGZus{}UINT128\PYGZus{}T is defined in CMake, 0 otherwise}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}\PYGZus{}\PYGZus{}UINT128\PYGZus{}T}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine   INT64X64\PYGZus{}USE\PYGZus{}128}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine   INT64X64\PYGZus{}USE\PYGZus{}DOUBLE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine   INT64X64\PYGZus{}USE\PYGZus{}CAIRO}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}STDINT\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}INTTYPES\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine   HAVE\PYGZus{}SYS\PYGZus{}INT\PYGZus{}TYPES\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}SYS\PYGZus{}TYPES\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}SYS\PYGZus{}STAT\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}DIRENT\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}STDLIB\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}GETENV}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine01 HAVE\PYGZus{}SIGNAL\PYGZus{}H}

\PYG{c+cm}{/*}
\PYG{c+cm}{* \PYGZsh{}cmakedefine turns into:}
\PYG{c+cm}{* //\PYGZsh{}define HAVE\PYGZus{}FLAG // if HAVE\PYGZus{}FLAG is not defined in CMake (e.g. unset(HAVE\PYGZus{}FLAG))}
\PYG{c+cm}{* \PYGZsh{}define HAVE\PYGZus{}FLAG // if HAVE\PYGZus{}FLAG is defined in CMake (e.g. set(HAVE\PYGZus{}FLAG))}
\PYG{c+cm}{*}
\PYG{c+cm}{* \PYGZsh{}cmakedefine01 turns into:}
\PYG{c+cm}{* \PYGZsh{}define HAVE\PYGZus{}FLAG 0 // if HAVE\PYGZus{}FLAG is not defined in CMake}
\PYG{c+cm}{* \PYGZsh{}define HAVE\PYGZus{}FLAG 1 // if HAVE\PYGZus{}FLAG is defined in CMake}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+c1}{//NS3\PYGZus{}CORE\PYGZus{}CONFIG\PYGZus{}H}
\end{sphinxVerbatim}


\paragraph{Custom targets}
\label{\detokenize{working-with-cmake:custom-targets}}
\sphinxAtStartPar
Another common thing to do is implement custom targets that run specific commands and
manage dependencies. Here is an example for Doxygen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} This command hides DOXYGEN from some CMake cache interfaces}
\PYG{n+nb}{mark\PYGZus{}as\PYGZus{}advanced}\PYG{p}{(}\PYG{l+s}{DOXYGEN}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This custom macro checks for dependencies CMake find\PYGZus{}package and program}
\PYG{c}{\PYGZsh{} dependencies and return the missing dependencies in the third argument}
\PYG{n+nb}{check\PYGZus{}deps}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}doxygen;dot;dia\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{doxygen\PYGZus{}docs\PYGZus{}missing\PYGZus{}deps}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If the variable contains missing dependencies, we stop processing doxygen targets}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{doxygen\PYGZus{}docs\PYGZus{}missing\PYGZus{}deps}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{STATUS}
\PYG{+w}{      }\PYG{l+s+s2}{\PYGZdq{}docs: doxygen documentation not enabled due to missing dependencies: \PYGZdl{}\PYGZob{}doxygen\PYGZus{}docs\PYGZus{}missing\PYGZus{}deps\PYGZcb{}\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{n+nb}{else}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} We checked this already exists, but we need the path to the executable}
\PYG{+w}{  }\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{Doxygen}\PYG{+w}{ }\PYG{l+s}{QUIET}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Get introspected doxygen}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}custom\PYGZus{}target}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{run\PYGZhy{}print\PYGZhy{}introspected\PYGZhy{}doxygen}
\PYG{+w}{    }\PYG{l+s}{COMMAND}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/utils/ns}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VER}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}print\PYGZhy{}introspected\PYGZhy{}doxygen}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{build\PYGZus{}profile\PYGZus{}suffix}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/introspected\PYGZhy{}doxygen.h}
\PYG{+w}{    }\PYG{l+s}{COMMAND}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}OUTPUT\PYGZus{}DIRECTORY}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/utils/ns}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{NS3\PYGZus{}VER}\PYG{o}{\PYGZcb{}}\PYG{l+s}{\PYGZhy{}print\PYGZhy{}introspected\PYGZhy{}doxygen}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{build\PYGZus{}profile\PYGZus{}suffix}\PYG{o}{\PYGZcb{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZhy{}\PYGZhy{}output\PYGZhy{}text}\PYG{+w}{ }\PYG{l+s}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/ns3\PYGZhy{}object.txt}
\PYG{+w}{    }\PYG{l+s}{DEPENDS}\PYG{+w}{ }\PYG{l+s}{print\PYGZhy{}introspected\PYGZhy{}doxygen}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Run test.py with NS\PYGZus{}COMMANDLINE\PYGZus{}INTROSPECTION=.. to print examples}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} introspected commandline}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}custom\PYGZus{}target}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{run\PYGZhy{}introspected\PYGZhy{}command\PYGZhy{}line}
\PYG{+w}{    }\PYG{l+s}{COMMAND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}COMMAND}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}E}\PYG{+w}{ }\PYG{l+s}{env}\PYG{+w}{ }\PYG{l+s}{NS\PYGZus{}COMMANDLINE\PYGZus{}INTROSPECTION=..}
\PYG{+w}{            }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{Python\PYGZus{}EXECUTABLE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{./test.py}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}\PYGZhy{}no\PYGZhy{}build}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}\PYGZhy{}constrain=example}
\PYG{+w}{    }\PYG{l+s}{WORKING\PYGZus{}DIRECTORY}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{DEPENDS}\PYG{+w}{ }\PYG{l+s}{all\PYGZhy{}test\PYGZhy{}targets}\PYG{+w}{ }\PYG{c}{\PYGZsh{} all\PYGZhy{}test\PYGZhy{}targets only exists if ENABLE\PYGZus{}TESTS is}
\PYG{+w}{                             }\PYG{c}{\PYGZsh{} set to ON}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} This file header is written during configuration}
\PYG{+w}{  }\PYG{n+nb}{file}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{WRITE}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/introspected\PYGZhy{}command\PYGZhy{}line.h}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}/* This file is automatically generated by}
\PYG{l+s+s2}{CommandLine::PrintDoxygenUsage() from the CommandLine configuration}
\PYG{l+s+s2}{in various example programs.  Do not edit this file!  Edit the}
\PYG{l+s+s2}{CommandLine configuration in those files instead.}
\PYG{l+s+s2}{*/}
\PYG{l+s+s2}{\PYGZbs{}n\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} After running test.py for the introspected commandline above,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} merge outputs and concatenate to the header file created during}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} configuration}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}custom\PYGZus{}target}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{assemble\PYGZhy{}introspected\PYGZhy{}command\PYGZhy{}line}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} works on CMake 3.18 or newer \PYGZgt{} COMMAND \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}COMMAND\PYGZcb{} \PYGZhy{}E cat}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/testpy\PYGZhy{}output/*.command\PYGZhy{}line \PYGZgt{}}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} \PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/doc/introspected\PYGZhy{}command\PYGZhy{}line.h}
\PYG{+w}{    }\PYG{l+s}{COMMAND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{cat\PYGZus{}command}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/testpy\PYGZhy{}output/*.command\PYGZhy{}line}
\PYG{+w}{            }\PYG{l+s}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/introspected\PYGZhy{}command\PYGZhy{}line.h}\PYG{+w}{ }\PYG{l+s}{2\PYGZgt{}}\PYG{+w}{ }\PYG{l+s}{NULL}
\PYG{+w}{    }\PYG{l+s}{DEPENDS}\PYG{+w}{ }\PYG{l+s}{run\PYGZhy{}introspected\PYGZhy{}command\PYGZhy{}line}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Create a target that updates the doxygen version}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}custom\PYGZus{}target}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{update\PYGZus{}doxygen\PYGZus{}version}
\PYG{+w}{    }\PYG{l+s}{COMMAND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/ns3\PYGZus{}html\PYGZus{}theme/get\PYGZus{}version.sh}
\PYG{+w}{    }\PYG{l+s}{WORKING\PYGZus{}DIRECTORY}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Create a doxygen target that builds the documentation and only runs}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} after the version target above was executed, the introspected doxygen}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} and command line were extracted}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}custom\PYGZus{}target}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{doxygen}
\PYG{+w}{    }\PYG{l+s}{COMMAND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{DOXYGEN\PYGZus{}EXECUTABLE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/doxygen.conf}
\PYG{+w}{    }\PYG{l+s}{WORKING\PYGZus{}DIRECTORY}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{DEPENDS}\PYG{+w}{ }\PYG{l+s}{update\PYGZus{}doxygen\PYGZus{}version}\PYG{+w}{ }\PYG{l+s}{run\PYGZhy{}print\PYGZhy{}introspected\PYGZhy{}doxygen}
\PYG{+w}{            }\PYG{l+s}{assemble\PYGZhy{}introspected\PYGZhy{}command\PYGZhy{}line}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Create a doxygen target that only needs to run the version target}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} which doesn\PYGZsq{}t trigger compilation of examples neither the execution of test.py}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} nor print\PYGZhy{}introspected\PYGZhy{}doxygen}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}custom\PYGZus{}target}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{doxygen\PYGZhy{}no\PYGZhy{}build}
\PYG{+w}{    }\PYG{l+s}{COMMAND}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{DOXYGEN\PYGZus{}EXECUTABLE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/doc/doxygen.conf}
\PYG{+w}{    }\PYG{l+s}{WORKING\PYGZus{}DIRECTORY}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{l+s}{DEPENDS}\PYG{+w}{ }\PYG{l+s}{update\PYGZus{}doxygen\PYGZus{}version}
\PYG{+w}{  }\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Project\sphinxhyphen{}wide compiler and linker flags}
\label{\detokenize{working-with-cmake:project-wide-compiler-and-linker-flags}}
\sphinxAtStartPar
Different compilers and links accept different flags, which must be
known during configuration time. Some of these flags are
handled directly by CMake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} equivalent to \PYGZhy{}fPIC for libraries and \PYGZhy{}fPIE for executables}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}POSITION\PYGZus{}INDEPENDENT\PYGZus{}CODE}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{c}{\PYGZsh{} link\PYGZhy{}time optimization flags such as \PYGZhy{}flto and \PYGZhy{}flto=thin}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}INTERPROCEDURAL\PYGZus{}OPTIMIZATION}\PYG{+w}{ }\PYG{l+s}{TRUE}\PYG{p}{)}

\PYG{c}{\PYGZsh{} C++ standard flag to use}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}CXX\PYGZus{}STANDARD\PYGZus{}MINIMUM}\PYG{+w}{ }\PYG{l+s}{17}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}CXX\PYGZus{}STANDARD\PYGZus{}REQUIRED}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{l+s}{static\PYGZus{}lib}\PYG{+w}{ }\PYG{l+s}{STATIC}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} equivalent to \PYGZhy{}static flag}
\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{l+s}{shared\PYGZus{}lib}\PYG{+w}{ }\PYG{l+s}{SHARED}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} equivalent to \PYGZhy{}shared flags}
\end{sphinxVerbatim}

\sphinxAtStartPar
Other flags need to be handled manually and change based on
the compiler used. The most commonly used are handled in
\sphinxcode{\sphinxupquote{build\sphinxhyphen{}support/macros\sphinxhyphen{}and\sphinxhyphen{}definitions.cmake}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{GCC}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{AND}\PYG{+w}{ }\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{l+s}{APPLE}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} using GCC}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}no\PYGZhy{}as\PYGZhy{}needed}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}as\PYGZhy{}needed}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE\PYGZus{}STATIC}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}whole\PYGZhy{}archive,\PYGZhy{}Bstatic}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST\PYGZus{}STATIC}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}Wl,\PYGZhy{}\PYGZhy{}no\PYGZhy{}whole\PYGZhy{}archive}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST\PYGZus{}STATIC\PYGZus{}DYN}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}Wl,\PYGZhy{}Bdynamic,\PYGZhy{}\PYGZhy{}no\PYGZhy{}whole\PYGZhy{}archive}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{LIB\_AS\_NEEDED}} values are used to force linking of all symbols,
and not only those explicitly used by the applications, which is necessary
since simulation scripts don’t directly use most of the symbols exported
by the modules. Their use can be seen in the \sphinxcode{\sphinxupquote{utils/CMakeLists.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{test\PYGZhy{}runner}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}PRE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ns3\PYGZhy{}libs\PYGZhy{}tests}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LIB\PYGZus{}AS\PYGZus{}NEEDED\PYGZus{}POST}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ns3\PYGZhy{}libs}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ns3\PYGZhy{}contrib\PYGZhy{}libs}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will ensure test\sphinxhyphen{}runner linking to \sphinxcode{\sphinxupquote{ns3\sphinxhyphen{}libs\sphinxhyphen{}tests}} (list containing all
module test libraries) with all symbols, which will make it able to find and run
all tests. The other two lists \sphinxcode{\sphinxupquote{ns3\sphinxhyphen{}libs}} (src modules) and \sphinxcode{\sphinxupquote{ns3\sphinxhyphen{}contrib\sphinxhyphen{}libs}}
(contrib modules) don’t need to be completely linked since the tests libraries are
already linked to them.

\sphinxAtStartPar
Other project\sphinxhyphen{}wide compiler\sphinxhyphen{}dependent flags can be set during compiler checking.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Check if the compiler is GCC}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{GCC}\PYG{+w}{ }\PYG{l+s}{FALSE}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}ID\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{MATCHES}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}GNU\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Check if GCC is a supported version}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}VERSION}\PYG{+w}{ }\PYG{l+s}{VERSION\PYGZus{}LESS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{GNU\PYGZus{}MinVersion}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{n+nb}{message}\PYG{p}{(}
\PYG{+w}{      }\PYG{l+s}{FATAL\PYGZus{}ERROR}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}GNU \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CXX\PYGZus{}COMPILER\PYGZus{}VERSION\PYGZcb{} \PYGZdl{}\PYGZob{}below\PYGZus{}minimum\PYGZus{}msg\PYGZcb{} \PYGZdl{}\PYGZob{}GNU\PYGZus{}MinVersion\PYGZcb{}\PYGZdq{}}
\PYG{+w}{    }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} If GCC is up\PYGZhy{}to\PYGZhy{}date, set flag to true and continue}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{GCC}\PYG{+w}{ }\PYG{l+s}{TRUE}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Disable semantic interposition}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}fno\PYGZhy{}semantic\PYGZhy{}interposition}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}fno\sphinxhyphen{}semantic\sphinxhyphen{}interposition}} flag \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/777}{disables semantic interposition}, which can
reduce overhead of function calls in shared libraries built with \sphinxcode{\sphinxupquote{\sphinxhyphen{}fPIC}}.
This is the default behaviour for Clang. The inlined \sphinxstyleemphasis{ns\sphinxhyphen{}3} calls will not be
correctly interposed by the \sphinxcode{\sphinxupquote{LD\_PRELOAD}} trick, which is not know to be used by \sphinxstyleemphasis{ns\sphinxhyphen{}3} users.
To re\sphinxhyphen{}enable semantic interposition, comment out the line and reconfigure the project.

\sphinxAtStartPar
Note: the most common use of the \sphinxcode{\sphinxupquote{LD\_PRELOAD}} trick is to use custom memory allocators,
and this continues to work since the interposed symbols are from the standard libraries,
which are compiled with semantic interposition.

\sphinxAtStartPar
Some modules may require special flags. The Openflow module for example
may require \sphinxcode{\sphinxupquote{\sphinxhyphen{}Wno\sphinxhyphen{}stringop\sphinxhyphen{}truncation}} flag to prevent an warning that
is treated as error to prevent the compilation from proceeding. The flag
can be passed to the entire module with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{add\PYGZus{}compile\PYGZus{}options}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}Wno\PYGZhy{}stringop\PYGZhy{}truncation}\PYG{p}{)}

\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{openflow}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{helper/openflow\PYGZhy{}switch\PYGZhy{}helper.cc}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}interface.cc}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}switch\PYGZhy{}net\PYGZhy{}device.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{helper/openflow\PYGZhy{}switch\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}interface.h}
\PYG{+w}{    }\PYG{l+s}{model/openflow\PYGZhy{}switch\PYGZhy{}net\PYGZhy{}device.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{openflow\PYGZus{}LIBRARIES}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}\PYG{+w}{ }\PYG{l+s}{test/openflow\PYGZhy{}switch\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If a flag prevents your compiler from compiling, wrap the flag inside a
compiler check. The currently checked compilers are \sphinxcode{\sphinxupquote{GCC}} and \sphinxcode{\sphinxupquote{CLANG}}
(includes both upstream LLVM Clang and Apple Clang).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{FAILING\PYGZus{}COMPILER}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}compile\PYGZus{}options}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}Wno\PYGZhy{}stringop\PYGZhy{}truncation}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} or}

\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{ONLY\PYGZus{}COMPILER\PYGZus{}THAT\PYGZus{}SUPPORTS\PYGZus{}UNIQUE\PYGZus{}FLAG}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}compile\PYGZus{}options}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}unique\PYGZus{}flag}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{CCache and Precompiled Headers}
\label{\detokenize{working-with-cmake:ccache-and-precompiled-headers}}
\sphinxAtStartPar
There are a few ways of speeding up the build of \sphinxstyleemphasis{ns\sphinxhyphen{}3} and its modules.
Partially rebuilding only changed modules is one of the ways, and
this is already handled by the build system.

\sphinxAtStartPar
However, cleaning up the build and cmake cache directories removes
the intermediate and final files that could be used to skip the build
of unchanged modules.

\sphinxAtStartPar
In this case, \sphinxhref{https://ccache.dev/}{CCache} is recommended. It acts as a compiler and stores the
intermediate and final object files and libraries on a cache artifact directory.

\sphinxAtStartPar
Note: for ease of use, CCache is enabled by default if found by the build system.

\sphinxAtStartPar
The cache artifact directory of CCACHE can be set by changing the
\sphinxcode{\sphinxupquote{CCACHE\_BASEDIR}} environment variable.

\sphinxAtStartPar
The CCache artifact cache is separated per directory, to prevent incompatible
artifacts, which may depend on different working directories \sphinxcode{\sphinxupquote{CWD}} to work properly
from getting mixed and producing binaries that will start running from a different directory.

\sphinxAtStartPar
Note: to reuse CCache artifacts from different directories,
set the \sphinxcode{\sphinxupquote{CCACHE\_NOHASHDIR}} environment variable to \sphinxcode{\sphinxupquote{true}}.

\sphinxAtStartPar
A different way of speeding up builds is by using Precompiled Headers (\sphinxhref{https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html}{PCHs}).
PCHs drastically reduce parsing times of C and C++ headers by precompiling their symbols,
which are imported instead of re\sphinxhyphen{}parsing the same headers again and again,
for each compilation unit (.cc file).

\sphinxAtStartPar
Note: for ease of use, PCH is enabled by default if supported. It can be manually disabled
by setting \sphinxcode{\sphinxupquote{NS3\_PRECOMPILE\_HEADERS}} to \sphinxcode{\sphinxupquote{OFF}}.


\subsubsection{Setting up and adding new headers to the PCH}
\label{\detokenize{working-with-cmake:setting-up-and-adding-new-headers-to-the-pch}}
\sphinxAtStartPar
When both CCache and PCH are used together, there is a set of settings that must be
properly configured, otherwise timestamps built into the PCH can invalidate the CCache
artifacts, forcing a new build of unmodified modules/programs.

\sphinxAtStartPar
Compiler settings required by PCH and CCache are set in the PCH block in macros\sphinxhyphen{}and\sphinxhyphen{}definitions.cmake.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PRECOMPILE\PYGZus{}HEADERS\PYGZus{}ENABLED}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{CLANG}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} Clang adds a timestamp to the PCH, which prevents ccache from working}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} correctly}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} https://github.com/ccache/ccache/issues/539\PYGZsh{}issuecomment\PYGZhy{}664198545}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}Xclang}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}fno\PYGZhy{}pch\PYGZhy{}timestamp}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{n+nb}{if}\PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{XCODE}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} XCode is weird and messes up with the PCH, requiring this flag}
\PYG{+w}{    }\PYG{c}{\PYGZsh{} https://github.com/ccache/ccache/issues/156}
\PYG{+w}{    }\PYG{n+nb}{add\PYGZus{}definitions}\PYG{p}{(}\PYG{l+s}{\PYGZhy{}Xclang}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}fno\PYGZhy{}validate\PYGZhy{}pch}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Headers that will be compiled into the PCH}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} Only worth for frequently included headers}
\PYG{+w}{  }\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{precompiled\PYGZus{}header\PYGZus{}libraries}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}cstdlib\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}cstring\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}exception\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}limits\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}list\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}map\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}math.h\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}ostream\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}set\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}stdint.h\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}string\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{+w}{      }\PYG{l+s}{\PYGZlt{}vector\PYGZgt{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} PCHs can be reused by similar targets (libraries or executables)}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} We have a PCH for libraries, compiled with the \PYGZhy{}fPIC flag}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{l+s}{stdlib\PYGZus{}pch}\PYG{+w}{ }\PYG{l+s}{OBJECT}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/build\PYGZhy{}support/empty.cc}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{stdlib\PYGZus{}pch}\PYG{+w}{ }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}precompiled\PYGZus{}header\PYGZus{}libraries\PYGZcb{}\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} And another PCH for executables, compiled with the \PYGZhy{}fPIE flag}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{stdlib\PYGZus{}pch\PYGZus{}exec}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PROJECT\PYGZus{}SOURCE\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/build\PYGZhy{}support/empty\PYGZhy{}main.cc}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{stdlib\PYGZus{}pch\PYGZus{}exec}\PYG{+w}{ }\PYG{l+s}{PUBLIC}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}precompiled\PYGZus{}header\PYGZus{}libraries\PYGZcb{}\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set\PYGZus{}runtime\PYGZus{}outputdirectory}\PYG{p}{(}\PYG{l+s}{stdlib\PYGZus{}pch\PYGZus{}exec}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}BINARY\PYGZus{}DIR}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The CCache settings required to work with PCH are set in the main CMakeLists.txt file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Use ccache if available}
\PYG{n+nb}{mark\PYGZus{}as\PYGZus{}advanced}\PYG{p}{(}\PYG{l+s}{CCACHE}\PYG{p}{)}
\PYG{n+nb}{find\PYGZus{}program}\PYG{p}{(}\PYG{l+s}{CCACHE}\PYG{+w}{ }\PYG{l+s}{ccache}\PYG{p}{)}
\PYG{n+nb}{if}\PYG{p}{(}\PYG{l+s}{NOT}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CCACHE\PYGZcb{}\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{STREQUAL}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}CCACHE\PYGZhy{}NOTFOUND\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set\PYGZus{}property}\PYG{p}{(}\PYG{l+s}{GLOBAL}\PYG{+w}{ }\PYG{l+s}{PROPERTY}\PYG{+w}{ }\PYG{l+s}{RULE\PYGZus{}LAUNCH\PYGZus{}COMPILE}\PYG{+w}{ }\PYG{l+s}{ccache}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{message}\PYG{p}{(}\PYG{l+s}{STATUS}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}CCache is enabled.\PYGZdq{}}\PYG{p}{)}

\PYG{+w}{  }\PYG{c}{\PYGZsh{} Changes user\PYGZhy{}wide settings from CCache to make it ignore:}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} \PYGZhy{} PCH definitions,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} \PYGZhy{} time related macros that could bake timestamps into cached artifacts,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{} \PYGZhy{} source file creation and modification timestamps,}
\PYG{+w}{  }\PYG{c}{\PYGZsh{}    forcing it to check for content changes instead}
\PYG{+w}{  }\PYG{n+nb}{execute\PYGZus{}process}\PYG{p}{(}
\PYG{+w}{    }\PYG{l+s}{COMMAND}
\PYG{+w}{      }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CCACHE}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{\PYGZhy{}\PYGZhy{}set\PYGZhy{}config}
\PYG{+w}{      }\PYG{l+s}{sloppiness=pch\PYGZus{}defines,time\PYGZus{}macros,include\PYGZus{}file\PYGZus{}mtime,include\PYGZus{}file\PYGZus{}ctime}
\PYG{+w}{  }\PYG{p}{)}
\PYG{n+nb}{endif}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note: you can use the following commands to manually check
and restore the CCache sloppiness settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}\PYGZdl{} ccache \PYGZhy{}\PYGZhy{}get\PYGZhy{}config sloppiness}
\PYG{g+go}{include\PYGZus{}file\PYGZus{}mtime, include\PYGZus{}file\PYGZus{}ctime, time\PYGZus{}macros, pch\PYGZus{}defines}
\PYG{g+go}{\PYGZti{}\PYGZdl{} ccache \PYGZhy{}\PYGZhy{}set\PYGZhy{}config sloppiness=\PYGZdq{}\PYGZdq{}}
\PYG{g+go}{\PYGZti{}\PYGZdl{} ccache \PYGZhy{}\PYGZhy{}get\PYGZhy{}config sloppiness}

\PYG{g+go}{\PYGZti{}\PYGZdl{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The PCHs can be reused later with one of the following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{add\PYGZus{}library}\PYG{p}{(}\PYG{l+s}{example\PYGZus{}lib}\PYG{+w}{ }\PYG{l+s}{example\PYGZus{}lib.cc}\PYG{p}{)}
\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}\PYG{l+s}{example\PYGZus{}lib}\PYG{+w}{ }\PYG{l+s}{REUSE\PYGZus{}FROM}\PYG{+w}{ }\PYG{l+s}{stdlib\PYGZus{}pch}\PYG{p}{)}

\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{example\PYGZus{}exec}\PYG{+w}{ }\PYG{l+s}{example\PYGZus{}exec.cc}\PYG{p}{)}
\PYG{n+nb}{target\PYGZus{}precompile\PYGZus{}headers}\PYG{p}{(}\PYG{l+s}{example\PYGZus{}exec}\PYG{+w}{ }\PYG{l+s}{REUSE\PYGZus{}FROM}\PYG{+w}{ }\PYG{l+s}{stdlib\PYGZus{}pch\PYGZus{}exec}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If if you have problems with the build times when the PCH is enabled,
you can diagnose issues with CCache by clearing the cache statistics (\sphinxcode{\sphinxupquote{ccache \sphinxhyphen{}z}}),
then cleaning, configuring, building, and finally printing the CCache statistics (\sphinxcode{\sphinxupquote{ccache \sphinxhyphen{}s}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ccache \PYGZhy{}z}
\PYG{g+go}{./ns3 clean}
\PYG{g+go}{./ns3 configure}
\PYG{g+go}{./ns3 build}
\PYG{g+go}{ccache \PYGZhy{}s}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you have changed any compiler flag, the cache hit rate should be very low.
Repeat the same commands once more.
If the cache hit rate is at 100\%, it means everything is working as it should.


\subsubsection{Possible side\sphinxhyphen{}effects, fixes and IGNORE\_PCH}
\label{\detokenize{working-with-cmake:possible-side-effects-fixes-and-ignore-pch}}\label{\detokenize{working-with-cmake:pch-side-effects}}
\sphinxAtStartPar
Precompiled headers can cause symbol collisions due to includes reordering or unwanted includes,
which can lead to attempts to redefine functions, macros, types or variables.
An example of such side\sphinxhyphen{}effect is shown below.

\sphinxAtStartPar
In order to exemplify how precompiled headers can cause issues, assume the following inclusion order from
\sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/src/aodv/model/aodv\sphinxhyphen{}routing\sphinxhyphen{}protocol.cc}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT                                   \PYGZbs{}}
\PYG{c+cp}{if (m\PYGZus{}ipv4) \PYGZob{} std::clog \PYGZlt{}\PYGZlt{} \PYGZdq{}[node \PYGZdq{} \PYGZlt{}\PYGZlt{} m\PYGZus{}ipv4\PYGZhy{}\PYGZgt{}GetObject\PYGZlt{}Node\PYGZgt{} ()\PYGZhy{}\PYGZgt{}GetId () \PYGZlt{}\PYGZlt{} \PYGZdq{}] \PYGZdq{}; \PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}aodv\PYGZhy{}routing\PYGZhy{}protocol.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/log.h\PYGZdq{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{NS\_LOG\_APPEND\_CONTEXT}} macro definition comes before the \sphinxcode{\sphinxupquote{ns3/log.h}} inclusion,
and that is the expected way of using \sphinxcode{\sphinxupquote{NS\_LOG\_APPEND\_CONTEXT}}, since we have the following
guards on \sphinxcode{\sphinxupquote{ns3/log\sphinxhyphen{}macros\sphinxhyphen{}enabled.h}}, which is included by \sphinxcode{\sphinxupquote{ns3/log.h}} when logs are enabled.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT */}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
By adding \sphinxcode{\sphinxupquote{\textless{}ns3/log.h\textgreater{}}} to the list of headers to precompile (\sphinxcode{\sphinxupquote{precompiled\_header\_libraries}})
in \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/build\sphinxhyphen{}support/macros\sphinxhyphen{}and\sphinxhyphen{}definitions.cmake}}, the \sphinxcode{\sphinxupquote{ns3/log.h}} header will
now be part of the PCH, which gets included before any parsing of the code is done.
This means the equivalent inclusion order would be different than what was originally intended,
as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmake\PYGZus{}pch.hxx\PYGZdq{}}\PYG{c+c1}{ // PCH includes ns3/log.h before defining ``NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT`` below}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT                                   \PYGZbs{}}
\PYG{c+cp}{if (m\PYGZus{}ipv4) \PYGZob{} std::clog \PYGZlt{}\PYGZlt{} \PYGZdq{}[node \PYGZdq{} \PYGZlt{}\PYGZlt{} m\PYGZus{}ipv4\PYGZhy{}\PYGZgt{}GetObject\PYGZlt{}Node\PYGZgt{} ()\PYGZhy{}\PYGZgt{}GetId () \PYGZlt{}\PYGZlt{} \PYGZdq{}] \PYGZdq{}; \PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}aodv\PYGZhy{}routing\PYGZhy{}protocol.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/log.h\PYGZdq{}}\PYG{c+c1}{ // isn\PYGZsq{}t processed since ``NS3\PYGZus{}LOG\PYGZus{}H`` was already defined by the PCH}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
While trying to build with the redefined symbols in the debug build, where warnings are treated
as errors, the build may fail with an error similar to the following from GCC 11.2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{FAILED: src/aodv/CMakeFiles/libaodv\PYGZhy{}obj.dir/model/aodv\PYGZhy{}routing\PYGZhy{}protocol.cc.o}
\PYG{g+go}{ccache /usr/bin/c++ ... \PYGZhy{}DNS3\PYGZus{}LOG\PYGZus{}ENABLE \PYGZhy{}Wall \PYGZhy{}Werror \PYGZhy{}include /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}debug/CMakeFiles/stdlib\PYGZus{}pch.dir/cmake\PYGZus{}pch.hxx}
\PYG{g+go}{/ns\PYGZhy{}3\PYGZhy{}dev/src/aodv/model/aodv\PYGZhy{}routing\PYGZhy{}protocol.cc:28: error: \PYGZdq{}NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT\PYGZdq{} redefined [\PYGZhy{}Werror]}
\PYG{g+go}{   28 | \PYGZsh{}define NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT                                   \PYGZbs{}}
\PYG{g+go}{      |}
\PYG{g+go}{In file included from /ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/log.h:32,}
\PYG{g+go}{                 from /ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/fatal\PYGZhy{}error.h:29,}
\PYG{g+go}{                 from /ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/assert.h:56,}
\PYG{g+go}{                 from /ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/buffer.h:26,}
\PYG{g+go}{                 from /ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/packet.h:24,}
\PYG{g+go}{                 from /ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}build\PYGZhy{}debug/CMakeFiles/stdlib\PYGZus{}pch.dir/cmake\PYGZus{}pch.hxx:23,}
\PYG{g+go}{                 from \PYGZlt{}command\PYGZhy{}line\PYGZgt{}:}
\PYG{g+go}{/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/log\PYGZhy{}macros\PYGZhy{}enabled.h:146: note: this is the location of the previous definition}
\PYG{g+go}{  146 | \PYGZsh{}define NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT}
\PYG{g+go}{      |}
\PYG{g+go}{cc1plus: all warnings being treated as errors}
\end{sphinxVerbatim}

\sphinxAtStartPar
One of the ways to fix this issue in particular is undefining \sphinxcode{\sphinxupquote{NS\_LOG\_APPEND\_CONTEXT}} before redefining it in
\sphinxcode{\sphinxupquote{/ns\sphinxhyphen{}3\sphinxhyphen{}dev/src/aodv/model/aodv\sphinxhyphen{}routing\sphinxhyphen{}protocol.cc}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmake\PYGZus{}pch.hxx\PYGZdq{}}\PYG{c+c1}{ // PCH includes ns3/log.h before defining NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT below}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{undef NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT }\PYG{c+c1}{// undefines symbol previously defined in the PCH}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NS\PYGZus{}LOG\PYGZus{}APPEND\PYGZus{}CONTEXT                                   \PYGZbs{}}
\PYG{c+cp}{if (m\PYGZus{}ipv4) \PYGZob{} std::clog \PYGZlt{}\PYGZlt{} \PYGZdq{}[node \PYGZdq{} \PYGZlt{}\PYGZlt{} m\PYGZus{}ipv4\PYGZhy{}\PYGZgt{}GetObject\PYGZlt{}Node\PYGZgt{} ()\PYGZhy{}\PYGZgt{}GetId () \PYGZlt{}\PYGZlt{} \PYGZdq{}] \PYGZdq{}; \PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}aodv\PYGZhy{}routing\PYGZhy{}protocol.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/log.h\PYGZdq{}}\PYG{c+c1}{ // isn\PYGZsq{}t processed since ``NS3\PYGZus{}LOG\PYGZus{}H`` was already defined by the PCH}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the \sphinxcode{\sphinxupquote{IGNORE\_PCH}} option is set in the {\hyperref[\detokenize{working-with-cmake:build-lib}]{\sphinxcrossref{build\_lib}}}, {\hyperref[\detokenize{working-with-cmake:build-lib-example}]{\sphinxcrossref{build\_lib\_example}}}, {\hyperref[\detokenize{working-with-cmake:build-exec}]{\sphinxcrossref{build\_exec}}} and the {\hyperref[\detokenize{working-with-cmake:build-example}]{\sphinxcrossref{build\_example}}}
macros, the PCH is not included in their targets, continuing to build as we normally would without the PCH.
This is only a workaround for the issue, which can be helpful when the same macro names, class names,
global variables and others are redefined by different components that can’t be modified safely.

\sphinxstepscope


\section{Logging}
\label{\detokenize{logging-asserts:logging}}\label{\detokenize{logging-asserts::doc}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} logging facility can be used to monitor or debug the progress
of simulation programs.  Logging output can be enabled by program statements
in your \sphinxcode{\sphinxupquote{main()}} program or by the use of the \sphinxcode{\sphinxupquote{NS\_LOG}} environment variable.

\sphinxAtStartPar
Logging statements are not compiled into \sphinxcode{\sphinxupquote{optimized}} builds of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  To use
logging, one must use the \sphinxcode{\sphinxupquote{default}} or \sphinxcode{\sphinxupquote{debug}} build profiles of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
The project makes no guarantee about whether logging output will remain
the same over time.  Users are cautioned against building simulation output
frameworks on top of logging code, as the output and the way the output
is enabled may change over time.


\subsection{Overview}
\label{\detokenize{logging-asserts:overview}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} logging statements are typically used to log various program
execution events, such as the occurrence of simulation events or the
use of a particular function.

\sphinxAtStartPar
For example, this code snippet is from \sphinxcode{\sphinxupquote{TcpSocketBase::EnterCwr()}} and informs the user that
the model is reducing the congestion window and changing state:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enter CWR recovery mode; set cwnd to }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}tcb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}cWnd}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ssthresh to }\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{                                                    }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}tcb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}ssThresh}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, recover to }\PYG{l+s}{\PYGZdq{}}
\PYG{+w}{                                                    }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}recover}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If logging has been enabled for the \sphinxcode{\sphinxupquote{Ipv4L3Protocol}} component at a severity
of \sphinxcode{\sphinxupquote{INFO}} or above (see below about log severity), the statement
will be printed out; otherwise, it will be suppressed.

\sphinxAtStartPar
The logging implementation is enabled in \sphinxcode{\sphinxupquote{debug}} and \sphinxcode{\sphinxupquote{default}}
builds, but disabled in all other build profiles,
so that it does not impact the execution speed of more optimized profiles.

\sphinxAtStartPar
You can try the example program \sphinxtitleref{log\sphinxhyphen{}example.cc} in \sphinxtitleref{src/core/example}
with various values for the \sphinxtitleref{NS\_LOG} environment variable to see the
effect of the options discussed below.


\subsection{Enabling Output}
\label{\detokenize{logging-asserts:enabling-output}}
\sphinxAtStartPar
There are two ways that users typically control log output.  The
first is by setting the \sphinxcode{\sphinxupquote{NS\_LOG}} environment variable; e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }first
\end{sphinxVerbatim}

\sphinxAtStartPar
will run the \sphinxcode{\sphinxupquote{first}} tutorial program with all logging output.  (The
specifics of the \sphinxcode{\sphinxupquote{NS\_LOG}} format will be discussed below.)

\sphinxAtStartPar
This can be made more granular by selecting individual components:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Ipv4L3Protocol\PYGZdq{}}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }first
\end{sphinxVerbatim}

\sphinxAtStartPar
The output can be further tailored with prefix options.

\sphinxAtStartPar
The second way to enable logging is to use explicit statements in your
program, such as in the \sphinxcode{\sphinxupquote{first}} tutorial program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}
\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{LogComponentEnable}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{UdpEchoClientApplication}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{LogComponentEnable}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{UdpEchoServerApplication}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
(The meaning of \sphinxcode{\sphinxupquote{LOG\_LEVEL\_INFO}}, and other possible values,
will be discussed below.)


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{NS\_LOG}} Syntax}
\label{\detokenize{logging-asserts:ns-log-syntax}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{NS\_LOG}} environment variable contains a list of log components
and options.  Log components are separated by \textasciigrave{}:’ characters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}:\PYGZlt{}log\PYGZhy{}component\PYGZgt{}...\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Options for each log component are given as flags after
each log component:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}=\PYGZlt{}option\PYGZgt{}|\PYGZlt{}option\PYGZgt{}...:\PYGZlt{}log\PYGZhy{}component\PYGZgt{}...\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Options control the severity and level for that component,
and whether optional information should be included, such as the
simulation time, simulation node, function name, and the symbolic severity.


\subsubsection{Log Components}
\label{\detokenize{logging-asserts:log-components}}
\sphinxAtStartPar
Generally a log component refers to a single source code \sphinxcode{\sphinxupquote{.cc}} file,
and encompasses the entire file.

\sphinxAtStartPar
Some helpers have special methods to enable the logging of all components
in a module, spanning different compilation units, but logically grouped
together, such as the \sphinxstyleemphasis{ns\sphinxhyphen{}3} wifi code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{WifiHelper}\PYG{+w}{ }\PYG{n}{wifiHelper}\PYG{p}{;}
\PYG{n}{wifiHelper}\PYG{p}{.}\PYG{n}{EnableLogComponents}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{NS\_LOG}} log component wildcard \textasciigrave{}*’ will enable all components.

\sphinxAtStartPar
To see what log components are defined, any of these will work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}print\PYGZhy{}list\PYGZdq{}}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }...

\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}foo\PYGZdq{}}\PYG{+w}{  }\PYG{c+c1}{\PYGZsh{} a token not matching any log\PYGZhy{}component}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first form will print the name and enabled flags for all log components
which are linked in; try it with \sphinxcode{\sphinxupquote{scratch\sphinxhyphen{}simulator}}.
The second form prints all registered log components,
then exit with an error.


\subsubsection{Severity and Level Options}
\label{\detokenize{logging-asserts:severity-and-level-options}}
\sphinxAtStartPar
Individual messages belong to a single “severity class,” set by the macro
creating the message.  In the example above,
\sphinxcode{\sphinxupquote{NS\_LOG\_INFO(..)}} creates the message in the \sphinxcode{\sphinxupquote{LOG\_INFO}} severity class.

\sphinxAtStartPar
The following severity classes are defined as \sphinxcode{\sphinxupquote{enum}} constants:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Severity Class
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_NONE}}
&
\sphinxAtStartPar
The default, no logging
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_ERROR}}
&
\sphinxAtStartPar
Serious error messages only
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_WARN}}
&
\sphinxAtStartPar
Warning messages
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_INFO}}
&
\sphinxAtStartPar
Info about the model changing state
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_FUNCTION}}
&
\sphinxAtStartPar
Function tracing
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LOGIC}}
&
\sphinxAtStartPar
For tracing key decision points or branches in a function
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_DEBUG}}
&
\sphinxAtStartPar
For use in debugging
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Typically one wants to see messages at a given severity class \sphinxstyleemphasis{and higher}.
This is done by defining inclusive logging “levels”:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Level
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_ERROR}}
&
\sphinxAtStartPar
Only \sphinxcode{\sphinxupquote{LOG\_ERROR}} severity class messages.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_WARN}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_WARN}} and above.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_INFO}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_INFO}} and above.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_FUNCTION}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_FUNCTION}} and above.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_LOGIC}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LOGIC}} and above.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_DEBUG}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_DEBUG}} and above.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_ALL}}
&
\sphinxAtStartPar
All severity classes.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_ALL}}
&
\sphinxAtStartPar
Synonym for \sphinxcode{\sphinxupquote{LOG\_LEVEL\_ALL}}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The severity class and level options can be given in the \sphinxcode{\sphinxupquote{NS\_LOG}}
environment variable by these tokens:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{*{2}{\X{1}{2}}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Class
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Level
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{error}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level\_error}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{warn}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level\_warn}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{info}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level\_info}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{function}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level\_function}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logic}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level\_logic}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{debug}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level\_debug}}
\\
\sphinxhline&
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{level\_all}}
\item[] \sphinxcode{\sphinxupquote{all}}
\item[] \sphinxcode{\sphinxupquote{*}}
\end{DUlineblock}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Using a severity class token enables log messages at that severity only.
For example, \sphinxcode{\sphinxupquote{NS\_LOG="*=warn"}} won’t output messages with severity \sphinxcode{\sphinxupquote{error}}.
\sphinxcode{\sphinxupquote{NS\_LOG="*=level\_debug"}} will output messages at severity levels
\sphinxcode{\sphinxupquote{debug}} and above.

\sphinxAtStartPar
Severity classes and levels can be combined with the \textasciigrave{}|’ operator:
\sphinxcode{\sphinxupquote{NS\_LOG="*=level\_warn|debug"}} will output messages at severity levels
\sphinxcode{\sphinxupquote{error}}, \sphinxcode{\sphinxupquote{warn}} and \sphinxcode{\sphinxupquote{debug}}, but not \sphinxcode{\sphinxupquote{info}}, \sphinxcode{\sphinxupquote{function}}, or \sphinxcode{\sphinxupquote{logic}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{NS\_LOG}} severity level wildcard \textasciigrave{}*’ and \sphinxcode{\sphinxupquote{all}}
are synonyms for \sphinxcode{\sphinxupquote{level\_all}}.

\sphinxAtStartPar
For log components merely mentioned in \sphinxcode{\sphinxupquote{NS\_LOG}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}:...\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
the default severity is \sphinxcode{\sphinxupquote{LOG\_LEVEL\_ALL}}.


\subsubsection{Prefix Options}
\label{\detokenize{logging-asserts:prefix-options}}
\sphinxAtStartPar
A number of prefixes can help identify
where and when a message originated, and at what severity.

\sphinxAtStartPar
The available prefix options (as \sphinxcode{\sphinxupquote{enum}} constants) are


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Prefix Symbol
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_FUNC}}
&
\sphinxAtStartPar
Prefix the name of the calling function.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_TIME}}
&
\sphinxAtStartPar
Prefix the simulation time.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_NODE}}
&
\sphinxAtStartPar
Prefix the node id.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_LEVEL}}
&
\sphinxAtStartPar
Prefix the severity level.
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_ALL}}
&
\sphinxAtStartPar
Enable all prefixes.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The prefix options are described briefly below.

\sphinxAtStartPar
The options can be given in the \sphinxcode{\sphinxupquote{NS\_LOG}}
environment variable by these tokens:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{*{2}{\X{1}{2}}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Token
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Alternate
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefix\_func}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefix\_time}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{time}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefix\_node}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{node}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefix\_level}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{level}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prefix\_all}}
&
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{all}}
\item[] \sphinxcode{\sphinxupquote{*}}
\end{DUlineblock}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
For log components merely mentioned in \sphinxcode{\sphinxupquote{NS\_LOG}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}:...\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
the default prefix options are \sphinxcode{\sphinxupquote{LOG\_PREFIX\_ALL}}.


\paragraph{Severity Prefix}
\label{\detokenize{logging-asserts:severity-prefix}}
\sphinxAtStartPar
The severity class of a message can be included with the options
\sphinxcode{\sphinxupquote{prefix\_level}} or \sphinxcode{\sphinxupquote{level}}.  For example, this value of \sphinxcode{\sphinxupquote{NS\_LOG}}
enables logging for all log components (\textasciigrave{}*’) and all severity
classes (\sphinxcode{\sphinxupquote{=all}}), and prefixes the message with the severity
class (\sphinxcode{\sphinxupquote{|prefix\_level}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=all|prefix\PYGZus{}level\PYGZdq{}}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }scratch\PYGZhy{}simulator
Scratch\PYG{+w}{ }Simulator
\PYG{o}{[}ERROR\PYG{o}{]}\PYG{+w}{ }error\PYG{+w}{ }message
\PYG{o}{[}WARN\PYG{o}{]}\PYG{+w}{ }warn\PYG{+w}{ }message
\PYG{o}{[}INFO\PYG{o}{]}\PYG{+w}{ }info\PYG{+w}{ }message
\PYG{o}{[}FUNCT\PYG{o}{]}\PYG{+w}{ }\PYG{k}{function}\PYG{+w}{ }message
\PYG{o}{[}LOGIC\PYG{o}{]}\PYG{+w}{ }logic\PYG{+w}{ }message
\PYG{o}{[}DEBUG\PYG{o}{]}\PYG{+w}{ }debug\PYG{+w}{ }message
\end{sphinxVerbatim}


\paragraph{Time Prefix}
\label{\detokenize{logging-asserts:time-prefix}}
\sphinxAtStartPar
The simulation time can be included with the options
\sphinxcode{\sphinxupquote{prefix\_time}} or \sphinxcode{\sphinxupquote{time}}.  This prints the simulation time in seconds.


\paragraph{Node Prefix}
\label{\detokenize{logging-asserts:node-prefix}}
\sphinxAtStartPar
The simulation node id can be included with the options
\sphinxcode{\sphinxupquote{prefix\_node}} or \sphinxcode{\sphinxupquote{node}}.


\paragraph{Function Prefix}
\label{\detokenize{logging-asserts:function-prefix}}
\sphinxAtStartPar
The name of the calling function can be included with the options
\sphinxcode{\sphinxupquote{prefix\_func}} or \sphinxcode{\sphinxupquote{func}}.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{NS\_LOG}} Wildcards}
\label{\detokenize{logging-asserts:ns-log-wildcards}}
\sphinxAtStartPar
The log component wildcard \textasciigrave{}*’ will enable all components.  To
enable all components at a specific severity level
use \sphinxcode{\sphinxupquote{*=\textless{}severity\textgreater{}}}.

\sphinxAtStartPar
The severity level option wildcard \textasciigrave{}*’ is a synonym for \sphinxcode{\sphinxupquote{all}}.
This must occur before any \textasciigrave{}|’ characters separating options.
To enable all severity classes, use \sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=*}},
or \sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=*|\textless{}options\textgreater{}}}.

\sphinxAtStartPar
The option wildcard \textasciigrave{}*’ or token \sphinxcode{\sphinxupquote{all}} enables all prefix options,
but must occur \sphinxstyleemphasis{after} a \textasciigrave{}|’ character.  To enable a specific
severity class or level, and all prefixes, use
\sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=\textless{}severity\textgreater{}|*}}.

\sphinxAtStartPar
The combined option wildcard \sphinxcode{\sphinxupquote{**}} enables all severities and all prefixes;
for example, \sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=**}}.

\sphinxAtStartPar
The uber\sphinxhyphen{}wildcard \sphinxcode{\sphinxupquote{***}} enables all severities and all prefixes
for all log components.  These are all equivalent:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}***\PYGZdq{}}\PYG{+w}{ }...\PYG{+w}{      }\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=all|*\PYGZdq{}}\PYG{+w}{ }...\PYG{+w}{        }\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=*|all\PYGZdq{}}\PYG{+w}{ }...
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=**\PYGZdq{}}\PYG{+w}{ }...\PYG{+w}{     }\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=level\PYGZus{}all|*\PYGZdq{}}\PYG{+w}{ }...\PYG{+w}{  }\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=*|prefix\PYGZus{}all\PYGZdq{}}\PYG{+w}{ }...
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=*|*\PYGZdq{}}\PYG{+w}{ }...
\end{sphinxVerbatim}

\sphinxAtStartPar
Be advised:  even the trivial \sphinxcode{\sphinxupquote{scratch\sphinxhyphen{}simulator}} produces over
46K lines of output with \sphinxcode{\sphinxupquote{NS\_LOG="***"}}!


\subsection{How to add logging to your code}
\label{\detokenize{logging-asserts:how-to-add-logging-to-your-code}}
\sphinxAtStartPar
Adding logging to your code is very simple:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_COMPONENT\_DEFINE(...);}} macro
inside of \sphinxcode{\sphinxupquote{namespace ns3}}.

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
Create a unique string identifier (usually based on the name of the file
and/or class defined within the file) and register it with a macro call
such as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{n}{NS\PYGZus{}LOG\PYGZus{}COMPONENT\PYGZus{}DEFINE}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Ipv4L3Protocol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This registers \sphinxcode{\sphinxupquote{Ipv4L3Protocol}} as a log component.

\sphinxAtStartPar
(The macro was carefully written to permit inclusion either within or
outside of namespace \sphinxcode{\sphinxupquote{ns3}}, and usage will vary across the codebase, but
the original intent was to register this \sphinxstyleemphasis{outside} of namespace \sphinxcode{\sphinxupquote{ns3}}
at file global scope.)
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Add logging statements (macro calls) to your functions and function bodies.

\end{enumerate}

\sphinxAtStartPar
In case you want to add logging statements to the methods of your template class
(which are defined in an header file):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_TEMPLATE\_DECLARE;}} macro in the private section of
your class declaration. For instance:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{Item}\PYG{o}{\PYGZgt{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Queue}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{QueueBase}
\PYG{p}{\PYGZob{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{list}\PYG{o}{\PYGZlt{}}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}packets}\PYG{p}{;}\PYG{+w}{           }\PYG{c+c1}{//!\PYGZlt{} the items in the queue}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}TEMPLATE\PYGZus{}DECLARE}\PYG{p}{;}\PYG{+w}{                  }\PYG{c+c1}{//!\PYGZlt{} the log component}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This requires you to perform these steps for all the subclasses of your class.
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_TEMPLATE\_DEFINE(...);}} macro in the constructor of
your class by providing the name of a log component registered by calling
the \sphinxcode{\sphinxupquote{NS\_LOG\_COMPONENT\_DEFINE(...);}} macro in some module. For instance:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{Item}\PYG{o}{\PYGZgt{}}
\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Queue}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}TEMPLATE\PYGZus{}DEFINE}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Queue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Add logging statements (macro calls) to the methods of your class.

\end{enumerate}

\sphinxAtStartPar
In case you want to add logging statements to a static member template
(which is defined in an header file):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_STATIC\_TEMPLATE\_DEFINE (...);}} macro in your static
method by providing the name of a log component registered by calling
the \sphinxcode{\sphinxupquote{NS\_LOG\_COMPONENT\_DEFINE(...);}} macro in some module. For instance:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{Item}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void}
\PYG{n}{NetDeviceQueue}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PacketEnqueued}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{queue}\PYG{p}{,}
\PYG{+w}{                               }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDeviceQueueInterface}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ndqi}\PYG{p}{,}
\PYG{+w}{                               }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{txq}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Item}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}STATIC\PYGZus{}TEMPLATE\PYGZus{}DEFINE}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NetDeviceQueueInterface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Add logging statements (macro calls) to your static method.

\end{enumerate}


\subsubsection{Logging Macros}
\label{\detokenize{logging-asserts:logging-macros}}\begin{quote}

\sphinxAtStartPar
The logging macros and associated severity levels are


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Severity Class
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Macro
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_NONE}}
&
\sphinxAtStartPar
(none needed)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_ERROR}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_ERROR(...);}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_WARN}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_WARN(...);}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_INFO}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_INFO(...);}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_FUNCTION}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION(...);}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_LOGIC}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_LOGIC(...);}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LOG\_DEBUG}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_DEBUG(...);}}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The macros function as output streamers, so anything you can send to
\sphinxcode{\sphinxupquote{std::cout}}, joined by \sphinxcode{\sphinxupquote{\textless{}\textless{}}} operators, is allowed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{MyClass::Check}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{(}\PYG{k}{this}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arg}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{item}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{arg}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{      }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}ERROR}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{encountered bad value }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{value}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}
\PYG{+w}{                   }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ while checking }\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{name}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION}} automatically inserts a \textasciigrave{}\sphinxcode{\sphinxupquote{,}}’
(comma\sphinxhyphen{}space) separator between each of its arguments.
This simplifies logging of function arguments;
just concatenate them with \sphinxcode{\sphinxupquote{\textless{}\textless{}}} as in the example above.
\end{quote}


\subsubsection{Unconditional Logging}
\label{\detokenize{logging-asserts:unconditional-logging}}
\sphinxAtStartPar
As a convenience, the \sphinxcode{\sphinxupquote{NS\_LOG\_UNCOND(...);}} macro will always log its
arguments, even if the associated log\sphinxhyphen{}component is not enabled at any
severity.  This macro does not use any of the prefix options.  Recall
that logging is only enabled in \sphinxcode{\sphinxupquote{debug}}, \sphinxcode{\sphinxupquote{default}} and \sphinxcode{\sphinxupquote{relwithdebinfo}}
builds, so this macro will only produce output in the same builds.

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} model libraries do not typically use the \sphinxcode{\sphinxupquote{NS\_LOG\_UNCOND(...)}} macro;
it is provided for users for assistance with debugging.


\subsubsection{Guidelines}
\label{\detokenize{logging-asserts:guidelines}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Start every significant class method with \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION(this \textless{}\textless{} args...);}}
This enables easy function call tracing.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Exception 1:  don’t log operators or explicit copy constructors,
since these will cause infinite recursion and stack overflow.

\item {} 
\sphinxAtStartPar
Exception 2:  For simple methods such as getters, avoid function
logging because it tends to overload the logging output.

\item {} 
\sphinxAtStartPar
For methods without arguments use the same form:
\sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION(this);}}

\item {} 
\sphinxAtStartPar
For static functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
With arguments use \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION(...);}} as normal.

\item {} 
\sphinxAtStartPar
Without arguments use \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION\_NOARGS();}}

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{NS\_LOG\_ERROR}} for serious error conditions that probably
invalidate the simulation execution.  Note that in \sphinxstyleemphasis{ns\sphinxhyphen{}3}, we typically
abort the simulation under such conditions rather than log it as
an error (which might go undetected if the user is not using logging).
The \sphinxcode{\sphinxupquote{NS\_ABORT\_MSG\_IF/UNLESS(cond,msg)}} macros and variants, as well
as the lower\sphinxhyphen{}level \sphinxcode{\sphinxupquote{NS\_FATAL\_ERROR(msg)}} macro, can be used to terminate
the simulation with an error message.

\item {} 
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{NS\_LOG\_WARN}} for unusual conditions that are not considered
invalid.  An example might be that some resource has been exhausted
(e.g., the DHCP server has run out of addresses to allocate).
Please give some hints as to the nature of the problem and how
it might be corrected.

\item {} 
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{NS\_LOG\_INFO}} for events that cause a state change in the model.
Avoid using it for logging periodic events that are not causing a
state change (e.g., a Wi\sphinxhyphen{}Fi beacon is sent, but all nodes are already
associated to the access point).  Try to be efficient in using it;
for instance, sending a message is usually an important state change event,
but try to capture this event with one single log message at the \sphinxcode{\sphinxupquote{INFO}}
level rather than multiple.  If multiple log messages are desired to
fully capture the event and all of its consequences,  use \sphinxcode{\sphinxupquote{DEBUG}} level
for the additional messages.  The intent of this log level is to allow a
user to examine the normal operation of a model without becoming overwhelmed
by the output.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_LOGIC}} is used to trace important logic branches or decision points
within a function, without dumping all details of the variable states,
called function return values, individual iterations, etc.  It may be useful
to think of it as a less granular level of function logging than \sphinxcode{\sphinxupquote{DEBUG,}}
and may not be used by all models (some authors may choose to only use
\sphinxcode{\sphinxupquote{DEBUG}} level for full logging).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NS\_LOG\_DEBUG}} is usually used for full voluminous debugging, and contains
much more information than \sphinxcode{\sphinxupquote{NS\_LOG\_INFO}}, such as the detailed execution
logic of functions and the values that variables take within those functions.

\item {} 
\sphinxAtStartPar
Test that your logging changes do not break the code.
Run some example programs with all log components turned on (e.g.
\sphinxcode{\sphinxupquote{NS\_LOG="***"}}).

\item {} 
\sphinxAtStartPar
Use a unary operator (preferred) or an explicit cast for any variable of type uint8\_t or int8\_t,
e.g., \sphinxcode{\sphinxupquote{NS\_LOG\_DEBUG("Variable i is " \textless{}\textless{} +i);}}.
e.g., \sphinxcode{\sphinxupquote{NS\_LOG\_DEBUG("Variable i is " \textless{}\textless{} static\_cast\textless{}int\textgreater{}(i));}} or
Without the cast, the integer is interpreted as a char, and the result
will be most likely not in line with the expectations.
This is a well documented C++ ‘feature’.

\end{itemize}


\subsection{Controlling timestamp precision}
\label{\detokenize{logging-asserts:controlling-timestamp-precision}}
\sphinxAtStartPar
Timestamps are printed out in units of seconds.  When used with the default
\sphinxstyleemphasis{ns\sphinxhyphen{}3} time resolution of nanoseconds, the default timestamp precision is 9
digits, with fixed format, to allow for 9 digits to be consistently printed
to the right of the decimal point.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{l+m+mf}{0.000123456}\PYG{n}{s}\PYG{+w}{ }\PYG{n}{RandomVariableStream}\PYG{o}{:}\PYG{n}{SetAntithetic}\PYG{p}{(}\PYG{l+m+mh}{0x805040}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
When the \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation uses higher time resolution such as picoseconds
or femtoseconds, the precision is expanded accordingly; e.g. for picosecond:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{l+m+mf}{0.000123456789}\PYG{n}{s}\PYG{+w}{ }\PYG{n}{RandomVariableStream}\PYG{o}{:}\PYG{n}{SetAntithetic}\PYG{p}{(}\PYG{l+m+mh}{0x805040}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
When the \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation uses a time resolution lower than microseconds,
the default C++ precision is used.

\sphinxAtStartPar
An example program at \sphinxcode{\sphinxupquote{src/core/examples/sample\sphinxhyphen{}log\sphinxhyphen{}time\sphinxhyphen{}format.cc}}
demonstrates how to change the timestamp formatting.

\sphinxAtStartPar
The maximum useful precision is 20 decimal digits, since Time is signed 64
bits.


\subsection{Asserts}
\label{\detokenize{logging-asserts:asserts}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} assert facility can be used to validate that invariant conditions
are met during execution. If the condition is not met an error message is given
and the program stops, printing the location of the failed assert.

\sphinxAtStartPar
The assert implementation is enabled in \sphinxcode{\sphinxupquote{debug}} and \sphinxcode{\sphinxupquote{default}}
builds, but disabled in all other build profiles to improve execution speed.


\subsubsection{How to add asserts to your code}
\label{\detokenize{logging-asserts:how-to-add-asserts-to-your-code}}
\sphinxAtStartPar
There is only one macro one should use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{message}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{condition}} should be the invariant you want to test, as a
boolean expression.  The \sphinxcode{\sphinxupquote{message}} should explain what the
condition means and/or the possible source of the error.

\sphinxAtStartPar
There is a variant available without a message, \sphinxcode{\sphinxupquote{NS\_ASSERT(condition)}},
but we recommend using the message variant in ns\sphinxhyphen{}3 library code,
as a well\sphinxhyphen{}crafted message can help users figure out how to fix the underlying
issue with their script.

\sphinxAtStartPar
In either case if the condition evaluates to \sphinxcode{\sphinxupquote{false}} the assert will print
an error message to \sphinxcode{\sphinxupquote{std::cerr}} containing the following
information:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Error message: “NS\_ASSERT failed, “

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{condition}} expression: “cond=”\sphinxcode{\sphinxupquote{condition}}”

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{message}}: “msg=”\sphinxcode{\sphinxupquote{message}}”

\item {} 
\sphinxAtStartPar
The simulation time and node, as would be printed by logging.
These are printed independent of the flags or prefix set on any
logging component.

\item {} 
\sphinxAtStartPar
The file and line containing the assert: “file=\textasciigrave{}\textasciigrave{}file\textasciigrave{}\textasciigrave{}, line=\textasciigrave{}\textasciigrave{}line\textasciigrave{}\textasciigrave{}

\end{itemize}

\sphinxAtStartPar
Here is an example which doesn’t assert:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }assert\PYGZhy{}example
\PYG{o}{[}\PYG{l+m}{0}/2\PYG{o}{]}\PYG{+w}{ }Re\PYGZhy{}checking\PYG{+w}{ }globbed\PYG{+w}{ }directories...
ninja:\PYG{+w}{ }no\PYG{+w}{ }work\PYG{+w}{ }to\PYG{+w}{ }\PYG{k}{do}.
NS\PYGZus{}ASSERT\PYGZus{}MSG\PYG{+w}{ }example
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }an\PYG{+w}{ }argument\PYG{+w}{ }is\PYG{+w}{ }given\PYG{+w}{ }this\PYG{+w}{ }example\PYG{+w}{ }will\PYG{+w}{ }assert.
\end{sphinxVerbatim}

\sphinxAtStartPar
and here is an example which does:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }assert\PYGZhy{}example\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }foo
\PYG{o}{[}\PYG{l+m}{0}/2\PYG{o}{]}\PYG{+w}{ }Re\PYGZhy{}checking\PYG{+w}{ }globbed\PYG{+w}{ }directories...
ninja:\PYG{+w}{ }no\PYG{+w}{ }work\PYG{+w}{ }to\PYG{+w}{ }\PYG{k}{do}.
NS\PYGZus{}ASSERT\PYGZus{}MSG\PYG{+w}{ }example
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }an\PYG{+w}{ }argument\PYG{+w}{ }is\PYG{+w}{ }given\PYG{+w}{ }this\PYG{+w}{ }example\PYG{+w}{ }will\PYG{+w}{ }assert.
NS\PYGZus{}ASSERT\PYG{+w}{ }failed,\PYG{+w}{ }\PYG{n+nv}{cond}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}argc == 1\PYGZdq{}},\PYG{+w}{ }\PYG{n+nv}{msg}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}An argument was given, so we assert\PYGZdq{}},\PYG{+w}{ }\PYG{n+nv}{file}\PYG{o}{=}/Users/barnes26/Code/netsim/ns3/repos/ns\PYGZhy{}3\PYGZhy{}dev/src/core/examples/assert\PYGZhy{}example.cc,\PYG{+w}{ }\PYG{n+nv}{line}\PYG{o}{=}\PYG{l+m}{44}
NS\PYGZus{}FATAL,\PYG{+w}{ }terminating
terminate\PYG{+w}{ }called\PYG{+w}{ }without\PYG{+w}{ }an\PYG{+w}{ }active\PYG{+w}{ }exception
Command\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}build/debug/src/core/examples/ns3\PYGZhy{}dev\PYGZhy{}assert\PYGZhy{}example\PYGZhy{}debug foo\PYGZsq{}}\PYG{+w}{ }died\PYG{+w}{ }with\PYG{+w}{ }\PYGZlt{}Signals.SIGABRT:\PYG{+w}{ }\PYG{l+m}{6}\PYGZgt{}.
\end{sphinxVerbatim}

\sphinxAtStartPar
You can try the example program \sphinxtitleref{assert\sphinxhyphen{}example.cc} in \sphinxtitleref{src/core/example}
with or without arguments to see the action of \sphinxcode{\sphinxupquote{NS\_ASSERT\_MSG}}.

\sphinxstepscope


\section{Tests}
\label{\detokenize{tests:tests}}\label{\detokenize{tests::doc}}
\sphinxstepscope


\subsection{Overview}
\label{\detokenize{test-overview:overview}}\label{\detokenize{test-overview::doc}}
\sphinxAtStartPar
This chapter is concerned with the testing and validation of \sphinxstyleemphasis{ns\sphinxhyphen{}3} software.

\sphinxAtStartPar
This chapter provides
\begin{itemize}
\item {} 
\sphinxAtStartPar
background about terminology and software testing

\item {} 
\sphinxAtStartPar
a description of the ns\sphinxhyphen{}3 testing framework

\item {} 
\sphinxAtStartPar
a guide to model developers or new model contributors for how to write tests

\end{itemize}

\sphinxstepscope


\subsection{Background}
\label{\detokenize{test-background:background}}\label{\detokenize{test-background::doc}}
\sphinxAtStartPar
\sphinxstylestrong{This chapter may be skipped by readers familiar with the basics of
software testing.}

\sphinxAtStartPar
Writing defect\sphinxhyphen{}free software is a difficult proposition.  There are many
dimensions to the problem and there is much confusion regarding what is
meant by different terms in different contexts.  We have found it worthwhile
to spend a little time reviewing the subject and defining some terms.

\sphinxAtStartPar
Software testing may be loosely defined as the process of executing a program
with the intent of finding errors.  When one enters a discussion regarding
software testing, it quickly becomes apparent that there are many distinct
mind\sphinxhyphen{}sets with which one can approach the subject.

\sphinxAtStartPar
For example, one could break the process into broad functional categories
like ‘’correctness testing,’’ ‘’performance testing,’’ ‘’robustness testing’’
and ‘’security testing.’’  Another way to look at the problem is by life\sphinxhyphen{}cycle:
‘’requirements testing,’’ ‘’design testing,’’ ‘’acceptance testing,’’ and
‘’maintenance testing.’’  Yet another view is by the scope of the tested system.
In this case one may speak of ‘’unit testing,’’ ‘’component testing,’’
‘’integration testing,’’ and ‘’system testing.’’  These terms are also not
standardized in any way, and so ‘’maintenance testing’’ and ‘’regression
testing’’ may be heard interchangeably.  Additionally, these terms are often
misused.

\sphinxAtStartPar
There are also a number of different philosophical approaches to software
testing.  For example, some organizations advocate writing test programs
before actually implementing the desired software, yielding ‘’test\sphinxhyphen{}driven
development.’’  Some organizations advocate testing from a customer perspective
as soon as possible, following a parallel with the agile development process:
‘’test early and test often.’’  This is sometimes called ‘’agile testing.’’  It
seems that there is at least one approach to testing for every development
methodology.

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} project is not in the business of advocating for any one of
these processes, but the project as a whole has requirements that help inform
the test process.

\sphinxAtStartPar
Like all major software products, \sphinxstyleemphasis{ns\sphinxhyphen{}3} has a number of qualities that
must be present for the product to succeed.  From a testing perspective, some
of these qualities that must be addressed are that \sphinxstyleemphasis{ns\sphinxhyphen{}3} must be
‘’correct,’’ ‘’robust,’’  ‘’performant’’ and ‘’maintainable.’’  Ideally there
should be metrics for each of these dimensions that are checked by the tests
to identify when the product fails to meet its expectations / requirements.


\subsubsection{Correctness}
\label{\detokenize{test-background:correctness}}
\sphinxAtStartPar
The essential purpose of testing is to determine that a piece of software
behaves ‘’correctly.’’  For \sphinxstyleemphasis{ns\sphinxhyphen{}3} this means that if we simulate
something, the simulation should faithfully represent some physical entity or
process to a specified accuracy and precision.

\sphinxAtStartPar
It turns out that there are two perspectives from which one can view
correctness.  Verifying that a particular model is implemented according
to its specification is generically called \sphinxstyleemphasis{verification}.  The process of
deciding that the model is correct for its intended use is generically called
\sphinxstyleemphasis{validation}.


\subsubsection{Validation and Verification}
\label{\detokenize{test-background:validation-and-verification}}
\sphinxAtStartPar
A computer model is a mathematical or logical representation of something. It
can represent a vehicle, an elephant (see
\sphinxhref{http://simutools.org/2009/}{David Harel’s talk about modeling an elephant at SIMUTools 2009}, or a networking card.  Models can also represent
processes such as global warming, freeway traffic flow or a specification of a
networking protocol.  Models can be completely faithful representations of a
logical process specification, but they necessarily can never completely
simulate a physical object or process.  In most cases, a number of
simplifications are made to the model to make simulation computationally
tractable.

\sphinxAtStartPar
Every model has a \sphinxstyleemphasis{target system} that it is attempting to simulate.  The
first step in creating a simulation model is to identify this target system and
the level of detail and accuracy that the simulation is desired to reproduce.
In the case of a logical process, the target system may be identified as ‘’TCP
as defined by RFC 793.’’  In this case, it will probably be desirable to create
a model that completely and faithfully reproduces RFC 793.  In the case of a
physical process this will not be possible. If, for example, you would like to
simulate a wireless networking card, you may determine that you need,  ‘’an
accurate MAC\sphinxhyphen{}level implementation of the 802.11 specification and {[}…{]} a
not\sphinxhyphen{}so\sphinxhyphen{}slow PHY\sphinxhyphen{}level model of the 802.11a specification.’’

\sphinxAtStartPar
Once this is done, one can develop an abstract model of the target system.  This
is typically an exercise in managing the tradeoffs between complexity, resource
requirements and accuracy.  The process of developing an abstract model has been
called \sphinxstyleemphasis{model qualification} in the literature.  In the case of a TCP
protocol, this process results in a design for a collection of objects,
interactions and behaviors that will fully implement RFC 793 in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
In the case of the wireless card, this process results in a number of tradeoffs
to allow the physical layer to be simulated and the design of a network device
and channel for ns\sphinxhyphen{}3, along with the desired objects, interactions and behaviors.

\sphinxAtStartPar
This abstract model is then developed into an \sphinxstyleemphasis{ns\sphinxhyphen{}3} model that
implements the abstract model as a computer program.  The process of getting the
implementation to agree with the abstract model is called \sphinxstyleemphasis{model
verification} in the literature.

\sphinxAtStartPar
The process so far is open loop. What remains is to make a determination that a
given ns\sphinxhyphen{}3 model has some connection to some reality \textendash{} that a model is an
accurate representation of a real system, whether a logical process or a physical
entity.

\sphinxAtStartPar
If one is going to use a simulation model to try and predict how some real
system is going to behave, there must be some reason to believe your results \textendash{}
i.e., can one trust that an inference made from the model translates into a
correct prediction for the real system.  The process of getting the ns\sphinxhyphen{}3 model
behavior to agree with the desired target system behavior as defined by the model
qualification process is called \sphinxstyleemphasis{model validation} in the literature. In the
case of a TCP implementation, you may want to compare the behavior of your ns\sphinxhyphen{}3
TCP model to some reference implementation in order to validate your model.  In
the case of a wireless physical layer simulation, you may want to compare the
behavior of your model to that of real hardware in a controlled setting,

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing environment provides tools to allow for both model
validation and testing, and encourages the publication of validation results.


\subsubsection{Robustness}
\label{\detokenize{test-background:robustness}}
\sphinxAtStartPar
Robustness is the quality of being able to withstand stresses, or changes in
environments, inputs or calculations, etc.  A system or design is ‘’robust’’
if it can deal with such changes with minimal loss of functionality.

\sphinxAtStartPar
This kind of testing is usually done with a particular focus.  For example, the
system as a whole can be run on many different system configurations to
demonstrate that it can perform correctly in a large number of environments.

\sphinxAtStartPar
The system can be also be stressed by operating close to or beyond capacity by
generating or simulating resource exhaustion of various kinds.  This genre of
testing is called ‘’stress testing.’’

\sphinxAtStartPar
The system and its components may be exposed to so\sphinxhyphen{}called ‘’clean tests’’ that
demonstrate a positive result \textendash{} that is that the system operates correctly in
response to a large variation of expected configurations.

\sphinxAtStartPar
The system and its components may also be exposed to ‘’dirty tests’’ which
provide inputs outside the expected range.  For example, if a module expects a
zero\sphinxhyphen{}terminated string representation of an integer, a dirty test might provide
an unterminated string of random characters to verify that the system does not
crash as a result of this unexpected input.  Unfortunately, detecting such
‘’dirty’’ input and taking preventive measures to ensure the system does not
fail catastrophically can require a huge amount of development overhead.  In
order to reduce development time, a decision was taken early on in the project
to minimize the amount of parameter validation and error handling in the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} codebase.  For this reason, we do not spend much time on dirty
testing \textendash{} it would just uncover the results of the design decision we know
we took.

\sphinxAtStartPar
We do want to demonstrate that \sphinxstyleemphasis{ns\sphinxhyphen{}3} software does work across some set
of conditions.  We borrow a couple of definitions to narrow this down a bit.
The \sphinxstyleemphasis{domain of applicability} is a set of prescribed conditions for which
the model has been tested, compared against reality to the extent possible, and
judged  suitable for use.  The \sphinxstyleemphasis{range of accuracy} is an agreement between
the computerized model and reality within a domain of applicability.

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing environment provides tools to allow for setting up
and running test environments over multiple systems (buildbot) and provides
classes to encourage clean tests to verify the operation of the system over the
expected ‘’domain of applicability’’ and ‘’range of accuracy.’’


\subsubsection{Performant}
\label{\detokenize{test-background:performant}}
\sphinxAtStartPar
Okay, ‘’performant’’ isn’t a real English word.  It is, however, a very concise
neologism that is quite often used to describe what we want \sphinxstyleemphasis{ns\sphinxhyphen{}3} to
be: powerful and fast enough to get the job done.

\sphinxAtStartPar
This is really about the broad subject of software performance testing.  One of
the key things that is done is to compare two systems to find which performs
better (cf benchmarks).  This is used to demonstrate that, for example,
\sphinxstyleemphasis{ns\sphinxhyphen{}3} can perform a basic kind of simulation at least as fast as a
competing tool, or can be used to identify parts of the system that perform
badly.

\sphinxAtStartPar
In the \sphinxstyleemphasis{ns\sphinxhyphen{}3} test framework, we provide support for timing various kinds
of tests.


\subsubsection{Maintainability}
\label{\detokenize{test-background:maintainability}}
\sphinxAtStartPar
A software product must be maintainable.  This is, again, a very broad
statement, but a testing framework can help with the task.  Once a model has
been developed, validated and verified, we can repeatedly execute the suite
of tests for the entire system to ensure that it remains valid and verified
over its lifetime.

\sphinxAtStartPar
When a feature stops functioning as intended after some kind of change to the
system is integrated, it is called generically a \sphinxstyleemphasis{regression}.
Originally the
term regression referred to a change that caused a previously fixed bug to
reappear, but the term has evolved to describe any kind of change that breaks
existing functionality.  There are many kinds of regressions that may occur
in practice.

\sphinxAtStartPar
A \sphinxstyleemphasis{local regression} is one in which a change affects the changed component
directly.  For example, if a component is modified to allocate and free memory
but stale pointers are used, the component itself fails.

\sphinxAtStartPar
A \sphinxstyleemphasis{remote regression} is one in which a change to one component breaks
functionality in another component.  This reflects violation of an implied but
possibly unrecognized contract between components.

\sphinxAtStartPar
An \sphinxstyleemphasis{unmasked regression} is one that creates a situation where a previously
existing bug that had no affect is suddenly exposed in the system.  This may
be as simple as exercising a code path for the first time.

\sphinxAtStartPar
A \sphinxstyleemphasis{performance regression} is one that causes the performance requirements
of the system to be violated.  For example, doing some work in a low level
function that may be repeated large numbers of times may suddenly render the
system unusable from certain perspectives.

\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing framework provides tools for automating the process
used to validate and verify the code in nightly test suites to help quickly
identify possible regressions.

\sphinxstepscope


\subsection{Testing framework}
\label{\detokenize{test-framework:testing-framework}}\label{\detokenize{test-framework::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} consists of a simulation core engine, a set of models, example programs,
and tests.  Over time, new contributors contribute models, tests, and
examples.  A Python test program \sphinxcode{\sphinxupquote{test.py}} serves as the test
execution manager; \sphinxcode{\sphinxupquote{test.py}} can run test code and examples to
look for regressions, can output the results into a number of forms, and
can manage code coverage analysis tools.  On top of this, we layer
\sphinxstyleemphasis{buildslaves} that are automated build robots that perform
robustness testing by running the test framework on different systems
and with different configuration options.


\subsubsection{Buildslaves}
\label{\detokenize{test-framework:buildslaves}}
\sphinxAtStartPar
At the highest level of \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing are the buildslaves (build robots).
If you are unfamiliar with
this system look at \sphinxurl{https://ns-buildmaster.ee.washington.edu:8010/}.
This is an open\sphinxhyphen{}source automated system that allows \sphinxstyleemphasis{ns\sphinxhyphen{}3} to be rebuilt
and tested daily.  By running the buildbots on a number
of different systems we can ensure that \sphinxstyleemphasis{ns\sphinxhyphen{}3} builds and executes
properly on all of its supported systems.

\sphinxAtStartPar
Users (and developers) typically will not interact with the buildslave system other
than to read its messages regarding test results.  If a failure is detected in
one of the automated build and test jobs, the buildbot will send an email to the
\sphinxstyleemphasis{ns\sphinxhyphen{}commits} mailing list.  This email will look something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[Ns\PYGZhy{}commits] Build failed in Jenkins: daily\PYGZhy{}ubuntu\PYGZhy{}without\PYGZhy{}valgrind » Ubuntu\PYGZhy{}64\PYGZhy{}15.04 \PYGZsh{}926

...
281 of 285 tests passed (281 passed, 3 skipped, 1 failed, 0 crashed, 0 valgrind errors)
List of SKIPped tests:
  ns3\PYGZhy{}tcp\PYGZhy{}cwnd
  ns3\PYGZhy{}tcp\PYGZhy{}interoperability
  nsc\PYGZhy{}tcp\PYGZhy{}loss
List of FAILed tests:
  random\PYGZhy{}variable\PYGZhy{}stream\PYGZhy{}generators
+ exit 1
Build step \PYGZsq{}Execute shell\PYGZsq{} marked build as failure
\end{sphinxVerbatim}

\sphinxAtStartPar
In the full details URL shown in the email, one can find links to the detailed test output.

\sphinxAtStartPar
The buildslave system will do its job quietly if there are no errors, and the
system will undergo build and test cycles every day to verify that all is well.


\subsubsection{Test.py}
\label{\detokenize{test-framework:test-py}}
\sphinxAtStartPar
The buildbots use a Python program, \sphinxcode{\sphinxupquote{test.py}}, that is responsible for
running all of the tests and collecting the resulting reports into a human\sphinxhyphen{}
readable form.  This program is also available for use by users and developers
as well.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{test.py}} is very flexible in allowing the user to specify the number
and kind of tests to run; and also the amount and kind of output to generate.

\sphinxAtStartPar
Before running \sphinxcode{\sphinxupquote{test.py}}, make sure that ns3’s examples and tests
have been built by doing the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, \sphinxcode{\sphinxupquote{test.py}} will run all available tests and report status
back in a very concise form.  Running the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py
\end{sphinxVerbatim}

\sphinxAtStartPar
will result in a number of \sphinxcode{\sphinxupquote{PASS}}, \sphinxcode{\sphinxupquote{FAIL}}, \sphinxcode{\sphinxupquote{CRASH}} or \sphinxcode{\sphinxupquote{SKIP}}
indications followed by the kind of test that was run and its display name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
Waf: Leaving directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
\PYGZsq{}build\PYGZsq{} finished successfully (0.939s)
FAIL: TestSuite propagation\PYGZhy{}loss\PYGZhy{}model
PASS: TestSuite object\PYGZhy{}name\PYGZhy{}service
PASS: TestSuite pcap\PYGZhy{}file\PYGZhy{}object
PASS: TestSuite ns3\PYGZhy{}tcp\PYGZhy{}cwnd
...
PASS: TestSuite ns3\PYGZhy{}tcp\PYGZhy{}interoperability
PASS: Example csma\PYGZhy{}broadcast
PASS: Example csma\PYGZhy{}multicast
\end{sphinxVerbatim}

\sphinxAtStartPar
This mode is intended to be used by users who are interested in determining if
their distribution is working correctly, and by developers who are interested
in determining if changes they have made have caused any regressions.

\sphinxAtStartPar
There are a number of options available to control the behavior of \sphinxcode{\sphinxupquote{test.py}}.
if you run \sphinxcode{\sphinxupquote{test.py \sphinxhyphen{}\sphinxhyphen{}help}} you should see a command summary like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Usage: test.py [options]

Options:
  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit
  \PYGZhy{}b BUILDPATH, \PYGZhy{}\PYGZhy{}buildpath=BUILDPATH
                        specify the path where ns\PYGZhy{}3 was built (defaults to the
                        build directory for the current variant)
  \PYGZhy{}c KIND, \PYGZhy{}\PYGZhy{}constrain=KIND
                        constrain the test\PYGZhy{}runner by kind of test
  \PYGZhy{}e EXAMPLE, \PYGZhy{}\PYGZhy{}example=EXAMPLE
                        specify a single example to run (no relative path is
                        needed)
  \PYGZhy{}d, \PYGZhy{}\PYGZhy{}duration        print the duration of each test suite and example
  \PYGZhy{}e EXAMPLE, \PYGZhy{}\PYGZhy{}example=EXAMPLE
                        specify a single example to run (no relative path is
                        needed)
  \PYGZhy{}u, \PYGZhy{}\PYGZhy{}update\PYGZhy{}data     If examples use reference data files, get them to re\PYGZhy{}
                        generate them
  \PYGZhy{}f FULLNESS, \PYGZhy{}\PYGZhy{}fullness=FULLNESS
                        choose the duration of tests to run: QUICK, EXTENSIVE,
                        or TAKES\PYGZus{}FOREVER, where EXTENSIVE includes QUICK and
                        TAKES\PYGZus{}FOREVER includes QUICK and EXTENSIVE (only QUICK
                        tests are run by default)
  \PYGZhy{}g, \PYGZhy{}\PYGZhy{}grind           run the test suites and examples using valgrind
  \PYGZhy{}k, \PYGZhy{}\PYGZhy{}kinds           print the kinds of tests available
  \PYGZhy{}l, \PYGZhy{}\PYGZhy{}list            print the list of known tests
  \PYGZhy{}m, \PYGZhy{}\PYGZhy{}multiple        report multiple failures from test suites and test
                        cases
  \PYGZhy{}n, \PYGZhy{}\PYGZhy{}nobuild           do not run ns3 before starting testing
  \PYGZhy{}p PYEXAMPLE, \PYGZhy{}\PYGZhy{}pyexample=PYEXAMPLE
                        specify a single python example to run (with relative
                        path)
  \PYGZhy{}r, \PYGZhy{}\PYGZhy{}retain          retain all temporary files (which are normally
                        deleted)
  \PYGZhy{}s TEST\PYGZhy{}SUITE, \PYGZhy{}\PYGZhy{}suite=TEST\PYGZhy{}SUITE
                        specify a single test suite to run
  \PYGZhy{}t TEXT\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}text=TEXT\PYGZhy{}FILE
                        write detailed test results into TEXT\PYGZhy{}FILE.txt
  \PYGZhy{}v, \PYGZhy{}\PYGZhy{}verbose         print progress and informational messages
  \PYGZhy{}w HTML\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}web=HTML\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}html=HTML\PYGZhy{}FILE
                        write detailed test results into HTML\PYGZhy{}FILE.html
  \PYGZhy{}x XML\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}xml=XML\PYGZhy{}FILE
                        write detailed test results into XML\PYGZhy{}FILE.xml
\end{sphinxVerbatim}

\sphinxAtStartPar
If one specifies an optional output style, one can generate detailed descriptions
of the tests and status.  Available styles are \sphinxcode{\sphinxupquote{text}} and \sphinxcode{\sphinxupquote{HTML}}.
The buildbots will select the HTML option to generate HTML test reports for the
nightly builds using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}html\PYG{o}{=}nightly.html
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, an HTML file named ‘’nightly.html’’ would be created with a pretty
summary of the testing done.  A ‘’human readable’’ format is available for users
interested in the details.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}text\PYG{o}{=}results.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
In the example above, the test suite checking the \sphinxstyleemphasis{ns\sphinxhyphen{}3} wireless
device propagation loss models failed.  By default no further information is
provided.

\sphinxAtStartPar
To further explore the failure, \sphinxcode{\sphinxupquote{test.py}} allows a single test suite
to be specified.  Running the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}propagation\PYGZhy{}loss\PYGZhy{}model
\end{sphinxVerbatim}

\sphinxAtStartPar
or equivalently

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}s\PYG{+w}{ }propagation\PYGZhy{}loss\PYGZhy{}model
\end{sphinxVerbatim}

\sphinxAtStartPar
results in that single test suite being run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FAIL: TestSuite propagation\PYGZhy{}loss\PYGZhy{}model
\end{sphinxVerbatim}

\sphinxAtStartPar
To find detailed information regarding the failure, one must specify the kind
of output desired.  For example, most people will probably be interested in
a text file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}propagation\PYGZhy{}loss\PYGZhy{}model\PYG{+w}{ }\PYGZhy{}\PYGZhy{}text\PYG{o}{=}results.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
This will result in that single test suite being run with the test status written to
the file ‘’results.txt’’.

\sphinxAtStartPar
You should find something similar to the following in that file

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FAIL: Test Suite \PYGZsq{}\PYGZsq{}propagation\PYGZhy{}loss\PYGZhy{}model\PYGZsq{}\PYGZsq{} (real 0.02 user 0.01 system 0.00)
PASS: Test Case \PYGZdq{}Check ... Friis ... model ...\PYGZdq{} (real 0.01 user 0.00 system 0.00)
FAIL: Test Case \PYGZdq{}Check ... Log Distance ... model\PYGZdq{} (real 0.01 user 0.01 system 0.00)
  Details:
    Message:   Got unexpected SNR value
    Condition: [long description of what actually failed]
    Actual:    176.395
    Limit:     176.407 +\PYGZhy{} 0.0005
    File:      ../src/test/ns3wifi/propagation\PYGZhy{}loss\PYGZhy{}models\PYGZhy{}test\PYGZhy{}suite.cc
    Line:      360
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that the Test Suite is composed of two Test Cases.  The first test case
checked the Friis propagation loss model and passed.  The second test case
failed checking the Log Distance propagation model.  In this case, an SNR of
176.395 was found, and the test expected a value of 176.407 correct to three
decimal places.  The file which implemented the failing test is listed as well
as the line of code which triggered the failure.

\sphinxAtStartPar
If you desire, you could just as easily have written an HTML file using the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}html}} option as described above.

\sphinxAtStartPar
Typically a user will run all tests at least once after downloading
\sphinxstyleemphasis{ns\sphinxhyphen{}3} to ensure that his or her environment has been built correctly
and is generating correct results according to the test suites.  Developers
will typically run the test suites before and after making a change to ensure
that they have not introduced a regression with their changes.  In this case,
developers may not want to run all tests, but only a subset.  For example,
the developer might only want to run the unit tests periodically while making
changes to a repository.  In this case, \sphinxcode{\sphinxupquote{test.py}} can be told to constrain
the types of tests being run to a particular class of tests.  The following
command will result in only the unit tests being run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}constrain\PYG{o}{=}unit
\end{sphinxVerbatim}

\sphinxAtStartPar
To see a quick list of the legal kinds of constraints, you can ask for them
to be listed.  The following command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}kinds
\end{sphinxVerbatim}

\sphinxAtStartPar
will result in the following list being displayed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
Waf: Leaving directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
\PYGZsq{}build\PYGZsq{} finished successfully (0.939s)Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
core:        Run all TestSuite\PYGZhy{}based tests (exclude examples)
example:     Examples (to see if example programs run successfully)
performance: Performance Tests (check to see if the system is as fast as expected)
system:      System Tests (spans modules to check integration of modules)
unit:        Unit Tests (within modules to check basic functionality)
\end{sphinxVerbatim}

\sphinxAtStartPar
Any of these kinds of test can be provided as a constraint using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}constraint}}
option.

\sphinxAtStartPar
To see a quick list of all of the test suites available, you can ask for them
to be listed.  The following command,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}list
\end{sphinxVerbatim}

\sphinxAtStartPar
will result in a list of the test suite being displayed, similar to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
Waf: Leaving directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
\PYGZsq{}build\PYGZsq{} finished successfully (0.939s)

Test Type    Test Name
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
performance  many\PYGZhy{}uniform\PYGZhy{}random\PYGZhy{}variables\PYGZhy{}one\PYGZhy{}get\PYGZhy{}value\PYGZhy{}call
performance  one\PYGZhy{}uniform\PYGZhy{}random\PYGZhy{}variable\PYGZhy{}many\PYGZhy{}get\PYGZhy{}value\PYGZhy{}calls
performance  type\PYGZhy{}id\PYGZhy{}perf
system       buildings\PYGZhy{}pathloss\PYGZhy{}test
system       buildings\PYGZhy{}shadowing\PYGZhy{}test
system       devices\PYGZhy{}mesh\PYGZhy{}dot11s\PYGZhy{}regression
system       devices\PYGZhy{}mesh\PYGZhy{}flame\PYGZhy{}regression
system       epc\PYGZhy{}gtpu
...
unit         wimax\PYGZhy{}phy\PYGZhy{}layer
unit         wimax\PYGZhy{}service\PYGZhy{}flow
unit         wimax\PYGZhy{}ss\PYGZhy{}mac\PYGZhy{}layer
unit         wimax\PYGZhy{}tlv
example      adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy
example      adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}matrix\PYGZhy{}propagation\PYGZhy{}loss\PYGZhy{}model
example      adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}with\PYGZhy{}microwave\PYGZhy{}oven
example      aodv
...
\end{sphinxVerbatim}

\sphinxAtStartPar
Any of these listed suites can be selected to be run by itself using the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}suite}} option as shown above.

\sphinxAtStartPar
To run multiple test suites at once it is possible to use a ‘Unix filename pattern matching’
style, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }../test.py\PYG{+w}{ }\PYGZhy{}s\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ipv6*\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the use of quotes. The result is similar to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: TestSuite ipv6\PYGZhy{}protocol
PASS: TestSuite ipv6\PYGZhy{}packet\PYGZhy{}info\PYGZhy{}tag
PASS: TestSuite ipv6\PYGZhy{}list\PYGZhy{}routing
PASS: TestSuite ipv6\PYGZhy{}extension\PYGZhy{}header
PASS: TestSuite ipv6\PYGZhy{}address\PYGZhy{}generator
PASS: TestSuite ipv6\PYGZhy{}raw
PASS: TestSuite ipv6\PYGZhy{}dual\PYGZhy{}stack
PASS: TestSuite ipv6\PYGZhy{}fragmentation
PASS: TestSuite ipv6\PYGZhy{}address\PYGZhy{}helper
PASS: TestSuite ipv6\PYGZhy{}address
PASS: TestSuite ipv6\PYGZhy{}forwarding
PASS: TestSuite ipv6\PYGZhy{}ripng
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly to test suites, one can run a single C++ example program
using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}example}} option.  Note that the relative path for the
example does not need to be included and that the executables built
for C++ examples do not have extensions.  Furthermore, the example
must be registered as an example to the test framework; it is not
sufficient to create an example and run it through test.py; it must
be added to the relevant \sphinxcode{\sphinxupquote{examples\sphinxhyphen{}to\sphinxhyphen{}run.py}} file, explained below.
Entering

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}example\PYG{o}{=}udp\PYGZhy{}echo
\end{sphinxVerbatim}

\sphinxAtStartPar
results in that single example being run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: Example examples/udp/udp\PYGZhy{}echo
\end{sphinxVerbatim}

\sphinxAtStartPar
You can specify the directory where \sphinxstyleemphasis{ns\sphinxhyphen{}3} was built using the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}buildpath}} option as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}buildpath\PYG{o}{=}/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build/debug\PYG{+w}{ }\PYGZhy{}\PYGZhy{}example\PYG{o}{=}wifi\PYGZhy{}simple\PYGZhy{}adhoc
\end{sphinxVerbatim}

\sphinxAtStartPar
One can run a single Python example program using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}pyexample}}
option.  Note that the relative path for the example must be included
and that Python examples do need their extensions.  Entering

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}pyexample\PYG{o}{=}examples/tutorial/first.py
\end{sphinxVerbatim}

\sphinxAtStartPar
results in that single example being run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: Example examples/tutorial/first.py
\end{sphinxVerbatim}

\sphinxAtStartPar
Because Python examples are not built, you do not need to specify the
directory where \sphinxstyleemphasis{ns\sphinxhyphen{}3} was built to run them.

\sphinxAtStartPar
Normally when example programs are executed, they write a large amount of trace
file data.  This is normally saved to the base directory of the distribution
(e.g., /home/user/ns\sphinxhyphen{}3\sphinxhyphen{}dev).  When \sphinxcode{\sphinxupquote{test.py}} runs an example, it really
is completely unconcerned with the trace files.  It just wants to to determine
if the example can be built and run without error.  Since this is the case, the
trace files are written into a \sphinxcode{\sphinxupquote{/tmp/unchecked\sphinxhyphen{}traces}} directory.  If you
run the above example, you should be able to find the associated
\sphinxcode{\sphinxupquote{udp\sphinxhyphen{}echo.tr}} and \sphinxcode{\sphinxupquote{udp\sphinxhyphen{}echo\sphinxhyphen{}n\sphinxhyphen{}1.pcap}} files there.

\sphinxAtStartPar
The list of available examples is defined by the contents of the ‘’examples’’
directory in the distribution.  If you select an example for execution using
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}example}} option, \sphinxcode{\sphinxupquote{test.py}} will not make any attempt to decide
if the example has been configured or not, it will just try to run it and
report the result of the attempt.

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{test.py}} runs, by default it will first ensure that the system has
been completely built.  This can be defeated by selecting the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}nobuild}}
option.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}list\PYG{+w}{ }\PYGZhy{}\PYGZhy{}nobuild
\end{sphinxVerbatim}

\sphinxAtStartPar
will result in a list of the currently built test suites being displayed, similar to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
propagation\PYGZhy{}loss\PYGZhy{}model
ns3\PYGZhy{}tcp\PYGZhy{}cwnd
ns3\PYGZhy{}tcp\PYGZhy{}interoperability
pcap\PYGZhy{}file
object\PYGZhy{}name\PYGZhy{}service
random\PYGZhy{}variable\PYGZhy{}stream\PYGZhy{}generators
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the absence of the \sphinxcode{\sphinxupquote{ns3}} build messages.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{test.py}} also supports running the test suites and examples under valgrind.
Valgrind is a flexible program for debugging and profiling Linux executables.  By
default, valgrind runs a tool called memcheck, which performs a range of memory\sphinxhyphen{}
checking functions, including detecting accesses to uninitialised memory, misuse
of allocated memory (double frees, access after free, etc.) and detecting memory
leaks.  This can be selected by using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}grind}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}grind
\end{sphinxVerbatim}

\sphinxAtStartPar
As it runs, \sphinxcode{\sphinxupquote{test.py}} and the programs that it runs indirectly, generate large
numbers of temporary files.  Usually, the content of these files is not interesting,
however in some cases it can be useful (for debugging purposes) to view these files.
\sphinxcode{\sphinxupquote{test.py}} provides a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}retain}} option which will cause these temporary
files to be kept after the run is completed.  The files are saved in a directory
named \sphinxcode{\sphinxupquote{testpy\sphinxhyphen{}output}} under a subdirectory named according to the current Coordinated
Universal Time (also known as Greenwich Mean Time).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}retain
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, \sphinxcode{\sphinxupquote{test.py}} provides a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}verbose}} option which will print
large amounts of information about its progress.  It is not expected that this
will be terribly useful unless there is an error.  In this case, you can get
access to the standard output and standard error reported by running test suites
and examples.  Select verbose in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}verbose
\end{sphinxVerbatim}

\sphinxAtStartPar
All of these options can be mixed and matched.  For example, to run all of the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} core test suites under valgrind, in verbose mode, while generating an HTML
output file, one would do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}verbose\PYG{+w}{ }\PYGZhy{}\PYGZhy{}grind\PYG{+w}{ }\PYGZhy{}\PYGZhy{}constrain\PYG{o}{=}core\PYG{+w}{ }\PYGZhy{}\PYGZhy{}html\PYG{o}{=}results.html
\end{sphinxVerbatim}


\subsubsection{TestTaxonomy}
\label{\detokenize{test-framework:testtaxonomy}}
\sphinxAtStartPar
As mentioned above, tests are grouped into a number of broadly defined
classifications to allow users to selectively run tests to address the different
kinds of testing that need to be done.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Build Verification Tests

\item {} 
\sphinxAtStartPar
Unit Tests

\item {} 
\sphinxAtStartPar
System Tests

\item {} 
\sphinxAtStartPar
Examples

\item {} 
\sphinxAtStartPar
Performance Tests

\end{itemize}

\sphinxAtStartPar
Moreover, each test is further classified according to the expected time needed to
run it. Tests are classified as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
QUICK

\item {} 
\sphinxAtStartPar
EXTENSIVE

\item {} 
\sphinxAtStartPar
TAKES\_FOREVER

\end{itemize}

\sphinxAtStartPar
Note that specifying EXTENSIVE fullness will also run tests in QUICK category.
Specifying TAKES\_FOREVER will run tests in EXTENSIVE and QUICK categories.
By default, only QUICK tests are ran.

\sphinxAtStartPar
As a rule of thumb, tests that must be run to ensure \sphinxstyleemphasis{ns\sphinxhyphen{}3} coherence should be
QUICK (i.e., take a few seconds). Tests that could be skipped, but are nice to do
can be EXTENSIVE; these are tests that typically need minutes. TAKES\_FOREVER is
left for tests that take a really long time, in the order of several minutes.
The main classification goal is to be able to run the buildbots in a reasonable
time, and still be able to perform more extensive tests when needed.


\paragraph{Unit Tests}
\label{\detokenize{test-framework:unit-tests}}
\sphinxAtStartPar
Unit tests are more involved tests that go into detail to make sure that a
piece of code works as advertised in isolation.  There is really no reason
for this kind of test to be built into an \sphinxstyleemphasis{ns\sphinxhyphen{}3} module.  It turns out, for
example, that the unit tests for the object name service are about the same
size as the object name service code itself.  Unit tests are tests that
check a single bit of functionality that are not built into the \sphinxstyleemphasis{ns\sphinxhyphen{}3} code,
but live in the same directory as the code it tests.  It is possible that
these tests check integration of multiple implementation files in a module
as well.  The file src/core/test/names\sphinxhyphen{}test\sphinxhyphen{}suite.cc is an example of this kind
of test.  The file src/network/test/pcap\sphinxhyphen{}file\sphinxhyphen{}test\sphinxhyphen{}suite.cc is another example
that uses a known good pcap file as a test vector file.  This file is stored
locally in the src/network directory.


\paragraph{System Tests}
\label{\detokenize{test-framework:system-tests}}
\sphinxAtStartPar
System tests are those that involve more than one module in the system.  We
have some of this kind of test running in our current regression framework,
but they are typically overloaded examples.  We provide a new place
for this kind of test in the directory \sphinxcode{\sphinxupquote{src/test}}.  The file
\sphinxcode{\sphinxupquote{src/test/ns3tcp/ns3tcp\sphinxhyphen{}loss\sphinxhyphen{}test\sphinxhyphen{}suite.cc}} is an example of this kind of
test.  It uses NSC TCP to test the \sphinxstyleemphasis{ns\sphinxhyphen{}3} TCP implementation.  Often there
will be test vectors required for this kind of test, and they are stored in
the directory where the test lives.  For example,
\sphinxcode{\sphinxupquote{ns3tcp\sphinxhyphen{}loss\sphinxhyphen{}NewReno0\sphinxhyphen{}response\sphinxhyphen{}vectors.pcap}} is a file consisting of a number of TCP
headers that are used as the expected responses of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} TCP under test.

\sphinxAtStartPar
Note that Unit Tests are often preferable to System Tests, as they are more
independent from small changes in the modules that are not the goal of the test.


\paragraph{Examples}
\label{\detokenize{test-framework:examples}}
\sphinxAtStartPar
The examples are tested by the framework to make sure they built and
will run.  Limited checking is done on examples; currently the pcap
files are just written off into /tmp to be discarded.  If the example
runs (don’t crash) and the exit status is zero, the example will pass
the smoke test.


\paragraph{Performance Tests}
\label{\detokenize{test-framework:performance-tests}}
\sphinxAtStartPar
Performance tests are those which exercise a particular part of the system
and determine if the tests have executed to completion in a reasonable time.


\subsubsection{Running Tests}
\label{\detokenize{test-framework:running-tests}}
\sphinxAtStartPar
Tests are typically run using the high level \sphinxcode{\sphinxupquote{test.py}} program. To get a list of the available command\sphinxhyphen{}line options, run \sphinxcode{\sphinxupquote{test.py \sphinxhyphen{}\sphinxhyphen{}help}}

\sphinxAtStartPar
The test program \sphinxcode{\sphinxupquote{test.py}} will run both tests and those examples that
have been added to the list to check.  The difference between tests
and examples is as follows.  Tests generally check that specific simulation
output or events conforms to expected behavior.  In contrast, the output
of examples is not checked, and the test program merely checks the exit
status of the example program to make sure that it runs without error.

\sphinxAtStartPar
Briefly, to run all tests, first one must configure tests during configuration
stage, and also (optionally) examples if examples are to be checked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, build \sphinxstyleemphasis{ns\sphinxhyphen{}3}, and after it is built, just run \sphinxcode{\sphinxupquote{test.py}}.  \sphinxcode{\sphinxupquote{test.py \sphinxhyphen{}h}}
will show a number of configuration options that modify the behavior
of test.py.

\sphinxAtStartPar
The program \sphinxcode{\sphinxupquote{test.py}} invokes, for C++ tests and examples, a lower\sphinxhyphen{}level
C++ program called \sphinxcode{\sphinxupquote{test\sphinxhyphen{}runner}} to actually run the tests.  As discussed
below, this \sphinxcode{\sphinxupquote{test\sphinxhyphen{}runner}} can be a helpful way to debug tests.


\subsubsection{Debugging Tests}
\label{\detokenize{test-framework:debugging-tests}}
\sphinxAtStartPar
The debugging of the test programs is best performed running the low\sphinxhyphen{}level
test\sphinxhyphen{}runner program. The test\sphinxhyphen{}runner is the bridge from generic Python
code to \sphinxstyleemphasis{ns\sphinxhyphen{}3} code. It is written in C++ and uses the automatic test
discovery process in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} code to find and allow execution of all
of the various tests.

\sphinxAtStartPar
The main reason why \sphinxcode{\sphinxupquote{test.py}} is not suitable for debugging is that it is
not allowed for logging to be turned on using the \sphinxcode{\sphinxupquote{NS\_LOG}} environmental
variable when test.py runs.  This limitation does not apply to the test\sphinxhyphen{}runner
executable. Hence, if you want to see logging output from your tests, you
have to run them using the test\sphinxhyphen{}runner directly.

\sphinxAtStartPar
In order to execute the test\sphinxhyphen{}runner, you run it like any other \sphinxstyleemphasis{ns\sphinxhyphen{}3} executable
\textendash{} using \sphinxcode{\sphinxupquote{ns3}}.  To get a list of available options, you can type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}help\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You should see something like the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Usage: /home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build/utils/ns3\PYGZhy{}dev\PYGZhy{}test\PYGZhy{}runner\PYGZhy{}debug [OPTIONS]

Options:
\PYGZhy{}\PYGZhy{}help                 : print these options
\PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}name\PYGZhy{}list : print the list of names of tests available
\PYGZhy{}\PYGZhy{}list                 : an alias for \PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}name\PYGZhy{}list
\PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}types     : print the type of tests along with their names
\PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}type\PYGZhy{}list : print the list of types of tests available
\PYGZhy{}\PYGZhy{}print\PYGZhy{}temp\PYGZhy{}dir       : print name of temporary directory before running
                         the tests
\PYGZhy{}\PYGZhy{}test\PYGZhy{}type=TYPE       : process only tests of type TYPE
\PYGZhy{}\PYGZhy{}test\PYGZhy{}name=NAME       : process only test whose name matches NAME
\PYGZhy{}\PYGZhy{}suite=NAME           : an alias (here for compatibility reasons only)
                         for \PYGZhy{}\PYGZhy{}test\PYGZhy{}name=NAME
\PYGZhy{}\PYGZhy{}assert\PYGZhy{}on\PYGZhy{}failure    : when a test fails, crash immediately (useful
                         when running under a debugger
\PYGZhy{}\PYGZhy{}stop\PYGZhy{}on\PYGZhy{}failure      : when a test fails, stop immediately
\PYGZhy{}\PYGZhy{}fullness=FULLNESS    : choose the duration of tests to run: QUICK,
                         EXTENSIVE, or TAKES\PYGZus{}FOREVER, where EXTENSIVE
                         includes QUICK and TAKES\PYGZus{}FOREVER includes
                         QUICK and EXTENSIVE (only QUICK tests are
                         run by default)
\PYGZhy{}\PYGZhy{}verbose              : print details of test execution
\PYGZhy{}\PYGZhy{}xml                  : format test run output as xml
\PYGZhy{}\PYGZhy{}tempdir=DIR          : set temp dir for tests to store output files
\PYGZhy{}\PYGZhy{}datadir=DIR          : set data dir for tests to read reference files
\PYGZhy{}\PYGZhy{}out=FILE             : send test result to FILE instead of standard output
\PYGZhy{}\PYGZhy{}append=FILE          : append test result to FILE instead of standard output
\end{sphinxVerbatim}

\sphinxAtStartPar
There are a number of things available to you which will be familiar to you if
you have looked at \sphinxcode{\sphinxupquote{test.py}}.  This should be expected since the test\sphinxhyphen{}
runner is just an interface between \sphinxcode{\sphinxupquote{test.py}} and \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  You
may notice that example\sphinxhyphen{}related commands are missing here.  That is because
the examples are really not \sphinxstyleemphasis{ns\sphinxhyphen{}3} tests.  \sphinxcode{\sphinxupquote{test.py}} runs them
as if they were to present a unified testing environment, but they are really
completely different and not to be found here.

\sphinxAtStartPar
The first new option that appears here, but not in test.py is the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}assert\sphinxhyphen{}on\sphinxhyphen{}failure}}
option.  This option is useful when debugging a test case when running under a
debugger like \sphinxcode{\sphinxupquote{gdb}}.  When selected, this option tells the underlying
test case to cause a segmentation violation if an error is detected.  This has
the nice side\sphinxhyphen{}effect of causing program execution to stop (break into the
debugger) when an error is detected.  If you are using gdb, you could use this
option something like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }shell
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }build/utils
\PYGZdl{}\PYG{+w}{ }gdb\PYG{+w}{ }ns3\PYGZhy{}dev\PYGZhy{}test\PYGZhy{}runner\PYGZhy{}debug
\PYGZdl{}\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}global\PYGZhy{}value\PYG{+w}{ }\PYGZhy{}\PYGZhy{}assert\PYGZhy{}on\PYGZhy{}failure
\end{sphinxVerbatim}

\sphinxAtStartPar
If an error is then found in the global\sphinxhyphen{}value test suite, a segfault would be
generated and the (source level) debugger would stop at the \sphinxcode{\sphinxupquote{NS\_TEST\_ASSERT\_MSG}}
that detected the error.

\sphinxAtStartPar
To run one of the tests directly from the test\sphinxhyphen{}runner
using \sphinxcode{\sphinxupquote{ns3}}, you will need to specify the test suite to run.
So you could use the shell and do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}suite=pcap\PYGZhy{}file\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} logging is available when you run it this way, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }\PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Packet\PYGZdq{}}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}suite=pcap\PYGZhy{}file\PYGZdq{}}
\end{sphinxVerbatim}


\paragraph{Test output}
\label{\detokenize{test-framework:test-output}}
\sphinxAtStartPar
Many test suites need to write temporary files (such as pcap files)
in the process of running the tests.  The tests then need a temporary directory
to write to.  The Python test utility (test.py) will provide a temporary file
automatically, but if run stand\sphinxhyphen{}alone this temporary directory must be provided.
It can be annoying to continually have to provide
a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}tempdir}}, so the test runner will figure one out for you if you don’t
provide one.  It first looks for environment variables named \sphinxcode{\sphinxupquote{TMP}} and
\sphinxcode{\sphinxupquote{TEMP}} and uses those.  If neither \sphinxcode{\sphinxupquote{TMP}} nor \sphinxcode{\sphinxupquote{TEMP}} are defined
it picks \sphinxcode{\sphinxupquote{/tmp}}.  The code then tacks on an identifier indicating what
created the directory (ns\sphinxhyphen{}3) then the time (hh.mm.ss) followed by a large random
number.  The test runner creates a directory of that name to be used as the
temporary directory.  Temporary files then go into a directory that will be
named something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/tmp/ns\PYGZhy{}3.10.25.37.61537845
\end{sphinxVerbatim}

\sphinxAtStartPar
The time is provided as a hint so that you can relatively easily reconstruct
what directory was used if you need to go back and look at the files that were
placed in that directory.

\sphinxAtStartPar
Another class of output is test output like pcap traces that are generated
to compare to reference output.  The test program will typically delete
these after the test suites all run.  To disable the deletion of test
output, run \sphinxcode{\sphinxupquote{test.py}} with the “retain” option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}r
\end{sphinxVerbatim}

\sphinxAtStartPar
and test output can be found in the \sphinxcode{\sphinxupquote{testpy\sphinxhyphen{}output/}} directory.


\paragraph{Reporting of test failures}
\label{\detokenize{test-framework:reporting-of-test-failures}}
\sphinxAtStartPar
When you run a test suite using the test\sphinxhyphen{}runner it will run the test
and report PASS or FAIL.
To run more quietly, you need to specify an output file to which the tests will write their status using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}out}} option.
Try,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}suite=pcap\PYGZhy{}file \PYGZhy{}\PYGZhy{}out=myfile.txt\PYGZdq{}}
\end{sphinxVerbatim}


\paragraph{Debugging test suite failures}
\label{\detokenize{test-framework:debugging-test-suite-failures}}
\sphinxAtStartPar
To debug test crashes, such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CRASH: TestSuite wifi\PYGZhy{}interference
\end{sphinxVerbatim}

\sphinxAtStartPar
You can access the underlying test\sphinxhyphen{}runner program via gdb as follows, and
then pass the “\textendash{}basedir=\textasciigrave{}pwd\textasciigrave{}” argument to run (you can also pass other
arguments as needed, but basedir is the minimum needed):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}gdb \PYGZpc{}s\PYGZdq{}}
Waf:\PYG{+w}{ }Entering\PYG{+w}{ }directory\PYG{+w}{ }\PYG{l+s+sb}{`}/home/tomh/hg/sep09/ns\PYGZhy{}3\PYGZhy{}allinone/ns\PYGZhy{}3\PYGZhy{}dev\PYGZhy{}678/build\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{Waf: Leaving directory `/home/tomh/hg/sep09/ns\PYGZhy{}3\PYGZhy{}allinone/ns\PYGZhy{}3\PYGZhy{}dev\PYGZhy{}678/build\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}build\PYGZsq{}}\PYG{+w}{ }finished\PYG{+w}{ }successfully\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{0}.380s\PYG{o}{)}
GNU\PYG{+w}{ }gdb\PYG{+w}{ }\PYG{l+m}{6}.8\PYGZhy{}debian
Copyright\PYG{+w}{ }\PYG{o}{(}C\PYG{o}{)}\PYG{+w}{ }\PYG{l+m}{2008}\PYG{+w}{ }Free\PYG{+w}{ }Software\PYG{+w}{ }Foundation,\PYG{+w}{ }Inc.
L\PYG{+w}{ }cense\PYG{+w}{ }GPLv3+:\PYG{+w}{ }GNU\PYG{+w}{ }GPL\PYG{+w}{ }version\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }or\PYG{+w}{ }later\PYG{+w}{ }\PYGZlt{}http://gnu.org/licenses/gpl.html\PYGZgt{}
This\PYG{+w}{ }is\PYG{+w}{ }free\PYG{+w}{ }software:\PYG{+w}{ }you\PYG{+w}{ }are\PYG{+w}{ }free\PYG{+w}{ }to\PYG{+w}{ }change\PYG{+w}{ }and\PYG{+w}{ }redistribute\PYG{+w}{ }it.
There\PYG{+w}{ }is\PYG{+w}{ }NO\PYG{+w}{ }WARRANTY,\PYG{+w}{ }to\PYG{+w}{ }the\PYG{+w}{ }extent\PYG{+w}{ }permitted\PYG{+w}{ }by\PYG{+w}{ }law.\PYG{+w}{  }Type\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}show copying\PYGZdq{}}
and\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}show warranty\PYGZdq{}}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }details.
This\PYG{+w}{ }GDB\PYG{+w}{ }was\PYG{+w}{ }configured\PYG{+w}{ }as\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu\PYGZdq{}}...
\PYG{o}{(}gdb\PYG{o}{)}\PYG{+w}{ }r\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}
Starting\PYG{+w}{ }program:\PYG{+w}{ }\PYGZlt{}..\PYGZgt{}/build/utils/ns3\PYGZhy{}dev\PYGZhy{}test\PYGZhy{}runner\PYGZhy{}debug\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}wifi\PYGZhy{}interference
\PYG{o}{[}Thread\PYG{+w}{ }debugging\PYG{+w}{ }using\PYG{+w}{ }libthread\PYGZus{}db\PYG{+w}{ }enabled\PYG{o}{]}
assert\PYG{+w}{ }failed.\PYG{+w}{ }\PYG{n+nv}{file}\PYG{o}{=}../src/core/model/type\PYGZhy{}id.cc,\PYG{+w}{ }\PYG{n+nv}{line}\PYG{o}{=}\PYG{l+m}{138},\PYG{+w}{ }\PYG{n+nv}{cond}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}uid \PYGZlt{}= m\PYGZus{}information.size() \PYGZam{}\PYGZam{} uid != 0\PYGZdq{}}
...
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is another example of how to use valgrind to debug a memory problem
such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
VALGR:\PYG{+w}{ }TestSuite\PYG{+w}{ }devices\PYGZhy{}mesh\PYGZhy{}dot11s\PYGZhy{}regression

\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }test\PYGZhy{}runner\PYG{+w}{ }\PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}valgrind \PYGZpc{}s \PYGZhy{}\PYGZhy{}suite=devices\PYGZhy{}mesh\PYGZhy{}dot11s\PYGZhy{}regression\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{Class TestRunner}
\label{\detokenize{test-framework:class-testrunner}}
\sphinxAtStartPar
The executables that run dedicated test programs use a TestRunner class.  This
class provides for automatic test registration and listing, as well as a way to
execute the individual tests.  Individual test suites use C++ global
constructors
to add themselves to a collection of test suites managed by the test runner.
The test runner is used to list all of the available tests and to select a test
to be run.  This is a quite simple class that provides three static methods to
provide or Adding and Getting test suites to a collection of tests.  See the
doxygen for class \sphinxcode{\sphinxupquote{ns3::TestRunner}} for details.


\subsubsection{Test Suite}
\label{\detokenize{test-framework:test-suite}}
\sphinxAtStartPar
All \sphinxstyleemphasis{ns\sphinxhyphen{}3} tests are classified into Test Suites and Test Cases.  A
test suite is a collection of test cases that completely exercise a given kind
of functionality.  As described above, test suites can be classified as,
\begin{itemize}
\item {} 
\sphinxAtStartPar
Build Verification Tests

\item {} 
\sphinxAtStartPar
Unit Tests

\item {} 
\sphinxAtStartPar
System Tests

\item {} 
\sphinxAtStartPar
Examples

\item {} 
\sphinxAtStartPar
Performance Tests

\end{itemize}

\sphinxAtStartPar
This classification is exported from the TestSuite class.  This class is quite
simple, existing only as a place to export this type and to accumulate test
cases.  From a user perspective, in order to create a new TestSuite in the
system one only has to define a new class that inherits from class \sphinxcode{\sphinxupquote{TestSuite}}
and perform these two duties.

\sphinxAtStartPar
The following code will define a new class that can be run by \sphinxcode{\sphinxupquote{test.py}}
as a ‘’unit’’ test with the display name, \sphinxcode{\sphinxupquote{my\sphinxhyphen{}test\sphinxhyphen{}suite\sphinxhyphen{}name}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MySuite}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{TestSuite}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{MyTestSuite}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{MyTestSuite}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyTestSuite}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{TestSuite}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZhy{}test\PYGZhy{}suite\PYGZhy{}name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UNIT}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{AddTestCase}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{MyTestCase}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TestCase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{QUICK}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static}\PYG{+w}{ }\PYG{n}{MyTestSuite}\PYG{+w}{ }\PYG{n}{myTestSuite}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The base class takes care of all of the registration and reporting required to
be a good citizen in the test framework.

\sphinxAtStartPar
Avoid putting initialization logic into the test suite or test case
constructors.  This is
because an instance of the test suite is created at run time
(due to the static variable above) regardless of whether the test is being
run or not.  Instead, the TestCase provides a virtual \sphinxcode{\sphinxupquote{DoSetup}} method
that can be specialized to perform setup before \sphinxcode{\sphinxupquote{DoRun}} is called.


\subsubsection{Test Case}
\label{\detokenize{test-framework:test-case}}
\sphinxAtStartPar
Individual tests are created using a TestCase class.  Common models for the use
of a test case include “one test case per feature”, and “one test case per method.”
Mixtures of these models may be used.

\sphinxAtStartPar
In order to create a new test case in the system, all one has to do is to inherit
from the  \sphinxcode{\sphinxupquote{TestCase}} base class, override the constructor to give the test
case a name and override the \sphinxcode{\sphinxupquote{DoRun}} method to run the test.  Optionally,
override also the \sphinxcode{\sphinxupquote{DoSetup}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyTestCase}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{TestCase}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{MyTestCase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DoSetup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DoRun}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{MyTestCase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyTestCase}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{TestCase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Check some bit of functionality}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}
\PYG{n}{MyTestCase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DoRun}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}EQ}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Some failure message}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Utilities}
\label{\detokenize{test-framework:utilities}}
\sphinxAtStartPar
There are a number of utilities of various kinds that are also part of the
testing framework.  Examples include a generalized pcap file useful for
storing test vectors; a generic container useful for transient storage of
test vectors during test execution; and tools for generating presentations
based on validation and verification testing results.

\sphinxAtStartPar
These utilities are not documented here, but for example, please see
how the TCP tests found in \sphinxcode{\sphinxupquote{src/test/ns3tcp/}} use pcap files and reference
output.

\sphinxstepscope


\subsection{How to write tests}
\label{\detokenize{how-to-write-tests:how-to-write-tests}}\label{\detokenize{how-to-write-tests::doc}}
\sphinxAtStartPar
A primary goal of the ns\sphinxhyphen{}3 project is to help users to improve the
validity and credibility of their results.  There are many elements
to obtaining valid models and simulations, and testing is a major
component.  If you contribute models or examples to ns\sphinxhyphen{}3, you may
be asked to contribute test code.  Models that you contribute will be
used for many years by other people, who probably have no idea upon
first glance whether the model is correct.  The test code that you
write for your model will help to avoid future regressions in
the output and will aid future users in understanding the verification
and bounds of applicability of your models.

\sphinxAtStartPar
There are many ways to verify the correctness of a model’s implementation.
In this section,
we hope to cover some common cases that can be used as a guide to
writing new tests.


\subsubsection{Sample TestSuite skeleton}
\label{\detokenize{how-to-write-tests:sample-testsuite-skeleton}}
\sphinxAtStartPar
When starting from scratch (i.e. not adding a TestCase to an existing
TestSuite), these things need to be decided up front:
\begin{itemize}
\item {} 
\sphinxAtStartPar
What the test suite will be called

\item {} 
\sphinxAtStartPar
What type of test it will be (Build Verification Test, Unit Test,
System Test, or Performance Test)

\item {} 
\sphinxAtStartPar
Where the test code will live (either in an existing ns\sphinxhyphen{}3 module or
separately in src/test/ directory).  You will have to edit the wscript
file in that directory to compile your new code, if it is a new file.

\end{itemize}

\sphinxAtStartPar
A program called \sphinxcode{\sphinxupquote{utils/create\sphinxhyphen{}module.py}} is a good starting point.
This program can be invoked such as \sphinxcode{\sphinxupquote{create\sphinxhyphen{}module.py router}} for
a hypothetical new module called \sphinxcode{\sphinxupquote{router}}.  Once you do this, you
will see a \sphinxcode{\sphinxupquote{router}} directory, and a \sphinxcode{\sphinxupquote{test/router\sphinxhyphen{}test\sphinxhyphen{}suite.cc}}
test suite.  This file can be a starting point for your initial test.
This is a working test suite, although the actual tests performed are
trivial.  Copy it over to your module’s test directory, and do a global
substitution of “Router” in that file for something pertaining to
the model that you want to test.  You can also edit things such as a
more descriptive test case name.

\sphinxAtStartPar
You also need to add a block into your wscript to get this test to
compile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module\PYGZus{}test}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/router\PYGZhy{}test\PYGZhy{}suite.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Before you actually start making this do useful things, it may help
to try to run the skeleton.  Make sure that ns\sphinxhyphen{}3 has been configured with
the “\textendash{}enable\sphinxhyphen{}tests” option.  Let’s assume that your new test suite
is called “router” such as here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RouterTestSuite}\PYG{o}{:}\PYG{o}{:}\PYG{n}{RouterTestSuite}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{TestSuite}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{router}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UNIT}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Try this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./test.py\PYG{+w}{ }\PYGZhy{}s\PYG{+w}{ }router
\end{sphinxVerbatim}

\sphinxAtStartPar
Output such as below should be produced:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: TestSuite router
1 of 1 tests passed (1 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
See src/lte/test/test\sphinxhyphen{}lte\sphinxhyphen{}antenna.cc for a worked example.


\subsubsection{Test macros}
\label{\detokenize{how-to-write-tests:test-macros}}
\sphinxAtStartPar
There are a number of macros available for checking test program
output with expected output.  These macros are defined in
\sphinxcode{\sphinxupquote{src/core/model/test.h}}.

\sphinxAtStartPar
The main set of macros that are used include the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}EQ}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}NE}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}LT}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}GT}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}EQ\PYGZus{}TOL}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{limit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{tol}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{msg}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first argument \sphinxcode{\sphinxupquote{actual}} is the value under test, the second value
\sphinxcode{\sphinxupquote{limit}} is the expected value (or the value to test against), and the
last argument \sphinxcode{\sphinxupquote{msg}} is the error message to print out if the test fails.

\sphinxAtStartPar
The first four macros above test for equality, inequality, less than, or
greater than, respectively.  The fifth macro above tests for equality,
but within a certain tolerance.  This variant is useful when testing
floating point numbers for equality against a limit, where you want to
avoid a test failure due to rounding errors.

\sphinxAtStartPar
Finally, there are variants of the above where the keyword \sphinxcode{\sphinxupquote{ASSERT}}
is replaced by \sphinxcode{\sphinxupquote{EXPECT}}.  These variants are designed specially for
use in methods (especially callbacks) returning void.  Reserve their
use for callbacks that you use in your test programs; otherwise,
use the \sphinxcode{\sphinxupquote{ASSERT}} variants.


\subsubsection{How to add an example program to the test suite}
\label{\detokenize{how-to-write-tests:how-to-add-an-example-program-to-the-test-suite}}
\sphinxAtStartPar
There are two methods for adding an example program to the the test
suite.  Normally an example is added using only one of these methods
to avoid running the example twice.

\sphinxAtStartPar
First, you can “smoke test” that examples compile and run successfully
to completion (without memory leaks) using the \sphinxcode{\sphinxupquote{examples\sphinxhyphen{}to\sphinxhyphen{}run.py}}
script located in your module’s test directory.  Briefly, by including
an instance of this file in your test directory, you can cause the
test runner to execute the examples listed.  It is usually best to
make sure that you select examples that have reasonably short run
times so as to not bog down the tests.  See the example in
\sphinxcode{\sphinxupquote{src/lte/test/}} directory.  The exit status of the example will be
checked when run and a non\sphinxhyphen{}zero exit status can be used to indicate
that the example has failed.  This is the easiest way to add an example
to the test suite but has limited checks.

\sphinxAtStartPar
The second method you can use to add an example to the test suite is
more complicated but enables checking of the example output
(\sphinxcode{\sphinxupquote{std::out}} and \sphinxcode{\sphinxupquote{std::err}}).  This approach uses the test suite
framework with a specialized \sphinxcode{\sphinxupquote{TestSuite}} or \sphinxcode{\sphinxupquote{TestCase}} class
designed to run an example and compare the output with a specified
known “good” reference file.  To use an example program as a test you
need to create a test suite file and add it to the appropriate list in
your module wscript file. The “good” output reference file needs to be
generated for detecting regressions.

\sphinxAtStartPar
If you are thinking about using this class, strongly consider using a
standard test instead.  The TestSuite class has better checking using
the \sphinxcode{\sphinxupquote{NS\_TEST\_*}} macros and in almost all cases is the better approach.
If your test can be done with a TestSuite class you will be asked by
the reviewers to rewrite the test when you do a pull request.

\sphinxAtStartPar
Let’s assume your module is called \sphinxcode{\sphinxupquote{mymodule}}, and the example
program is \sphinxcode{\sphinxupquote{mymodule/examples/mod\sphinxhyphen{}example.cc}}.  First you should
create a test file \sphinxcode{\sphinxupquote{mymodule/test/mymodule\sphinxhyphen{}examples\sphinxhyphen{}test\sphinxhyphen{}suite.cc}}
which looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/example\PYGZhy{}as\PYGZhy{}test.h\PYGZdq{}}
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{ns3}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ExampleAsTestSuite}\PYG{+w}{ }\PYG{n}{g\PYGZus{}modExampleOne}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymodule\PYGZhy{}example\PYGZhy{}mod\PYGZhy{}example\PYGZhy{}one}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mod\PYGZhy{}example}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NS\PYGZus{}TEST\PYGZus{}SOURCEDIR}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}arg\PYGZhy{}one}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{ns3}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ExampleAsTestSuite}\PYG{+w}{ }\PYG{n}{g\PYGZus{}modExampleTwo}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymodule\PYGZhy{}example\PYGZhy{}mod\PYGZhy{}example\PYGZhy{}two}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mod\PYGZhy{}example}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NS\PYGZus{}TEST\PYGZus{}SOURCEDIR}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}arg\PYGZhy{}two}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The arguments to the constructor are the name of the test suite, the
example to run, the directory that contains the “good” reference file
(the macro \sphinxcode{\sphinxupquote{NS\_TEST\_SOURCEDIR}} is normally the correct directory),
and command line arguments for the example.  In the preceding code the
same example is run twice with different arguments.

\sphinxAtStartPar
You then need to add that newly created test suite file to the list of
test sources in \sphinxcode{\sphinxupquote{mymodule/wscript}}.  Building of examples
is an option so you need to guard the inclusion of the test suite:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{bld}\PYG{o}{.}\PYG{n}{env}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ENABLE\PYGZus{}EXAMPLES}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{module}\PYG{o}{.}\PYG{n}{source}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/mymodule\PYGZhy{}examples\PYGZhy{}test\PYGZhy{}suite.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since you modified a wscript file you need to reconfigure and rebuild
everything.

\sphinxAtStartPar
You just added new tests so you will need to generate the “good”
output reference files that will be used to verify the example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}mymodule\PYGZhy{}example\PYGZhy{}*\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}update
\end{sphinxVerbatim}

\sphinxAtStartPar
This will run all tests starting with “mymodule\sphinxhyphen{}example\sphinxhyphen{}” and save new
“good” reference files.  Updating the reference files should be done
when you create the test and whenever output changes.  When updating
the reference output you should inspect it to ensure that it is valid.
The reference files should be committed with the new test.

\sphinxAtStartPar
This completes the process of adding a new example.

\sphinxAtStartPar
You can now run the test with the standard \sphinxcode{\sphinxupquote{test.py}} script.  For
example to run the suites you just added:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./test.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}suite\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}mymodule\PYGZhy{}example\PYGZhy{}*\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will run all \sphinxcode{\sphinxupquote{mymodule\sphinxhyphen{}example\sphinxhyphen{}...}} tests and report whether they
produce output matching the reference files.

\sphinxAtStartPar
You can also add multiple examples as test cases to a \sphinxcode{\sphinxupquote{TestSuite}}
using \sphinxcode{\sphinxupquote{ExampleAsTestCase}}.  See
\sphinxcode{\sphinxupquote{src/core/test/examples\sphinxhyphen{}as\sphinxhyphen{}tests\sphinxhyphen{}test\sphinxhyphen{}suite.cc}} for examples of
setting examples as tests.

\sphinxAtStartPar
When setting up an example for use by this class you should be very
careful about what output the example generates.  For example, writing
output which includes simulation time (especially high resolution
time) makes the test sensitive to potentially minor changes in event
times.  This makes the reference output hard to verify and hard to
keep up\sphinxhyphen{}to\sphinxhyphen{}date.  Output as little as needed for the example and
include only behavioral state that is important for determining if the
example has run correctly.


\subsubsection{Testing (de)serialization of Headers}
\label{\detokenize{how-to-write-tests:testing-de-serialization-of-headers}}
\sphinxAtStartPar
Implementing serialization and deserialization of Headers is often prone to
errors. A generic approach to test these operations is to start from a given
Header, serialize the given header in a buffer, then create a new header by
deserializing from the buffer and serialize the new header into a second buffer.
If everything is correct, the two buffers have the same size and the same content.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{HeaderSerializationTestCase}} class enables to perform such a test in an
easy manner. Test cases willing to exploit such an approach have to inherit from
\sphinxcode{\sphinxupquote{HeaderSerializationTestCase}} instead of \sphinxcode{\sphinxupquote{TestCase}} and pass a Header object
to the \sphinxcode{\sphinxupquote{TestHeaderSerialization}} method (along with arguments that may be
needed to construct the new header that is going to be deserialized).

\sphinxAtStartPar
Note that such an approach is not restricted to Header subclasses, but it is
available for all classes that provide (de)serialization operations, such as
the wifi Information Elements.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/header\PYGZhy{}serialization\PYGZhy{}test.h\PYGZdq{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{BasicMultiLinkElementTest}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{HeaderSerializationTestCase}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{void}
\PYG{n+nf}{BasicMultiLinkElementTest::DoRun}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{MultiLinkElement}\PYG{+w}{ }\PYG{n}{mle}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}MAC\PYGZus{}MGT\PYGZus{}BEACON}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+c1}{// Fill in the Multi\PYGZhy{}Link Element}
\PYG{+w}{  }\PYG{n}{TestHeaderSerialization}\PYG{p}{(}\PYG{n}{mle}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}MAC\PYGZus{}MGT\PYGZus{}BEACON}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Examples of this approach are found, e.g., in \sphinxcode{\sphinxupquote{src/wifi/test/wifi\sphinxhyphen{}eht\sphinxhyphen{}info\sphinxhyphen{}elems\sphinxhyphen{}test.cc}}


\subsubsection{Testing for boolean outcomes}
\label{\detokenize{how-to-write-tests:testing-for-boolean-outcomes}}

\subsubsection{Testing outcomes when randomness is involved}
\label{\detokenize{how-to-write-tests:testing-outcomes-when-randomness-is-involved}}

\subsubsection{Testing output data against a known distribution}
\label{\detokenize{how-to-write-tests:testing-output-data-against-a-known-distribution}}

\subsubsection{Providing non\sphinxhyphen{}trivial input vectors of data}
\label{\detokenize{how-to-write-tests:providing-non-trivial-input-vectors-of-data}}

\subsubsection{Storing and referencing non\sphinxhyphen{}trivial output data}
\label{\detokenize{how-to-write-tests:storing-and-referencing-non-trivial-output-data}}

\subsubsection{Presenting your output test data}
\label{\detokenize{how-to-write-tests:presenting-your-output-test-data}}
\sphinxstepscope


\section{Creating a new \sphinxstyleemphasis{ns\sphinxhyphen{}3} model}
\label{\detokenize{new-models:creating-a-new-ns3-model}}\label{\detokenize{new-models::doc}}
\sphinxAtStartPar
This chapter walks through the design process of an \sphinxstyleemphasis{ns\sphinxhyphen{}3} model.  In many
research cases, users will not be satisfied to merely adapt existing models, but
may want to extend the core of the simulator in a novel way. We will use the
example of adding an ErrorModel to a simple \sphinxstyleemphasis{ns\sphinxhyphen{}3} link as a motivating example
of how one might approach this problem and proceed through a design and
implementation.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Documentation

\sphinxAtStartPar
Here we focus on the process of creating new models
and new modules, and some of the design choices involved.
For the sake of clarity, we defer discussion of the
\sphinxstyleemphasis{mechanics} of documenting models and source code to the
{\hyperref[\detokenize{documentation::doc}]{\sphinxcrossref{\DUrole{doc}{Documentation}}}} chapter.
\end{sphinxadmonition}


\subsection{Design Approach}
\label{\detokenize{new-models:design-approach}}
\sphinxAtStartPar
Consider how you want it to work; what should it do. Think about these things:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{functionality:}  What functionality should it have?  What attributes or
configuration is exposed to the user?

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{reusability:}  How much should others be able to reuse my design?  Can I
reuse code from \sphinxstyleemphasis{ns\sphinxhyphen{}2} to get started?  How does a user integrate the model
with the rest of another simulation?

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{dependencies:}  How can I reduce the introduction of outside dependencies on
my new code as much as possible (to make it more modular)?  For instance,
should I avoid any dependence on IPv4 if I want it to also be used by IPv6?
Should I avoid any dependency on IP at all?

\end{itemize}

\sphinxAtStartPar
Do not be hesitant to contact the \sphinxtitleref{ns\sphinxhyphen{}3\sphinxhyphen{}users} or \sphinxtitleref{ns\sphinxhyphen{}developers} list if you have
questions. In particular, it is important to think about the public API of your
new model and ask for feedback. It also helps to let others know of your work in
case you are interested in collaborators.


\subsubsection{Example: \sphinxtitleref{ErrorModel}}
\label{\detokenize{new-models:example-errormodel}}
\sphinxAtStartPar
An error model exists in \sphinxstyleemphasis{ns\sphinxhyphen{}2}. It allows packets to be passed to a stateful
object that determines, based on a random variable, whether the packet is
corrupted.  The caller can then decide what to do with the packet (drop it,
etc.).

\sphinxAtStartPar
The main API of the error model is a function to pass a packet to, and the
return value of this function is a boolean that tells the caller whether any
corruption occurred.  Note that depending on the error model, the packet data
buffer may or may not be corrupted.  Let’s call this function “IsCorrupt()”.

\sphinxAtStartPar
So far, in our design, we have:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{ }\PYG{c+cm}{/**}
\PYG{c+cm}{  * \PYGZbs{}returns true if the Packet is to be considered as errored/corrupted}
\PYG{c+cm}{  * \PYGZbs{}param pkt Packet to apply error model to}
\PYG{c+cm}{  */}
\PYG{+w}{  }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{IsCorrupt}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we do not pass a const pointer, thereby allowing the function to
modify the packet if IsCorrupt() returns true. Not all error models will
actually modify the packet; whether or not the packet data buffer is corrupted
should be documented.

\sphinxAtStartPar
We may also want specialized versions of this, such as in \sphinxstyleemphasis{ns\sphinxhyphen{}2}, so although it
is not the only design choice for polymorphism, we assume that we will subclass
a base class ErrorModel for specialized classes, such as RateErrorModel,
ListErrorModel, etc, such as is done in \sphinxstyleemphasis{ns\sphinxhyphen{}2}.

\sphinxAtStartPar
You may be thinking at this point, “Why not make IsCorrupt() a virtual method?”.
That is one approach; the other is to make the public non\sphinxhyphen{}virtual function
indirect through a private virtual function (this in C++ is known as the non
virtual interface idiom and is adopted in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} ErrorModel class).

\sphinxAtStartPar
Next, should this device have any dependencies on IP or other protocols?  We do
not want to create dependencies on Internet protocols (the error model should be
applicable to non\sphinxhyphen{}Internet protocols too), so we’ll keep that in mind later.

\sphinxAtStartPar
Another consideration is how objects will include this error model.  We envision
putting an explicit setter in certain NetDevice implementations, for example.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * Attach a receive ErrorModel to the PointToPointNetDevice.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The PointToPointNetDevice may optionally include an ErrorModel in}
\PYG{c+cm}{ * the packet receive chain.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @see ErrorModel}
\PYG{c+cm}{ * @param em Ptr to the ErrorModel.}
\PYG{c+cm}{ */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{PointToPointNetDevice::SetReceiveErrorModel}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{em}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Again, this is not the only choice we have (error models could be aggregated to
lots of other objects), but it satisfies our primary use case, which is to allow
a user to force errors on otherwise successful packet transmissions, at the
NetDevice level.

\sphinxAtStartPar
After some thinking and looking at existing \sphinxstyleemphasis{ns\sphinxhyphen{}2} code, here is a sample API of
a base class and first subclass that could be posted for initial review:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{ErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{o}{\PYGZti{}}\PYG{n}{ErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{IsCorrupt}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Reset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Enable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Disable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{IsEnabled}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{DoCorrupt}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{pkt}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DoReset}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{ErrorUnit}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{EU\PYGZus{}BIT}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{EU\PYGZus{}BYTE}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{EU\PYGZus{}PKT}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Determine which packets are errored corresponding to an underlying}
\PYG{c+c1}{// random variable distribution, an error rate, and unit for the rate.}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{RateErrorModel}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{n}{RateErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{o}{\PYGZti{}}\PYG{n}{RateErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{ErrorUnit}\PYG{+w}{ }\PYG{n}{GetUnit}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SetUnit}\PYG{p}{(}\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{ErrorUnit}\PYG{+w}{ }\PYG{n}{error\PYGZus{}unit}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{GetRate}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SetRate}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{rate}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SetRandomVariable}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{RandomVariable}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{ranvar}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{DoCorrupt}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DoReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Scaffolding}
\label{\detokenize{new-models:scaffolding}}
\sphinxAtStartPar
Let’s say that you are ready to start implementing; you have a fairly clear
picture of what you want to build, and you may have solicited some initial
review or suggestions from the list.  One way to approach the next step
(implementation) is to create scaffolding and fill in the details as the design
matures.

\sphinxAtStartPar
This section walks through many of the steps you should consider to define
scaffolding, or a non\sphinxhyphen{}functional skeleton of what your model will eventually
implement. It is usually good practice to not wait to get these details
integrated at the end, but instead to plumb a skeleton of your model into the
system early and then add functions later once the API and integration seems
about right.

\sphinxAtStartPar
Note that you will want to modify a few things in the below presentation for
your model since if you follow the error model verbatim, the code you produce
will collide with the existing error model. The below is just an outline of how
ErrorModel was built that you can adapt to other models.


\subsubsection{Review the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Coding Style Document}
\label{\detokenize{new-models:review-the-ns3-coding-style-document}}
\sphinxAtStartPar
At this point, you may want to pause and read the \sphinxstyleemphasis{ns\sphinxhyphen{}3} coding style document,
especially if you are considering to contribute your code back to the project.
The coding style document is linked off the main project page: \sphinxhref{http://www.nsnam.org/developers/contributing-code/coding-style/}{ns\sphinxhyphen{}3 coding
style}.


\subsubsection{Decide Where in the Source Tree the Model Should Reside}
\label{\detokenize{new-models:decide-where-in-the-source-tree-the-model-should-reside}}
\sphinxAtStartPar
All of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} model source code is in the directory \sphinxcode{\sphinxupquote{src/}}.  You will need
to choose which subdirectory it resides in. If it is new model code of some
sort, it makes sense to put it into the \sphinxcode{\sphinxupquote{src/}} directory somewhere,
particularly for ease of integrating with the build system.

\sphinxAtStartPar
In the case of the error model, it is very related to the packet class, so it
makes sense to implement this in the \sphinxcode{\sphinxupquote{src/network/}} module where \sphinxstyleemphasis{ns\sphinxhyphen{}3}
packets are implemented.


\subsubsection{\sphinxtitleref{cmake} and \sphinxtitleref{CMakeLists.txt}}
\label{\detokenize{new-models:cmake-and-cmakelists-txt}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the \sphinxhref{https://cmake.org/}{CMake} build system.
You will want to integrate your new \sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the CMake build system. You will
want to integrate your new source files into this system. This requires that you
add your files to the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file found in each directory.

\sphinxAtStartPar
Let’s start with empty files error\sphinxhyphen{}model.h and error\sphinxhyphen{}model.cc, and add this to
\sphinxcode{\sphinxupquote{src/network/CMakeLists.txt}}. It is really just a matter of adding the .cc file to the
rest of the source files, and the .h file to the list of the header files.

\sphinxAtStartPar
Now, pop up to the top level directory and type “./test.py”.  You
shouldn’t have broken anything by this operation.


\subsubsection{Include Guards}
\label{\detokenize{new-models:include-guards}}
\sphinxAtStartPar
Next, let’s add some \sphinxhref{http://en.wikipedia.org/wiki/Include\_guard}{include guards} in our header file.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{\sphinxtitleref{namespace ns3}}
\label{\detokenize{new-models:namespace-ns3}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxhref{http://en.wikipedia.org/wiki/Namespace\_(computer\_science)\#Use\_in\_common\_languages}{namespace}
to isolate its symbols from other namespaces. Typically, a user will next put
an \sphinxstyleemphasis{ns\sphinxhyphen{}3} namespace block in both the cc and h file.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, we have some skeletal files in which we can start defining
our new classes. The header file looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ERROR\PYGZus{}MODEL\PYGZus{}H}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{c+c1}{// namespace ns3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

\sphinxAtStartPar
while the \sphinxcode{\sphinxupquote{error\sphinxhyphen{}model.cc}} file simply looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}error\PYGZhy{}model.h\PYGZdq{}}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{c+c1}{// namespace ns3}
\end{sphinxVerbatim}

\sphinxAtStartPar
These files should compile since they don’t really have any contents.  We’re now
ready to start adding classes.


\subsection{Initial Implementation}
\label{\detokenize{new-models:initial-implementation}}
\sphinxAtStartPar
At this point, we’re still working on some scaffolding, but we can begin to
define our classes, with the functionality to be added later.


\subsubsection{Inherit from the \sphinxtitleref{Object} Class?}
\label{\detokenize{new-models:inherit-from-the-object-class}}
\sphinxAtStartPar
This is an important design step; whether to use class \sphinxcode{\sphinxupquote{Object}} as a
base class for your new classes.

\sphinxAtStartPar
As described in the chapter on the \sphinxstyleemphasis{ns\sphinxhyphen{}3} {\hyperref[\detokenize{object-model:object-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Object model}}}}, classes that
inherit from class \sphinxcode{\sphinxupquote{Object}} get special properties:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} type and attribute system (see {\hyperref[\detokenize{attributes:attributes}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration and Attributes}}}})

\item {} 
\sphinxAtStartPar
an object aggregation system

\item {} 
\sphinxAtStartPar
a smart\sphinxhyphen{}pointer reference counting system (class Ptr)

\end{itemize}

\sphinxAtStartPar
Classes that derive from class \sphinxcode{\sphinxupquote{ObjectBase}}\} get the first two
properties above, but do not get smart pointers. Classes that derive from class
\sphinxcode{\sphinxupquote{RefCountBase}} get only the smart\sphinxhyphen{}pointer reference counting system.

\sphinxAtStartPar
In practice, class \sphinxcode{\sphinxupquote{Object}} is the variant of the three above that
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} developer will most commonly encounter.

\sphinxAtStartPar
In our case, we want to make use of the attribute system, and we will be passing
instances of this object across the \sphinxstyleemphasis{ns\sphinxhyphen{}3} public API, so class
\sphinxcode{\sphinxupquote{Object}} is appropriate for us.


\subsubsection{Initial Classes}
\label{\detokenize{new-models:initial-classes}}
\sphinxAtStartPar
One way to proceed is to start by defining the bare minimum functions and see if
they will compile. Let’s review what all is needed to implement when we derive
from class Object.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ERROR\PYGZus{}MODEL\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/object.h\PYGZdq{}}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ErrorModel}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{ErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{o}{\PYGZti{}}\PYG{n}{ErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{RateErrorModel}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{n}{RateErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{o}{\PYGZti{}}\PYG{n}{RateErrorModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

\sphinxAtStartPar
A few things to note here. We need to include \sphinxcode{\sphinxupquote{object.h}}. The convention in
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is that if the header file is co\sphinxhyphen{}located in the same directory, it may be
included without any path prefix. Therefore, if we were implementing ErrorModel
in \sphinxcode{\sphinxupquote{src/core/model}} directory, we could have just said “\sphinxcode{\sphinxupquote{\#include "object.h"}}”.
But we are in \sphinxcode{\sphinxupquote{src/network/model}}, so we must include it as “\sphinxcode{\sphinxupquote{\#include
"ns3/object.h"}}”. Note also that this goes outside the namespace declaration.

\sphinxAtStartPar
Second, each class must implement a static public member function called
\sphinxcode{\sphinxupquote{GetTypeId()}}.

\sphinxAtStartPar
Third, it is a good idea to implement constructors and destructors rather than
to let the compiler generate them, and to make the destructor virtual. In C++,
note also that copy assignment operator and copy constructors are auto\sphinxhyphen{}generated
if they are not defined, so if you do not want those, you should implement those
as private members. This aspect of C++ is discussed in Scott Meyers’ Effective
C++ book. item 45.

\sphinxAtStartPar
Let’s now look at some corresponding skeletal implementation code in the .cc
file.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}error\PYGZhy{}model.h\PYGZdq{}}

\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{ns3}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED}\PYG{p}{(}\PYG{n}{ErrorModel}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n+nf}{ErrorModel::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ErrorModel}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{ErrorModel}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED}\PYG{p}{(}\PYG{n}{RateErrorModel}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n+nf}{RateErrorModel::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RateErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{RateErrorModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{RateErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{RateErrorModel}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{RateErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{RateErrorModel}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
What is the \sphinxcode{\sphinxupquote{GetTypeId()}} function? This function does a few things.  It
registers a unique string into the TypeId system. It establishes  the hierarchy
of objects in the attribute system (via \sphinxcode{\sphinxupquote{SetParent}}). It also declares that
certain objects can be created via the object creation framework
(\sphinxcode{\sphinxupquote{AddConstructor}}).

\sphinxAtStartPar
The macro \sphinxcode{\sphinxupquote{NS\_OBJECT\_ENSURE\_REGISTERED(classname)}} is needed also once for
every class that defines a new GetTypeId method, and it does the actual
registration of the class into the system.  The {\hyperref[\detokenize{object-model:object-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Object model}}}} chapter
discusses this in more detail.


\subsubsection{Including External Files}
\label{\detokenize{new-models:including-external-files}}

\subsubsection{Logging Support}
\label{\detokenize{new-models:logging-support}}
\sphinxAtStartPar
\sphinxstyleemphasis{Here, write a bit about adding |ns3| logging macros. Note that
LOG\_COMPONENT\_DEFINE is done outside the namespace ns3}


\subsubsection{Constructor, Empty Function Prototypes}
\label{\detokenize{new-models:constructor-empty-function-prototypes}}

\subsubsection{Key Variables (Default Values, Attributes)}
\label{\detokenize{new-models:key-variables-default-values-attributes}}

\subsubsection{Test Program 1}
\label{\detokenize{new-models:test-program-1}}

\subsubsection{Object Framework}
\label{\detokenize{new-models:object-framework}}

\subsection{Adding a Sample Script}
\label{\detokenize{new-models:adding-a-sample-script}}
\sphinxAtStartPar
At this point, one may want to try to take the basic scaffolding defined above
and add it into the system. Performing this step now allows one to use a simpler
model when plumbing into the system and may also reveal whether any design or
API modifications need to be made. Once this is done, we will return to building
out the functionality of the ErrorModels themselves.


\subsubsection{Add Basic Support in the Class}
\label{\detokenize{new-models:add-basic-support-in-the-class}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* point\PYGZhy{}to\PYGZhy{}point\PYGZhy{}net\PYGZhy{}device.h */}
\PYG{+w}{  }\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{ErrorModel}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/**}
\PYG{c+cm}{   * Error model for receive packet events}
\PYG{c+cm}{   */}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Add Accessor}
\label{\detokenize{new-models:add-accessor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{PointToPointNetDevice::SetReceiveErrorModel}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{em}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{(}\PYG{k}{this}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{em}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{em}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{+w}{   }\PYG{p}{.}\PYG{n}{AddAttribute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ReceiveErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                   }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The receiver error model used to simulate packet loss}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                   }\PYG{n}{PointerValue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                   }\PYG{n}{MakePointerAccessor}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                   }\PYG{n}{MakePointerChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Plumb Into the System}
\label{\detokenize{new-models:plumb-into-the-system}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{PointToPointNetDevice::Receive}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{packet}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{(}\PYG{k}{this}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{packet}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{protocol}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{  }\PYG{k}{if}\PYG{p}{(}\PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{IsCorrupt}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//}
\PYG{c+c1}{// If we have an error model and it indicates that it is time to lose a}
\PYG{c+c1}{// corrupted packet, don\PYGZsq{}t forward this packet up, let it go.}
\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}dropTrace}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//}
\PYG{c+c1}{// Hit the receive trace hook, strip off the point\PYGZhy{}to\PYGZhy{}point protocol header}
\PYG{c+c1}{// and forward this packet up the protocol stack.}
\PYG{c+c1}{//}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}rxTrace}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{ProcessHeader}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{protocol}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{m\PYGZus{}rxCallback}\PYG{p}{(}\PYG{k}{this}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{packet}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{protocol}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GetRemote}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{m\PYGZus{}promiscCallback}\PYG{p}{.}\PYG{n}{IsNull}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{+w}{           }\PYG{n}{m\PYGZus{}promiscCallback}\PYG{p}{(}\PYG{k}{this}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{packet}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{protocol}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GetRemote}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{                      }\PYG{n}{GetAddress}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{NetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PACKET\PYGZus{}HOST}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Create Null Functional Script}
\label{\detokenize{new-models:create-null-functional-script}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* simple\PYGZhy{}error\PYGZhy{}model.cc */}

\PYG{+w}{  }\PYG{c+c1}{// Error model}
\PYG{+w}{  }\PYG{c+c1}{// We want to add an error model to node 3\PYGZsq{}s NetDevice}
\PYG{+w}{  }\PYG{c+c1}{// We can obtain a handle to the NetDevice via the channel and node}
\PYG{+w}{  }\PYG{c+c1}{// pointers}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nd3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{PointToPointTopology}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetNetDevice}
\PYG{+w}{   }\PYG{p}{(}\PYG{n}{n3}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{channel2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{em}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{nd3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetReceiveErrorModel}\PYG{p}{(}\PYG{n}{em}\PYG{p}{)}\PYG{p}{;}


\PYG{k+kt}{bool}
\PYG{n+nf}{ErrorModel::DoCorrupt}\PYG{p}{(}\PYG{n}{Packet}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{NS\PYGZus{}LOG\PYGZus{}UNCOND}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Corrupt!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, we can run the program with our trivial ErrorModel plumbed into
the receive path of the PointToPointNetDevice. It prints out the string
“Corrupt!” for each packet received at node n3. Next, we return to the error
model to add in a subclass that performs more interesting error modeling.


\subsection{Add a Subclass}
\label{\detokenize{new-models:add-a-subclass}}
\sphinxAtStartPar
The trivial base class ErrorModel does not do anything interesting, but it
provides a useful base class interface (\sphinxcode{\sphinxupquote{Corrupt()}} and \sphinxcode{\sphinxupquote{Reset()}}), forwarded to
virtual functions that can be subclassed. Let’s next consider what we call a
BasicErrorModel which is based on the \sphinxstyleemphasis{ns\sphinxhyphen{}2} ErrorModel class (in
\sphinxcode{\sphinxupquote{ns\sphinxhyphen{}2/queue/errmodel.\{cc,h\}}}).

\sphinxAtStartPar
What properties do we want this to have, from a user interface perspective? We
would like for the user to be able to trivially swap out the type of ErrorModel
used in the NetDevice. We would also like the capability to set configurable
parameters.

\sphinxAtStartPar
Here are a few simple requirements we will consider:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ability to set the random variable that governs the losses (default is
UniformVariable)

\item {} 
\sphinxAtStartPar
Ability to set the unit (bit, byte, packet, time) of granularity over which
errors are applied.

\item {} 
\sphinxAtStartPar
Ability to set the rate of errors (e.g. 10\textasciicircum{}\sphinxhyphen{}3) corresponding to the above unit
of granularity.

\item {} 
\sphinxAtStartPar
Ability to enable/disable (default is enabled)

\end{itemize}


\subsubsection{How to Subclass}
\label{\detokenize{new-models:how-to-subclass}}
\sphinxAtStartPar
We declare BasicErrorModel to be a subclass of ErrorModel as follows,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{BasicErrorModel}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{k}{public}\PYG{+w}{ }\PYG{n}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{  }\PYG{c+c1}{// Implement base class pure virtual functions}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{DoCorrupt}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{DoReset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and configure the subclass GetTypeId function by setting a unique TypeId string
and setting the Parent to ErrorModel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n+nf}{RateErrorModel::GetTypeId}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n}{tid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RateErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{SetGroupName}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{RateErrorModel}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}


\subsection{Build Core Functions and Unit Tests}
\label{\detokenize{new-models:build-core-functions-and-unit-tests}}

\subsubsection{Assert Macros}
\label{\detokenize{new-models:assert-macros}}

\subsubsection{Writing Unit Tests}
\label{\detokenize{new-models:writing-unit-tests}}
\sphinxstepscope


\section{Adding a New Module to \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{new-modules:adding-a-new-module-to-ns3}}\label{\detokenize{new-modules:id1}}\label{\detokenize{new-modules::doc}}
\sphinxAtStartPar
When you have created a group of related classes, examples, and tests,
they can be combined together into an \sphinxstyleemphasis{ns\sphinxhyphen{}3} module so that they can be
used with existing \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules and by other researchers.

\sphinxAtStartPar
This chapter walks you through the steps necessary to add a new module
to \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Step 0 \sphinxhyphen{} Module Layout}
\label{\detokenize{new-modules:step-0-module-layout}}\label{\detokenize{new-modules:step-0}}
\sphinxAtStartPar
All modules can be found in the \sphinxcode{\sphinxupquote{src}} directory.  Each module can be
found in a directory that has the same name as the module.  For
example, the \sphinxcode{\sphinxupquote{spectrum}} module can be found here: \sphinxcode{\sphinxupquote{src/spectrum}}.
We’ll be quoting from the \sphinxcode{\sphinxupquote{spectrum}} module for illustration.

\sphinxAtStartPar
A prototypical module has the following directory structure and
required files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src/
  module\PYGZhy{}name/
    bindings/
    doc/
    examples/
      CMakeLists.txt
    helper/
    model/
    test/
      examples\PYGZhy{}to\PYGZhy{}run.py
    CMakeLists.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
Not all directories will be present in each module.


\subsection{Step 1 \sphinxhyphen{} Create a Module Skeleton}
\label{\detokenize{new-modules:step-1-create-a-module-skeleton}}
\sphinxAtStartPar
A python program is provided in the \sphinxcode{\sphinxupquote{utils}} directory that
will create a skeleton for a new module.  For the purposes
of this discussion we will assume that your new module
is called \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}}.  From the top directory, do the following
to create the new module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./utils/create\PYGZhy{}module.py\PYG{+w}{ }new\PYGZhy{}module
\end{sphinxVerbatim}

\sphinxAtStartPar
By default \sphinxcode{\sphinxupquote{create\sphinxhyphen{}module.py}} creates the module skeleton in the
\sphinxcode{\sphinxupquote{src}} directory.  However, it can also create modules in \sphinxcode{\sphinxupquote{contrib}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./utils/create\PYGZhy{}module.py\PYG{+w}{ }contrib/new\PYGZhy{}contrib
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s assume we’ve created our new module in \sphinxcode{\sphinxupquote{src}}.
\sphinxcode{\sphinxupquote{cd}} into \sphinxcode{\sphinxupquote{src/new\sphinxhyphen{}module}}; you will find this directory layout:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd new\PYGZhy{}module
\PYGZdl{} ls
doc examples  helper  model  test  CMakeLists.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
In more detail, the \sphinxcode{\sphinxupquote{create\sphinxhyphen{}module.py}} script will create the
directories as well as initial skeleton \sphinxcode{\sphinxupquote{CMakeLists.txt}}, \sphinxcode{\sphinxupquote{.h}}, \sphinxcode{\sphinxupquote{.cc}}
and \sphinxcode{\sphinxupquote{.rst}} files.  The complete module with skeleton files looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src/
  new\PYGZhy{}module/
    doc/
  new\PYGZhy{}module.rst
examples/
  new\PYGZhy{}module\PYGZhy{}example.cc
  CMakeLists.txt
helper/
  new\PYGZhy{}module\PYGZhy{}helper.cc
  new\PYGZhy{}module\PYGZhy{}helper.h
model/
  new\PYGZhy{}module.cc
  new\PYGZhy{}module.h
test/
  new\PYGZhy{}module\PYGZhy{}test\PYGZhy{}suite.cc
CMakeLists.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
(If required the \sphinxcode{\sphinxupquote{bindings/}} directory listed in
{\hyperref[\detokenize{new-modules:step-0}]{\sphinxcrossref{\DUrole{std,std-ref}{Step\sphinxhyphen{}0}}}} will be created automatically during
the build.)

\sphinxAtStartPar
We next walk through how to customize this module.  Informing \sphinxcode{\sphinxupquote{ns3}}
about the files which make up your module is done by editing the two
\sphinxcode{\sphinxupquote{CMakeLists.txt}} files.  We will walk through the main steps in this chapter.

\sphinxAtStartPar
All \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules depend on the \sphinxcode{\sphinxupquote{core}} module and usually on
other modules.  This dependency is specified in the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file
(at the top level of the module, not the separate \sphinxcode{\sphinxupquote{CMakeLists.txt}} file
in the \sphinxcode{\sphinxupquote{examples}} directory!).  In the skeleton \sphinxcode{\sphinxupquote{CMakeLists.txt}}
the call that will declare your new module to \sphinxcode{\sphinxupquote{ns3}} will look
like this (before editing):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}module}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{helper/new\PYGZhy{}module\PYGZhy{}helper.cc}
\PYG{+w}{               }\PYG{l+s}{model/new\PYGZhy{}module.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{helper/new\PYGZhy{}module\PYGZhy{}helper.h}
\PYG{+w}{               }\PYG{l+s}{model/new\PYGZhy{}module.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libcore}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}\PYG{+w}{ }\PYG{l+s}{test/new\PYGZhy{}module\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s assume that \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}} depends on the \sphinxcode{\sphinxupquote{internet}},
\sphinxcode{\sphinxupquote{mobility}}, and \sphinxcode{\sphinxupquote{aodv}} modules.  After editing it the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file
should look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}module}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{helper/new\PYGZhy{}module\PYGZhy{}helper.cc}
\PYG{+w}{               }\PYG{l+s}{model/new\PYGZhy{}module.cc}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{helper/new\PYGZhy{}module\PYGZhy{}helper.h}
\PYG{+w}{               }\PYG{l+s}{model/new\PYGZhy{}module.h}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libmobility}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libaodv}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}\PYG{+w}{ }\PYG{l+s}{test/new\PYGZhy{}module\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that only first level module dependencies should be listed, which
is why we removed \sphinxcode{\sphinxupquote{core}}; the \sphinxcode{\sphinxupquote{internet}} module in turn depends on
\sphinxcode{\sphinxupquote{core}}.

\sphinxAtStartPar
Your module will most likely have model source files.  Initial skeletons
(which will compile successfully) are created in \sphinxcode{\sphinxupquote{model/new\sphinxhyphen{}module.cc}}
and \sphinxcode{\sphinxupquote{model/new\sphinxhyphen{}module.h}}.

\sphinxAtStartPar
If your module will have helper source files, then they will go into
the \sphinxcode{\sphinxupquote{helper/}} directory; again, initial skeletons are created
in that directory.

\sphinxAtStartPar
Finally, it is good practice to write tests and examples.  These will
almost certainly be required for new modules to be accepted into
the official \sphinxstyleemphasis{ns\sphinxhyphen{}3} source tree.  A skeleton
test suite and test case is created in the \sphinxcode{\sphinxupquote{test/}} directory.
The skeleton test suite will contain the below constructor,
which declares a new unit test named \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}},
with a single test case consisting of the class \sphinxcode{\sphinxupquote{NewModuleTestCase1}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NewModuleTestSuite}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NewModuleTestSuite}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{  }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{TestSuite}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{new\PYGZhy{}module}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UNIT}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{AddTestCase}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{n}{NewModuleTestCase1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Step 3 \sphinxhyphen{} Declare Source Files}
\label{\detokenize{new-modules:step-3-declare-source-files}}
\sphinxAtStartPar
The public header and source code files for your new module
should be specified in the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file by modifying it with
your text editor.

\sphinxAtStartPar
As an example, after declaring the \sphinxcode{\sphinxupquote{spectrum}} module,
the \sphinxcode{\sphinxupquote{src/spectrum/CMakeLists.txt}} specifies the source code files
with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{source\PYGZus{}files}
\PYG{+w}{  }\PYG{l+s}{helper/adhoc\PYGZhy{}aloha\PYGZhy{}noack\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}helper.cc}
\PYG{+w}{  }\PYG{l+s}{helper/spectrum\PYGZhy{}analyzer\PYGZhy{}helper.cc}
\PYG{+w}{  }\PYG{l+s}{helper/spectrum\PYGZhy{}helper.cc}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{p}{)}

\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}files}
\PYG{+w}{  }\PYG{l+s}{helper/adhoc\PYGZhy{}aloha\PYGZhy{}noack\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}helper.h}
\PYG{+w}{  }\PYG{l+s}{helper/spectrum\PYGZhy{}analyzer\PYGZhy{}helper.h}
\PYG{+w}{  }\PYG{l+s}{helper/spectrum\PYGZhy{}helper.h}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{p}{)}

\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{spectrum}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{source\PYGZus{}files}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}files}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libpropagation}\PYG{o}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libantenna}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}interference\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}value\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}waveform\PYGZhy{}generator\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/three\PYGZhy{}gpp\PYGZhy{}channel\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/tv\PYGZhy{}helper\PYGZhy{}distribution\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/tv\PYGZhy{}spectrum\PYGZhy{}transmitter\PYGZhy{}test.cc}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note: the \sphinxcode{\sphinxupquote{source\_files}} and \sphinxcode{\sphinxupquote{header\_files}} lists are not necessary.
They are used keep the \sphinxcode{\sphinxupquote{build\_lib}} macro readable for modules with many
source files.

\sphinxAtStartPar
The objects resulting from compiling these sources will be assembled
into a link library, which will be linked to any programs relying on this
module.

\sphinxAtStartPar
But how do such programs learn the public API of our new module?  Read on!


\subsection{Step 4 \sphinxhyphen{} Declare Public Header Files}
\label{\detokenize{new-modules:step-4-declare-public-header-files}}
\sphinxAtStartPar
The header files defining the public API of your model and helpers
also should be specified in the \sphinxcode{\sphinxupquote{CMakeLists.txt}} file.

\sphinxAtStartPar
Continuing with the \sphinxcode{\sphinxupquote{spectrum}} model illustration,
the public header files are specified with the following stanza.
(Note that the variable \sphinxcode{\sphinxupquote{header\_files}} tells
\sphinxcode{\sphinxupquote{CMake}} to install this module’s headers with the other \sphinxstyleemphasis{ns\sphinxhyphen{}3} headers):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{header\PYGZus{}files}
\PYG{+w}{    }\PYG{l+s}{helper/adhoc\PYGZhy{}aloha\PYGZhy{}noack\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{helper/spectrum\PYGZhy{}analyzer\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{...}
\PYG{+w}{    }\PYG{l+s}{model/tv\PYGZhy{}spectrum\PYGZhy{}transmitter.h}
\PYG{+w}{    }\PYG{l+s}{model/waveform\PYGZhy{}generator.h}
\PYG{+w}{    }\PYG{l+s}{model/wifi\PYGZhy{}spectrum\PYGZhy{}value\PYGZhy{}helper.h}
\PYG{p}{)}

\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{spectrum}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{header\PYGZus{}files}\PYG{o}{\PYGZcb{}}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the list of headers is short, use the following instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{spectrum}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{+w}{  }\PYG{l+s}{HEADER\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{helper/adhoc\PYGZhy{}aloha\PYGZhy{}noack\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{helper/spectrum\PYGZhy{}analyzer\PYGZhy{}helper.h}
\PYG{+w}{    }\PYG{l+s}{...}
\PYG{+w}{    }\PYG{l+s}{model/tv\PYGZhy{}spectrum\PYGZhy{}transmitter.h}
\PYG{+w}{    }\PYG{l+s}{model/waveform\PYGZhy{}generator.h}
\PYG{+w}{    }\PYG{l+s}{model/wifi\PYGZhy{}spectrum\PYGZhy{}value\PYGZhy{}helper.h}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Headers made public in this way will be accessible to users of your model
with include statements like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}ns3/spectrum\PYGZhy{}model.h\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Headers used strictly internally in your implementation should not
be included here.  They are still accessible to your implementation by
include statements like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}my\PYGZhy{}module\PYGZhy{}implementation.h\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Step 5 \sphinxhyphen{} Declare Tests}
\label{\detokenize{new-modules:step-5-declare-tests}}
\sphinxAtStartPar
If your new module has tests, then they must be specified in your
\sphinxcode{\sphinxupquote{CMakeLists.txt}} file by modifying it with your text editor.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{spectrum}} model tests are specified with the following stanza:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{n+nb}{build\PYGZus{}lib}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{LIBNAME}\PYG{+w}{ }\PYG{l+s}{spectrum}
\PYG{+w}{  }\PYG{l+s}{...}
\PYG{+w}{  }\PYG{l+s}{TEST\PYGZus{}SOURCES}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}interference\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}value\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/spectrum\PYGZhy{}waveform\PYGZhy{}generator\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/three\PYGZhy{}gpp\PYGZhy{}channel\PYGZhy{}test\PYGZhy{}suite.cc}
\PYG{+w}{    }\PYG{l+s}{test/tv\PYGZhy{}helper\PYGZhy{}distribution\PYGZhy{}test.cc}
\PYG{+w}{    }\PYG{l+s}{test/tv\PYGZhy{}spectrum\PYGZhy{}transmitter\PYGZhy{}test.cc}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
See {\hyperref[\detokenize{tests::doc}]{\sphinxcrossref{\DUrole{doc}{Tests}}}} for more information on how to write test cases.


\subsection{Step 6 \sphinxhyphen{} Declare Examples}
\label{\detokenize{new-modules:step-6-declare-examples}}
\sphinxAtStartPar
If your new module has examples, then they must be specified in your
\sphinxcode{\sphinxupquote{examples/CMakeLists.txt}} file.  (The skeleton top\sphinxhyphen{}level \sphinxcode{\sphinxupquote{CMakeLists.txt}} will
recursively include \sphinxcode{\sphinxupquote{examples/CMakeLists.txt}} only if the examples were
enabled at configure time.)

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{spectrum}} model defines it’s first example in
\sphinxcode{\sphinxupquote{src/spectrum/examples/CMakeLists.txt}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib\PYGZus{}example}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy.cc}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libspectrum}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libmobility}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libapplications}\PYG{o}{\PYGZcb{}}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the variable \sphinxcode{\sphinxupquote{libraries\_to\_link}} is the list of modules that
the program being created depends on; again, don’t forget to include
\sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}} in the list.  It’s best practice to list only the direct
module dependencies, and let \sphinxcode{\sphinxupquote{CMake}} deduce the full dependency tree.

\sphinxAtStartPar
Occasionally, for clarity, you may want to split the implementation
for your example among several source files.  In this case, just
include those files as additional explicit sources of the example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{build\PYGZus{}lib\PYGZus{}example}\PYG{p}{(}
\PYG{+w}{  }\PYG{l+s}{NAME}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}module\PYGZhy{}example}
\PYG{+w}{  }\PYG{l+s}{SOURCE\PYGZus{}FILES}\PYG{+w}{ }\PYG{l+s}{new\PYGZhy{}module\PYGZhy{}example.cc}
\PYG{+w}{  }\PYG{l+s}{LIBRARIES\PYGZus{}TO\PYGZus{}LINK}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libspectrum}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libmobility}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libinternet}\PYG{o}{\PYGZcb{}}
\PYG{+w}{    }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{libapplications}\PYG{o}{\PYGZcb{}}
\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Step 7 \sphinxhyphen{} Examples Run as Tests}
\label{\detokenize{new-modules:step-7-examples-run-as-tests}}
\sphinxAtStartPar
In addition to running explicit test code, the test framework
can also be instrumented to run full example programs to
try to catch regressions in the examples.  However, not all examples
are suitable for regression tests.  The file \sphinxcode{\sphinxupquote{test/examples\sphinxhyphen{}to\sphinxhyphen{}run.py}}
controls the invocation of the examples when the test framework runs.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{spectrum}} model examples run by \sphinxcode{\sphinxupquote{test.py}} are specified in
\sphinxcode{\sphinxupquote{src/spectrum/test/examples\sphinxhyphen{}to\sphinxhyphen{}run.py}} using the following
two lists of C++ and Python examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} A list of C++ examples to run in order to ensure that they remain}
\PYG{c+c1}{\PYGZsh{} buildable and runnable over time.  Each tuple in the list contains}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}     (example\PYGZus{}name, do\PYGZus{}run, do\PYGZus{}valgrind\PYGZus{}run).}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} See test.py for more information.}
\PYG{n}{cpp\PYGZus{}examples} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}with\PYGZhy{}microwave\PYGZhy{}oven}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}matrix\PYGZhy{}propagation\PYGZhy{}loss\PYGZhy{}model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} A list of Python examples to run in order to ensure that they remain}
\PYG{c+c1}{\PYGZsh{} runnable over time.  Each tuple in the list contains}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}     (example\PYGZus{}name, do\PYGZus{}run).}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} See test.py for more information.}
\PYG{n}{python\PYGZus{}examples} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sample\PYGZhy{}simulator.py}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
As indicated in the comment, each entry in the C++ list of examples to run
contains the tuple \sphinxcode{\sphinxupquote{(example\_name, do\_run, do\_valgrind\_run)}}, where
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{example\_name}} is the executable to be run,

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{do\_run}} is a condition under which to run the example, and

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{do\_valgrind\_run}} is a condition under which to run the example
under valgrind.  (This is needed because NSC causes illegal instruction
crashes with some tests when they are run under valgrind.)

\end{itemize}

\sphinxAtStartPar
Note that the two conditions are Python statements that
can depend on \sphinxcode{\sphinxupquote{ns3}} configuration variables.  For example, using the
NSC\_ENABLED variable that was defined up until ns\sphinxhyphen{}3.35:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tcp\PYGZhy{}nsc\PYGZhy{}lfn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NSC\PYGZus{}ENABLED == True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NSC\PYGZus{}ENABLED == False}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each entry in the Python list of examples to run contains the tuple
\sphinxcode{\sphinxupquote{(example\_name, do\_run)}}, where, as for the C++ examples,
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{example\_name}} is the Python script to be run, and

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{do\_run}} is a condition under which to run the example.

\end{itemize}

\sphinxAtStartPar
Again, the condition is a Python statement that can
depend on \sphinxcode{\sphinxupquote{ns3}} configuration variables.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{realtime\PYGZhy{}udp\PYGZhy{}echo.py}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ENABLE\PYGZus{}REAL\PYGZus{}TIME == False}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}


\subsection{Step 8 \sphinxhyphen{} Configure and Build}
\label{\detokenize{new-modules:step-8-configure-and-build}}
\sphinxAtStartPar
You can now configure, build and test your module as normal.
You must reconfigure the project as a first step so that \sphinxcode{\sphinxupquote{ns3}}
caches the new information in your \sphinxcode{\sphinxupquote{CMakeLists.txt}} files,
or else your new module will not be included in the build.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\PYGZdl{}\PYG{+w}{ }./test.py
\end{sphinxVerbatim}

\sphinxAtStartPar
Look for your new module’s test suite (and example programs,
if your module has any enabled) in the test output.


\subsection{Step 9 \sphinxhyphen{} Python Bindings}
\label{\detokenize{new-modules:step-9-python-bindings}}
\sphinxAtStartPar
Adding Python bindings to your module is optional.

\sphinxAtStartPar
If you want to include Python bindings (needed only if you want
to write Python ns\sphinxhyphen{}3 programs instead of C++ ns\sphinxhyphen{}3 programs), you
should scan your module to generate new bindings for the Python
API (covered elsewhere in this manual), and they will be used
if NS3\_PYTHON\_BINDINGS is set to ON.

\sphinxstepscope


\section{Creating Documentation}
\label{\detokenize{documentation:creating-documentation}}\label{\detokenize{documentation::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3} supplies two kinds of documentation:  expository “user\sphinxhyphen{}guide”\sphinxhyphen{}style
chapters, and source code API documentation.

\sphinxAtStartPar
The “user\sphinxhyphen{}guide” chapters are written by hand in \sphinxhref{http://sphinx-doc.org/rest.html}{reStructuredText}
format (\sphinxcode{\sphinxupquote{.rst}}), which is processed by the Python documentation
system \sphinxhref{http://sphinx-doc.org/}{Sphinx} to generate web pages and pdf files.
The API documentation is generated from the source code itself,
using \sphinxhref{http://www.doxygen.org/}{Doxygen}, to generate cross\sphinxhyphen{}linked web pages.
Both of these are important:  the Sphinx chapters explain the \sphinxstyleemphasis{why}
and overview of using a model; the API documentation explains the
\sphinxstyleemphasis{how} details.

\sphinxAtStartPar
This chapter gives a quick overview of these
tools, emphasizing preferred usage and customizations for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
To build all the standard documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }docs
\end{sphinxVerbatim}

\sphinxAtStartPar
For more specialized options, read on.


\subsection{Documenting with Sphinx}
\label{\detokenize{documentation:documenting-with-sphinx}}
\sphinxAtStartPar
We use \sphinxhref{http://sphinx-doc.org/}{Sphinx} to generate expository chapters describing
the design and usage of each module.  Right now you are reading the
{\hyperref[\detokenize{documentation::doc}]{\sphinxcrossref{\DUrole{doc}{Documentation}}}} Chapter.
If you are reading the html version, the
\sphinxhref{\_sources/documentation.txt}{Show Source} link in the sidebar
will show you the reStructuredText source for this chapter.


\subsubsection{Adding New Chapters}
\label{\detokenize{documentation:adding-new-chapters}}
\sphinxAtStartPar
Adding a new chapter takes three steps (described in more detail below):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Choose {\hyperref[\detokenize{documentation:where}]{\sphinxcrossref{Where?}}} the documentation file(s) will live.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{documentation:link}]{\sphinxcrossref{Link}}} from an existing page to the new documentation.

\item {} 
\sphinxAtStartPar
Add the new file to the {\hyperref[\detokenize{documentation:makefile}]{\sphinxcrossref{Makefile}}}.

\end{enumerate}


\paragraph{Where?}
\label{\detokenize{documentation:where}}
\sphinxAtStartPar
Documentation for a specific module, \sphinxcode{\sphinxupquote{foo}}, should normally go in
\sphinxcode{\sphinxupquote{src/foo/doc/}}.  For example \sphinxcode{\sphinxupquote{src/foo/doc/foo.rst}} would be the
top\sphinxhyphen{}level document for the module.  The \sphinxcode{\sphinxupquote{utils/create\sphinxhyphen{}module.py}} script
will create this file for you.

\sphinxAtStartPar
Some models require several \sphinxcode{\sphinxupquote{.rst}} files, and figures; these should
all go in the \sphinxcode{\sphinxupquote{src/foo/doc/}} directory.  The docs are actually built
by a Sphinx Makefile.  For especially involved
documentation, it may be helpful to have a local \sphinxcode{\sphinxupquote{Makefile}}
in the \sphinxcode{\sphinxupquote{src/foo/doc/}} directory to
simplify building the documentation for this module
(\sphinxhref{http://www.nsnam.org/docs/models/html/antenna.html}{Antenna} is an example).  Setting this up
is not particularly hard, but is beyond the scope of this chapter.

\sphinxAtStartPar
In some cases, documentation spans multiple models; the
\sphinxhref{http://www.nsnam.org/docs/models/html/network.html}{Network} chapter is an example.  In these cases
adding the \sphinxcode{\sphinxupquote{.rst}} files directly to \sphinxcode{\sphinxupquote{doc/models/source/}} might
be appropriate.


\paragraph{Link}
\label{\detokenize{documentation:link}}
\sphinxAtStartPar
Sphinx has to know \sphinxstyleemphasis{where} your new chapter should appear.  In most
cases, a new model chapter should appear the in \sphinxtitleref{Models} book.
To add your chapter there, edit \sphinxcode{\sphinxupquote{doc/models/source/index.rst}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{toctree}\PYG{p}{::}
   \PYG{n+nc}{:maxdepth:} 1

  organization
  animation
  antenna
  aodv
  applications
\PYG{c+cp}{  ...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Add the name of your document (without the \sphinxcode{\sphinxupquote{.rst}} extension) to
this list.  Please keep the Model chapters in alphabetical order,
to ease visual scanning for specific chapters.


\paragraph{Makefile}
\label{\detokenize{documentation:makefile}}
\sphinxAtStartPar
You also have to add your document to the appropriate \sphinxcode{\sphinxupquote{Makefile}},
so \sphinxcode{\sphinxupquote{make}} knows to check it for updates.  The Models book Makefile
is \sphinxcode{\sphinxupquote{doc/models/Makefile}}, the Manual book Makefile is
\sphinxcode{\sphinxupquote{doc/manual/Makefile}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} list all model library .rst files that need to be copied to \PYGZdl{}SOURCETEMP}
\PYG{n+nv}{SOURCES}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }source/conf.py\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }source/\PYGZus{}static\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }source/index.rst\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }source/replace.txt\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }source/organization.rst\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }...
\PYG{+w}{        }\PYG{k}{\PYGZdl{}(}SRC\PYG{k}{)}/antenna/doc/source/antenna.rst\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{        }...
\end{sphinxVerbatim}

\sphinxAtStartPar
You add your \sphinxcode{\sphinxupquote{.rst}} files to the \sphinxcode{\sphinxupquote{SOURCES}} variable.  To add figures,
read the comments in the \sphinxcode{\sphinxupquote{Makefile}} to see which variable should contain
your image files.  Again, please keep these in alphabetical order.


\subsubsection{Building Sphinx Docs}
\label{\detokenize{documentation:building-sphinx-docs}}
\sphinxAtStartPar
Building the Sphinx documentation is pretty simple.
To build all the Sphinx documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }sphinx
\end{sphinxVerbatim}

\sphinxAtStartPar
To build just the Models documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }make\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }doc/models\PYG{+w}{ }html
\end{sphinxVerbatim}

\sphinxAtStartPar
To see the generated documentation point your browser at
\sphinxcode{\sphinxupquote{doc/models/build/html}}.

\sphinxAtStartPar
As you can see, Sphinx uses Make to guide the process.
The default target builds all enabled output forms, which in
\sphinxstyleemphasis{ns\sphinxhyphen{}3} are the multi\sphinxhyphen{}page \sphinxcode{\sphinxupquote{html}}, single\sphinxhyphen{}page \sphinxcode{\sphinxupquote{singlehtml}}, and pdf
(\sphinxcode{\sphinxupquote{latex}}).  To build just the multi\sphinxhyphen{}page html, you add the \sphinxcode{\sphinxupquote{html}} target:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }make\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }doc/models\PYG{+w}{ }html
\end{sphinxVerbatim}

\sphinxAtStartPar
This can be helpful to reduce the build time (and the size of the
build chatter) as you are writing your chapter.

\sphinxAtStartPar
Before committing your documentation to the repo, please check
that it builds without errors or warnings.  The build process
generates lots of output (mostly normal chatter from LaTeX),
which can make it difficult to see if there are any Sphinx
warnings or errors.  To find important warnings and errors
build just the \sphinxcode{\sphinxupquote{html}} version, then search the build log
for \sphinxcode{\sphinxupquote{warning}} or \sphinxcode{\sphinxupquote{error}}.


\subsubsection{\sphinxstyleemphasis{ns\sphinxhyphen{}3} Specifics}
\label{\detokenize{documentation:ns3-specifics}}
\sphinxAtStartPar
The Sphinx \sphinxhref{http://sphinx-doc.org/contents.html}{documentation} and \sphinxhref{http://sphinx-doc.org/tutorial.html}{tutorial} are pretty good.  We won’t duplicate
the basics here, instead focusing on preferred usage for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Start documents with these two lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{include}\PYG{p}{::} replace.txt
\PYG{p}{..} \PYG{o+ow}{highlight}\PYG{p}{::} cpp
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line enables some simple replacements.  For example,
typing \sphinxcode{\sphinxupquote{|ns3|}} renders as \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
The second sets the default source code highlighting language explicitly
for the file, since the parser guess isn’t always accurate.
(It’s also possible to set the language explicitly for a single code block,
see below.)

\item {} 
\sphinxAtStartPar
Sections:

\sphinxAtStartPar
Sphinx is pretty liberal about marking section headings.  By convention,
we prefer this hierarchy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{.. heading hierarchy:}
\PYG{c+cp}{   \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Chapter}
\PYG{c+cp}{   ************* Section (\PYGZsh{}.\PYGZsh{})}
\PYG{c+cp}{   ============= Subsection (\PYGZsh{}.\PYGZsh{}.\PYGZsh{})}
\PYG{c+cp}{   \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Sub\PYGZhy{}subsection}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Syntax Highlighting:

\sphinxAtStartPar
To use the default syntax highlighter, simply start a sourcecode block:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{*{2}{\X{1}{2}}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Sphinx Source
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Rendered Output
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
The \PYG{l+s}{``}\PYG{l+s}{Frobnitz}\PYG{l+s}{``} is accessed by\PYG{l+s+se}{::}

\PYG{l+s}{  }\PYG{l+s}{Foo::Frobnitz frob;}
\PYG{l+s}{  frob.Set(...);}
\end{sphinxVerbatimintable}
&
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Frobnitz}} is accessed by:

\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYG{n}{Foo}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Frobnitz}\PYG{+w}{ }\PYG{n}{frob}\PYG{p}{;}
\PYG{n}{frob}\PYG{p}{.}\PYG{n}{Set}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatimintable}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
To use a specific syntax highlighter, for example, \sphinxcode{\sphinxupquote{bash}} shell commands:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{*{2}{\X{1}{2}}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Sphinx Source
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Rendered Output
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{sourcecode}\PYG{p}{::} bash

   \PYGZdl{} ls
\end{sphinxVerbatimintable}
&
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }ls
\end{sphinxVerbatimintable}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\item {} 
\sphinxAtStartPar
Shorthand Notations:

\sphinxAtStartPar
These shorthands are defined:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{*{2}{\X{1}{2}}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Sphinx Source
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Rendered Output
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
|ns3|
\end{sphinxVerbatimintable}
&
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}3}
\\
\sphinxhline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
|ns2|
\end{sphinxVerbatimintable}
&
\sphinxAtStartPar
\sphinxstyleemphasis{ns\sphinxhyphen{}2}
\\
\sphinxhline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
|check|
\end{sphinxVerbatimintable}
&
\sphinxAtStartPar
\(\checkmark\)
\\
\sphinxhline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYG{n+na}{:rfc:}\PYG{n+nv}{`6282`}
\end{sphinxVerbatimintable}
&
\sphinxAtStartPar
\index{RFC@\spxentry{RFC}!RFC 6282@\spxentry{RFC 6282}}\sphinxhref{https://datatracker.ietf.org/doc/html/rfc6282.html}{\sphinxstylestrong{RFC 6282}}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\end{itemize}


\subsection{Documenting with Doxygen}
\label{\detokenize{documentation:documenting-with-doxygen}}
\sphinxAtStartPar
We use \sphinxhref{http://www.doxygen.org/}{Doxygen} to generate \sphinxhref{https://www.nsnam.org/docs/doxygen}{browsable} API documentation.  Doxygen
provides a number of useful features:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Summary table of all class members.

\item {} 
\sphinxAtStartPar
Graphs of inheritance and collaboration for all classes.

\item {} 
\sphinxAtStartPar
Links to the source code implementing each function.

\item {} 
\sphinxAtStartPar
Links to every place a member is used.

\item {} 
\sphinxAtStartPar
Links to every object used in implementing a function.

\item {} 
\sphinxAtStartPar
Grouping of related classes, such as all the classes related to
a specific protocol.

\end{itemize}

\sphinxAtStartPar
In addition, we use the \sphinxcode{\sphinxupquote{TypeId}} system to add to the documentation
for every class
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Config}} paths by which such objects can be reached.

\item {} 
\sphinxAtStartPar
Documentation for any \sphinxcode{\sphinxupquote{Attributes}}, including \sphinxcode{\sphinxupquote{Attributes}}
defined in parent classes.

\item {} 
\sphinxAtStartPar
Documentation for any \sphinxcode{\sphinxupquote{Trace}} sources defined by the class.

\item {} 
\sphinxAtStartPar
The memory footprint for each class.

\end{itemize}

\sphinxAtStartPar
Doxygen operates by scanning the source code, looking for
specially marked comments.  It also creates a cross reference,
indicating \sphinxstyleemphasis{where} each file, class, method, and variable is used.


\subsubsection{Preferred Style}
\label{\detokenize{documentation:preferred-style}}
\sphinxAtStartPar
The preferred style for Doxygen comments is the JavaDoc style:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  Brief description of this class or method.}
\PYG{c+cm}{ *  Adjacent lines become a single paragraph.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  Longer description, with lots of details.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  Blank lines separate paragraphs.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  Explain what the class or method does, using what algorithm.}
\PYG{c+cm}{ *  Explain the units of arguments and return values.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  \PYGZbs{}note Note any limitations or gotchas.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  (For functions with arguments or return valued:)}
\PYG{c+cm}{ *  \PYGZbs{}param [in] foo Brief noun phrase describing this argument. Note}
\PYG{c+cm}{ *                  that we indicate if the argument is input,}
\PYG{c+cm}{ *                  output, or both.}
\PYG{c+cm}{ *  \PYGZbs{}param [in,out] bar Note Sentence case, and terminating period.}
\PYG{c+cm}{ *  \PYGZbs{}param [in] baz Indicate boolean values with \PYGZbs{}c true or \PYGZbs{}c false.}
\PYG{c+cm}{ *  \PYGZbs{}return Brief noun phrase describing the value.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  \PYGZbs{}internal}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  You can also discuss internal implementation details.}
\PYG{c+cm}{ *  Understanding this material shouldn\PYGZsq{}t be necessary to using}
\PYG{c+cm}{ *  the class or method.}
\PYG{c+cm}{ */}
\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{ExampleFunction}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{foo}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{bar}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{baz}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this style the Doxygen comment block begins with two \textasciigrave{}*’ characters:
\sphinxcode{\sphinxupquote{/**}}, and precedes the item being documented.

\sphinxAtStartPar
For items needing only a brief description, either of these short forms
is appropriate:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Destructor implementation. */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DoDispose}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m\PYGZus{}count}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//!\PYGZlt{} Count of ...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the special form of the end of line comment, \sphinxcode{\sphinxupquote{//!\textless{}}}, indicating
that it refers to the \sphinxstyleemphasis{preceding} item.

\sphinxAtStartPar
Some items to note:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use sentence case, including the initial capital.

\item {} 
\sphinxAtStartPar
Use punctuation, especially \textasciigrave{}.’s at the end of sentences or phrases.

\item {} \begin{description}
\sphinxlineitem{The \sphinxcode{\sphinxupquote{\textbackslash{}brief}} tag is not needed; the first sentence will be}
\sphinxAtStartPar
used as the brief description.

\end{description}

\end{itemize}

\sphinxAtStartPar
Every class, method, typedef, member variable, function argument
and return value should be documented in all source code files
which form the formal API and implementation for \sphinxstyleemphasis{ns\sphinxhyphen{}3}, such as
\sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/model/*}}, \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/helper/*}} and
\sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/utils/*}}.  Documentation for items in \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/test/*}}
and \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/examples/*}} is preferred, but not required.


\subsubsection{Useful Features}
\label{\detokenize{documentation:useful-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Inherited members will automatically inherit docs from the parent,
(but can be replaced by local documentation).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Document the base class.

\item {} 
\sphinxAtStartPar
In the sub class mark inherited functions with an ordinary comment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Inherited methods}
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{FooBar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{BarFoo}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{baz}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This doesn’t work for static functions; see \sphinxcode{\sphinxupquote{GetTypeId}}, below, for an
example.

\end{enumerate}

\end{itemize}


\subsubsection{Building Doxygen Docs}
\label{\detokenize{documentation:building-doxygen-docs}}
\sphinxAtStartPar
Building the Doxygen documentation is pretty simple:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }doxygen
\end{sphinxVerbatim}

\sphinxAtStartPar
This builds using the default configuration, which generates
documentation sections for \sphinxstyleemphasis{all} items, even if they do not have
explicit comment documentation blocks.  This has the effect of
suppressing warnings for undocumented items, but makes sure everything
appears in the generated output, which is usually what you want for
general use.  Note that we generate documentation even for modules
which are disabled, to make it easier to see all the features
available in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
When writing documentation, it’s often more useful to see which items
are generating warnings, typically about missing documentation.  To
see the full warnings list, use the \sphinxcode{\sphinxupquote{doc/doxygen.warnings.report.sh}}
script:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }doc/doxygen.warnings.report.sh

doxygen.warnings.report.sh:
Building\PYG{+w}{ }and\PYG{+w}{ }running\PYG{+w}{ }print\PYGZhy{}introspected\PYGZhy{}doxygen...done.
Rebuilding\PYG{+w}{ }doxygen\PYG{+w}{ }\PYG{o}{(}v1.8.10\PYG{o}{)}\PYG{+w}{ }docs\PYG{+w}{ }with\PYG{+w}{ }full\PYG{+w}{ }errors...done.


Report\PYG{+w}{ }of\PYG{+w}{ }Doxygen\PYG{+w}{ }warnings
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

\PYG{o}{(}All\PYG{+w}{ }counts\PYG{+w}{ }are\PYG{+w}{ }lower\PYG{+w}{ }bounds.\PYG{o}{)}

Warnings\PYG{+w}{ }by\PYG{+w}{ }module/directory:

Count\PYG{+w}{ }Directory
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{l+m}{3414}\PYG{+w}{ }src/lte/model
\PYG{l+m}{1532}\PYG{+w}{ }src/wimax/model
\PYG{+w}{ }\PYG{l+m}{825}\PYG{+w}{ }src/lte/test
....
\PYG{+w}{   }\PYG{l+m}{1}\PYG{+w}{ }src/applications/test
\PYG{+w}{ }\PYG{l+m}{97}\PYG{+w}{ }additional\PYG{+w}{ }undocumented\PYG{+w}{ }parameters.
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{ }\PYG{l+m}{12460}\PYG{+w}{ }total\PYG{+w}{ }warnings
\PYG{+w}{   }\PYG{l+m}{100}\PYG{+w}{ }directories\PYG{+w}{ }with\PYG{+w}{ }warnings


Warnings\PYG{+w}{ }by\PYG{+w}{ }file\PYG{+w}{ }\PYG{o}{(}alphabetical\PYG{o}{)}

Count\PYG{+w}{ }File
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{  }\PYG{l+m}{15}\PYG{+w}{ }examples/routing/manet\PYGZhy{}routing\PYGZhy{}compare.cc
\PYG{+w}{  }\PYG{l+m}{26}\PYG{+w}{ }examples/stats/wifi\PYGZhy{}example\PYGZhy{}apps.h
\PYG{+w}{  }\PYG{l+m}{12}\PYG{+w}{ }examples/tutorial/fifth.cc
....
\PYG{+w}{  }\PYG{l+m}{17}\PYG{+w}{ }utils/python\PYGZhy{}unit\PYGZhy{}tests.py
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{   }\PYG{l+m}{771}\PYG{+w}{ }files\PYG{+w}{ }with\PYG{+w}{ }warnings


Warnings\PYG{+w}{ }by\PYG{+w}{ }file\PYG{+w}{ }\PYG{o}{(}numerical\PYG{o}{)}

Count\PYG{+w}{ }File
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{ }\PYG{l+m}{273}\PYG{+w}{ }src/lte/model/lte\PYGZhy{}rrc\PYGZhy{}sap.h
\PYG{+w}{ }\PYG{l+m}{272}\PYG{+w}{ }src/core/model/simulator.h
\PYG{+w}{ }\PYG{l+m}{221}\PYG{+w}{ }src/netanim/model/animation\PYGZhy{}interface.h
....
\PYG{+w}{   }\PYG{l+m}{1}\PYG{+w}{ }src/wimax/model/ul\PYGZhy{}job.cc
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{   }\PYG{l+m}{771}\PYG{+w}{ }files\PYG{+w}{ }with\PYG{+w}{ }warnings


Doxygen\PYG{+w}{ }Warnings\PYG{+w}{ }Summary
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{   }\PYG{l+m}{100}\PYG{+w}{ }directories
\PYG{+w}{   }\PYG{l+m}{771}\PYG{+w}{ }files
\PYG{+w}{ }\PYG{l+m}{12460}\PYG{+w}{ }warnings
\end{sphinxVerbatim}

\sphinxAtStartPar
(This snippet has \sphinxstyleemphasis{a lot} of lines suppressed!)

\sphinxAtStartPar
The script modifies the configuration to show all warnings, and to
shorten the run time.  (It shortens the run time primarily by
disabling creation of diagrams, such as call trees, and doesn’t
generate documentation for undocumented items, in order to trigger the
warnings.)  As you can see, at this writing we have \sphinxstyleemphasis{a lot} of
undocumented items.  The report summarizes warnings by module
\sphinxcode{\sphinxupquote{src/*/*}}, and by file, in alphabetically and numerical order.

\sphinxAtStartPar
The script has a few options to pare things down and make the output more
manageable.  For help, use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}h}} option.  Having run it once
to do the Doxygen build and generate the full warnings log,
you can reprocess the log file with various “filters,”
without having to do the full Doxygen build again by
using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}s}} option.  You can exclude warnings
from \sphinxcode{\sphinxupquote{*/examples/*}} files (\sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} option), and/or \sphinxcode{\sphinxupquote{*/test/*}} files
(\sphinxcode{\sphinxupquote{\sphinxhyphen{}t}}).  Just to be clear, all of the filter options do the complete
fast doxygen build; they just filter doxygen log and warnings output.

\sphinxAtStartPar
Perhaps the most useful option when writing documentation comments
is \sphinxcode{\sphinxupquote{\sphinxhyphen{}m \textless{}module\textgreater{}}}, which will limit the report to just files matching
\sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/*}}, and follow the report with the actual warning lines.
Combine with \sphinxcode{\sphinxupquote{\sphinxhyphen{}et}} and you can focus on the warnings that are most
urgent in a single module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }doc/doxygen.warnings.report.sh\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }mesh/helper
...
Doxygen\PYG{+w}{ }Warnings\PYG{+w}{ }Summary
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{+w}{  }\PYG{l+m}{1}\PYG{+w}{ }directories
\PYG{+w}{  }\PYG{l+m}{3}\PYG{+w}{ }files
\PYG{l+m}{149}\PYG{+w}{ }warnings


Filtered\PYG{+w}{ }\PYG{n+nv}{Warnings}
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
src/mesh/helper/dot11s/dot11s\PYGZhy{}installer.h:72:\PYG{+w}{ }warning:\PYG{+w}{ }Member\PYG{+w}{ }m\PYGZus{}root\PYG{+w}{ }\PYG{o}{(}variable\PYG{o}{)}\PYG{+w}{ }of\PYG{+w}{ }class\PYG{+w}{ }ns3::Dot11sStack\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented.
src/mesh/helper/dot11s/dot11s\PYGZhy{}installer.h:35:\PYG{+w}{ }warning:\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{type}\PYG{+w}{ }of\PYG{+w}{ }member\PYG{+w}{ }ns3::Dot11sStack::GetTypeId\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented
src/mesh/helper/dot11s/dot11s\PYGZhy{}installer.h:56:\PYG{+w}{ }warning:\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{type}\PYG{+w}{ }of\PYG{+w}{ }member\PYG{+w}{ }ns3::Dot11sStack::InstallStack\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented
src/mesh/helper/flame/lfame\PYGZhy{}installer.h:40:\PYG{+w}{ }warning:\PYG{+w}{ }Member\PYG{+w}{ }GetTypeId\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{(}\PYG{k}{function}\PYG{o}{)}\PYG{+w}{ }of\PYG{+w}{ }class\PYG{+w}{ }ns3::FlameStack\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented.
src/mesh/helper/flame/flame\PYGZhy{}installer.h:60:\PYG{+w}{ }warning:\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{type}\PYG{+w}{ }of\PYG{+w}{ }member\PYG{+w}{ }ns3::FlameStack::InstallStack\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented
src/mesh/helper/mesh\PYGZhy{}helper.h:213:\PYG{+w}{ }warning:\PYG{+w}{ }Member\PYG{+w}{ }m\PYGZus{}nInterfaces\PYG{+w}{ }\PYG{o}{(}variable\PYG{o}{)}\PYG{+w}{ }of\PYG{+w}{ }class\PYG{+w}{ }ns3::MeshHelper\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:214:\PYG{+w}{ }warning:\PYG{+w}{ }Member\PYG{+w}{ }m\PYGZus{}spreadChannelPolicy\PYG{+w}{ }\PYG{o}{(}variable\PYG{o}{)}\PYG{+w}{ }of\PYG{+w}{ }class\PYG{+w}{ }ns3::MeshHelper\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:215:\PYG{+w}{ }warning:\PYG{+w}{ }Member\PYG{+w}{ }m\PYGZus{}stack\PYG{+w}{ }\PYG{o}{(}variable\PYG{o}{)}\PYG{+w}{ }of\PYG{+w}{ }class\PYG{+w}{ }ns3::MeshHelper\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:216:\PYG{+w}{ }warning:\PYG{+w}{ }Member\PYG{+w}{ }m\PYGZus{}stackFactory\PYG{+w}{ }\PYG{o}{(}variable\PYG{o}{)}\PYG{+w}{ }of\PYG{+w}{ }class\PYG{+w}{ }ns3::MeshHelper\PYG{+w}{ }is\PYG{+w}{ }not\PYG{+w}{ }documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:209:\PYG{+w}{ }warning:\PYG{+w}{ }parameters\PYG{+w}{ }of\PYG{+w}{ }member\PYG{+w}{ }ns3::MeshHelper::CreateInterface\PYG{+w}{ }are\PYG{+w}{ }not\PYG{+w}{ }\PYG{o}{(}all\PYG{o}{)}\PYG{+w}{ }documented
src/mesh/helper/mesh\PYGZhy{}helper.h:119:\PYG{+w}{ }warning:\PYG{+w}{ }parameters\PYG{+w}{ }of\PYG{+w}{ }member\PYG{+w}{ }ns3::MeshHelper::SetStandard\PYG{+w}{ }are\PYG{+w}{ }not\PYG{+w}{ }\PYG{o}{(}all\PYG{o}{)}\PYG{+w}{ }documented
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, note that undocumented items (classes, methods, functions,
typedefs, \sphinxstyleemphasis{etc.} won’t produce documentation when you build with
\sphinxcode{\sphinxupquote{doxygen.warnings.report.sh}}, and only the outermost item
will produce a warning.  As a result, if you don’t see documentation
for a class method in the generated documentation, the class itself
probably needs documentation.

\sphinxAtStartPar
Now it’s just a matter of understanding the code, and writing some
docs!


\subsubsection{\sphinxstyleemphasis{ns\sphinxhyphen{}3} Specifics}
\label{\detokenize{documentation:id1}}
\sphinxAtStartPar
As for Sphinx, the Doxygen \sphinxhref{https://www.doxygen.nl/index.html}{docs} and \sphinxhref{https://www.doxygen.nl/manual/commands.html}{reference} are pretty good.
We won’t duplicate the basics here, instead focusing on preferred
usage for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use Doxygen \sphinxcode{\sphinxupquote{Modules}} to group related items.

\sphinxAtStartPar
In the main header for a module, create a Doxgyen group:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}defgroup foo Foo protocol.}
\PYG{c+cm}{ *  Implementation of the Foo protocol.}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}

\sphinxAtStartPar
The symbol \sphinxcode{\sphinxupquote{foo}} is how other items can add themselves to this group.
The string following that will be the title for the group.  Any further
text will be the detailed description for the group page.

\item {} 
\sphinxAtStartPar
Document each file, assigning it to the relevant group.  In a header file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}file}
\PYG{c+cm}{ *  \PYGZbs{}ingroup foo}
\PYG{c+cm}{ *  Class Foo declaration.}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}

\sphinxAtStartPar
or in the corresponding \sphinxcode{\sphinxupquote{.cc}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}file}
\PYG{c+cm}{ *  \PYGZbs{}ingroup foo}
\PYG{c+cm}{ *  Class FooBar implementation.}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Mark each associated class as belonging to the group:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}ingroup foo}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  FooBar packet type.}
\PYG{c+cm}{*/}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{FooBar}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Did you know \sphinxcode{\sphinxupquote{typedefs}} can have formal arguments?  This enables
documentation of function pointer signatures:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  Bar callback function signature.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  \PYGZbs{}param ale The size of a pint of ale, in Imperial ounces.}
\PYG{c+cm}{ */}
\PYG{k}{typedef}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{BarCallback}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{ale}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Copy the \sphinxcode{\sphinxupquote{Attribute}} help strings from the \sphinxcode{\sphinxupquote{GetTypeId}} method to use
as the brief descriptions of associated members.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}bugid\{298\}}} will create a link to bug 298 in our Bugzilla.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}p foo}} in a description will format \sphinxcode{\sphinxupquote{foo}}
the same as the \sphinxcode{\sphinxupquote{\textbackslash{}param foo}} parameter, making it clear that you
are referring to an actual argument.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}RFC\{301\}}} will create a link to RFC 301.

\item {} 
\sphinxAtStartPar
Document the direction of function arguments with \sphinxcode{\sphinxupquote{\textbackslash{}param {[}in{]}}}, \sphinxstyleemphasis{etc}.
The allowed values of the direction token are \sphinxcode{\sphinxupquote{{[}in{]}}}, \sphinxcode{\sphinxupquote{{[}out{]}}}, and
\sphinxcode{\sphinxupquote{{[}in,out{]}}} (note the explicit square brackets), as discussed in the
Doxygen docs for \sphinxcode{\sphinxupquote{\textbackslash{}param}}.

\item {} 
\sphinxAtStartPar
Document template arguments with \sphinxcode{\sphinxupquote{\textbackslash{}tparam}}, just as you use \sphinxcode{\sphinxupquote{\textbackslash{}param}}
for function arguments.

\item {} 
\sphinxAtStartPar
For template arguments, indicate if they will be deduced or must be given
explicitly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * A templated function.}
\PYG{c+cm}{ * \PYGZbs{}tparam T \PYGZbs{}explicit The return type.}
\PYG{c+cm}{ * \PYGZbs{}tparam U \PYGZbs{}deduced The argument type.}
\PYG{c+cm}{ * \PYGZbs{}param [in] a The argument.}
\PYG{c+cm}{ */}
\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{U}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{T}\PYG{+w}{ }\PYG{n}{Function}\PYG{p}{(}\PYG{n}{U}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{\textbackslash{}tparam U \textbackslash{}deduced}} because the type \sphinxcode{\sphinxupquote{U}} can be deduced at
the site where the template is invoked.  Basically deduction can only
be done for function arguments.

\item {} 
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{\textbackslash{}tparam T \textbackslash{}explicit}} because the type \sphinxcode{\sphinxupquote{T}} can’t be deduced;
it must be given explicitly at the invocation site, as in
\sphinxcode{\sphinxupquote{Create\textless{}MyObject\textgreater{}(...)}}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}internal}} should be used only to set off a discussion of implementation
details, not to mark \sphinxcode{\sphinxupquote{private}} functions (they are already marked,
as \sphinxcode{\sphinxupquote{private}}!)

\item {} 
\sphinxAtStartPar
Don’t create classes with trivial names, such as \sphinxcode{\sphinxupquote{class A}},
even in test suites.  These cause all instances of the class name
literal \textasciigrave{}A’ to be rendered as links.

\end{itemize}

\sphinxAtStartPar
As noted above, static functions don’t inherit the documentation
of the same functions in the parent class.  \sphinxstyleemphasis{ns\sphinxhyphen{}3} uses a few static
functions ubiquitously; the suggested documentation block for these
cases is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Default constructor/destructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//!\PYGZlt{} Default constructor}
\PYG{o}{\PYGZti{}}\PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//!\PYGZlt{} Destructor}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Dummy destructor and DoDispose:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Dummy destructor, see DoDispose. */}
\PYG{o}{\PYGZti{}}\PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/** Destructor implementation */}
\PYG{k}{virtual}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{DoDispose}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
GetTypeId:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  Register this type.}
\PYG{c+cm}{ *  \PYGZbs{}return The object TypeId.}
\PYG{c+cm}{ */}
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{TypeId}\PYG{+w}{ }\PYG{n+nf}{GetTypeId}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}

\sphinxstepscope


\section{Profiling}
\label{\detokenize{profiling:profiling}}\label{\detokenize{profiling::doc}}
\sphinxAtStartPar
Memory profiling is essential to identify issues that
may cause memory corruption, which may lead to all sorts of
side\sphinxhyphen{}effects, such as crashing after many hours of simulation and
producing wrong results that invalidate the entire simulation.

\sphinxAtStartPar
It also can help tracking sources of excessive memory allocations,
the size of these allocations and memory usage during simulation.
These can affect simulation performance, or limit the complexity
and the number of concurrent simulations.

\sphinxAtStartPar
Performance profiling on the other hand is essential for
high\sphinxhyphen{}performance applications, as it allows for the identification
of bottlenecks and their mitigation.

\sphinxAtStartPar
Another type of profiling is related to system calls. They
can be used to debug issues and identify hotspots that
may cause performance issues in specific conditions. Excessive
calls results in more context switches, which interrupt the
simulations, ultimately slowing them down.

\sphinxAtStartPar
Other than profiling the simulations, which can highlight bottlenecks
in the simulator, we can also profile the compilation process.
This allows us to identify and fix bottlenecks, which speed up
build times.


\subsection{Memory Profilers}
\label{\detokenize{profiling:memory-profilers}}
\sphinxAtStartPar
Memory profilers are tools that help identifying memory related
issues.

\sphinxAtStartPar
There are two well known tools for finding bugs such as uninitialized memory usage,
out\sphinxhyphen{}of\sphinxhyphen{}bound accesses, dereferencing null pointers and other memory\sphinxhyphen{}related bugs:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://valgrind.org/}{Valgrind}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Pros: very rich tooling, no need to recompile programs to profile the program.

\item {} 
\sphinxAtStartPar
Cons: very slow and limited to Linux and MacOS.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/google/sanitizers/wiki}{Sanitizers}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Pros: sanitizers are distributed along with compilers, such as GCC, Clang and MSVC.
They are widely available, cross platform and faster than Valgrind.

\item {} 
\sphinxAtStartPar
Cons: false positives, high memory usage, memory sanitizer is incompatible
with other sanitizers (e.g. address sanitizer), requiring two instrumented
compilations and two test runs. The memory sanitizer requires Clang.

\end{itemize}

\end{itemize}

\sphinxAtStartPar
There are also tools to count memory allocations, track memory usage and memory leaks,
such as: \sphinxhref{https://apps.kde.org/heaptrack/}{Heaptrack}, \sphinxhref{https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingLeaks.html}{MacOS’s leaks}, \sphinxhref{https://github.com/koute/bytehound}{Bytehound} and \sphinxhref{https://github.com/gperftools/gperftools}{gperftools}.

\sphinxAtStartPar
An overview on how to use \sphinxhref{https://valgrind.org/}{Valgrind}, \sphinxhref{https://github.com/google/sanitizers/wiki}{Sanitizers} and
\sphinxhref{https://apps.kde.org/heaptrack/}{Heaptrack} is provided in the following sections.


\subsubsection{Valgrind}
\label{\detokenize{profiling:id1}}
\sphinxAtStartPar
\sphinxhref{https://valgrind.org/}{Valgrind} is suite of profiling tools, being the main tool called Memcheck.
To check for memory errors including leaks, one can call valgrind directly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{valgrind \PYGZhy{}\PYGZhy{}leak\PYGZhy{}check=yes ./relative/path/to/program argument1 argument2}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or can use the \sphinxcode{\sphinxupquote{ns3}} script:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{./ns3 run \PYGZdq{}program argument1 argument2\PYGZdq{} \PYGZhy{}\PYGZhy{}valgrind}
\end{sphinxVerbatim}

\sphinxAtStartPar
Additional Valgrind options are listed on its \sphinxhref{https://valgrind.org/docs/manual/mc-manual.html}{manual}.


\subsubsection{Sanitizers}
\label{\detokenize{profiling:id2}}
\sphinxAtStartPar
\sphinxhref{https://github.com/google/sanitizers/wiki}{Sanitizers} are a suite of libraries made by Google and part of the LLVM project,
used to profile programs at runtime and find issues related to undefined behavior,
memory corruption (out\sphinxhyphen{}of\sphinxhyphen{}bound access, uninitialized memory use), leaks, race
conditions and others.

\sphinxAtStartPar
Sanitizers are shipped with most modern compilers and can be used by instructing the
compiler to link the required libraries and instrument the code.

\sphinxAtStartPar
To build ns\sphinxhyphen{}3 with sanitizers, enable the \sphinxcode{\sphinxupquote{NS3\_SANITIZE}} option. This can be done
directly via CMake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZus{}cache/\PYGZdl{} cmake \PYGZhy{}DNS3\PYGZus{}SANITIZE=ON ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or via the \sphinxcode{\sphinxupquote{ns3}} wrapper:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}sanitizers}
\end{sphinxVerbatim}

\sphinxAtStartPar
The memory sanitizer can be enabled with \sphinxcode{\sphinxupquote{NS3\_SANITIZE\_MEMORY}}, but it is not
compatible with \sphinxcode{\sphinxupquote{NS3\_SANITIZE}} and only works with the Clang compiler.

\sphinxAtStartPar
Sanitizers were used to find issues in multiple occasions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A global buffer overflow in the LTE module
\begin{itemize}
\item {} 
\sphinxAtStartPar
When the wrong index (\sphinxhyphen{}1) was used to access a \sphinxcode{\sphinxupquote{int {[}{]}{[}{]}}} variable, a different variable that is stored closely in memory was accessed.

\item {} 
\sphinxAtStartPar
In the best case scenario, this results in reading an incorrect value that causes the program to fail

\item {} 
\sphinxAtStartPar
In the worst case scenario, this value is overwritten corrupting the program memory

\item {} 
\sphinxAtStartPar
The likely scenario: wrong value is read and the program continued running, potentially producing incorrect results

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}amc.cc:303:43: runtime error: index \PYGZhy{}1 out of bounds for type \PYGZsq{}int [110][27]\PYGZsq{}}
\PYG{g+go}{=================================================================}
\PYG{g+go}{==51636==ERROR: AddressSanitizer: global\PYGZhy{}buffer\PYGZhy{}overflow on address 0x7fe78cc2dbbc at pc 0x7fe78ba65e65 bp 0x7ffde70b25c0 sp 0x7ffde70b25b0}
\PYG{g+go}{READ of size 4 at 0x7fe78cc2dbbc thread T0}
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{0}\PYG{+w}{ }0x7fe78ba65e64\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::LteAmc::GetDlTbSizeFromMcs\PYG{o}{(}int,\PYG{+w}{ }int\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}amc.cc:303
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{1}\PYG{+w}{ }0x7fe78c538aba\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::TdTbfqFfMacScheduler::DoSchedDlTriggerReq\PYG{o}{(}ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters\PYG{+w}{ }const\PYG{p}{\PYGZam{}}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/tdtbfq\PYGZhy{}ff\PYGZhy{}mac\PYGZhy{}scheduler.cc:1160
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{2}\PYG{+w}{ }0x7fe78c564736\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::MemberSchedSapProvider\PYGZlt{}ns3::TdTbfqFfMacScheduler\PYGZgt{}::SchedDlTriggerReq\PYG{o}{(}ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters\PYG{+w}{ }const\PYG{p}{\PYGZam{}}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/ff\PYGZhy{}mac\PYGZhy{}sched\PYGZhy{}sap.h:409
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{3}\PYG{+w}{ }0x7fe78c215596\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::LteEnbMac::DoSubframeIndication\PYG{o}{(}unsigned\PYG{+w}{ }int,\PYG{+w}{ }unsigned\PYG{+w}{ }int\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}enb\PYGZhy{}mac.cc:588
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{4}\PYG{+w}{ }0x7fe78c20921d\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::EnbMacMemberLteEnbPhySapUser::SubframeIndication\PYG{o}{(}unsigned\PYG{+w}{ }int,\PYG{+w}{ }unsigned\PYG{+w}{ }int\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}enb\PYGZhy{}mac.cc:297
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{5}\PYG{+w}{ }0x7fe78b924105\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::LteEnbPhy::StartSubFrame\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}enb\PYGZhy{}phy.cc:764
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{6}\PYG{+w}{ }0x7fe78b949d54\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::MakeEvent\PYGZlt{}void\PYG{+w}{ }\PYG{o}{(}ns3::LteEnbPhy::*\PYG{o}{)}\PYG{o}{(}\PYG{o}{)},\PYG{+w}{ }ns3::LteEnbPhy*\PYGZgt{}\PYG{o}{(}void\PYG{+w}{ }\PYG{o}{(}ns3::LteEnbPhy::*\PYG{o}{)}\PYG{o}{(}\PYG{o}{)},\PYG{+w}{ }ns3::LteEnbPhy*\PYG{o}{)}::EventMemberImpl0::Notify\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{(}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}lte\PYGZhy{}deb.so+0x3a9cd54\PYG{o}{)}
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{7}\PYG{+w}{ }0x7fe795252022\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::EventImpl::Invoke\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/event\PYGZhy{}impl.cc:51
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{8}\PYG{+w}{ }0x7fe795260de2\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::DefaultSimulatorImpl::ProcessOneEvent\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/default\PYGZhy{}simulator\PYGZhy{}impl.cc:151
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{9}\PYG{+w}{ }0x7fe795262dbd\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::DefaultSimulatorImpl::Run\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/default\PYGZhy{}simulator\PYGZhy{}impl.cc:204
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{10}\PYG{+w}{ }0x7fe79525436f\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::Simulator::Run\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/simulator.cc:176
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{11}\PYG{+w}{ }0x7fe7b0f77ee2\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }LteDistributedFfrAreaTestCase::DoRun\PYG{o}{(}\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/test/lte\PYGZhy{}test\PYGZhy{}frequency\PYGZhy{}reuse.cc:1777
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{12}\PYG{+w}{ }0x7fe7952d125a\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::TestCase::Run\PYG{o}{(}ns3::TestRunnerImpl*\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/test.cc:363
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{13}\PYG{+w}{ }0x7fe7952d0f4d\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::TestCase::Run\PYG{o}{(}ns3::TestRunnerImpl*\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/test.cc:357
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{14}\PYG{+w}{ }0x7fe7952e39c0\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::TestRunnerImpl::Run\PYG{o}{(}int,\PYG{+w}{ }char**\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/test.cc:1094
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{15}\PYG{+w}{ }0x7fe7952e427e\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns3::TestRunner::Run\PYG{o}{(}int,\PYG{+w}{ }char**\PYG{o}{)}\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/core/model/test.cc:1118
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{16}\PYG{+w}{ }0x564a13d67c9c\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }main\PYG{+w}{ }\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/utils/test\PYGZhy{}runner.cc:23
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{17}\PYG{+w}{ }0x7fe793cde0b2\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYGZus{}\PYGZus{}libc\PYGZus{}start\PYGZus{}main\PYG{+w}{ }\PYG{o}{(}/lib/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/libc.so.6+0x270b2\PYG{o}{)}
\PYG{g+gp}{    \PYGZsh{}}\PYG{l+m}{18}\PYG{+w}{ }0x564a13d67bbd\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYGZus{}start\PYG{+w}{ }\PYG{o}{(}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/utils/test\PYGZhy{}runner+0xae0bbd\PYG{o}{)}
\PYG{g+go}{0x7fe78cc2dbbc is located 40 bytes to the right of global variable \PYGZsq{}McsToItbsUl\PYGZsq{} defined in \PYGZsq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}amc.cc:105:18\PYGZsq{} (0x7fe78cc2db20) of size 116}
\PYG{g+go}{0x7fe78cc2dbbc is located 4 bytes to the left of global variable \PYGZsq{}TransportBlockSizeTable\PYGZsq{} defined in \PYGZsq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}amc.cc:118:18\PYGZsq{} (0x7fe78cc2dbc0) of size 11880}
\PYG{g+go}{SUMMARY: AddressSanitizer: global\PYGZhy{}buffer\PYGZhy{}overflow \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/lte/model/lte\PYGZhy{}amc.cc:303 in ns3::LteAmc::GetDlTbSizeFromMcs(int, int)}
\PYG{g+go}{Shadow bytes around the buggy address:}
\PYG{g+go}{  0x0ffd7197db50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 f9}
\PYG{g+go}{  0x0ffd7197db60: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00}
\PYG{g+go}{=\PYGZgt{}0x0ffd7197db70: 00 00 04 f9 f9 f9 f9[f9]00 00 00 00 00 00 00 00}
\PYG{g+go}{Shadow byte legend (one shadow byte represents 8 application bytes):}
\PYG{g+go}{  Addressable:           00}
\PYG{g+go}{  Partially addressable: 01 02 03 04 05 06 07}
\PYG{g+go}{  Global redzone:        f9}
\PYG{g+go}{==51636==ABORTING}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The output above shows the type of error (\sphinxcode{\sphinxupquote{global\sphinxhyphen{}buffer\sphinxhyphen{}overflow}}),
the stack\sphinxhyphen{}trace of where the bug happened (\sphinxcode{\sphinxupquote{LteAmc::GetDlTbSizeFromMcs}}),
affected variables (\sphinxcode{\sphinxupquote{McsToItbsUl}} and \sphinxcode{\sphinxupquote{TransportBlockSizeTable}}),
and a shadow bytes map, showing the wrong access between square brackets.

\item {} 
\sphinxAtStartPar
The the global redzone (f9) shadow bytes are empty memory allocated between global variables (00s and 04s),
which are left there to be corrupted by the bugged program.
Any eventual corruption is then traced back to the source, without affecting the program execution.

\item {} 
\sphinxAtStartPar
The adopted solution in merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/703}{MR703} was to fix one of the schedulers that could produce the index value of \sphinxhyphen{}1,
and updating the asserts to catch the illegal index value.

\end{itemize}

\item {} 
\sphinxAtStartPar
A wrong downcast in the Wimax module:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The pointer was casted incorrectly to U16TlvValue instead of U8TvlValue, which could have different sizes in memory
leading to the program reading the wrong memory address.
Reading the wrong memory address can result in unexpected or invalid values being read, which could change the
program flow and corrupt memory, producing wrong simulation results or crashing the program.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/wimax/model/service\PYGZhy{}flow.cc:159:86: runtime error: downcast of address 0x6020000148b0 which does not point to an object of type \PYGZsq{}U16TlvValue\PYGZsq{}}
\PYG{g+go}{0x6020000148b0: note: object is of type \PYGZsq{}ns3::U8TlvValue\PYGZsq{}}
\PYG{g+go}{48 00 00 36  c8 09 02 62 5c 7f 00 00  00 be be be be be be be  03 00 00 00 00 00 00 04  10 00 00 00}
\PYG{g+go}{              \PYGZca{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}}
\PYG{g+go}{              vptr for \PYGZsq{}ns3::U8TlvValue\PYGZsq{}}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/wimax/model/service\PYGZhy{}flow.cc:159:99: runtime error: member call on address 0x6020000148b0 which does not point to an object of type \PYGZsq{}U16TlvValue\PYGZsq{}}
\PYG{g+go}{0x6020000148b0: note: object is of type \PYGZsq{}ns3::U8TlvValue\PYGZsq{}}
\PYG{g+go}{48 00 00 36  c8 09 02 62 5c 7f 00 00  00 be be be be be be be  03 00 00 00 00 00 00 04  10 00 00 00}
\PYG{g+go}{              \PYGZca{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}}
\PYG{g+go}{              vptr for \PYGZsq{}ns3::U8TlvValue\PYGZsq{}}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/wimax/model/wimax\PYGZhy{}tlv.cc:589:10: runtime error: member access within address 0x6020000148b0 which does not point to an object of type \PYGZsq{}U16TlvValue\PYGZsq{}}
\PYG{g+go}{0x6020000148b0: note: object is of type \PYGZsq{}ns3::U8TlvValue\PYGZsq{}}
\PYG{g+go}{48 00 00 36  c8 09 02 62 5c 7f 00 00  00 be be be be be be be  03 00 00 00 00 00 00 04  10 00 00 00}
\PYG{g+go}{              \PYGZca{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}}
\PYG{g+go}{              vptr for \PYGZsq{}ns3::U8TlvValue\PYGZsq{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The bug was fixed with the correct cast in merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/704}{MR704}.

\end{itemize}

\end{itemize}


\subsubsection{Heaptrack}
\label{\detokenize{profiling:id3}}
\sphinxAtStartPar
\sphinxhref{https://apps.kde.org/heaptrack/}{Heaptrack} is an utility made by \sphinxhref{https://kde.org}{KDE} to trace memory allocations
along with stack traces, allowing developers to identify code responsible
for possible memory leaks and unnecessary allocations.

\sphinxAtStartPar
For the examples below we used the default configuration of ns\sphinxhyphen{}3,
with the output going to the \sphinxcode{\sphinxupquote{build}} directory. The actual executable
for the \sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}he\sphinxhyphen{}network}} example is \sphinxcode{\sphinxupquote{./build/examples/wireless/ns3\sphinxhyphen{}dev\sphinxhyphen{}wifi\sphinxhyphen{}he\sphinxhyphen{}network}}, which is what is
executed by \sphinxcode{\sphinxupquote{./ns3 run wifi\sphinxhyphen{}he\sphinxhyphen{}network}}.

\sphinxAtStartPar
To collect information of a program (in this case the \sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}he\sphinxhyphen{}network}}
example), run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{} heaptrack ./build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you prefer to use the \sphinxcode{\sphinxupquote{ns3}} wrapper, try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}heaptrack \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\end{sphinxVerbatim}

\sphinxAtStartPar
In both cases, heaptrack will print to the terminal the output file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}heaptrack \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\PYG{g+go}{heaptrack output will be written to \PYGZdq{}\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/heaptrack.ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network.210305.zst\PYGZdq{}}
\PYG{g+go}{starting application, this might take some time...}
\PYG{g+go}{MCS value               Channel width           GI                      Throughput}
\PYG{g+go}{0                       20 MHz                  3200 ns                 5.91733 Mbit/s}
\PYG{g+go}{0                       20 MHz                  1600 ns                 5.91733 Mbit/s}
\PYG{g+go}{...}
\PYG{g+go}{11                      160 MHz                 1600 ns                 479.061 Mbit/s}
\PYG{g+go}{11                      160 MHz                 800 ns                  524.459 Mbit/s}
\PYG{g+go}{heaptrack stats:}
\PYG{g+go}{        allocations:            149185947}
\PYG{g+go}{        leaked allocations:     10467}
\PYG{g+go}{        temporary allocations:  21145932}
\PYG{g+go}{Heaptrack finished! Now run the following to investigate the data:}

\PYG{g+go}{    heaptrack \PYGZhy{}\PYGZhy{}analyze \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/heaptrack.ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network.210305.zst\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output above shows a summary of the stats collected: \textasciitilde{}149 million allocations,
\textasciitilde{}21 million temporary allocations and \textasciitilde{}10 thousand possible leaked allocations.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{heaptrack\sphinxhyphen{}gui}} is installed, running \sphinxcode{\sphinxupquote{heaptrack}} will launch it. If it is not installed,
the command line interface will be used.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} heaptrack \PYGZhy{}\PYGZhy{}analyze \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/heaptrack.ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network.210305.zst\PYGZdq{}}
\PYG{g+go}{reading file \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/heaptrack.ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network.210305.zst\PYGZdq{} \PYGZhy{} please wait, this might take some time...}
\PYG{g+go}{Debuggee command was: \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745}
\PYG{g+go}{finished reading file, now analyzing data:}

\PYG{g+go}{MOST CALLS TO ALLOCATION FUNCTIONS}
\PYG{g+go}{23447502 calls to allocation functions with 1.12MB peak consumption from}
\PYG{g+go}{ns3::Packet::Copy() const}
\PYG{g+go}{in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}network.so}
\PYG{g+go}{4320000 calls with 0B peak consumption from:}
\PYG{g+go}{    ns3::UdpSocketImpl::DoSendTo(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ipv4Address, unsigned short, unsigned char)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::UdpSocketImpl::DoSend(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::UdpSocketImpl::Send(ns3::Ptr\PYGZlt{}\PYGZgt{}, unsigned int)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::Socket::Send(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}network.so}
\PYG{g+go}{    ns3::UdpClient::Send()}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}applications.so}
\PYG{g+go}{    ns3::DefaultSimulatorImpl::ProcessOneEvent()}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}core.so}
\PYG{g+go}{    ns3::DefaultSimulatorImpl::Run()}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}core.so}
\PYG{g+go}{    main}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network}

\PYG{g+go}{...}

\PYG{g+go}{MOST TEMPORARY ALLOCATIONS}
\PYG{g+go}{6182320 temporary allocations of 6182701 allocations in total (99.99\PYGZpc{}) from}
\PYG{g+go}{ns3::QueueDisc::DropBeforeEnqueue(ns3::Ptr\PYGZlt{}\PYGZgt{}, char const*)}
\PYG{g+go}{in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{1545580 temporary allocations of 1545580 allocations in total (100.00\PYGZpc{}) from:}
\PYG{g+go}{    std::\PYGZus{}Function\PYGZus{}handler\PYGZlt{}\PYGZgt{}::\PYGZus{}M\PYGZus{}invoke(std::\PYGZus{}Any\PYGZus{}data const\PYGZam{}, ns3::Ptr\PYGZlt{}\PYGZgt{}\PYGZam{}\PYGZam{}, char const*\PYGZam{}\PYGZam{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    std::function\PYGZlt{}\PYGZgt{}::operator()(ns3::Ptr\PYGZlt{}\PYGZgt{}, char const*) const}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::MemPtrCallbackImpl\PYGZlt{}\PYGZgt{}::operator()(ns3::Ptr\PYGZlt{}\PYGZgt{}, char const*)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::TracedCallback\PYGZlt{}\PYGZgt{}::operator()(ns3::Ptr\PYGZlt{}\PYGZgt{}, char const*) const}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::QueueDisc::DropBeforeEnqueue(ns3::Ptr\PYGZlt{}\PYGZgt{}, char const*)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::CoDelQueueDisc::DoEnqueue(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::QueueDisc::Enqueue(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::FqCoDelQueueDisc::DoEnqueue(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::QueueDisc::Enqueue(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::TrafficControlLayer::Send(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}traffic\PYGZhy{}control.so}
\PYG{g+go}{    ns3::Ipv4Interface::Send(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ipv4Header const\PYGZam{}, ns3::Ipv4Address)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::Ipv4L3Protocol::SendRealOut(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ipv4Header const\PYGZam{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::Ipv4L3Protocol::Send(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ipv4Address, ns3::Ipv4Address, unsigned char, ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::UdpL4Protocol::Send(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ipv4Address, ns3::Ipv4Address, unsigned short, unsigned short, ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::UdpSocketImpl::DoSendTo(ns3::Ptr\PYGZlt{}\PYGZgt{}, ns3::Ipv4Address, unsigned short, unsigned char)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::UdpSocketImpl::DoSend(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::UdpSocketImpl::Send(ns3::Ptr\PYGZlt{}\PYGZgt{}, unsigned int)}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}internet.so}
\PYG{g+go}{    ns3::Socket::Send(ns3::Ptr\PYGZlt{}\PYGZgt{})}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}network.so}
\PYG{g+go}{    ns3::UdpClient::Send()}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}applications.so}
\PYG{g+go}{    ns3::DefaultSimulatorImpl::ProcessOneEvent()}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}core.so}
\PYG{g+go}{    ns3::DefaultSimulatorImpl::Run()}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}core.so}
\PYG{g+go}{    main}
\PYG{g+go}{    in \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network}

\PYG{g+go}{...}

\PYG{g+go}{total runtime: 156.30s.}
\PYG{g+go}{calls to allocation functions: 149185947 (954466/s)}
\PYG{g+go}{temporary memory allocations: 21757614 (139201/s)}
\PYG{g+go}{peak heap memory consumption: 4.87MB}
\PYG{g+go}{peak RSS (including heaptrack overhead): 42.02MB}
\PYG{g+go}{total memory leaked: 895.45KB}
\end{sphinxVerbatim}

\sphinxAtStartPar
The terminal output above lists the most frequently called functions that allocated memory.

\sphinxAtStartPar
Here is a short description of what each line of the last block of the output means:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Allocation functions are all functions that allocated memory, either explicitly
via C\sphinxhyphen{}style \sphinxcode{\sphinxupquote{malloc}} and C++ \sphinxcode{\sphinxupquote{new}}, or implicitly via RAII and automatic conversions.

\item {} 
\sphinxAtStartPar
Temporary memory allocations are allocations that are followed by the
deallocation without modifying the data.

\item {} 
\sphinxAtStartPar
Peak heap memory is the maximum memory allocated by the program throughout its execution.
The memory allocator may reuse memory freed by previous destructors, \sphinxcode{\sphinxupquote{del}} and \sphinxcode{\sphinxupquote{free}} calls,
reducing the number of system calls and maximum memory allocated.

\item {} 
\sphinxAtStartPar
RSS is the Resident Set Size, which is the amount of physical memory occupied by the process.

\item {} 
\sphinxAtStartPar
Total memory leak refers to memory allocated but never freed. This includes static initialization,
so it is not uncommon to be different than 0KB. However this does not mean the program does not
have memory leaks. Other memory profilers such as Valgrind and memory sanitizers are better
suited to track down memory leaks.

\end{itemize}

\sphinxAtStartPar
Based on the stack trace, it is fairly easy to locate the corresponding code and act on it to
reduce the number of allocations.

\sphinxAtStartPar
In the case of \sphinxcode{\sphinxupquote{ns3::QueueDisc::DropBeforeEnqueue}} shown above, the
allocations were caused by the transformation of C strings (\sphinxcode{\sphinxupquote{char*}}) into C++ strings
(std::string) before performing the search in ns3::QueueDisc::Stats maps.
These unnecessary allocations were prevented by making use of the transparent
comparator \sphinxcode{\sphinxupquote{std::less\textless{}\textgreater{}}}, part of merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/830}{MR830}.

\sphinxAtStartPar
Heaptrack also has a GUI that provides the same information printed by the command line interface,
but in a more interactive way.

\noindent\sphinxincludegraphics{{heaptrack}.png}

\sphinxAtStartPar
Heaptrack was used in merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/830}{MR830} to track and reduce the number of allocations
in the \sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}he\sphinxhyphen{}network}} example mentioned above. About 29 million unnecessary allocations
were removed, which translates to a 20\% reduction. This resulted in a 1.07x speedup of the
test suite with Valgrind (\sphinxcode{\sphinxupquote{./test.py \sphinxhyphen{}d \sphinxhyphen{}g}}) and 1.02x speedup without it.


\subsubsection{Memray}
\label{\detokenize{profiling:memray}}
\sphinxAtStartPar
\sphinxhref{https://bloomberg.github.io/memray/}{Memray} is an utility made by Bloomberg to trace memory allocations of Python programs,
including native code called by them. Along with stack traces, developers can trace down
possible memory leaks and unnecessary allocations.

\sphinxAtStartPar
Note: Memray is ineffective for profiling the ns\sphinxhyphen{}3 python bindings since Cppyy hides away
the calls to the ns\sphinxhyphen{}3 module libraries. However, it is still useful for python scripts
in general, for example ones used to parse and consolidate simulation results.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ns3}} script includes a run option to launch Python programs with Memray.
Memray can produce different types of reports, such as a flamegraph in HTML, or
text reports (\sphinxcode{\sphinxupquote{summary}} and \sphinxcode{\sphinxupquote{stats}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{} ./ns3 run sample\PYGZhy{}rng\PYGZhy{}plot.py \PYGZhy{}\PYGZhy{}memray}
\PYG{g+go}{Writing profile results into memray.output}
\PYG{g+go}{Memray WARNING: Correcting symbol for aligned\PYGZus{}alloc from 0x7fd97023c890 to 0x7fd97102fce0}
\PYG{g+go}{[memray] Successfully generated profile results.}

\PYG{g+go}{You can now generate reports from the stored allocation records.}
\PYG{g+go}{Some example commands to generate reports:}

\PYG{g+go}{/usr/bin/python3 \PYGZhy{}m memray flamegraph memray.output}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} /usr/bin/python3 \PYGZhy{}m memray stats memray.output}
\PYG{g+go}{   Total allocations:}
\PYG{g+go}{         5364235}

\PYG{g+go}{   Total memory allocated:}
\PYG{g+go}{         10.748GB}

\PYG{g+go}{   Histogram of allocation size:}
\PYG{g+go}{         min: 0.000B}
\PYG{g+go}{         \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{         \PYGZlt{} 8.000B   :  264149 |||}
\PYG{g+go}{         \PYGZlt{} 78.000B  : 2051906 |||||||||||||||||||||||}
\PYG{g+go}{         \PYGZlt{} 699.000B : 2270941 |||||||||||||||||||||||||}
\PYG{g+go}{         \PYGZlt{} 6.064KB  :  608993 |||||||}
\PYG{g+go}{         \PYGZlt{} 53.836KB :  165307 ||}
\PYG{g+go}{         \PYGZlt{} 477.912KB:    2220 |}
\PYG{g+go}{         \PYGZlt{} 4.143MB  :     511 |}
\PYG{g+go}{         \PYGZlt{} 36.779MB :     188 |}
\PYG{g+go}{         \PYGZlt{} 326.492MB:      19 |}
\PYG{g+go}{         \PYGZlt{}=2.830GB  :       1 |}
\PYG{g+go}{         \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{         max: 2.830GB}

\PYG{g+go}{   Allocator type distribution:}
\PYG{g+go}{          MALLOC: 4647765}
\PYG{g+go}{          CALLOC: 435525}
\PYG{g+go}{          REALLOC: 277736}
\PYG{g+go}{          POSIX\PYGZus{}MEMALIGN: 2686}
\PYG{g+go}{          MMAP: 523}

\PYG{g+go}{   Top 5 largest allocating locations (by size):}
\PYG{g+go}{         \PYGZhy{} include:/usr/local/lib/python3.10/dist\PYGZhy{}packages/cppyy/\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py:243 \PYGZhy{}\PYGZgt{} 8.814GB}
\PYG{g+go}{         \PYGZhy{} \PYGZlt{}stack trace unavailable\PYGZgt{} \PYGZhy{}\PYGZgt{} 746.999MB}
\PYG{g+go}{         \PYGZhy{} show:\PYGZti{}/.local/lib/python3.10/site\PYGZhy{}packages/matplotlib/backends/backend\PYGZus{}gtk4.py:340 \PYGZhy{}\PYGZgt{} 263.338MB}
\PYG{g+go}{         \PYGZhy{} load\PYGZus{}library:/usr/local/lib/python3.10/dist\PYGZhy{}packages/cppyy/\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py:235 \PYGZhy{}\PYGZgt{} 245.684MB}
\PYG{g+go}{         \PYGZhy{} \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}:/usr/lib/python3.10/ctypes/\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py:374 \PYGZhy{}\PYGZgt{} 225.797MB}

\PYG{g+go}{   Top 5 largest allocating locations (by number of allocations):}
\PYG{g+go}{         \PYGZhy{} include:/usr/local/lib/python3.10/dist\PYGZhy{}packages/cppyy/\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py:243 \PYGZhy{}\PYGZgt{} 2246145}
\PYG{g+go}{         \PYGZhy{} show:\PYGZti{}/.local/lib/python3.10/site\PYGZhy{}packages/matplotlib/backends/backend\PYGZus{}gtk4.py:340 \PYGZhy{}\PYGZgt{} 1264614}
\PYG{g+go}{         \PYGZhy{} \PYGZlt{}stack trace unavailable\PYGZgt{} \PYGZhy{}\PYGZgt{} 1098543}
\PYG{g+go}{         \PYGZhy{} \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}:\PYGZti{}/.local/lib/python3.10/site\PYGZhy{}packages/matplotlib/backends/backend\PYGZus{}gtk4.py:61 \PYGZhy{}\PYGZgt{} 89466}
\PYG{g+go}{         \PYGZhy{} run:/usr/lib/python3/dist\PYGZhy{}packages/gi/overrides/Gio.py:42 \PYGZhy{}\PYGZgt{} 79582}
\end{sphinxVerbatim}


\subsection{Performance Profilers}
\label{\detokenize{profiling:performance-profilers}}
\sphinxAtStartPar
Performance profilers are programs that collect runtime information and help to
identify performance bottlenecks. In some cases, they can point out hotspots
and suggest solutions.

\sphinxAtStartPar
There are many tools to profile your program, including:
\begin{itemize}
\item {} 
\sphinxAtStartPar
profilers from CPU manufacturers, such as \sphinxhref{https://www.amd.com/en/developer/uprof.html}{AMD uProf} and \sphinxhref{https://www.intel.com/content/www/us/en/develop/documentation/get-started-with-vtune/top.html}{Intel VTune}

\item {} 
\sphinxAtStartPar
profilers from the operating systems, such as Linux’s \sphinxhref{https://perf.wiki.kernel.org/index.php/Tutorial}{Perf} and \sphinxhref{https://docs.microsoft.com/en-us/windows-hardware/test/wpt/}{Windows Performance Toolkit}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://perf.wiki.kernel.org/index.php/Tutorial}{Perf} also has a few graphical user interfaces available, being \sphinxhref{https://github.com/KDAB/hotspot}{Hotspot} one of them

\end{itemize}

\item {} 
\sphinxAtStartPar
instrumented compilation and auxiliary tools provided by compilers, such as \sphinxhref{https://sourceware.org/binutils/docs/gprof/}{Gprof}

\item {} 
\sphinxAtStartPar
third\sphinxhyphen{}party tools, such as \sphinxhref{https://wiki.gnome.org/Apps/Sysprof}{Sysprof} and \sphinxhref{https://oprofile.sourceforge.io/faq/}{Oprofile}

\end{itemize}

\sphinxAtStartPar
An overview on how to use \sphinxhref{https://perf.wiki.kernel.org/index.php/Tutorial}{Perf} with \sphinxhref{https://github.com/KDAB/hotspot}{Hotspot}, \sphinxhref{https://www.amd.com/en/developer/uprof.html}{AMD uProf} and
\sphinxhref{https://www.intel.com/content/www/us/en/develop/documentation/get-started-with-vtune/top.html}{Intel VTune} is provided in the following sections.


\subsubsection{Linux Perf and Hotspot GUI}
\label{\detokenize{profiling:linux-perf-and-hotspot-gui}}\label{\detokenize{profiling:id5}}
\sphinxAtStartPar
\sphinxhref{https://perf.wiki.kernel.org/index.php/Tutorial}{Perf} is the kernel tool to measure performance of the Linux kernel,
drivers and user\sphinxhyphen{}space applications.

\sphinxAtStartPar
Perf tracks some performance events, being some of the most important for performance:
\begin{itemize}
\item {} 
\sphinxAtStartPar
cycles
\begin{itemize}
\item {} 
\sphinxAtStartPar
Clocks (time) spent running.

\end{itemize}

\item {} 
\sphinxAtStartPar
cache\sphinxhyphen{}misses
\begin{itemize}
\item {} 
\sphinxAtStartPar
When either data or instructions were not in the L1/L2 caches, requiring
a L3 or memory access.

\end{itemize}

\item {} 
\sphinxAtStartPar
branch\sphinxhyphen{}misses
\begin{itemize}
\item {} 
\sphinxAtStartPar
How many branch instructions were mispredicted.
Mispredictions causes the CPU to stall and clean the pipeline,
slowing down the program.

\end{itemize}

\item {} 
\sphinxAtStartPar
stalled\sphinxhyphen{}cycles\sphinxhyphen{}frontend
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cycles wasted by the processor waiting for the next instruction,
usually due to instruction cache miss or mispredictions.
Starves the CPU pipeline of instructions and slows down the program.

\end{itemize}

\item {} 
\sphinxAtStartPar
stalled\sphinxhyphen{}cycles\sphinxhyphen{}backend
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cycles wasted waiting for pipeline resources to finish their work.
Usually waiting for memory read/write, or executing long\sphinxhyphen{}latency instructions.

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Just like with \sphinxcode{\sphinxupquote{heaptrack}}, perf can be executed using the \sphinxcode{\sphinxupquote{ns3}} wrapper
command template. In the following command we output perf data from \sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}he\sphinxhyphen{}network}}
to the \sphinxcode{\sphinxupquote{perf.data}} output file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}command\PYGZhy{}template \PYGZdq{}perf record \PYGZhy{}o ./perf.data \PYGZhy{}\PYGZhy{}call\PYGZhy{}graph dwarf \PYGZhy{}\PYGZhy{}event cycles,cache\PYGZhy{}misses,branch\PYGZhy{}misses \PYGZhy{}\PYGZhy{}sample\PYGZhy{}cpu \PYGZpc{}s\PYGZdq{} \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\end{sphinxVerbatim}

\sphinxAtStartPar
For ease of use, \sphinxcode{\sphinxupquote{ns3}} also provides the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}perf}} run option, that
include the recommended settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}perf \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\end{sphinxVerbatim}

\sphinxAtStartPar
When running for the first time, you may receive the following error:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}perf \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\PYG{g+go}{Error:}
\PYG{g+go}{Access to performance monitoring and observability operations is limited.}
\PYG{g+go}{Consider adjusting /proc/sys/kernel/perf\PYGZus{}event\PYGZus{}paranoid setting to open}
\PYG{g+go}{access to performance monitoring and observability operations for processes}
\PYG{g+go}{without CAP\PYGZus{}PERFMON, CAP\PYGZus{}SYS\PYGZus{}PTRACE or CAP\PYGZus{}SYS\PYGZus{}ADMIN Linux capability.}
\PYG{g+go}{More information can be found at \PYGZsq{}Perf events and tool security\PYGZsq{} document:}
\PYG{g+go}{https://www.kernel.org/doc/html/latest/admin\PYGZhy{}guide/perf\PYGZhy{}security.html}
\PYG{g+go}{perf\PYGZus{}event\PYGZus{}paranoid setting is 1:}
\PYG{g+go}{  \PYGZhy{}1: Allow use of (almost) all events by all users}
\PYG{g+go}{      Ignore mlock limit after perf\PYGZus{}event\PYGZus{}mlock\PYGZus{}kb without CAP\PYGZus{}IPC\PYGZus{}LOCK}
\PYG{g+go}{\PYGZgt{}= 0: Disallow raw and ftrace function tracepoint access}
\PYG{g+go}{\PYGZgt{}= 1: Disallow CPU event access}
\PYG{g+go}{\PYGZgt{}= 2: Disallow kernel profiling}
\PYG{g+go}{To make the adjusted perf\PYGZus{}event\PYGZus{}paranoid setting permanent preserve it}
\PYG{g+go}{in /etc/sysctl.conf (e.g. kernel.perf\PYGZus{}event\PYGZus{}paranoid = \PYGZlt{}setting\PYGZgt{})}
\PYG{g+go}{Command \PYGZsq{}build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network\PYGZhy{}default record \PYGZhy{}\PYGZhy{}call\PYGZhy{}graph dwarf \PYGZhy{}a \PYGZhy{}e cache\PYGZhy{}misses,branch\PYGZhy{}misses,cpu\PYGZhy{}cycles,instructions,context\PYGZhy{}switches build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network\PYGZhy{}default \PYGZhy{}n=100\PYGZsq{} returned non\PYGZhy{}zero exit status 255.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This error is related to lacking permissions to access performance events from the kernel and CPU.
As said in the error, permissions can be granted for the current session
by changing the \sphinxcode{\sphinxupquote{perf\_event\_paranoid}} setting with \sphinxcode{\sphinxupquote{echo 0 \textgreater{} /proc/sys/kernel/perf\_event\_paranoid}}.
This change can be made permanent by changing the setting in \sphinxcode{\sphinxupquote{/etc/sysctl.conf}}, but
this is not recommended. Administrative permissions (\sphinxcode{\sphinxupquote{sudo su}}) are required in both cases.

\sphinxAtStartPar
After the program finishes, it will print recording statistics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{MCS value               Channel width           GI                      Throughput}
\PYG{g+go}{0                       20 MHz                  3200 ns                 6.01067 Mbit/s}
\PYG{g+go}{0                       20 MHz                  1600 ns                 5.936 Mbit/s}
\PYG{g+go}{...}
\PYG{g+go}{11                      160 MHz                 1600 ns                 493.397 Mbit/s}
\PYG{g+go}{11                      160 MHz                 800 ns                  534.016 Mbit/s}
\PYG{g+go}{[ perf record: Woken up 9529 times to write data ]}
\PYG{g+go}{Warning:}
\PYG{g+go}{Processed 517638 events and lost 94 chunks!}

\PYG{g+go}{Check IO/CPU overload!}

\PYG{g+go}{Warning:}
\PYG{g+go}{1 out of order events recorded.}
\PYG{g+go}{[ perf record: Captured and wrote 2898,307 MB perf.data (436509 samples) ]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Results saved in \sphinxcode{\sphinxupquote{perf.data}} can be reviewed with the \sphinxcode{\sphinxupquote{perf report}} command.

\sphinxAtStartPar
\sphinxhref{https://github.com/KDAB/hotspot}{Hotspot} is a GUI for Perf, that makes performance profiling more
enjoyable and productive. It can parse the \sphinxcode{\sphinxupquote{perf.data}} and show in
a more friendly way.

\sphinxAtStartPar
To record the same perf.data from Hotspot directly, fill the fields
for working directory, path to the executable, arguments, perf
events to track and output directory for the \sphinxcode{\sphinxupquote{perf.data}}.
Then run to start recording.

\noindent\sphinxincludegraphics{{hotspot-setup}.png}

\sphinxAtStartPar
The cycles per function for this program is shown in the following
image.

\noindent\sphinxincludegraphics{{hotspot-cycles}.png}

\sphinxAtStartPar
The data is also presented in a tabular format in the bottom\sphinxhyphen{}up,
top\sphinxhyphen{}down and caller/callee tabs (top left of the screen).

\noindent\sphinxincludegraphics{{hotspot-top-down}.png}

\sphinxAtStartPar
Hotspot was used to identify performance bottlenecks in multiple occasions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}primary\sphinxhyphen{}channels}} test suite was extremely slow due to unnecessary RF processing.
The adopted solution was to replace the filtering step of the entire channel to just the desired
sub\sphinxhyphen{}band, and assuming sub\sphinxhyphen{}bands are uniformly sized, saving multiplications in the integral
used to compute the power of each sub\sphinxhyphen{}band. This resulted in a 6x speedup with
\sphinxcode{\sphinxupquote{./ns3 run "test\sphinxhyphen{}runner \sphinxhyphen{}\sphinxhyphen{}fullness=TAKES\_FOREVER \sphinxhyphen{}\sphinxhyphen{}test\sphinxhyphen{}name=wifi\sphinxhyphen{}primary\sphinxhyphen{}channels"}}.
Hotspot was used along with AMD uProf to track this and other bottlenecks in \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/issues/426}{issue 426}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WifiMacQueue::TtlExceeded}} dereferenced data out of cache when calling Simulator::Now().
The adopted solution was to move Simulator::Now() out of TtlExceeded and reuse the value
and inlining TtlExceeded. This resulted in a \textasciitilde{}1.20x speedup with the test suite (\sphinxcode{\sphinxupquote{./test.py \sphinxhyphen{}d}}).
Hotspot was used along with AMD uProf to track this and other bottlenecks in \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/issues/280}{issue 280}
and merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/681}{MR681}.

\item {} 
\sphinxAtStartPar
MpduAggregator and MsduAggregator required an expensive attribute lookup to get the maximum sizes
from the RegularWifiMac. Bypassing the attribute lookup reduced cache misses and unnecessary branches.
The adopted solution was to move Simulator::Now() out of TtlExceeded and reuse the value
and inlining TtlExceeded. This resulted in a \textasciitilde{}1.02x speedup with the test suite (\sphinxcode{\sphinxupquote{./test.py \sphinxhyphen{}d}}).
More details on: merge requests \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/681}{MR681} and \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/685}{MR685}.

\end{enumerate}


\subsubsection{AMD uProf}
\label{\detokenize{profiling:id6}}
\sphinxAtStartPar
\sphinxhref{https://www.amd.com/en/developer/uprof.html}{AMD uProf} works much like {\hyperref[\detokenize{profiling:linux-perf-and-hotspot-gui}]{\sphinxcrossref{Linux Perf and Hotspot GUI}}}, but
is available in more platforms (Linux, Windows and BSD) using AMD
processors. Differently from Perf, it provides more performance
trackers for finer analysis.

\sphinxAtStartPar
To use it, open uProf then click to profile an application. If you
have already profile an application, you can reuse those settings for
another application by clicking in one of the items in the \sphinxcode{\sphinxupquote{Recently Used
Configurations}} section.

\noindent\sphinxincludegraphics{{uprof-start}.png}

\sphinxAtStartPar
Fill the fields with the application path, the arguments and
the working directory.

\sphinxAtStartPar
You may need to add the LD\_LIBRARY\_PATH environment variable
(or PATH on Windows), pointing it to the library output
directory (e.g. \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/build/lib}}).

\sphinxAtStartPar
Then click next:

\noindent\sphinxincludegraphics{{uprof-profile-application}.png}

\sphinxAtStartPar
Now select custom events and pick the events you want.
\begin{description}
\sphinxlineitem{The recommended ones for performance profiling are:}\begin{itemize}
\item {} 
\sphinxAtStartPar
CYCLES\_NOT\_IN\_HALT
\begin{itemize}
\item {} 
\sphinxAtStartPar
Clocks (time) spent running.

\end{itemize}

\item {} 
\sphinxAtStartPar
RETIRED\_INST
\begin{itemize}
\item {} 
\sphinxAtStartPar
How many instructions were completed.

\item {} 
\sphinxAtStartPar
These do not count mispredictions, stalls, etc.

\item {} 
\sphinxAtStartPar
Instructions per clock (IPC) = RETIRED\_INST / CYCLES\_NOT\_IN\_HALT

\end{itemize}

\item {} 
\sphinxAtStartPar
RETIRED\_BR\_INST\_MISP
\begin{itemize}
\item {} 
\sphinxAtStartPar
How many branch instructions were mispredicted.

\item {} 
\sphinxAtStartPar
Mispredictions causes the CPU to stall and clean the pipeline,
slowing down the program.

\end{itemize}

\item {} 
\sphinxAtStartPar
L2\_CACHE\_MISS.FROM\_L1\_IC\_MISS
\begin{itemize}
\item {} 
\sphinxAtStartPar
L2 cache misses caused by instruction L1 cache misses.

\item {} 
\sphinxAtStartPar
Results in L3/memory accesses due to missing instructions in L1/L2.

\end{itemize}

\item {} 
\sphinxAtStartPar
L2\_CACHE\_MISS.FROM\_L1\_DC\_MISS
\begin{itemize}
\item {} 
\sphinxAtStartPar
L2 cache misses caused by data L1 cache misses.

\item {} 
\sphinxAtStartPar
Results in L3/memory accesses due to missing instructions in L1/L2

\end{itemize}

\item {} 
\sphinxAtStartPar
MISALIGNED\_LOADS
\begin{itemize}
\item {} 
\sphinxAtStartPar
Loads not aligned with processor words.

\item {} 
\sphinxAtStartPar
Might result in additional cache and memory accesses.

\end{itemize}

\end{itemize}

\end{description}

\noindent\sphinxincludegraphics{{uprof-select-events}.png}

\sphinxAtStartPar
Now click in advanced options to enable collection of the call stack.

\noindent\sphinxincludegraphics{{uprof-collect-callstack}.png}

\sphinxAtStartPar
Then click \sphinxcode{\sphinxupquote{Start Profile}} and wait for the program to end.
After it finishes you will be greeted with a hotspot summary screen,
but the \sphinxcode{\sphinxupquote{Analyze}} tab (top of the screen) has sub\sphinxhyphen{}tabs with more
relevant information.

\sphinxAtStartPar
In the following image the metrics are shown per module, including the
C library (libc.so.6) which provides the \sphinxcode{\sphinxupquote{malloc}} and \sphinxcode{\sphinxupquote{free}} functions.
Values can be shown in terms of samples or percentages for easier reading
and to decide where to optimize.

\noindent\sphinxincludegraphics{{uprof-stats}.png}

\sphinxAtStartPar
Here are a few cases where AMD uProf was used to identify performance bottlenecks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WifiMacQueue::TtlExceeded}} dereferenced data out of cache when calling Simulator::Now().
The adopted solution was to move Simulator::Now() out of TtlExceeded and reuse the value
and inlining TtlExceeded. This resulted in a \textasciitilde{}1.20x speedup with the test suite (\sphinxcode{\sphinxupquote{./test.py \sphinxhyphen{}d}}).
More details on: \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/issues/280}{issue 280} and merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/681}{MR681}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}primary\sphinxhyphen{}channels}} test suite was extremely slow due to unnecessary RF processing.
The adopted solution was to replace the filtering step of the entire channel to just the desired
sub\sphinxhyphen{}band, and assuming sub\sphinxhyphen{}bands are uniformly sized, saving multiplications in the integral
used to compute the power of each sub\sphinxhyphen{}band. This resulted in a 6x speedup with
\sphinxcode{\sphinxupquote{./ns3 run "test\sphinxhyphen{}runner \sphinxhyphen{}\sphinxhyphen{}fullness=TAKES\_FOREVER \sphinxhyphen{}\sphinxhyphen{}test\sphinxhyphen{}name=wifi\sphinxhyphen{}primary\sphinxhyphen{}channels"}}.
More details on: \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/issues/426}{issue 426} and merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/677}{MR677}.

\item {} 
\sphinxAtStartPar
Continuing the work on \sphinxcode{\sphinxupquote{wifi\sphinxhyphen{}primary\sphinxhyphen{}channels}} test suite, profiling showed an excessive
number of cache misses in \sphinxcode{\sphinxupquote{InterferenceHelper::GetNextPosition}}.
This function searches for an iterator on a map, which is very fast
if the map is small and fits in the cache, which was not the case. After reviewing the code,
it was noticed in most cases this call was unnecessary as the iterator was already known.
The adopted solution was to reuse the iterator whenever possible.
This resulted in a 1.78x speedup on top of the previous 6x with
\sphinxcode{\sphinxupquote{./ns3 run "test\sphinxhyphen{}runner \sphinxhyphen{}\sphinxhyphen{}fullness=TAKES\_FOREVER \sphinxhyphen{}\sphinxhyphen{}test\sphinxhyphen{}name=wifi\sphinxhyphen{}primary\sphinxhyphen{}channels"}}.
More details on: \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/issues/426}{issue 426} and merge requests \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/677}{MR677} and \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/680}{MR680}.

\item {} 
\sphinxAtStartPar
Position\sphinxhyphen{}Independent Code libraries (\sphinxcode{\sphinxupquote{\sphinxhyphen{}fPIC}}) have an additional layer of indirection that increases
instruction cache misses. The adopted solution was to disable \sphinxhref{https://maskray.me/blog/2021-05-09-fno-semantic-interposition}{semantic interposition} with flag
\sphinxcode{\sphinxupquote{\sphinxhyphen{}fno\sphinxhyphen{}semantic\sphinxhyphen{}interposition}} on GCC. This is the default setting on Clang. This results in
approximately 1.14x speedup with \sphinxcode{\sphinxupquote{./test.py \sphinxhyphen{}d}}. More details on: \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/777}{MR777}.

\end{enumerate}

\sphinxAtStartPar
Note: all speedups above were measured on the same machine. Results may differ based on clock speeds,
cache sizes, number of cores, memory bandwidth and latency, storage throughput and latency.


\subsubsection{Intel VTune}
\label{\detokenize{profiling:id8}}
\sphinxAtStartPar
\sphinxhref{https://www.intel.com/content/www/us/en/develop/documentation/get-started-with-vtune/top.html}{Intel VTune} works much like {\hyperref[\detokenize{profiling:linux-perf-and-hotspot-gui}]{\sphinxcrossref{Linux Perf and Hotspot GUI}}}, but
is available in more platforms (Linux, Windows and Mac) using Intel
processors. Differently from Perf, it provides more performance
trackers for finer analysis.

\sphinxAtStartPar
When you open the program, you will be greeted by the landing page
shown in the following image. To start a new profiling project, click
in the \sphinxcode{\sphinxupquote{Configure Analysis}} button. If you already have a project,
right\sphinxhyphen{}click the entry and click to configure analysis to reuse the
settings.

\noindent\sphinxincludegraphics{{vtune-landing}.png}

\sphinxAtStartPar
A configuration page will open, where you can fill the fields with
the path to the program, arguments, and set working directory and
environment variables.

\sphinxAtStartPar
Note: in this example on Windows using MinGW,
we need to define the \sphinxcode{\sphinxupquote{PATH}} environment variable with the paths
to both \sphinxcode{\sphinxupquote{\textasciitilde{}/ns\sphinxhyphen{}3\sphinxhyphen{}dev/build/lib}} and the MinGW binaries folder
(\sphinxcode{\sphinxupquote{\textasciitilde{}/msys64/mingw64/bin}}), which contains essential libraries.
On Linux\sphinxhyphen{}like systems you will need to define the
\sphinxcode{\sphinxupquote{LD\_LIBRARY\_PATH}} environment variable instead of \sphinxcode{\sphinxupquote{PATH}}.

\sphinxAtStartPar
Clicking on the \sphinxcode{\sphinxupquote{Performance Snapshot}} shows the different profiling
options.

\noindent\sphinxincludegraphics{{vtune-configure}.png}

\sphinxAtStartPar
If executed as is, a quicker profiling will be executed to
determine what areas should be profiled with more details.
For the specific example, it is indicated that there are
microarchitectural bottlenecks and low parallelism
(not a surprise since ns\sphinxhyphen{}3 is single\sphinxhyphen{}threaded).

\noindent\sphinxincludegraphics{{vtune-perf-snapshot}.png}

\sphinxAtStartPar
If the \sphinxcode{\sphinxupquote{microarchitecture exploration}} option is selected, cycles,
branch mispredictions, cache misses and other metrics will be collected.

\noindent\sphinxincludegraphics{{vtune-select-uarch-profiling}.png}

\sphinxAtStartPar
After executing the \sphinxcode{\sphinxupquote{microarchitecture exploration}}, a summary will
be shown. Hovering the mouse over the red flags will explain what
each sentence means and how it impacts performance.

\noindent\sphinxincludegraphics{{vtune-uarch-profiling-summary}.png}

\sphinxAtStartPar
Clicking in the \sphinxcode{\sphinxupquote{Bottom\sphinxhyphen{}up}} tab shows all the information per module.
A plethora of stats such as CPU time, instructions retired,
retiring percentage (how many of the dispatched instructions
were executed until the end, usually lower than 100\% because of branch
mispredictions), bad speculation, cache misses, unused load ports,
and more.

\sphinxAtStartPar
The stats for the wifi module are shown below. The retiring
metric indicates about 40\% of dispatched instructions are
executed. The diagram on the right shows the bottleneck is
in the front\sphinxhyphen{}end of the pipeline (red), due to high
instruction cache misses, translation lookaside buffer (TLB)
overhead and unknown branches (most likely callbacks).

\noindent\sphinxincludegraphics{{vtune-uarch-wifi-stats}.png}

\sphinxAtStartPar
The stats for the core module are shown below.
More specifically for the ns3::Object::DoGetObject function.
Metrics indicates about 63\% of bad speculations.
The diagram on the right shows that there are bottlenecks
both in the front\sphinxhyphen{}end and due to bad speculation (red).

\noindent\sphinxincludegraphics{{vtune-uarch-core-stats}.png}


\subsection{System calls profilers}
\label{\detokenize{profiling:system-calls-profilers}}
\sphinxAtStartPar
System call profilers collect information on which system
calls were made by a program, how long they took to be
fulfilled and how many of them resulted in errors.

\sphinxAtStartPar
There are many system call profilers, including \sphinxhref{https://github.com/opendtrace/documentation}{dtrace}, \sphinxhref{https://strace.io/}{strace} and \sphinxhref{https://docs.microsoft.com/en-us/sysinternals/downloads/procmon}{procmon}.

\sphinxAtStartPar
An overview on how to use \sphinxhref{https://strace.io/}{strace} is provided in the following section.


\subsubsection{Strace}
\label{\detokenize{profiling:id9}}
\sphinxAtStartPar
The \sphinxhref{https://strace.io/}{strace} is a system calls (syscalls) profiler for Linux. It can filter
specific syscalls, or gather stats during the execution.

\sphinxAtStartPar
To collect statistics, use \sphinxcode{\sphinxupquote{strace \sphinxhyphen{}c}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}command\PYGZhy{}template \PYGZdq{}strace \PYGZhy{}c \PYGZpc{}s\PYGZdq{} \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\PYG{g+go}{MCS value               Channel width           GI                      Throughput}
\PYG{g+go}{0                       20 MHz                  3200 ns                 5.91733 Mbit/s}
\PYG{g+go}{...}
\PYG{g+go}{11                      160 MHz                 800 ns                  524.459 Mbit/s}
\PYG{g+gp}{\PYGZpc{} }\PYG{n+nb}{time}\PYG{+w}{     }seconds\PYG{+w}{  }usecs/call\PYG{+w}{     }calls\PYG{+w}{    }errors\PYG{+w}{ }syscall
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{ 37.62    0.004332          13       326       233 openat}
\PYG{g+go}{ 35.46    0.004083           9       415           mmap}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{100.00    0.011515           8      1378       251 total}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the example above, the syscalls are listed in the right, after
the time spent on each syscall, number of calls and errors.

\sphinxAtStartPar
The errors can be caused due to multiple reasons and may not
be a problem. To check if they were problems, strace can log the
syscalls with \sphinxcode{\sphinxupquote{strace \sphinxhyphen{}o calls.log}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{} ./ns3 run \PYGZdq{}wifi\PYGZhy{}he\PYGZhy{}network \PYGZhy{}\PYGZhy{}simulationTime=0.3 \PYGZhy{}\PYGZhy{}frequency=5 \PYGZhy{}\PYGZhy{}useRts=1 \PYGZhy{}\PYGZhy{}minExpectedThroughput=6 \PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{} \PYGZhy{}\PYGZhy{}command\PYGZhy{}template \PYGZdq{}strace \PYGZhy{}o calls.log \PYGZpc{}s\PYGZdq{} \PYGZhy{}\PYGZhy{}no\PYGZhy{}build}
\PYG{g+go}{MCS value               Channel width           GI                      Throughput}
\PYG{g+go}{0                       20 MHz                  3200 ns                 5.91733 Mbit/s}
\PYG{g+go}{...}
\PYG{g+go}{11                      160 MHz                 800 ns                  524.459 Mbit/s}
\end{sphinxVerbatim}

\sphinxAtStartPar
Looking at the \sphinxcode{\sphinxupquote{calls.log}} file, we can see different sections. In the
following section, the example is executed (\sphinxcode{\sphinxupquote{execve}}), architecture is checked (\sphinxcode{\sphinxupquote{arch\_prctl}}),
memory is mapped for execution (\sphinxcode{\sphinxupquote{mmap}}) and LD\_PRELOAD use is checked.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{execve(\PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/examples/wireless/ns3\PYGZhy{}dev\PYGZhy{}wifi\PYGZhy{}he\PYGZhy{}network\PYGZdq{}, [\PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/b\PYGZdq{}..., \PYGZdq{}\PYGZhy{}\PYGZhy{}simulationTime=0.3\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}frequency=5\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}useRts=1\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}minExpectedThroughput=6\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}maxExpectedThroughput=745\PYGZdq{}], 0x7fffb0f91ad8 /* 3 vars */) = 0}
\PYG{g+go}{brk(NULL)                               = 0x563141b37000}
\PYG{g+go}{arch\PYGZus{}prctl(0x3001 /* ARCH\PYGZus{}??? */, 0x7ffff8d63a50) = \PYGZhy{}1 EINVAL (Invalid argument)}
\PYG{g+go}{mmap(NULL, 8192, PROT\PYGZus{}READ|PROT\PYGZus{}WRITE, MAP\PYGZus{}PRIVATE|MAP\PYGZus{}ANONYMOUS, \PYGZhy{}1, 0) = 0x7f103c2e9000}
\PYG{g+go}{access(\PYGZdq{}/etc/ld.so.preload\PYGZdq{}, R\PYGZus{}OK)      = \PYGZhy{}1 ENOENT (No such file or directory)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then the program searches for the wifi module library and fails multiple times (the errors seen in the table above).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/glibc\PYGZhy{}hwcaps/x86\PYGZhy{}64\PYGZhy{}v3/libns3\PYGZhy{}dev\PYGZhy{}wifi.so\PYGZdq{}, O\PYGZus{}RDONLY|O\PYGZus{}CLOEXEC) = \PYGZhy{}1 ENOENT (No such file or directory)}
\PYG{g+go}{newfstatat(AT\PYGZus{}FDCWD, \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/glibc\PYGZhy{}hwcaps/x86\PYGZhy{}64\PYGZhy{}v3\PYGZdq{}, 0x7ffff8d62c80, 0) = \PYGZhy{}1 ENOENT (No such file or directory)}
\PYG{g+go}{...}
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/x86\PYGZus{}64/libns3\PYGZhy{}dev\PYGZhy{}wifi.so\PYGZdq{}, O\PYGZus{}RDONLY|O\PYGZus{}CLOEXEC) = \PYGZhy{}1 ENOENT (No such file or directory)}
\PYG{g+go}{newfstatat(AT\PYGZus{}FDCWD, \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/x86\PYGZus{}64\PYGZdq{}, 0x7ffff8d62c80, 0) = \PYGZhy{}1 ENOENT (No such file or directory)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The library is finally found and its header is read:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/lib/libns3\PYGZhy{}dev\PYGZhy{}wifi.so\PYGZdq{}, O\PYGZus{}RDONLY|O\PYGZus{}CLOEXEC) = 3}
\PYG{g+go}{read(3, \PYGZdq{}\PYGZbs{}177ELF\PYGZbs{}2\PYGZbs{}1\PYGZbs{}1\PYGZbs{}3\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}3\PYGZbs{}0\PYGZgt{}\PYGZbs{}0\PYGZbs{}1\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0py\PYGZbs{}30\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZbs{}0\PYGZdq{}..., 832) = 832}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then other modules that wifi depends on are loaded, then execution of the program continues to the main
function of the simulation.

\sphinxAtStartPar
Strace was used to track down issues found while running the \sphinxcode{\sphinxupquote{lena\sphinxhyphen{}radio\sphinxhyphen{}link\sphinxhyphen{}failure}} example.
Its \sphinxcode{\sphinxupquote{strace \sphinxhyphen{}c}} table was the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZpc{} }\PYG{n+nb}{time}\PYG{+w}{     }seconds\PYG{+w}{  }usecs/call\PYG{+w}{     }calls\PYG{+w}{    }errors\PYG{+w}{ }syscall
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{ 31,51    0,246243           2    103480       942 openat}
\PYG{g+go}{ 30,23    0,236284           2    102360           write}
\PYG{g+go}{ 19,90    0,155493           1    102538           close}
\PYG{g+go}{ 16,65    0,130132           1    102426           lseek}
\PYG{g+go}{  1,05    0,008186          18       437           mmap}
\PYG{g+go}{  0,21    0,001671          16        99           newfstatat}
\PYG{g+go}{  0,20    0,001595          11       134           mprotect}
\PYG{g+go}{  0,18    0,001391          14        98           read}
\PYG{g+go}{...}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{100,00    0,781554           1    411681       951 total}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice the number of \sphinxcode{\sphinxupquote{openat}}, \sphinxcode{\sphinxupquote{write}}, \sphinxcode{\sphinxupquote{close}} and \sphinxcode{\sphinxupquote{lseek}} calls
are much more frequent than the other calls. These mean
\sphinxcode{\sphinxupquote{lena\sphinxhyphen{}radio\sphinxhyphen{}link\sphinxhyphen{}failure}} is opening, then seeking, then writing,
then closing at least one file handler.

\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{strace}}, we can easily find the most frequently used file handlers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}ns\PYGZhy{}3\PYGZhy{}dev/\PYGZdl{}./ns3 run \PYGZdq{}lena\PYGZhy{}radio\PYGZhy{}link\PYGZhy{}failure \PYGZhy{}\PYGZhy{}numberOfEnbs=2 \PYGZhy{}\PYGZhy{}useIdealRrc=0 \PYGZhy{}\PYGZhy{}interSiteDistance=700 \PYGZhy{}\PYGZhy{}simTime=17\PYGZdq{} \PYGZhy{}\PYGZhy{}command\PYGZhy{}template=\PYGZdq{}strace \PYGZpc{}s\PYGZdq{}}
\PYG{g+go}{...}
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}DlTxPhyStats.txt\PYGZdq{}, O\PYGZus{}WRONLY|O\PYGZus{}CREAT|O\PYGZus{}APPEND, 0666) = 3}
\PYG{g+go}{lseek(3, 0, SEEK\PYGZus{}END)                   = 9252}
\PYG{g+go}{write(3, \PYGZdq{}635\PYGZbs{}t1\PYGZbs{}t1\PYGZbs{}t1\PYGZbs{}t0\PYGZbs{}t20\PYGZbs{}t1191\PYGZbs{}t0\PYGZbs{}t1\PYGZbs{}t0\PYGZbs{}n\PYGZdq{}, 26) = 26}
\PYG{g+go}{close(3)                                = 0}
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}DlMacStats.txt\PYGZdq{}, O\PYGZus{}WRONLY|O\PYGZus{}CREAT|O\PYGZus{}APPEND, 0666) = 3}
\PYG{g+go}{lseek(3, 0, SEEK\PYGZus{}END)                   = 11100}
\PYG{g+go}{write(3, \PYGZdq{}0.635\PYGZbs{}t1\PYGZbs{}t1\PYGZbs{}t64\PYGZbs{}t6\PYGZbs{}t1\PYGZbs{}t20\PYGZbs{}t1191\PYGZbs{}t0\PYGZbs{}t0\PYGZbs{}t0\PYGZbs{}n\PYGZdq{}, 31) = 31}
\PYG{g+go}{close(3)                                = 0}
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}UlMacStats.txt\PYGZdq{}, O\PYGZus{}WRONLY|O\PYGZus{}CREAT|O\PYGZus{}APPEND, 0666) = 3}
\PYG{g+go}{lseek(3, 0, SEEK\PYGZus{}END)                   = 8375}
\PYG{g+go}{write(3, \PYGZdq{}0.635\PYGZbs{}t1\PYGZbs{}t1\PYGZbs{}t64\PYGZbs{}t6\PYGZbs{}t1\PYGZbs{}t0\PYGZbs{}t85\PYGZbs{}t0\PYGZbs{}n\PYGZdq{}, 24) = 24}
\PYG{g+go}{close(3)                                = 0}
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}DlRsrpSinrStats.txt\PYGZdq{}, O\PYGZus{}WRONLY|O\PYGZus{}CREAT|O\PYGZus{}APPEND, 0666) = 3}
\PYG{g+go}{lseek(3, 0, SEEK\PYGZus{}END)                   = 16058}
\PYG{g+go}{write(3, \PYGZdq{}0.635214\PYGZbs{}t1\PYGZbs{}t1\PYGZbs{}t1\PYGZbs{}t6.88272e\PYGZhy{}15\PYGZbs{}t22.99\PYGZdq{}..., 37) = 37}
\PYG{g+go}{close(3)                                = 0}
\PYG{g+go}{openat(AT\PYGZus{}FDCWD, \PYGZdq{}UlTxPhyStats.txt\PYGZdq{}, O\PYGZus{}WRONLY|O\PYGZus{}CREAT|O\PYGZus{}APPEND, 0666) = 3}
\PYG{g+go}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
With the name of the files, we can look at the code that manipulates them.

\sphinxAtStartPar
The issue above was found in \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/777}{MR777}, were performance for some LTE examples
regressed for no apparent reason. The flame graph below, produced by \sphinxhref{https://www.amd.com/en/developer/uprof.html}{AMD uProf},
contains four large columns/”flames” in red, which
correspond to the \sphinxcode{\sphinxupquote{write}}, \sphinxcode{\sphinxupquote{openat}}, \sphinxcode{\sphinxupquote{close}} and \sphinxcode{\sphinxupquote{lseek}} syscalls.

\noindent\sphinxincludegraphics{{uprof-strace-lte}.png}

\sphinxAtStartPar
Upon closer inspection, these syscalls take a long time to complete due to
the underlying filesystem of the machine running the example (NTFS mount
using the ntfs\sphinxhyphen{}3g FUSE filesystem). In other words, the bottleneck only
exists when running the example in slow file systems
(e.g. FUSE and network file systems).

\sphinxAtStartPar
The merge request \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/814}{MR814} addressed the issue by keeping the files open
throughout the simulation. That alone resulted in a 1.75x speedup.


\subsection{Compilation Profilers}
\label{\detokenize{profiling:compilation-profilers}}
\sphinxAtStartPar
Compilation profilers can help identifying which steps of the compilation
are slowing it down. These profilers are built into the compilers themselves,
only requiring third\sphinxhyphen{}party tools to consolidate the results.

\sphinxAtStartPar
The GCC feature is mentioned and exemplified, but is not the recommended
compilation profiling method. For that, Clang is recommended.


\subsubsection{GCC}
\label{\detokenize{profiling:gcc}}
\sphinxAtStartPar
GCC has a special flag \sphinxcode{\sphinxupquote{\sphinxhyphen{}ftime\sphinxhyphen{}report}}, which makes it print a table
with time spent per compilation phase for each compiled file. The printed
output for a file is shown below. The line of \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}}} was inserted for clarity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{Time variable                      usr           sys          wall               GGC}
\PYG{g+go}{phase setup            :   0.00 (  0\PYGZpc{})   0.00 (  0\PYGZpc{})   0.01 (  1\PYGZpc{})    1478 kB (  2\PYGZpc{})}
\PYG{g+go}{phase parsing          :   0.31 ( 46\PYGZpc{})   0.17 ( 85\PYGZpc{})   0.48 ( 55\PYGZpc{})   55432 kB ( 71\PYGZpc{})}
\PYG{g+go}{phase lang. deferred   :   0.03 (  4\PYGZpc{})   0.00 (  0\PYGZpc{})   0.03 (  3\PYGZpc{})    4287 kB (  5\PYGZpc{})}
\PYG{g+go}{phase opt and generate :   0.32 ( 48\PYGZpc{})   0.03 ( 15\PYGZpc{})   0.35 ( 40\PYGZpc{})   16635 kB ( 21\PYGZpc{})}
\PYG{g+go}{phase last asm         :   0.01 (  1\PYGZpc{})   0.00 (  0\PYGZpc{})   0.01 (  1\PYGZpc{})     769 kB (  1\PYGZpc{})}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{|name lookup           :   0.05 (  7\PYGZpc{})   0.02 ( 10\PYGZpc{})   0.04 (  5\PYGZpc{})    2468 kB (  3\PYGZpc{})}
\PYG{g+go}{|overload resolution   :   0.05 (  7\PYGZpc{})   0.00 (  0\PYGZpc{})   0.05 (  6\PYGZpc{})    4217 kB (  5\PYGZpc{})}
\PYG{g+go}{dump files             :   0.00 (  0\PYGZpc{})   0.00 (  0\PYGZpc{})   0.01 (  1\PYGZpc{})       0 kB (  0\PYGZpc{})}
\PYG{g+go}{callgraph construction :   0.01 (  1\PYGZpc{})   0.00 (  0\PYGZpc{})   0.01 (  1\PYGZpc{})    2170 kB (  3\PYGZpc{})}
\PYG{g+go}{...}
\PYG{g+go}{preprocessing          :   0.05 (  7\PYGZpc{})   0.06 ( 30\PYGZpc{})   0.10 ( 11\PYGZpc{})    1751 kB (  2\PYGZpc{})}
\PYG{g+go}{parser (global)        :   0.06 (  9\PYGZpc{})   0.03 ( 15\PYGZpc{})   0.07 (  8\PYGZpc{})   16303 kB ( 21\PYGZpc{})}
\PYG{g+go}{parser struct body     :   0.06 (  9\PYGZpc{})   0.04 ( 20\PYGZpc{})   0.08 (  9\PYGZpc{})   12525 kB ( 16\PYGZpc{})}
\PYG{g+go}{parser enumerator list :   0.01 (  1\PYGZpc{})   0.00 (  0\PYGZpc{})   0.00 (  0\PYGZpc{})     112 kB (  0\PYGZpc{})}
\PYG{g+go}{parser function body   :   0.02 (  3\PYGZpc{})   0.02 ( 10\PYGZpc{})   0.02 (  2\PYGZpc{})    3039 kB (  4\PYGZpc{})}
\PYG{g+go}{parser inl. func. body :   0.03 (  4\PYGZpc{})   0.00 (  0\PYGZpc{})   0.01 (  1\PYGZpc{})    2024 kB (  3\PYGZpc{})}
\PYG{g+go}{parser inl. meth. body :   0.02 (  3\PYGZpc{})   0.01 (  5\PYGZpc{})   0.06 (  7\PYGZpc{})    5792 kB (  7\PYGZpc{})}
\PYG{g+go}{template instantiation :   0.09 ( 13\PYGZpc{})   0.01 (  5\PYGZpc{})   0.13 ( 15\PYGZpc{})   12274 kB ( 16\PYGZpc{})}
\PYG{g+go}{...}
\PYG{g+go}{symout                 :   0.01 (  1\PYGZpc{})   0.00 (  0\PYGZpc{})   0.02 (  2\PYGZpc{})    8114 kB ( 10\PYGZpc{})}
\PYG{g+go}{...}
\PYG{g+go}{TOTAL                  :   0.67          0.20          0.88          78612 kB}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the table above, the first few lines show the five main compilations steps: \sphinxcode{\sphinxupquote{setup}},
\sphinxcode{\sphinxupquote{parsing}}, \sphinxcode{\sphinxupquote{lang. deferred}} (C++ specific transformations),
\sphinxcode{\sphinxupquote{opt(imize) and generate (code)}}, \sphinxcode{\sphinxupquote{last asm}} (produce binary code).

\sphinxAtStartPar
The lines below the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}}} line show sub\sphinxhyphen{}steps of the five main compilation steps.
For this specific case, parsing global definitions (21\%) and structures (16\%),
\sphinxcode{\sphinxupquote{template instantiation}} (16\%) and generating the code in \sphinxcode{\sphinxupquote{symout}} (10\%).

\sphinxAtStartPar
Aggregating the data into a meaningful output to help focus where to improve is not that easy
and it is \sphinxhref{https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=92396}{not a priority} for GCC developers.

\sphinxAtStartPar
It is recommended to use the Clang alternative.


\subsubsection{Clang}
\label{\detokenize{profiling:clang}}\label{\detokenize{profiling:id10}}
\sphinxAtStartPar
Clang can output very similar results with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}ftime\sphinxhyphen{}trace}} flag, but can also aggregate
it in a more meaningful way. With the help of the third\sphinxhyphen{}party tool \sphinxhref{https://github.com/aras-p/ClangBuildAnalyzer}{ClangBuildAnalyzer},
we can have really good insights on where to spend time trying to speed up the compilation.

\sphinxAtStartPar
Support for building with \sphinxcode{\sphinxupquote{\sphinxhyphen{}ftime\sphinxhyphen{}trace}}, compiling \sphinxhref{https://github.com/aras-p/ClangBuildAnalyzer}{ClangBuildAnalyzer} and producing a
report for the project have been baked into the CMake project of ns\sphinxhyphen{}3, and can be enabled
with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DNS3\_CLANG\_TIMETRACE=ON}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZus{}cache\PYGZdl{} cmake \PYGZhy{}DNS3\PYGZus{}CLANG\PYGZus{}TIMETRACE=ON ..}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or via \sphinxcode{\sphinxupquote{ns3}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}CLANG\PYGZus{}TIMETRACE=ON}
\end{sphinxVerbatim}

\sphinxAtStartPar
The entire procedure looks like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} CXX=\PYGZdq{}clang++\PYGZdq{} ./ns3 configure \PYGZhy{}d release \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}CLANG\PYGZus{}TIMETRACE=ON}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build timeTraceReport}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} cat ClangBuildAnalyzerReport.txt}
\PYG{g+go}{Analyzing build trace from \PYGZsq{}\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZus{}cache/clangBuildAnalyzerReport.bin\PYGZsq{}...}
\PYG{g+go}{**** Time summary:}
\PYG{g+go}{Compilation (2993 times):}
\PYG{g+go}{  Parsing (frontend):         2476.1 s}
\PYG{g+go}{  Codegen \PYGZam{} opts (backend):   1882.9 s}

\PYG{g+go}{**** Files that took longest to parse (compiler frontend):}
\PYG{g+go}{  8966 ms: src/test/CMakeFiles/libtest.dir/traced/traced\PYGZhy{}callback\PYGZhy{}typedef\PYGZhy{}test\PYGZhy{}suite.cc.o}
\PYG{g+go}{  6633 ms: src/wifi/examples/CMakeFiles/wifi\PYGZhy{}bianchi.dir/wifi\PYGZhy{}bianchi.cc.o}
\PYG{g+go}{...}

\PYG{g+go}{**** Files that took longest to codegen (compiler backend):}
\PYG{g+go}{36430 ms: src/wifi/CMakeFiles/libwifi\PYGZhy{}test.dir/test/block\PYGZhy{}ack\PYGZhy{}test\PYGZhy{}suite.cc.o}
\PYG{g+go}{24941 ms: src/wifi/CMakeFiles/libwifi\PYGZhy{}test.dir/test/wifi\PYGZhy{}mac\PYGZhy{}ofdma\PYGZhy{}test.cc.o}
\PYG{g+go}{...}

\PYG{g+go}{**** Templates that took longest to instantiate:}
\PYG{g+go}{12651 ms: std::unordered\PYGZus{}map\PYGZlt{}int, int\PYGZgt{} (615 times, avg 20 ms)}
\PYG{g+go}{10950 ms: std::\PYGZus{}Hashtable\PYGZlt{}int, std::pair\PYGZlt{}const int, int\PYGZgt{}, std::allocator\PYGZlt{}std::... (615 times, avg 17 ms)}
\PYG{g+go}{10712 ms: std::\PYGZus{}\PYGZus{}detail::\PYGZus{}\PYGZus{}hyperg\PYGZlt{}long double\PYGZgt{} (1172 times, avg 9 ms)}
\PYG{g+go}{...}

\PYG{g+go}{**** Template sets that took longest to instantiate:}
\PYG{g+go}{111660 ms: std::list\PYGZlt{}\PYGZdl{}\PYGZgt{} (27141 times, avg 4 ms)}
\PYG{g+go}{ 79892 ms: std::\PYGZus{}List\PYGZus{}base\PYGZlt{}\PYGZdl{}\PYGZgt{} (27140 times, avg 2 ms)}
\PYG{g+go}{ 75131 ms: std::map\PYGZlt{}\PYGZdl{}\PYGZgt{} (11752 times, avg 6 ms)}
\PYG{g+go}{ 65214 ms: std::allocator\PYGZlt{}\PYGZdl{}\PYGZgt{} (66622 times, avg 0 ms)}
\PYG{g+go}{...}

\PYG{g+go}{**** Functions that took longest to compile:}
\PYG{g+go}{  7206 ms: OfdmaAckSequenceTest::CheckResults(ns3::Time, ns3::Time, unsigned ch... (\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/wifi/test/wifi\PYGZhy{}mac\PYGZhy{}ofdma\PYGZhy{}test.cc)}
\PYG{g+go}{  6146 ms: PieQueueDiscTestCase::RunPieTest(ns3::QueueSizeUnit) (\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/src/traffic\PYGZhy{}control/test/pie\PYGZhy{}queue\PYGZhy{}disc\PYGZhy{}test\PYGZhy{}suite.cc)}
\PYG{g+go}{...}

\PYG{g+go}{**** Function sets that took longest to compile / optimize:}
\PYG{g+go}{14801 ms: std::\PYGZus{}\PYGZus{}cxx11::basic\PYGZus{}string\PYGZlt{}\PYGZdl{}\PYGZgt{} ns3::CallbackImplBase::GetCppTypeid\PYGZlt{}\PYGZdl{}\PYGZgt{}() (2342 times, avg 6 ms)}
\PYG{g+go}{12013 ms: ns3::CallbackImpl\PYGZlt{}\PYGZdl{}\PYGZgt{}::DoGetTypeid[abi:cxx11]() (1283 times, avg 9 ms)}
\PYG{g+go}{10034 ms: ns3::Ptr\PYGZlt{}\PYGZdl{}\PYGZgt{}::\PYGZti{}Ptr() (5975 times, avg 1 ms)}
\PYG{g+go}{ 8932 ms: ns3::Callback\PYGZlt{}\PYGZdl{}\PYGZgt{}::DoAssign(ns3::Ptr\PYGZlt{}\PYGZdl{}\PYGZgt{}) (591 times, avg 15 ms)}
\PYG{g+go}{ 6318 ms: ns3::CallbackImpl\PYGZlt{}\PYGZdl{}\PYGZgt{}::DoGetTypeid() (431 times, avg 14 ms)}
\PYG{g+go}{...}

\PYG{g+go}{*** Expensive headers:}
\PYG{g+go}{293609 ms: \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/log.h (included 1404 times, avg 209 ms), included via:}
\PYG{g+go}{  cqa\PYGZhy{}ff\PYGZhy{}mac\PYGZhy{}scheduler.cc.o  (758 ms)}
\PYG{g+go}{  ipv6\PYGZhy{}list\PYGZhy{}routing.cc.o  (746 ms)}
\PYG{g+go}{  ...}

\PYG{g+go}{239884 ms: \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/nstime.h (included 1093 times, avg 219 ms), included via:}
\PYG{g+go}{  lte\PYGZhy{}enb\PYGZhy{}rrc.cc.o lte\PYGZhy{}enb\PYGZhy{}rrc.h  (891 ms)}
\PYG{g+go}{  wifi\PYGZhy{}acknowledgment.cc.o wifi\PYGZhy{}acknowledgment.h  (877 ms)}
\PYG{g+go}{  ...}

\PYG{g+go}{216218 ms: \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/object.h (included 1205 times, avg 179 ms), included via:}
\PYG{g+go}{  energy\PYGZhy{}source\PYGZhy{}container.cc.o energy\PYGZhy{}source\PYGZhy{}container.h energy\PYGZhy{}source.h  (1192 ms)}
\PYG{g+go}{  phased\PYGZhy{}array\PYGZhy{}model.cc.o phased\PYGZhy{}array\PYGZhy{}model.h  (1135 ms)}
\PYG{g+go}{  ...}

\PYG{g+go}{206801 ms: \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/core\PYGZhy{}module.h (included 195 times, avg 1060 ms), included via:}
\PYG{g+go}{  sample\PYGZhy{}show\PYGZhy{}progress.cc.o  (1973 ms)}
\PYG{g+go}{  length\PYGZhy{}example.cc.o  (1848 ms)}
\PYG{g+go}{  ...}

\PYG{g+go}{193116 ms: /usr/bin/../lib/gcc/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/11/../../../../include/c++/11/bits/basic\PYGZus{}string.h (included 1499 times, avg 128 ms), included via:}
\PYG{g+go}{  model\PYGZhy{}typeid\PYGZhy{}creator.h attribute\PYGZhy{}default\PYGZhy{}iterator.h type\PYGZhy{}id.h attribute.h string  (250 ms)}
\PYG{g+go}{  li\PYGZhy{}ion\PYGZhy{}energy\PYGZhy{}source\PYGZhy{}helper.h energy\PYGZhy{}model\PYGZhy{}helper.h attribute.h string  (243 ms)}
\PYG{g+go}{  ...}

\PYG{g+go}{185075 ms: /usr/bin/../lib/gcc/x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu/11/../../../../include/c++/11/bits/ios\PYGZus{}base.h (included 1495 times, avg 123 ms), included via:}
\PYG{g+go}{  iomanip  (403 ms)}
\PYG{g+go}{  mpi\PYGZhy{}test\PYGZhy{}fixtures.h iomanip  (364 ms)}
\PYG{g+go}{  ...}

\PYG{g+go}{169464 ms: \PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/build/include/ns3/ptr.h (included 1399 times, avg 121 ms), included via:}
\PYG{g+go}{  lte\PYGZhy{}test\PYGZhy{}rlc\PYGZhy{}um\PYGZhy{}e2e.cc.o config.h  (568 ms)}
\PYG{g+go}{  lte\PYGZhy{}test\PYGZhy{}rlc\PYGZhy{}um\PYGZhy{}transmitter.cc.o simulator.h event\PYGZhy{}id.h  (560 ms)}
\PYG{g+go}{  ...}


\PYG{g+go}{  done in 2.8s.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output printed out contain a summary of time spent on parsing and on code generation, along
with multiple lists for different tracked categories. From the summary, it is clear that parsing times
are very high when compared to the optimization time (\sphinxcode{\sphinxupquote{\sphinxhyphen{}O3}}). Skipping the others categories and going straight
to the expensive headers section, we can better understand why parsing times are so high, with some headers
adding as much as 5 minutes of CPU time to the parsing time.

\sphinxAtStartPar
Precompiled headers (\sphinxcode{\sphinxupquote{\sphinxhyphen{}DNS3\_PRECOMPILE\_HEADERS=ON}}) can \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/731\#note\_687176503}{drastically speed up parsing times},
however, they can increase ccache misses, reducing the time of the first
compilation at the cost of increasing recompilation times.


\subsubsection{NinjaTracing}
\label{\detokenize{profiling:id11}}
\sphinxAtStartPar
If the Ninja generator is being used (\sphinxcode{\sphinxupquote{./ns3 configure \sphinxhyphen{}G Ninja}}), its build log
can be used to identify targets slowing down the build process. The \sphinxhref{https://github.com/nico/ninjatracing}{NinjaTracing}
utility is used to convert the log format into a tracing Json file.

\sphinxAtStartPar
The following steps show how it can be used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}ninja\PYGZhy{}tracing}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build ninjaTrace}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output \sphinxcode{\sphinxupquote{ninja\_performance\_trace.json}} should be located in the \sphinxcode{\sphinxupquote{\textasciitilde{}/ns\sphinxhyphen{}3\sphinxhyphen{}dev}} directory.
You can then visualize the results using the \sphinxcode{\sphinxupquote{about:tracing}} panel available in
Chromium\sphinxhyphen{}based browser or with a compatible trace viewer such as \sphinxhref{https://ui.perfetto.dev/}{Perfetto UI}.

\sphinxAtStartPar
It can also be used in conjunction with the {\hyperref[\detokenize{profiling:clang}]{\sphinxcrossref{Clang}}} time\sphinxhyphen{}trace feature for more granular
information from within the compiler and linker.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} CXX=clang++ ./ns3 configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}ninja\PYGZhy{}tracing \PYGZhy{}\PYGZhy{} \PYGZhy{}DNS3\PYGZus{}CLANG\PYGZus{}TIMETRACE=ON}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 build ninjaTrace}
\end{sphinxVerbatim}


\subsection{CMake Profiler}
\label{\detokenize{profiling:cmake-profiler}}
\sphinxAtStartPar
CMake has a built\sphinxhyphen{}in tracer that permits tracking hotspots in the CMake files slowing down the
project configuration. To use the tracer, call cmake directly from a clean CMake cache directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/cmake\PYGZhy{}cache\PYGZdl{} cmake .. \PYGZhy{}\PYGZhy{}profiling\PYGZhy{}format=google\PYGZhy{}trace \PYGZhy{}\PYGZhy{}profiling\PYGZhy{}output=../cmake\PYGZus{}performance\PYGZus{}trace.log}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or using the ns3 wrapper:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} ./ns3 configure \PYGZhy{}\PYGZhy{}trace\PYGZhy{}performance}
\end{sphinxVerbatim}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{cmake\_performance\_trace.log}} file will be generated in the ns\sphinxhyphen{}3\sphinxhyphen{}dev directory.
The tracing results can be visualized using the \sphinxcode{\sphinxupquote{about:tracing}} panel available
in Chromium\sphinxhyphen{}based browsers or a compatible trace viewer such as \sphinxhref{https://ui.perfetto.dev/}{Perfetto UI}.

\sphinxAtStartPar
After opening the trace file, select the traced process and click on
any of the blocks to inspect the different stacks and find hotspots.
An auxiliary panel containing the function/macro name, arguments
and location can be shown, providing enough information to trace
back the location of each specific call.

\sphinxAtStartPar
Just like in performance profilers, visual inspection makes it easier
to identify hotspots and focus on trying to optimize what matters most.

\sphinxAtStartPar
The trace below was generated during the discussion of \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/issues/588}{issue \#588},
while investigating the long configuration times, especially when using HDDs.

\sphinxAtStartPar
The single largest contributor was CMake’s \sphinxcode{\sphinxupquote{configure\_file}}, used to keeping
up\sphinxhyphen{}to\sphinxhyphen{}date copies of headers in the output directory.

\noindent\sphinxincludegraphics{{perfetto-trace-cmake}.png}

\sphinxAtStartPar
In \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/merge\_requests/911}{MR911}, alternatives such as stub headers that include the original header
files, keeping them in their respective modules, and symlinking headers to the
output directory were used to reduce the configuration overhead.

\sphinxAtStartPar
Note: when testing I/O bottlenecks, you may want to drop filesystem caches,
otherwise the cache may hide the issues. In Linux, the caches can be cleared
using the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} sudo sysctl vm.drop\PYGZus{}caches=3}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Working with gitlab\sphinxhyphen{}ci\sphinxhyphen{}local}
\label{\detokenize{working-with-gitlab-ci-local:working-with-gitlab-ci-local}}\label{\detokenize{working-with-gitlab-ci-local::doc}}
\sphinxAtStartPar
The ns\sphinxhyphen{}3 project repository is currently hosted in GitLab, which includes
\sphinxhref{https://docs.gitlab.com/ee/ci/}{continuous integration (CI)} tools to automate build, tests, packaging and
distribution of software. The CI works based on jobs, that are defined
on YAML files.

\sphinxAtStartPar
The ns\sphinxhyphen{}3 GitLab CI files are located in \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev/utils/tests/}}.
The main GitLab CI file is \sphinxcode{\sphinxupquote{gitlab\sphinxhyphen{}ci.yml}}. The different jobs
are used to check if a multitude of compilers and package versions
are compatible with the current ns\sphinxhyphen{}3 build, which is why a build is
usually followed by a test run. Other CI jobs build and warn about
missing the documentation.

\sphinxAtStartPar
The GitLab CI jobs are executed based on \sphinxhref{https://docs.gitlab.com/ee/ci/introduction/index.html\#continuous-integration}{pipelines} containing a
sequence of job batches. Jobs within a batch can be executed in parallel.
These \sphinxhref{https://docs.gitlab.com/ee/ci/introduction/index.html\#continuous-integration}{pipelines} can be triggered manually, or scheduled to run automatically
per commit and/or based on a time period
(ns\sphinxhyphen{}3 has \sphinxhref{https://gitlab.com/nsnam/ns-3-dev/-/pipeline\_schedules}{daily and weekly pipelines} scheduled).

\sphinxAtStartPar
The GitLab CI free tier is very slow, taking a lot of time to identify
issues during active merge request development.

\sphinxAtStartPar
Note: the free tier
now requires a credit card due to \sphinxhref{https://about.gitlab.com/blog/2021/05/17/prevent-crypto-mining-abuse/}{crypto miners abuse}.

\sphinxAtStartPar
\sphinxhref{https://github.com/firecow/gitlab-ci-local}{GitLab\sphinxhyphen{}CI\sphinxhyphen{}local} is a tool that allows an user to use the \sphinxhref{https://docs.gitlab.com/ee/ci/}{GitLab CI}
configuration files locally, allowing for the debugging of CI settings
and pipelines without requiring pushes to test repositories or main
repositories that fill up the CI job queues with failed jobs due to
script errors.

\sphinxAtStartPar
GitLab\sphinxhyphen{}CI\sphinxhyphen{}local relies on \sphinxhref{https://docs.docker.com/desktop/}{Docker} to setup the environment to execute
the jobs.

\sphinxAtStartPar
Note: Docker is usually setup in root mode, requiring
frequent use of administrative permissions/sudo. However,
this is highly discouraged. You can configure Docker to run
in \sphinxhref{https://docs.docker.com/engine/security/rootless/}{rootless mode}. From this point onwards, we assume Docker is configured
in \sphinxhref{https://docs.docker.com/engine/security/rootless/}{rootless mode}.

\sphinxAtStartPar
After installing both \sphinxhref{https://docs.docker.com/desktop/}{Docker} in \sphinxhref{https://docs.docker.com/engine/security/rootless/}{rootless mode} and \sphinxhref{https://github.com/firecow/gitlab-ci-local}{GitLab\sphinxhyphen{}CI\sphinxhyphen{}local},
the ns\sphinxhyphen{}3 jobs can be listed using the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{}\PYG{+w}{ }gitlab\PYGZhy{}ci\PYGZhy{}local\PYG{+w}{ }\PYGZhy{}\PYGZhy{}file\PYG{+w}{ }./utils/tests/gitlab\PYGZhy{}ci.yml\PYG{+w}{ }\PYGZhy{}\PYGZhy{}list
parsing\PYG{+w}{ }and\PYG{+w}{ }downloads\PYG{+w}{ }finished\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{226}\PYG{+w}{ }ms
name\PYG{+w}{                                   }description\PYG{+w}{  }stage\PYG{+w}{          }when\PYG{+w}{        }allow\PYGZus{}failure\PYG{+w}{  }needs
weekly\PYGZhy{}build\PYGZhy{}ubuntu\PYGZhy{}18.04\PYGZhy{}debug\PYG{+w}{                     }build\PYG{+w}{          }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}

...

weekly\PYGZhy{}build\PYGZhy{}clang\PYGZhy{}11\PYGZhy{}optimized\PYG{+w}{                     }build\PYG{+w}{          }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
cppyy\PYGZhy{}22.04\PYG{+w}{                                         }build\PYG{+w}{          }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
per\PYGZhy{}commit\PYGZhy{}compile\PYGZhy{}debug\PYG{+w}{                            }build\PYG{+w}{          }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
per\PYGZhy{}commit\PYGZhy{}compile\PYGZhy{}release\PYG{+w}{                          }build\PYG{+w}{          }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
per\PYGZhy{}commit\PYGZhy{}compile\PYGZhy{}optimized\PYG{+w}{                        }build\PYG{+w}{          }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
daily\PYGZhy{}test\PYGZhy{}debug\PYG{+w}{                                    }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
daily\PYGZhy{}test\PYGZhy{}release\PYG{+w}{                                  }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
daily\PYGZhy{}test\PYGZhy{}optimized\PYG{+w}{                                }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
daily\PYGZhy{}test\PYGZhy{}optimized\PYGZhy{}valgrind\PYG{+w}{                       }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
weekly\PYGZhy{}test\PYGZhy{}debug\PYGZhy{}valgrind\PYG{+w}{                          }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
weekly\PYGZhy{}test\PYGZhy{}release\PYGZhy{}valgrind\PYG{+w}{                        }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
weekly\PYGZhy{}test\PYGZhy{}optimized\PYGZhy{}valgrind\PYG{+w}{                      }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
weekly\PYGZhy{}test\PYGZhy{}takes\PYGZhy{}forever\PYGZhy{}optimized\PYG{+w}{                 }\PYG{n+nb}{test}\PYG{+w}{           }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
doxygen\PYG{+w}{                                             }documentation\PYG{+w}{  }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
manual\PYG{+w}{                                              }documentation\PYG{+w}{  }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
tutorial\PYG{+w}{                                            }documentation\PYG{+w}{  }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
models\PYG{+w}{                                              }documentation\PYG{+w}{  }on\PYGZus{}success\PYG{+w}{  }\PYG{n+nb}{false}
\end{sphinxVerbatim}

\sphinxAtStartPar
To execute the \sphinxcode{\sphinxupquote{per\sphinxhyphen{}commit\sphinxhyphen{}compile\sphinxhyphen{}release}} job, or any of the others listed above, use
the following command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} gitlab\PYGZhy{}ci\PYGZhy{}local \PYGZhy{}\PYGZhy{}file ./utils/tests/gitlab\PYGZhy{}ci.yml per\PYGZhy{}commit\PYGZhy{}compile\PYGZhy{}release}
\end{sphinxVerbatim}

\sphinxAtStartPar
WARNING: if you do not specify the job name, all jobs that can be executed in parallel will be
executed at the same time. You may run out of disk, memory or both.

\sphinxAtStartPar
Some jobs might require a previous job to complete successfully before getting started.
The doxygen job is one of these.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} gitlab\PYGZhy{}ci\PYGZhy{}local \PYGZhy{}\PYGZhy{}file ./utils/tests/gitlab\PYGZhy{}ci.yml doxygen}
\PYG{g+go}{Using fallback git user.name}
\PYG{g+go}{Using fallback git user.email}
\PYG{g+go}{parsing and downloads finished in 202 ms}
\PYG{g+go}{doxygen                               starting archlinux:latest (documentation)}
\PYG{g+go}{doxygen                               pulled archlinux:latest in 64 ms}
\PYG{g+go}{doxygen                               \PYGZgt{} still running...}
\PYG{g+go}{doxygen                               \PYGZgt{} still running...}
\PYG{g+go}{doxygen                               copied to container in 20 s}
\PYG{g+go}{doxygen                               imported cache \PYGZsq{}ccache\PYGZhy{}\PYGZsq{} in 3.67 s}
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev/.gitlab\PYGZhy{}ci\PYGZhy{}local/artifacts/pybindgen doesn\PYGZsq{}t exist, did you forget \PYGZhy{}\PYGZhy{}needs}
\end{sphinxVerbatim}

\sphinxAtStartPar
As instructed by the previous command output, you can add the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}needs}} to build required
jobs before proceeding. However, doing so will run all jobs as the \sphinxcode{\sphinxupquote{doxygen}} is only supposed
to run after weekly jobs are successfully executed.

\sphinxAtStartPar
Another option is to run the specific job that produces the required artifact. In this case
the \sphinxcode{\sphinxupquote{pybindgen}} job.

\sphinxAtStartPar
Note: Pybindgen has been replaced by Cppyy, which does not produce artifacts to be consumed
by other jobs. However, the example is kept for reference.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{} gitlab\PYGZhy{}ci\PYGZhy{}local \PYGZhy{}\PYGZhy{}file ./utils/tests/gitlab\PYGZhy{}ci.yml pybindgen}
\PYG{g+go}{Using fallback git user.name}
\PYG{g+go}{Using fallback git user.email}
\PYG{g+go}{parsing and downloads finished in 202 ms}
\PYG{g+go}{pybindgen                               starting archlinux:latest (build)}

\PYG{g+go}{...}

\PYG{g+go}{pybindgen                             \PYGZdl{} git diff src \PYGZgt{} pybindgen\PYGZus{}new.patch}
\PYG{g+go}{pybindgen                             exported artifacts in 911 ms}
\PYG{g+go}{pybindgen                             copied artifacts to cwd in 56 ms}
\PYG{g+go}{pybindgen                             finished in 5.77 min}

\PYG{g+go}{ PASS  pybindgen}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then run the doxygen job again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZti{}/ns\PYGZhy{}3\PYGZhy{}dev\PYGZdl{}\PYG{+w}{ }gitlab\PYGZhy{}ci\PYGZhy{}local\PYG{+w}{ }\PYGZhy{}\PYGZhy{}file\PYG{+w}{ }./utils/tests/gitlab\PYGZhy{}ci.yml\PYG{+w}{ }doxygen
Using\PYG{+w}{ }fallback\PYG{+w}{ }git\PYG{+w}{ }user.name
Using\PYG{+w}{ }fallback\PYG{+w}{ }git\PYG{+w}{ }user.email
parsing\PYG{+w}{ }and\PYG{+w}{ }downloads\PYG{+w}{ }finished\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{170}\PYG{+w}{ }ms
doxygen\PYG{+w}{                               }starting\PYG{+w}{ }archlinux:latest\PYG{+w}{ }\PYG{o}{(}documentation\PYG{o}{)}

...

doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{      }\PYG{l+m}{1}\PYG{+w}{ }files\PYG{+w}{ }with\PYG{+w}{ }warnings
doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{ }Doxygen\PYG{+w}{ }Warnings\PYG{+w}{ }Summary
doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{      }\PYG{l+m}{1}\PYG{+w}{ }directories
doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{      }\PYG{l+m}{1}\PYG{+w}{ }files
doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{     }\PYG{l+m}{23}\PYG{+w}{ }warnings
doxygen\PYG{+w}{                               }\PYGZgt{}\PYG{+w}{ }\PYG{k}{done}.
doxygen\PYG{+w}{                               }exported\PYG{+w}{ }cache\PYG{+w}{ }ns\PYGZhy{}3\PYGZhy{}ccache\PYGZhy{}storage/\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}ccache\PYGZhy{}\PYGZsq{}}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{6}.86\PYG{+w}{ }s
doxygen\PYG{+w}{                               }exported\PYG{+w}{ }artifacts\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{954}\PYG{+w}{ }ms
doxygen\PYG{+w}{                               }copied\PYG{+w}{ }artifacts\PYG{+w}{ }to\PYG{+w}{ }cwd\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{59}\PYG{+w}{ }ms
doxygen\PYG{+w}{                               }finished\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{l+m}{15}\PYG{+w}{ }min

\PYG{+w}{ }PASS\PYG{+w}{  }doxygen
\end{sphinxVerbatim}

\sphinxAtStartPar
Artifacts built by the CI jobs will be stored in separate subfolders
based on the job name.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textasciitilde{}/ns\sphinxhyphen{}3\sphinxhyphen{}dev/.gitlab\sphinxhyphen{}ci\sphinxhyphen{}local/artifacts/jobname}}

\sphinxstepscope


\chapter{Utilities}
\label{\detokenize{utilities:utilities}}\label{\detokenize{utilities:id1}}\label{\detokenize{utilities::doc}}

\section{Print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen}
\label{\detokenize{utilities:print-introspected-doxygen}}
\sphinxAtStartPar
\sphinxtitleref{print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen} is used to generate doxygen documentation
using various TypeIds defined throughout the \sphinxstyleemphasis{ns\sphinxhyphen{}3} source code.
The tool returns the various config paths, attributes, trace sources,
etc. for the various files in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Invocation}
\label{\detokenize{utilities:invocation}}
\sphinxAtStartPar
This tool is run automatically by the build system when generating
the Doxygen API docs, so you don’t normally have to run it by hand.

\sphinxAtStartPar
However, since it does give a fair bit of information about TypeIds
it can be useful to run from the command line and
search for specific information.

\sphinxAtStartPar
To run it, simply open terminal and type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }print\PYGZhy{}introspected\PYGZhy{}doxygen
\end{sphinxVerbatim}

\sphinxAtStartPar
This will give all the output, formatted for Doxygen, which can be viewed
in a text editor.

\sphinxAtStartPar
One way to use this is to capture it to a file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }print\PYGZhy{}introspected\PYGZhy{}doxygen\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }doc.html
\end{sphinxVerbatim}

\sphinxAtStartPar
Some users might prefer to use tools like grep
to locate the required piece of information from the documentation
instead of using an editor. For such uses\sphinxhyphen{}cases and more,
\sphinxtitleref{print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen} can return plain text:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}print\PYGZhy{}introspected\PYGZhy{}doxygen \PYGZhy{}\PYGZhy{}output\PYGZhy{}text\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Note the quotes around the inner command and options.)
\begin{quote}

\sphinxAtStartPar
\$ ./ns3 run “print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen \textendash{}output\sphinxhyphen{}text” | grep “hello”
\end{quote}

\sphinxAtStartPar
This will output the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*\PYG{+w}{ }HelloInterval:\PYG{+w}{ }HELLO\PYG{+w}{ }messages\PYG{+w}{ }emission\PYG{+w}{ }interval.
*\PYG{+w}{ }DeletePeriod:\PYG{+w}{ }DeletePeriod\PYG{+w}{ }is\PYG{+w}{ }intended\PYG{+w}{ }to\PYG{+w}{ }provide\PYG{+w}{ }an\PYG{+w}{ }upper\PYG{+w}{ }bound\PYG{+w}{ }on\PYG{+w}{ }the\PYG{+w}{ }\PYG{n+nb}{time}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }which\PYG{+w}{ }an\PYG{+w}{ }upstream\PYG{+w}{ }node\PYG{+w}{ }A\PYG{+w}{ }can\PYG{+w}{ }have\PYG{+w}{ }a\PYG{+w}{ }neighbor\PYG{+w}{ }B\PYG{+w}{ }as\PYG{+w}{ }an\PYG{+w}{ }active\PYG{+w}{ }next\PYG{+w}{ }hop\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }destination\PYG{+w}{ }D,\PYG{+w}{ }\PYG{k}{while}\PYG{+w}{ }B\PYG{+w}{ }has\PYG{+w}{ }invalidated\PYG{+w}{ }the\PYG{+w}{ }route\PYG{+w}{ }to\PYG{+w}{ }D.\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }*\PYG{+w}{ }max\PYG{+w}{ }\PYG{o}{(}HelloInterval,\PYG{+w}{ }ActiveRouteTimeout\PYG{o}{)}
*\PYG{+w}{ }AllowedHelloLoss:\PYG{+w}{ }Number\PYG{+w}{ }of\PYG{+w}{ }hello\PYG{+w}{ }messages\PYG{+w}{ }which\PYG{+w}{ }may\PYG{+w}{ }be\PYG{+w}{ }loss\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }valid\PYG{+w}{ }link.
*\PYG{+w}{ }EnableHello:\PYG{+w}{ }Indicates\PYG{+w}{ }whether\PYG{+w}{ }a\PYG{+w}{ }hello\PYG{+w}{ }messages\PYG{+w}{ }enable.
*\PYG{+w}{ }HelloInterval:\PYG{+w}{ }HELLO\PYG{+w}{ }messages\PYG{+w}{ }emission\PYG{+w}{ }interval.
*\PYG{+w}{ }HelloInterval:\PYG{+w}{ }HELLO\PYG{+w}{ }messages\PYG{+w}{ }emission\PYG{+w}{ }interval.
*\PYG{+w}{ }DeletePeriod:\PYG{+w}{ }DeletePeriod\PYG{+w}{ }is\PYG{+w}{ }intended\PYG{+w}{ }to\PYG{+w}{ }provide\PYG{+w}{ }an\PYG{+w}{ }upper\PYG{+w}{ }bound\PYG{+w}{ }on\PYG{+w}{ }the\PYG{+w}{ }\PYG{n+nb}{time}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }which\PYG{+w}{ }an\PYG{+w}{ }upstream\PYG{+w}{ }node\PYG{+w}{ }A\PYG{+w}{ }can\PYG{+w}{ }have\PYG{+w}{ }a\PYG{+w}{ }neighbor\PYG{+w}{ }B\PYG{+w}{ }as\PYG{+w}{ }an\PYG{+w}{ }active\PYG{+w}{ }next\PYG{+w}{ }hop\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }destination\PYG{+w}{ }D,\PYG{+w}{ }\PYG{k}{while}\PYG{+w}{ }B\PYG{+w}{ }has\PYG{+w}{ }invalidated\PYG{+w}{ }the\PYG{+w}{ }route\PYG{+w}{ }to\PYG{+w}{ }D.\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m}{5}\PYG{+w}{ }*\PYG{+w}{ }max\PYG{+w}{ }\PYG{o}{(}HelloInterval,\PYG{+w}{ }ActiveRouteTimeout\PYG{o}{)}
*\PYG{+w}{ }AllowedHelloLoss:\PYG{+w}{ }Number\PYG{+w}{ }of\PYG{+w}{ }hello\PYG{+w}{ }messages\PYG{+w}{ }which\PYG{+w}{ }may\PYG{+w}{ }be\PYG{+w}{ }loss\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }valid\PYG{+w}{ }link.
*\PYG{+w}{ }EnableHello:\PYG{+w}{ }Indicates\PYG{+w}{ }whether\PYG{+w}{ }a\PYG{+w}{ }hello\PYG{+w}{ }messages\PYG{+w}{ }enable.
*\PYG{+w}{ }HelloInterval:\PYG{+w}{ }HELLO\PYG{+w}{ }messages\PYG{+w}{ }emission\PYG{+w}{ }interval.
\end{sphinxVerbatim}


\section{bench\sphinxhyphen{}scheduler}
\label{\detokenize{utilities:bench-scheduler}}
\sphinxAtStartPar
This tool is used to benchmark the scheduler algorithms used in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Command\sphinxhyphen{}line Arguments}
\label{\detokenize{utilities:command-line-arguments}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}bench\PYGZhy{}scheduler \PYGZhy{}\PYGZhy{}help\PYGZdq{}}
bench\PYGZhy{}scheduler\PYG{+w}{ }\PYG{o}{[}Program\PYG{+w}{ }Options\PYG{o}{]}\PYG{+w}{ }\PYG{o}{[}General\PYG{+w}{ }Arguments\PYG{o}{]}

Benchmark\PYG{+w}{ }the\PYG{+w}{ }simulator\PYG{+w}{ }scheduler.

Event\PYG{+w}{ }intervals\PYG{+w}{ }are\PYG{+w}{ }taken\PYG{+w}{ }from\PYG{+w}{ }one\PYG{+w}{ }of:
\PYG{+w}{  }an\PYG{+w}{ }exponential\PYG{+w}{ }distribution,\PYG{+w}{ }with\PYG{+w}{ }mean\PYG{+w}{ }\PYG{l+m}{100}\PYG{+w}{ }ns,
\PYG{+w}{  }an\PYG{+w}{ }ascii\PYG{+w}{ }file,\PYG{+w}{ }given\PYG{+w}{ }by\PYG{+w}{ }the\PYG{+w}{ }\PYGZhy{}\PYGZhy{}file\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}filename\PYGZgt{}\PYGZdq{}}\PYG{+w}{ }argument,
\PYG{+w}{  }or\PYG{+w}{ }standard\PYG{+w}{ }input,\PYG{+w}{ }by\PYG{+w}{ }the\PYG{+w}{ }argument\PYG{+w}{ }\PYGZhy{}\PYGZhy{}file\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}
In\PYG{+w}{ }the\PYG{+w}{ }\PYG{k}{case}\PYG{+w}{ }of\PYG{+w}{ }either\PYG{+w}{ }\PYGZhy{}\PYGZhy{}file\PYG{+w}{ }form,\PYG{+w}{ }the\PYG{+w}{ }input\PYG{+w}{ }is\PYG{+w}{ }expected
to\PYG{+w}{ }be\PYG{+w}{ }ascii,\PYG{+w}{ }giving\PYG{+w}{ }the\PYG{+w}{ }relative\PYG{+w}{ }event\PYG{+w}{ }\PYG{n+nb}{times}\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }ns.

Program\PYG{+w}{ }Options:
\PYGZhy{}\PYGZhy{}all:\PYG{+w}{     }use\PYG{+w}{ }all\PYG{+w}{ }schedulers\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}cal:\PYG{+w}{     }use\PYG{+w}{ }CalendarSheduler\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}calrev:\PYG{+w}{  }reverse\PYG{+w}{ }ordering\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }the\PYG{+w}{ }CalendarScheduler\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}heap:\PYG{+w}{    }use\PYG{+w}{ }HeapScheduler\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}list:\PYG{+w}{    }use\PYG{+w}{ }ListSheduler\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}map:\PYG{+w}{     }use\PYG{+w}{ }MapScheduler\PYG{+w}{ }\PYG{o}{(}default\PYG{o}{)}\PYG{+w}{ }\PYG{o}{[}true\PYG{o}{]}
\PYGZhy{}\PYGZhy{}pri:\PYG{+w}{     }use\PYG{+w}{ }PriorityQueue\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}debug:\PYG{+w}{   }\PYG{n+nb}{enable}\PYG{+w}{ }debugging\PYG{+w}{ }output\PYG{+w}{ }\PYG{o}{[}false\PYG{o}{]}
\PYGZhy{}\PYGZhy{}pop:\PYG{+w}{     }event\PYG{+w}{ }population\PYG{+w}{ }size\PYG{+w}{ }\PYG{o}{(}default\PYG{+w}{ }1E5\PYG{o}{)}\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{100000}\PYG{o}{]}
\PYGZhy{}\PYGZhy{}total:\PYG{+w}{   }total\PYG{+w}{ }number\PYG{+w}{ }of\PYG{+w}{ }events\PYG{+w}{ }to\PYG{+w}{ }run\PYG{+w}{ }\PYG{o}{(}default\PYG{+w}{ }1E6\PYG{o}{)}\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{1000000}\PYG{o}{]}
\PYGZhy{}\PYGZhy{}runs:\PYG{+w}{    }number\PYG{+w}{ }of\PYG{+w}{ }runs\PYG{+w}{ }\PYG{o}{(}default\PYG{+w}{ }\PYG{l+m}{1}\PYG{o}{)}\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{1}\PYG{o}{]}
\PYGZhy{}\PYGZhy{}file:\PYG{+w}{    }file\PYG{+w}{ }of\PYG{+w}{ }relative\PYG{+w}{ }event\PYG{+w}{ }\PYG{n+nb}{times}
\PYGZhy{}\PYGZhy{}prec:\PYG{+w}{    }printed\PYG{+w}{ }output\PYG{+w}{ }precision\PYG{+w}{ }\PYG{o}{[}\PYG{l+m}{6}\PYG{o}{]}

General\PYG{+w}{ }Arguments:
...
\end{sphinxVerbatim}

\sphinxAtStartPar
You can change the Scheduler being benchmarked by passing
the appropriate flags, for example if you want to
benchmark the CalendarScheduler pass \sphinxtitleref{\textendash{}cal} to the program.

\sphinxAtStartPar
The default total number of events, runs or population size
can be overridden by passing \sphinxtitleref{\textendash{}total=value}, \sphinxtitleref{\textendash{}runs=value}
and \sphinxtitleref{\textendash{}pop=value} respectively.

\sphinxAtStartPar
If you want to use an event distribution which is stored in a file,
you can pass the file option by \sphinxtitleref{\textendash{}file=FILE\_NAME}.

\sphinxAtStartPar
\sphinxtitleref{\textendash{}prec} can be used to change the output precision value and
\sphinxtitleref{\textendash{}debug} as the name suggests enables debugging.


\subsection{Invocation}
\label{\detokenize{utilities:id2}}
\sphinxAtStartPar
To run it, simply open the terminal and type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }bench\PYGZhy{}scheduler\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}runs\PYG{o}{=}\PYG{l+m}{5}
\end{sphinxVerbatim}

\sphinxAtStartPar
It will show something like this depending upon the scheduler being benchmarked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bench\PYGZhy{}scheduler:\PYG{+w}{  }Benchmark\PYG{+w}{ }the\PYG{+w}{ }simulator\PYG{+w}{ }scheduler
\PYG{+w}{  }Event\PYG{+w}{ }population\PYG{+w}{ }size:\PYG{+w}{        }\PYG{l+m}{100000}
\PYG{+w}{  }Total\PYG{+w}{ }events\PYG{+w}{ }per\PYG{+w}{ }run:\PYG{+w}{         }\PYG{l+m}{1000000}
\PYG{+w}{  }Number\PYG{+w}{ }of\PYG{+w}{ }runs\PYG{+w}{ }per\PYG{+w}{ }scheduler:\PYG{+w}{ }\PYG{l+m}{5}
\PYG{+w}{  }Event\PYG{+w}{ }\PYG{n+nb}{time}\PYG{+w}{ }distribution:\PYG{+w}{      }default\PYG{+w}{ }exponential

ns3::MapScheduler\PYG{+w}{ }\PYG{o}{(}default\PYG{o}{)}
Run\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{}       Initialization:                     Simulation:}
Time\PYG{+w}{ }\PYG{o}{(}s\PYG{o}{)}\PYG{+w}{    }Rate\PYG{+w}{ }\PYG{o}{(}ev/s\PYG{o}{)}\PYG{+w}{ }Per\PYG{+w}{ }\PYG{o}{(}s/ev\PYG{o}{)}\PYG{+w}{  }Time\PYG{+w}{ }\PYG{o}{(}s\PYG{o}{)}\PYG{+w}{    }Rate\PYG{+w}{ }\PYG{o}{(}ev/s\PYG{o}{)}\PYG{+w}{ }Per\PYG{+w}{ }\PYG{o}{(}s/ev\PYG{o}{)}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
prime\PYG{+w}{       }\PYG{l+m}{0}.01\PYG{+w}{        }1e+06\PYG{+w}{       }1e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{5}.51\PYG{+w}{        }\PYG{l+m}{1}.81488e+06\PYG{+w}{ }\PYG{l+m}{5}.51e\PYGZhy{}07
\PYG{l+m}{0}\PYG{+w}{           }\PYG{l+m}{0}\PYG{+w}{           }inf\PYG{+w}{         }\PYG{l+m}{0}\PYG{+w}{           }\PYG{l+m}{6}.25\PYG{+w}{        }\PYG{l+m}{1}.6e+06\PYG{+w}{     }\PYG{l+m}{6}.25e\PYGZhy{}07
\PYG{l+m}{1}\PYG{+w}{           }\PYG{l+m}{0}\PYG{+w}{           }inf\PYG{+w}{         }\PYG{l+m}{0}\PYG{+w}{           }\PYG{l+m}{6}.52\PYG{+w}{        }\PYG{l+m}{1}.53374e+06\PYG{+w}{ }\PYG{l+m}{6}.52e\PYGZhy{}07
\PYG{l+m}{2}\PYG{+w}{           }\PYG{l+m}{0}.01\PYG{+w}{        }1e+06\PYG{+w}{       }1e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{7}.28\PYG{+w}{        }\PYG{l+m}{1}.37363e+06\PYG{+w}{ }\PYG{l+m}{7}.28e\PYGZhy{}07
\PYG{l+m}{3}\PYG{+w}{           }\PYG{l+m}{0}\PYG{+w}{           }inf\PYG{+w}{         }\PYG{l+m}{0}\PYG{+w}{           }\PYG{l+m}{7}.72\PYG{+w}{        }\PYG{l+m}{1}.29534e+06\PYG{+w}{ }\PYG{l+m}{7}.72e\PYGZhy{}07
\PYG{l+m}{4}\PYG{+w}{           }\PYG{l+m}{0}.01\PYG{+w}{        }1e+06\PYG{+w}{       }1e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{8}.16\PYG{+w}{        }\PYG{l+m}{1}.22549e+06\PYG{+w}{ }\PYG{l+m}{8}.16e\PYGZhy{}07
average\PYG{+w}{     }\PYG{l+m}{0}.004\PYG{+w}{       }nan\PYG{+w}{         }4e\PYGZhy{}07\PYG{+w}{       }\PYG{l+m}{7}.186\PYG{+w}{       }\PYG{l+m}{1}.40564e+06\PYG{+w}{ }\PYG{l+m}{7}.186e\PYGZhy{}07
stdev\PYG{+w}{       }\PYG{l+m}{0}.00489898\PYG{+w}{  }nan\PYG{+w}{         }\PYG{l+m}{4}.89898e\PYGZhy{}07\PYG{+w}{ }\PYG{l+m}{0}.715866\PYG{+w}{    }\PYG{l+m}{141302}\PYG{+w}{      }\PYG{l+m}{7}.15866e\PYGZhy{}08
\end{sphinxVerbatim}

\sphinxAtStartPar
Suppose we had to benchmark \sphinxtitleref{CalendarScheduler} instead, we would have written

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }bench\PYGZhy{}scheduler\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}runs\PYG{o}{=}\PYG{l+m}{5}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}cal\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
And the output would look something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bench\PYGZhy{}scheduler:\PYG{+w}{  }Benchmark\PYG{+w}{ }the\PYG{+w}{ }simulator\PYG{+w}{ }scheduler
\PYG{+w}{  }Event\PYG{+w}{ }population\PYG{+w}{ }size:\PYG{+w}{        }\PYG{l+m}{10000}
\PYG{+w}{  }Total\PYG{+w}{ }events\PYG{+w}{ }per\PYG{+w}{ }run:\PYG{+w}{         }\PYG{l+m}{10000000}
\PYG{+w}{  }Number\PYG{+w}{ }of\PYG{+w}{ }runs\PYG{+w}{ }per\PYG{+w}{ }scheduler:\PYG{+w}{ }\PYG{l+m}{5}
\PYG{+w}{  }Event\PYG{+w}{ }\PYG{n+nb}{time}\PYG{+w}{ }distribution:\PYG{+w}{      }default\PYG{+w}{ }exponential

ns3::CalendarScheduler:\PYG{+w}{ }insertion\PYG{+w}{ }order:\PYG{+w}{ }normal
Run\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{}       Initialization:                     Simulation:}
Time\PYG{+w}{ }\PYG{o}{(}s\PYG{o}{)}\PYG{+w}{    }Rate\PYG{+w}{ }\PYG{o}{(}ev/s\PYG{o}{)}\PYG{+w}{ }Per\PYG{+w}{ }\PYG{o}{(}s/ev\PYG{o}{)}\PYG{+w}{  }Time\PYG{+w}{ }\PYG{o}{(}s\PYG{o}{)}\PYG{+w}{    }Rate\PYG{+w}{ }\PYG{o}{(}ev/s\PYG{o}{)}\PYG{+w}{ }Per\PYG{+w}{ }\PYG{o}{(}s/ev\PYG{o}{)}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
prime\PYG{+w}{       }\PYG{l+m}{0}.01\PYG{+w}{        }1e+06\PYG{+w}{       }1e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{8}.14\PYG{+w}{        }\PYG{l+m}{1}.2285e+06\PYG{+w}{  }\PYG{l+m}{8}.14e\PYGZhy{}07
\PYG{l+m}{0}\PYG{+w}{           }\PYG{l+m}{0}.01\PYG{+w}{        }1e+06\PYG{+w}{       }1e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{17}.14\PYG{+w}{       }\PYG{l+m}{583431}\PYG{+w}{      }\PYG{l+m}{1}.714e\PYGZhy{}06
\PYG{l+m}{1}\PYG{+w}{           }\PYG{l+m}{0}.02\PYG{+w}{        }\PYG{l+m}{500000}\PYG{+w}{      }2e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{23}.33\PYG{+w}{       }\PYG{l+m}{428633}\PYG{+w}{      }\PYG{l+m}{2}.333e\PYGZhy{}06
\PYG{l+m}{2}\PYG{+w}{           }\PYG{l+m}{0}.02\PYG{+w}{        }\PYG{l+m}{500000}\PYG{+w}{      }2e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{33}.2\PYG{+w}{        }\PYG{l+m}{301205}\PYG{+w}{      }\PYG{l+m}{3}.32e\PYGZhy{}06
\PYG{l+m}{3}\PYG{+w}{           }\PYG{l+m}{0}.03\PYG{+w}{        }\PYG{l+m}{333333}\PYG{+w}{      }3e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{42}.98\PYG{+w}{       }\PYG{l+m}{232666}\PYG{+w}{      }\PYG{l+m}{4}.298e\PYGZhy{}06
\PYG{l+m}{4}\PYG{+w}{           }\PYG{l+m}{0}.05\PYG{+w}{        }\PYG{l+m}{200000}\PYG{+w}{      }5e\PYGZhy{}06\PYG{+w}{       }\PYG{l+m}{57}.1\PYG{+w}{        }\PYG{l+m}{175131}\PYG{+w}{      }\PYG{l+m}{5}.71e\PYGZhy{}06
average\PYG{+w}{     }\PYG{l+m}{0}.026\PYG{+w}{       }\PYG{l+m}{506667}\PYG{+w}{      }\PYG{l+m}{2}.6e\PYGZhy{}06\PYG{+w}{     }\PYG{l+m}{34}.75\PYG{+w}{       }\PYG{l+m}{344213}\PYG{+w}{      }\PYG{l+m}{3}.475e\PYGZhy{}06
stdev\PYG{+w}{       }\PYG{l+m}{0}.0135647\PYG{+w}{   }\PYG{l+m}{271129}\PYG{+w}{      }\PYG{l+m}{1}.35647e\PYGZhy{}06\PYG{+w}{ }\PYG{l+m}{14}.214\PYG{+w}{      }\PYG{l+m}{146446}\PYG{+w}{      }\PYG{l+m}{1}.4214e\PYGZhy{}06
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Support}
\label{\detokenize{support:support}}\label{\detokenize{support::doc}}
\sphinxstepscope


\section{Enabling Subsets of \sphinxstyleemphasis{ns\sphinxhyphen{}3} Modules}
\label{\detokenize{enable-modules:enabling-subsets-of-ns3-modules}}\label{\detokenize{enable-modules::doc}}
\sphinxAtStartPar
As with most software projects, \sphinxstyleemphasis{ns\sphinxhyphen{}3} is ever growing larger in terms of number of modules, lines of code, and memory footprint.  Users, however, may only use a few of those modules at a time.  For this reason, users may want to explicitly enable only the subset of the possible \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules that they actually need for their research.

\sphinxAtStartPar
This chapter discusses how to enable only the \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules that you are interested in using.


\subsection{How to enable a subset of \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s modules}
\label{\detokenize{enable-modules:how-to-enable-a-subset-of-ns3-s-modules}}
\sphinxAtStartPar
If shared libraries are being built, then enabling a module will cause at least one library to be built:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}modulename.so
\end{sphinxVerbatim}

\sphinxAtStartPar
If the module has a test library and test libraries are being built, then

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}modulename\PYGZhy{}test.so
\end{sphinxVerbatim}

\sphinxAtStartPar
will be built, too.  Other modules that the module depends on and their test libraries will also be built.

\sphinxAtStartPar
By default, all modules are built in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  There are two ways to enable a subset of these modules:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Using ns3’s \textendash{}enable\sphinxhyphen{}modules option

\item {} 
\sphinxAtStartPar
Using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file

\end{enumerate}


\subsubsection{Enable modules using ns3’s \textendash{}enable\sphinxhyphen{}modules option}
\label{\detokenize{enable-modules:enable-modules-using-ns3-s-enable-modules-option}}
\sphinxAtStartPar
To enable only the core module with example and tests, for example,
try these commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }clean
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}modules\PYG{o}{=}core
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }build/lib
\PYGZdl{}\PYG{+w}{ }ls
\end{sphinxVerbatim}

\sphinxAtStartPar
and the following libraries should be present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}core.so
libns3\PYGZhy{}core\PYGZhy{}test.so
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the \sphinxcode{\sphinxupquote{./ns3 clean}} step is done here only to make it more obvious which module libraries were built.  You don’t have to do \sphinxcode{\sphinxupquote{./ns3 clean}} in order to enable subsets of modules.

\sphinxAtStartPar
Running test.py will cause only those tests that depend on module core to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
24 of 24 tests passed (24 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
Repeat the above steps for the “network” module instead of the “core” module, and the following will be built, since network depends on core:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}core.so       libns3\PYGZhy{}network.so
libns3\PYGZhy{}core\PYGZhy{}test.so  libns3\PYGZhy{}network\PYGZhy{}test.so
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py will cause those tests that depend on only the core and network modules to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
31 of 31 tests passed (31 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable modules using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file}
\label{\detokenize{enable-modules:enable-modules-using-the-ns3-configuration-file}}
\sphinxAtStartPar
A configuration file, .ns3rc, has been added to \sphinxstyleemphasis{ns\sphinxhyphen{}3} that allows users to specify which modules are to be included in the build.

\sphinxAtStartPar
When enabling a subset of \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules, the precedence rules are as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the \textendash{}enable\sphinxhyphen{}modules configure string overrides any .ns3rc file

\item {} 
\sphinxAtStartPar
the .ns3rc file in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory is next consulted, if present

\item {} 
\sphinxAtStartPar
the system searches for \textasciitilde{}/.ns3rc if the above two are unspecified

\end{enumerate}

\sphinxAtStartPar
If none of the above limits the modules to be built, all modules that CMake knows about will be built.

\sphinxAtStartPar
The maintained version of the .ns3rc file in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} source code repository resides in the \sphinxcode{\sphinxupquote{utils}} directory.  The reason for this is if it were in the top\sphinxhyphen{}level directory of the repository, it would be prone to accidental checkins from maintainers that enable the modules they want to use.  Therefore, users need to manually copy the .ns3rc from the \sphinxcode{\sphinxupquote{utils}} directory to their preferred place (top level directory or their home directory) to enable persistent modular build configuration.

\sphinxAtStartPar
Assuming that you are in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can get a copy of the .ns3rc file that is in the \sphinxcode{\sphinxupquote{utils}} directory as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }cp\PYG{+w}{ }utils/.ns3rc\PYG{+w}{ }.
\end{sphinxVerbatim}

\sphinxAtStartPar
The .ns3rc file should now be in your top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, and it contains the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} All modules can be enabled by emptying the list.}
\PYG{c}{\PYGZsh{} To list modules, append the modules separated by space or semicolon; e.g.:}
\PYG{c}{\PYGZsh{} set(ns3rc\PYGZus{}enabled\PYGZus{}modules core propagation)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} A list of the modules that will be disabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be disabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} If the list is empty, no module will be disabled.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}disabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want examples to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}examples\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want tests to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}tests\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Override other ns\PYGZhy{}3 settings by setting their values below}
\PYG{c}{\PYGZsh{} Note: command\PYGZhy{}line settings will also be overridden.}
\PYG{c}{\PYGZsh{}set(NS3\PYGZus{}LOG ON)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Use your favorite editor to modify the .ns3rc file to only enable the core module with examples and tests like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} All modules can be enabled by emptying the list.}
\PYG{c}{\PYGZsh{} To list modules, append the modules separated by space or semicolon; e.g.:}
\PYG{c}{\PYGZsh{} set(ns3rc\PYGZus{}enabled\PYGZus{}modules core propagation)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{+w}{ }\PYG{l+s}{core}\PYG{p}{)}

\PYG{c}{\PYGZsh{} A list of the modules that will be disabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be disabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} If the list is empty, no module will be disabled.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}disabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want examples to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}examples\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want tests to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}tests\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Override other ns\PYGZhy{}3 settings by setting their values below}
\PYG{c}{\PYGZsh{} Note: command\PYGZhy{}line settings will also be overridden.}
\PYG{c}{\PYGZsh{}set(NS3\PYGZus{}LOG ON)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Only the core module will be enabled now if you try these commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }clean
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }build/lib/
\PYGZdl{}\PYG{+w}{ }ls
\end{sphinxVerbatim}

\sphinxAtStartPar
and the following libraries should be present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}core.so
libns3\PYGZhy{}core\PYGZhy{}test.so
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the \sphinxcode{\sphinxupquote{./ns3 clean}} step is done here only to make it more obvious which module libraries were built.  You don’t have to do \sphinxcode{\sphinxupquote{./ns3 clean}} in order to enable subsets of modules.

\sphinxAtStartPar
Running test.py will cause only those tests that depend on module core to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
24 of 24 tests passed (24 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
Repeat the above steps for the “network” module instead of the “core” module, and the following will be built, since network depends on core:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}core.so       libns3\PYGZhy{}network.so
libns3\PYGZhy{}core\PYGZhy{}test.so  libns3\PYGZhy{}network\PYGZhy{}test.so
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py will cause those tests that depend on only the core and network modules to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
31 of 31 tests passed (31 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
As the comment in the sample \sphinxcode{\sphinxupquote{.ns3rc}} file suggests, users may list multiple enabled modules by
separating each requested module by space or semicolon; e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{+w}{ }\PYG{l+s}{core}\PYG{+w}{ }\PYG{l+s}{propagation}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following also works (but note that a comma delimiter will not work with this CMake list):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{+w}{ }\PYG{l+s}{core;propagation}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Enabling/disabling \sphinxstyleemphasis{ns\sphinxhyphen{}3} Tests and Examples}
\label{\detokenize{enable-tests:enabling-disabling-ns3-tests-and-examples}}\label{\detokenize{enable-tests::doc}}
\sphinxAtStartPar
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} distribution includes many examples and tests that are used to validate the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system.  Users, however, may not always want these examples and tests to be run for their installation of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
This chapter discusses how to build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with or without its examples and tests.


\subsection{How to enable/disable examples and tests in \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{enable-tests:how-to-enable-disable-examples-and-tests-in-ns3}}
\sphinxAtStartPar
There are 3 ways to enable/disable examples and tests in \sphinxstyleemphasis{ns\sphinxhyphen{}3}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Using build.py when \sphinxstyleemphasis{ns\sphinxhyphen{}3} is built for the first time

\item {} 
\sphinxAtStartPar
Using ns3 once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built

\item {} 
\sphinxAtStartPar
Using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built

\end{enumerate}


\subsubsection{Enable/disable examples and tests using build.py}
\label{\detokenize{enable-tests:enable-disable-examples-and-tests-using-build-py}}
\sphinxAtStartPar
You can use build.py to enable/disable examples and tests when \sphinxstyleemphasis{ns\sphinxhyphen{}3} is built for the first time.

\sphinxAtStartPar
By default, examples and tests are not built in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
From the ns\sphinxhyphen{}3\sphinxhyphen{}allinone directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} without any
examples or tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./build.py
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory now will cause no examples or tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
If you would like build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples and tests, then do the following from the ns\sphinxhyphen{}3\sphinxhyphen{}allinone directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./build.py\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory will cause all of the examples and tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable/disable examples and tests using ns3}
\label{\detokenize{enable-tests:enable-disable-examples-and-tests-using-ns3}}
\sphinxAtStartPar
You can use ns3 to enable/disable examples and tests once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built.

\sphinxAtStartPar
By default, examples and tests are not built in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\sphinxAtStartPar
From the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} without any
examples or tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py now will cause no examples or tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
If you would like build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples and tests, then do the following from the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples\PYG{+w}{ }\PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py will cause all of the examples and tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable/disable examples and tests using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file}
\label{\detokenize{enable-tests:enable-disable-examples-and-tests-using-the-ns3-configuration-file}}
\sphinxAtStartPar
A configuration file, .ns3rc, has been added to \sphinxstyleemphasis{ns\sphinxhyphen{}3} that allows users to specify whether examples and tests should be built or not.  You can use this file to enable/disable examples and tests once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built.

\sphinxAtStartPar
When enabling disabling examples and tests, the precedence rules are as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
the \textendash{}enable\sphinxhyphen{}examples/\textendash{}disable\sphinxhyphen{}examples configure strings override any .ns3rc file

\item {} 
\sphinxAtStartPar
the \textendash{}enable\sphinxhyphen{}tests/\textendash{}disable\sphinxhyphen{}tests configure strings override any .ns3rc file

\item {} 
\sphinxAtStartPar
the .ns3rc file in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory is next consulted, if present

\item {} 
\sphinxAtStartPar
the system searches for \textasciitilde{}/.ns3rc if the .ns3rc file was not found in the previous step

\end{enumerate}

\sphinxAtStartPar
If none of the above exists, then examples and tests will not be built.

\sphinxAtStartPar
The maintained version of the .ns3rc file in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} source code repository resides in the \sphinxcode{\sphinxupquote{utils}} directory.  The reason for this is if it were in the top\sphinxhyphen{}level directory of the repository, it would be prone to accidental checkins from maintainers that enable the modules they want to use.  Therefore, users need to manually copy the .ns3rc from the \sphinxcode{\sphinxupquote{utils}} directory to their preferred place (top level directory or their home directory) to enable persistent enabling of examples and tests.

\sphinxAtStartPar
Assuming that you are in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can get a copy of the .ns3rc file that is in the \sphinxcode{\sphinxupquote{utils}} directory as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }cp\PYG{+w}{ }utils/.ns3rc\PYG{+w}{ }.
\end{sphinxVerbatim}

\sphinxAtStartPar
The .ns3rc file should now be in your top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, and it contains the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} All modules can be enabled by emptying the list.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} A list of the modules that will be disabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be disabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} If the list is empty, no module will be disabled.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}disabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want examples to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}examples\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want tests to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}tests\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{OFF}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Override other ns\PYGZhy{}3 settings by setting their values below}
\PYG{c}{\PYGZsh{} Note: command\PYGZhy{}line settings will also be overridden.}
\PYG{c}{\PYGZsh{}set(NS3\PYGZus{}LOG ON)}
\end{sphinxVerbatim}

\sphinxAtStartPar
From the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} without any
examples or tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py now will cause no examples or tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

\sphinxAtStartPar
If you would like build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples and tests, use your
favorite editor to change the values in the .ns3rc file for
ns3rc\_examples\_enabled and ns3rc\_tests\_enabled file to be True:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} All modules can be enabled by emptying the list.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} A list of the modules that will be disabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be disabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} If the list is empty, no module will be disabled.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}disabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want examples to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}examples\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Set this equal to ON if you want tests to be run.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}tests\PYGZus{}enabled}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Override other ns\PYGZhy{}3 settings by setting their values below}
\PYG{c}{\PYGZsh{} Note: command\PYGZhy{}line settings will also be overridden.}
\PYG{c}{\PYGZsh{}set(NS3\PYGZus{}LOG ON)}
\end{sphinxVerbatim}

\sphinxAtStartPar
From the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples
and tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }configure
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }build
\end{sphinxVerbatim}

\sphinxAtStartPar
Running test.py will cause all of the examples and tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable examples and tests that depend on a set of modules using \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{enable-tests:enable-examples-and-tests-that-depend-on-a-set-of-modules-using-ns3}}
\sphinxAtStartPar
As seen above, the following command only builds the requested modules (core and wifi),
plus any modules that are implicitly needed (e.g., network), and the resulting compatible examples and tests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./ns3 configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}modules=\PYGZdq{}wifi;core\PYGZdq{} \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\end{sphinxVerbatim}

\sphinxAtStartPar
However, when developing a new module, you may prefer to use the following alternative, which builds
all module libraries, but will filter out any examples and tests from modules that are not explicitly listed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./ns3 configure \PYGZhy{}\PYGZhy{}filter\PYGZhy{}module\PYGZhy{}examples\PYGZhy{}and\PYGZhy{}tests=\PYGZdq{}wifi;core\PYGZdq{} \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\end{sphinxVerbatim}

\sphinxAtStartPar
The first command will generally lead to a shorter build time, but the second option will provide better
coverage, by building additional test cases and examples directly related to the specified modules.


\subsubsection{Enable examples and tests that depend on a set of modules using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file}
\label{\detokenize{enable-tests:enable-examples-and-tests-that-depend-on-a-set-of-modules-using-the-ns3-configuration-file}}
\sphinxAtStartPar
As seen above, examples and tests can be enabled for just a subset of the available modules via the
\sphinxcode{\sphinxupquote{ns3}} script. The same can be accomplished via the \sphinxcode{\sphinxupquote{.ns3rc}} configuration file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} All modules can be enabled by emptying the list.}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{ns3rc\PYGZus{}enabled\PYGZus{}modules}\PYG{p}{)}

\PYG{c}{\PYGZsh{} ...}

\PYG{c}{\PYGZsh{} Override other ns\PYGZhy{}3 settings by setting their values below}
\PYG{c}{\PYGZsh{} Note: command\PYGZhy{}line settings will also be overridden.}
\PYG{c}{\PYGZsh{}set(NS3\PYGZus{}LOG ON)}

\PYG{c}{\PYGZsh{} The following will build core and wifi tests, plus their examples}
\PYG{c}{\PYGZsh{} and examples on /ns\PYGZhy{}3\PYGZhy{}dev/examples that depend on either of them}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{NS3\PYGZus{}FILTER\PYGZus{}MODULE\PYGZus{}EXAMPLES\PYGZus{}AND\PYGZus{}TESTS}\PYG{+w}{ }\PYG{l+s}{wifi}\PYG{+w}{ }\PYG{l+s}{core}\PYG{p}{)}\PYG{+w}{ }\PYG{c}{\PYGZsh{} \PYGZlt{}==}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Troubleshooting}
\label{\detokenize{troubleshoot:troubleshooting}}\label{\detokenize{troubleshoot::doc}}
\sphinxAtStartPar
This chapter posts some information about possibly common errors in building
or running \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs.

\sphinxAtStartPar
Please note that the wiki
(\sphinxurl{http://www.nsnam.org/wiki/Troubleshooting}) may have contributed
items.


\subsection{Build errors}
\label{\detokenize{troubleshoot:build-errors}}

\subsection{Run\sphinxhyphen{}time errors}
\label{\detokenize{troubleshoot:run-time-errors}}
\sphinxAtStartPar
Sometimes, errors can occur with a program after a successful build. These are
run\sphinxhyphen{}time errors, and can commonly occur when memory is corrupted or pointer
values are unexpectedly null.

\sphinxAtStartPar
Here is an example of what might occur:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point
Entering\PYG{+w}{ }directory\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build\PYGZsq{}}
Compilation\PYG{+w}{ }finished\PYG{+w}{ }successfully
Command\PYG{+w}{ }\PYG{o}{[}\PYG{l+s+s1}{\PYGZsq{}/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build/debug/examples/tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point\PYGZsq{}}\PYG{o}{]}\PYG{+w}{ }exited\PYG{+w}{ }with\PYG{+w}{ }code\PYG{+w}{ }\PYGZhy{}11
\end{sphinxVerbatim}

\sphinxAtStartPar
The error message says that the program terminated unsuccessfuly, but it is
not clear from this information what might be wrong. To examine more
closely, try running it under the \sphinxhref{https://access.redhat.com/documentation/en-us/red\_hat\_developer\_toolset/9/html/user\_guide/chap-gdb}{gdb debugger}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point\PYG{+w}{ }\PYGZhy{}\PYGZhy{}gdb
Entering\PYG{+w}{ }directory\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build\PYGZsq{}}
Compilation\PYG{+w}{ }finished\PYG{+w}{ }successfully
GNU\PYG{+w}{ }gdb\PYG{+w}{ }Red\PYG{+w}{ }Hat\PYG{+w}{ }Linux\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{6}.3.0.0\PYGZhy{}1.134.fc5rh\PYG{o}{)}
Copyright\PYG{+w}{ }\PYG{l+m}{2004}\PYG{+w}{ }Free\PYG{+w}{ }Software\PYG{+w}{ }Foundation,\PYG{+w}{ }Inc.
GDB\PYG{+w}{ }is\PYG{+w}{ }free\PYG{+w}{ }software,\PYG{+w}{ }covered\PYG{+w}{ }by\PYG{+w}{ }the\PYG{+w}{ }GNU\PYG{+w}{ }General\PYG{+w}{ }Public\PYG{+w}{ }License,\PYG{+w}{ }and\PYG{+w}{ }you\PYG{+w}{ }are
welcome\PYG{+w}{ }to\PYG{+w}{ }change\PYG{+w}{ }it\PYG{+w}{ }and/or\PYG{+w}{ }distribute\PYG{+w}{ }copies\PYG{+w}{ }of\PYG{+w}{ }it\PYG{+w}{ }under\PYG{+w}{ }certain\PYG{+w}{ }conditions.
Type\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}show copying\PYGZdq{}}\PYG{+w}{ }to\PYG{+w}{ }see\PYG{+w}{ }the\PYG{+w}{ }conditions.
There\PYG{+w}{ }is\PYG{+w}{ }absolutely\PYG{+w}{ }no\PYG{+w}{ }warranty\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }GDB.\PYG{+w}{  }Type\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}show warranty\PYGZdq{}}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }details.
This\PYG{+w}{ }GDB\PYG{+w}{ }was\PYG{+w}{ }configured\PYG{+w}{ }as\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}i386\PYGZhy{}redhat\PYGZhy{}linux\PYGZhy{}gnu\PYGZdq{}}...Using\PYG{+w}{ }host\PYG{+w}{ }libthread\PYGZus{}db
library\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}/lib/libthread\PYGZus{}db.so.1\PYGZdq{}}.

\PYG{o}{(}gdb\PYG{o}{)}\PYG{+w}{ }run
Starting\PYG{+w}{ }program:\PYG{+w}{ }/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build/debug/examples/tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point
Reading\PYG{+w}{ }symbols\PYG{+w}{ }from\PYG{+w}{ }shared\PYG{+w}{ }object\PYG{+w}{ }\PYG{n+nb}{read}\PYG{+w}{ }from\PYG{+w}{ }target\PYG{+w}{ }memory...done.
Loaded\PYG{+w}{ }system\PYG{+w}{ }supplied\PYG{+w}{ }DSO\PYG{+w}{ }at\PYG{+w}{ }0xf5c000

Program\PYG{+w}{ }received\PYG{+w}{ }signal\PYG{+w}{ }SIGSEGV,\PYG{+w}{ }Segmentation\PYG{+w}{ }fault.
0x0804aa12\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }main\PYG{+w}{ }\PYG{o}{(}\PYG{n+nv}{argc}\PYG{o}{=}\PYG{l+m}{1},\PYG{+w}{ }\PYG{n+nv}{argv}\PYG{o}{=}0xbfdfefa4\PYG{o}{)}
\PYG{+w}{    }at\PYG{+w}{ }../examples/tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point.cc:136
\PYG{l+m}{136}\PYG{+w}{       }Ptr\PYGZlt{}Socket\PYGZgt{}\PYG{+w}{ }\PYG{n+nv}{localSocket}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }socketFactory\PYGZhy{}\PYGZgt{}CreateSocket\PYG{o}{(}\PYG{o}{)}\PYG{p}{;}
\PYG{o}{(}gdb\PYG{o}{)}\PYG{+w}{ }p\PYG{+w}{ }localSocket
\PYG{n+nv}{\PYGZdl{}1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZob{}}\PYG{n+nv}{m\PYGZus{}ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }0x3c5d65\PYG{o}{\PYGZcb{}}
\PYG{o}{(}gdb\PYG{o}{)}\PYG{+w}{ }p\PYG{+w}{ }socketFactory
\PYG{n+nv}{\PYGZdl{}2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZob{}}\PYG{n+nv}{m\PYGZus{}ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }0x0\PYG{o}{\PYGZcb{}}
\PYG{o}{(}gdb\PYG{o}{)}\PYG{+w}{ }quit
The\PYG{+w}{ }program\PYG{+w}{ }is\PYG{+w}{ }running.\PYG{+w}{  }Exit\PYG{+w}{ }anyway?\PYG{+w}{ }\PYG{o}{(}y\PYG{+w}{ }or\PYG{+w}{ }n\PYG{o}{)}\PYG{+w}{ }y
\end{sphinxVerbatim}

\sphinxAtStartPar
Note first the way the program was invoked\textendash{} pass the command to run as an
argument to the command template “gdb \%s”.

\sphinxAtStartPar
This tells us that there was an attempt to dereference a null pointer
socketFactory.

\sphinxAtStartPar
Let’s look around line 136 of tcp\sphinxhyphen{}point\sphinxhyphen{}to\sphinxhyphen{}point, as gdb suggests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{SocketFactory}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{socketFactory}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{SocketFactory}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{Tcp}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iid}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Socket}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{localSocket}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{socketFactory}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CreateSocket}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{localSocket}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Bind}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The culprit here is that the return value of GetObject is not being checked and
may be null.

\sphinxAtStartPar
Sometimes you may need to use the \sphinxhref{http://valgrind.org}{valgrind memory checker} for more subtle errors. Again, you invoke the use of
valgrind similarly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }./ns3\PYG{+w}{ }run\PYG{+w}{ }tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point\PYG{+w}{ }\PYGZhy{}\PYGZhy{}valgrind
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{Cic06}
\bibitem[Cic06]{probe:cic06}
\sphinxAtStartPar
Claudio Cicconetti, Enzo Mingozzi, Giovanni Stea, “An Integrated
Framework for Enabling Effective Data Collection and Statistical
Analysis with ns2, Workshop on ns\sphinxhyphen{}2 (WNS2), Pisa, Italy, October 2006.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}