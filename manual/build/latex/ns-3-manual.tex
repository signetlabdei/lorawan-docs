%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

\usepackage{amssymb}
 \definecolor{VerbatimBorderColor}{rgb}{1,1,1}
 \renewcommand{\sphinxcode}[1]{\texttt{\small{#1}}}


\title{ns-3 Manual}
\date{Apr 29, 2020}
\release{ns-3-dev}
\author{ns-3 project}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{ns-3.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


This is the \sphinxstyleemphasis{ns\sphinxhyphen{}3 Manual}. Primary documentation for the ns\sphinxhyphen{}3 project is
available in five forms:
\begin{itemize}
\item {} 
\sphinxhref{https://www.nsnam.org/doxygen/index.html}{ns\sphinxhyphen{}3 Doxygen}: Documentation of the public APIs of the simulator

\item {} 
Tutorial, Manual \sphinxstyleemphasis{(this document)}, and Model Library for the \sphinxhref{https://www.nsnam.org/documentation/latest/}{latest release} and \sphinxhref{https://www.nsnam.org/documentation/development-tree/}{development tree}

\item {} 
\sphinxhref{https://www.nsnam.org/wiki}{ns\sphinxhyphen{}3 wiki}

\end{itemize}

This document is written in \sphinxhref{http://docutils.sourceforge.net/rst.html}{reStructuredText} for \sphinxhref{http://sphinx.pocoo.org/}{Sphinx} and is maintained in the
\sphinxcode{\sphinxupquote{doc/manual}} directory of ns\sphinxhyphen{}3’s source code.


\chapter{Organization}
\label{\detokenize{organization:organization}}\label{\detokenize{organization::doc}}
This chapter describes the overall \sphinxstyleemphasis{ns\sphinxhyphen{}3} software organization and the
corresponding organization of this manual.

\sphinxstyleemphasis{ns\sphinxhyphen{}3} is a discrete\sphinxhyphen{}event network simulator in which the simulation core
and models are implemented in C++. \sphinxstyleemphasis{ns\sphinxhyphen{}3} is built as a library which may be
statically or dynamically linked to a C++ main program that defines the
simulation topology and starts the simulator. \sphinxstyleemphasis{ns\sphinxhyphen{}3} also exports nearly all
of its API to Python, allowing Python programs to import an “ns3” module in
much the same way as the \sphinxstyleemphasis{ns\sphinxhyphen{}3} library is linked by executables in C++.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{software-organization}.pdf}
\caption{Software organization of \sphinxstyleemphasis{ns\sphinxhyphen{}3}}\label{\detokenize{organization:id1}}\label{\detokenize{organization:software-organization}}\end{figure}

The source code for \sphinxstyleemphasis{ns\sphinxhyphen{}3} is mostly organized in the \sphinxcode{\sphinxupquote{src}} directory and
can be described by the diagram in {\hyperref[\detokenize{organization:software-organization}]{\sphinxcrossref{\DUrole{std,std-ref}{Software organization of ns\sphinxhyphen{}3}}}}. We will
work our way from the bottom up; in general, modules only have dependencies
on modules beneath them in the figure.

We first describe the core of the simulator; those components that are
common across all protocol, hardware, and environmental models.
The simulation core is implemented in \sphinxcode{\sphinxupquote{src/core}}. Packets are
fundamental objects in a network simulator
and are implemented in \sphinxcode{\sphinxupquote{src/network}}. These two simulation modules by
themselves are intended to comprise a generic simulation core that can be
used by different kinds of networks, not just Internet\sphinxhyphen{}based networks.  The
above modules of \sphinxstyleemphasis{ns\sphinxhyphen{}3} are independent of specific network and device
models, which are covered in subsequent parts of this manual.

In addition to the above \sphinxstyleemphasis{ns\sphinxhyphen{}3} core, we introduce, also in the initial
portion of the manual, two other modules that supplement the core C++\sphinxhyphen{}based
API.  \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs may access
all of the API directly or may make use of a so\sphinxhyphen{}called \sphinxstyleemphasis{helper API} that
provides convenient wrappers or encapsulation of low\sphinxhyphen{}level API calls. The
fact that \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs can be written to two APIs (or a combination
thereof) is a fundamental aspect of the simulator.
We also describe how Python is supported in \sphinxstyleemphasis{ns\sphinxhyphen{}3} before moving onto
specific models of relevance to network simulation.

The remainder of the manual is focused on documenting the models and
supporting capabilities.  The next part focuses on two fundamental objects in
\sphinxstyleemphasis{ns\sphinxhyphen{}3}:  the \sphinxcode{\sphinxupquote{Node}} and \sphinxcode{\sphinxupquote{NetDevice}}. Two special NetDevice types are
designed to support network emulation use cases, and emulation is described
next.  The following chapter is devoted to Internet\sphinxhyphen{}related models,
including the
sockets API used by Internet applications. The next chapter covers
applications, and the following chapter describes additional support for
simulation, such as animators and statistics.

The project maintains a separate manual devoted to testing and validation
of \sphinxstyleemphasis{ns\sphinxhyphen{}3} code (see the \sphinxhref{http://www.nsnam.org/tutorials.html}{ns\sphinxhyphen{}3 Testing and Validation manual}).


\chapter{Working with git as a user}
\label{\detokenize{working-with-git:working-with-git-as-a-user}}\label{\detokenize{working-with-git:working-with-git}}\label{\detokenize{working-with-git::doc}}
The ns\sphinxhyphen{}3 project used Mercurial in the past as its source code control system, but it has moved to Git in December 2018. Git is a VCS like Mercurial, Subversion or CVS, and it is used to maintain many open\sphinxhyphen{}source (and closed\sphinxhyphen{}source) projects. While git and mercurial have a lot of common properties, if you are new to git you should read first an introduction to it. The most up\sphinxhyphen{}to\sphinxhyphen{}date guide is the Git Book, at \sphinxurl{https://git-scm.com/book/en/v2/Getting-Started-Git-Basics}.

The ns\sphinxhyphen{}3 project is officially hosted on GitLab.com at \sphinxurl{https://gitlab.com/nsnam/}.  For convenience and historical reasons, ns\sphinxhyphen{}3\sphinxhyphen{}dev mirrors are currently posted on Bitbucket.com and GitHub.com, and kept in sync with the official repository periodically via cron jobs.  We recommend that users who have been working from one of these mirrors repoint their remotes so that they pull origin or upstream from GitLab.com (see below explanation about how to configure remotes).

This section of the manual provides common tips for both users and maintainers. Since the first part is shared, in this manual section we will start with a personal repository and then explain what to do in some typical cases. ns\sphinxhyphen{}3 users often combine ns\sphinxhyphen{}3\sphinxhyphen{}dev with other repositories (pybindgen, netanim, apps from the app store).  This manual chapter does not cover this use case; it only focuses on the single ns\sphinxhyphen{}3\sphinxhyphen{}dev repository.  See other project documentation such as the ns\sphinxhyphen{}3 tutorial for descriptions on bundled releases distributed as source archives, or on the bake build tool for managing multiple repositories.  The guidelines listed below also largely pertain to the user who is using (and cloning) bake from the GitLab.com repository.


\section{ns\sphinxhyphen{}3’s Git workflow in a nutshell}
\label{\detokenize{working-with-git:ns-3-s-git-workflow-in-a-nutshell}}
Experienced git users will not necessarily need instruction on how to set up personal repositories (below).  However, they should be aware of the project’s workflow:
\begin{itemize}
\item {} 
The main repository’s \sphinxcode{\sphinxupquote{master}} branch is the main development branch.  The project maintains only this one branch and strives to maintain a mostly linear history on it.

\item {} 
Releases are made by creating a branch from the \sphinxcode{\sphinxupquote{master}} branch and tagging the branch with the release number when ready, and then merging the release branch back to the \sphinxcode{\sphinxupquote{master}} branch.  Releases can be identified by a git tag, and a modified \sphinxcode{\sphinxupquote{VERSION}} file in the branch.  However, the modified \sphinxcode{\sphinxupquote{VERSION}} file is not merged back to \sphinxcode{\sphinxupquote{master}}.
\begin{itemize}
\item {} 
If a hotfix release must be made to update a past release, a new hotfix support branch will be created by branching from the tip of the last relevant release.  Changesets from \sphinxcode{\sphinxupquote{master}} branch (such as bug fixes) may be cherry\sphinxhyphen{}picked to the hotfix branch.  The hotfix release is tagged with the hotfix version number, and merged back to the \sphinxcode{\sphinxupquote{master}} branch.

\end{itemize}

\item {} 
Merges to the ns\sphinxhyphen{}3 \sphinxcode{\sphinxupquote{master}} branch are fast forwarded when possible, and commits can be squashed as appropriate, to maintain a clean linear history.  Merge commits can be avoided in simple cases.
\begin{itemize}
\item {} 
More complicated merges might not be able to be fast forwarded, with the result that there will be a merge commit upon the merge.

\end{itemize}

\item {} 
Maintainers can commit obvious non\sphinxhyphen{}critical fixes (documentation improvements, typos etc.) directly into the \sphinxcode{\sphinxupquote{master}} branch.  Users who are not maintainers can create GitLab.com Merge Requests for small items such as these, for maintainers to review.

\item {} 
Maintainers can directly commit bug fixes to their maintained modules without review/approval by other maintainers, although a review phase is recommended for non\sphinxhyphen{}trivial fixes.  Larger commits that touch multiple modules should be reviewed and approved by the set of affected maintainers.

\item {} 
When proposing code (new features, bug fixes, etc.) for a module maintained by someone else, the typical workflow will be to fork the \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} repository, create a local feature branch on your fork, and use GitLab.com to generate a Merge Request towards \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} when ready.  The Merge Request will then be reviewed, and in response to changes requested or comments from maintainers, authors are are asked to modify their feature branch and rebase to the tip of \sphinxcode{\sphinxupquote{ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} as needed.

\end{itemize}


\section{Setup of a personal repository}
\label{\detokenize{working-with-git:setup-of-a-personal-repository}}
We will provide two ways, one anonymous (but will impede the creation of merge requests) and the other, preferred, that include forking the repository through the GitLab.com web interface.


\subsection{Directly cloning ns\sphinxhyphen{}3\sphinxhyphen{}dev}
\label{\detokenize{working-with-git:directly-cloning-ns-3-dev}}
If you go to the official ns\sphinxhyphen{}3\sphinxhyphen{}dev page, hosted at \sphinxurl{https://gitlab.com/nsnam/ns-3-dev}, you can find a button that says \sphinxcode{\sphinxupquote{Clone}}. If you are not logged in, then you will see only the option of cloning the repository through HTTPS, with this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://gitlab.com/nsnam/ns\PYGZhy{}3\PYGZhy{}dev.git
\end{sphinxVerbatim}

If this command exits successfully, you will have a newly created \sphinxtitleref{ns\sphinxhyphen{}3\sphinxhyphen{}dev} directory with all the source code.


\subsection{Forking ns\sphinxhyphen{}3\sphinxhyphen{}dev on GitLab.com}
\label{\detokenize{working-with-git:forking-ns-3-dev-on-gitlab-com}}
Assume that you are the user \sphinxstyleemphasis{john} on GitLab.com and that you want to create a new repository that is synced with nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Log into GitLab.com

\item {} 
Navigate to \sphinxurl{https://gitlab.com/nsnam/ns-3-dev}

\item {} 
In the top\sphinxhyphen{}right corner of the page, click \sphinxcode{\sphinxupquote{Fork}}.

\end{enumerate}

Note that you may only do this once; if you try to fork again, Gitlab will take you to the page of the original fork. So, if you are planning to maintain two or more separate forks (for example, one for your private work, another for maintenance, etc.), you are doing a mistake. Instead, you should add these forks as a remote of your existing directory (see below for adding remotes). Usually, it is a good thing to add the maintainer’s repository as remotes, because it can happen that “bleeding edge” features will appear there before landing in ns\sphinxhyphen{}3\sphinxhyphen{}dev.

For more information on forking with Gilab, there is plenty of visual documentation (\sphinxurl{https://docs.gitlab.com/ee/gitlab-basics/fork-project.html}). To work with your forked repository, you have two ways: one is a clean clone while the other is meant to re\sphinxhyphen{}use an existing ns\sphinxhyphen{}3 git repository.


\subsubsection{Clone your forked repository on your machine}
\label{\detokenize{working-with-git:clone-your-forked-repository-on-your-machine}}
Git is a distributed versioning system. This means that \sphinxstyleemphasis{nobody} will touch your personal repository, until you do something. Please note that every gitlab user has, at least, two repositories: the first is represented by the repository hosted on gitlab servers, which will be called in the following \sphinxcode{\sphinxupquote{origin}}. Then, you have your clone on your machine. This means that you could have many clones, on different machines, which points to \sphinxcode{\sphinxupquote{origin}}.

To clone the newly created fork to your system, go to the homepage of your fork (that should be in the form \sphinxtitleref{https://gitlab.com/your\sphinxhyphen{}user\sphinxhyphen{}name/ns\sphinxhyphen{}3\sphinxhyphen{}dev}) and click the \sphinxtitleref{Clone} button. Then, go to your computer’s terminal, and issue the command (please refer to \sphinxurl{https://docs.gitlab.com/ee/gitlab-basics/command-line-commands.html\#clone-your-project} for more documentation):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://gitlab.com/your\PYGZhy{}user\PYGZhy{}name/ns\PYGZhy{}3\PYGZhy{}dev
\PYGZdl{} \PYG{n+nb}{cd} ns\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

In this example we used the HTTPS address because in some place the git + ssh address is blocked by firewalls. If you are not under this constraint, it is recommended to use the git + ssh address to avoid the username/password typing at each request.


\subsubsection{Naming conventions}
\label{\detokenize{working-with-git:naming-conventions}}
Git is able to fetch and push changes to several repositories, each of them is called \sphinxcode{\sphinxupquote{remote}}. With time, you probably will have many remotes, each one with many branches. To avoid confusion, it is recommended to give meaningful names to the remotes; in the following, we will use \sphinxcode{\sphinxupquote{origin}} to indicate the ns\sphinxhyphen{}3\sphinxhyphen{}dev repository in your personal namespace (your forked version, server\sphinxhyphen{}side) and \sphinxcode{\sphinxupquote{nsnam}} to indicate the ns\sphinxhyphen{}3\sphinxhyphen{}dev repository in the nsnam namespace, server\sphinxhyphen{}side.


\section{Add the official ns\sphinxhyphen{}3 repository as remote upstream}
\label{\detokenize{working-with-git:add-the-official-ns-3-repository-as-remote-upstream}}
You could have already used git in the past, and therefore already having a ns\sphinxhyphen{}3 git repository somewhere. Or, instead, you could have it cloned for the first time in the step above. In both cases, when you fork/clone a repository, your history is no more bound to the repository itself. At this point, it is your duty to sync your fork with the original repository. The first remote repository we have encountered is \sphinxcode{\sphinxupquote{origin}}; we must add the official ns\sphinxhyphen{}3 repo as another remote repository:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git remote add nsnam https://gitlab.com/nsnam/ns\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

With the command above, we added a remote repository, named nsnam, which links to the official ns\sphinxhyphen{}3 repo. To show your remote repositories:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git remote show
\end{sphinxVerbatim}

To see to what \sphinxcode{\sphinxupquote{origin}} is linking to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git remote show origin
\end{sphinxVerbatim}

Many options are available; please refer to the git manual for more.


\section{Add your forked repository as remote}
\label{\detokenize{working-with-git:add-your-forked-repository-as-remote}}
If you were a user of the old github mirror, you probably have an existing git repository installed somewhere. In your case, it is not necessary to clone your fork and to port all your work in the new directory; you can add the fork as new remote:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git remote rename origin old\PYGZhy{}origin
\PYGZdl{} git remote add origin https://gitlab.com/your\PYGZhy{}user\PYGZhy{}name/ns\PYGZhy{}3\PYGZhy{}dev
\end{sphinxVerbatim}

After these two commands, you will have a remote, named origin, that points
to your forked repository on gitlab.


\section{Keep in sync your repository with latest ns\sphinxhyphen{}3\sphinxhyphen{}dev updates}
\label{\detokenize{working-with-git:keep-in-sync-your-repository-with-latest-ns-3-dev-updates}}
We assume, from now to the end of this document, that you will not make commits on top of the master branch. It should be kept clean from \sphinxstyleemphasis{any} personal modifications: all the works must be done in branches. Therefore, to move the current HEAD of the master branch to the latest commit in ns\sphinxhyphen{}3\sphinxhyphen{}dev, you should do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout master
\PYGZdl{} git fetch nsnam
\PYGZdl{} git pull nsnam master
\end{sphinxVerbatim}

If you tried a pull which resulted in a conflict and you would like to start over, you can recover with git reset (but this never happens if you do not commit over master).


\section{Start a new branch to do some work}
\label{\detokenize{working-with-git:start-a-new-branch-to-do-some-work}}
Look at the available branches:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git branch \PYGZhy{}a
\end{sphinxVerbatim}

you should see something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* master
  remotes/origin/master
  remotes/nsnam/master
\end{sphinxVerbatim}

The branch master is your local master branch; remotes/origin/master point at the master branch on your repository located in the Gitlab server, while remotes/nsnam/master points to the official master branch.

Before entering in details on how to create a new branch, we have to explain why it is recommended to do it. First of all, if you put all your work in a separate branch, you can easily see the diff between ns\sphinxhyphen{}3 mainline and your feature branch (with \sphinxcode{\sphinxupquote{git diff master}}). Also, you can integrate more easily the upstream advancements in your work, and when you wish, you can create a \sphinxstyleemphasis{conflict\sphinxhyphen{}free} merge request, that will ease the maintainer’s job in reviewing your work.

To create a new branch, starting from master, the command is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout master
\PYGZdl{} git checkout \PYGZhy{}b \PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\end{sphinxVerbatim}

To switch between branches, remove the \sphinxhyphen{}b option. You should now see:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git branch \PYGZhy{}a
 * master
  \PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
  remotes/origin/master
  remotes/nsnam/master
\end{sphinxVerbatim}


\section{Edit and commit the modifications}
\label{\detokenize{working-with-git:edit-and-commit-the-modifications}}
After you edit some file, you should commit the difference. As a policy, git users love small and incremental patches. So, commit early, and commit often: you could rewrite your history later.

Suppose we edited \sphinxcode{\sphinxupquote{src/internet/model/tcp\sphinxhyphen{}socket\sphinxhyphen{}base.cc}}. With git status, we can see the repository status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git status
   On branch tcp\PYGZhy{}next
   Your branch is up\PYGZhy{}to\PYGZhy{}date with \PYG{l+s+s1}{\PYGZsq{}mirror/tcp\PYGZhy{}next\PYGZsq{}}.
   Changes not staged \PYG{k}{for} commit:
     modified:   src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
\end{sphinxVerbatim}

and we can see the edits with git diff:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git diff

nat@miyamoto \PYGZti{}/Work/ns\PYGZhy{}3\PYGZhy{}dev\PYGZhy{}git (tcp\PYGZhy{}next)\PYGZdl{} git diff
diff \PYGZhy{}\PYGZhy{}git i/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc w/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
index 1bf0f69..e2298b0 100644
\PYGZhy{}\PYGZhy{}\PYGZhy{} i/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
+++ w/src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
@@ \PYGZhy{}1439,6 +1439,10 @@ TcpSocketBase::ReceivedAck (Ptr\PYGZlt{}Packet\PYGZgt{} packet, const TcpHeader\PYGZam{} tcpHeader)
       // There is a DupAck
       ++m\PYGZus{}dupAckCount;

+      // I\PYGZsq{}m introducing a subtle bug!
+
+      m\PYGZus{}tcb\PYGZhy{}\PYGZgt{}m\PYGZus{}cWnd = m\PYGZus{}tcb\PYGZhy{}\PYGZgt{}m\PYGZus{}ssThresh;
+
       if (m\PYGZus{}tcb\PYGZhy{}\PYGZgt{}m\PYGZus{}congState == TcpSocketState::CA\PYGZus{}OPEN)
         \PYGZob{}
           // From Open we go Disorder
\end{sphinxVerbatim}

To create a commit, select the file you want to add to the commit with git add:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git add src/internet/model/tcp\PYGZhy{}socket\PYGZhy{}base.cc
\end{sphinxVerbatim}

and then commit the result:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git commit \PYGZhy{}m \PYG{l+s+s2}{\PYGZdq{}My new TCP broken\PYGZdq{}}
\end{sphinxVerbatim}

Of course, it would be better to have some rules for the commit message: they will be reported in the next subsection.


\subsection{Commit message guidelines}
\label{\detokenize{working-with-git:commit-message-guidelines}}
The commit title should not go over the 80 char limit. It should be prefixed by the name of the module you are working on, and if it fixes a bug, it should reference it in the commit title. For instance, a good commit title would be:
\begin{quote}

tcp: My new TCP broken
\end{quote}

Another example is:
\begin{quote}

tcp: (fixes \#2322) Corrected the uint32\_t wraparound during recovery
\end{quote}

In the body message, try to explain what the problem was, and how you resolved that. If it is a new feature, try to describe it at a very high level, and highlight any modifications that changed the behaviour or the interface towards the users or other modules.


\subsection{Commit log}
\label{\detokenize{working-with-git:commit-log}}
You can see the history of the commits with git log. To show a particular commit, copy the sha\sphinxhyphen{}id and use \sphinxcode{\sphinxupquote{git show \textless{}sha\sphinxhyphen{}id\textgreater{}}}. The ID is unique, so it can be referenced in emails or in issues. The next step is useful if you plan to contribute back your changes, but also to keep your feature branch updated with the latest changes from ns\sphinxhyphen{}3\sphinxhyphen{}dev.


\section{Rebase your branch on top of master}
\label{\detokenize{working-with-git:rebase-your-branch-on-top-of-master}}
Meanwhile you were busy with your branch, the upstream master could have changed. To rebase your work with the now new master, first of all sync your master branch (pulling the nsnam/master branch into your local master branch) as explained before; then

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout \PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\PYGZdl{} git rebase master
\end{sphinxVerbatim}

The last command will rewind your work, update the HEAD of your branch to the actual master, and then re\sphinxhyphen{}apply all your work. If some of your work conflicts with the actual master, you will be asked to fix these conflicts if automatic merge fails.


\section{Pushing your changes to origin}
\label{\detokenize{working-with-git:pushing-your-changes-to-origin}}
After you have done some work on a branch, if you would like to share it with others, there is nothing better than pushing your work to your origin repository, on Gitlab servers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout \PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\PYGZdl{} git push origin \PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{git push}} command can be used every time you need to push something from your computer to a remote repository, except when you propose changes to the main ns\sphinxhyphen{}3\sphinxhyphen{}dev repository: your changes must pass a review stage.

Please note that for older git version, the push command looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git push \PYGZhy{}u origin \PYG{o}{[}name\PYGZus{}of\PYGZus{}your\PYGZus{}new\PYGZus{}branch\PYG{o}{]}
\end{sphinxVerbatim}


\section{Submit work for review}
\label{\detokenize{working-with-git:submit-work-for-review}}
After you push your branch to origin, you can follow the instructions here \sphinxurl{https://docs.gitlab.com/ee/gitlab-basics/add-merge-request.html} to create a merge request. Please remember to add, as reviewer, at least one maintainer. To get the information on who is maintaining what, please refer to the \sphinxhref{https://www.nsnam.org/develop/maintainers/}{nsnam website}.


\section{Porting patches from mercurial repositories to git}
\label{\detokenize{working-with-git:porting-patches-from-mercurial-repositories-to-git}}
\sphinxstyleemphasis{Placeholder section; please improve it.}


\chapter{Working with git as a maintainer}
\label{\detokenize{working-with-git:working-with-git-as-a-maintainer}}
As a maintainer, you are a person who has write access to the main nsnam repository. You could push your own work (without passing from code review) or push someone else’s work. Let’s investigate the two cases.


\section{Pushing your own work}
\label{\detokenize{working-with-git:pushing-your-own-work}}
Since you have been added to the Developer list on Gitlab (if not, please open an issue) you can use the git + ssh address when adding nsnam as remote. Once you have done that, you can do your modifications to a local branch, then update the master to point to the latest changes of the nsnam repo, and then:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout master
\PYGZdl{} git pull nsnam master
\PYGZdl{} git merge \PYG{o}{[}your\PYGZus{}branch\PYGZus{}name\PYG{o}{]}
\PYGZdl{} git push nsnam master
\end{sphinxVerbatim}

Please note that if you want to keep track of your branch, you can use as command \sphinxcode{\sphinxupquote{git merge \sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}ff {[}your\_branch\_name{]}}}. It is always recommended to rebase your branch before merging, to have a clean history. That is not a requirement, though: git perfectly handles a master with parallel merged branches.


\section{Review and merge someone else’s work}
\label{\detokenize{working-with-git:review-and-merge-someone-else-s-work}}
Gitlab.com has a plenty of documentation on how to handle merge requests. Please take a look here: \sphinxurl{https://docs.gitlab.com/ee/user/project/merge\_requests/index.html}.

If you are committing a patch from someone else, and it is not coming through a Merge Request process, you can use the \textendash{}author=’’ argument to ‘git commit’ to assign authorship to another email address (such as we have done in the past with the Mercurial \sphinxhyphen{}u option).


\section{Making a release}
\label{\detokenize{working-with-git:making-a-release}}
As stated above, the project has adopted a workflow to aim for a mostly
linear history on a single \sphinxcode{\sphinxupquote{master}} branch.  Releases are branches from
this \sphinxcode{\sphinxupquote{master}} branch but the branches themselves are not long\sphinxhyphen{}lived;
the release branches are merged back to \sphinxcode{\sphinxupquote{master}} in a special way.  However,
the release branches can be checked out by using the git tag facility;
a named release such as ‘ns\sphinxhyphen{}3.30’ can be checked out on a branch by specifying
the release name ‘ns\sphinxhyphen{}3.30’ (or ‘ns\sphinxhyphen{}3.30.1’ etc.).

To facilitate this, let’s look at a toy repository and the git commands
involved.  This repository is initialized with a few files (\sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{b}},
\sphinxcode{\sphinxupquote{c}}, and \sphinxcode{\sphinxupquote{README.md}}) and a \sphinxcode{\sphinxupquote{VERSION}} file.  \sphinxcode{\sphinxupquote{VERSION}} is always
kept on the string \sphinxcode{\sphinxupquote{3\sphinxhyphen{}dev}} in the \sphinxcode{\sphinxupquote{master}} branch, but is changed to
the release number in the release branches.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls
a  b  c  README.md  VERSION
\end{sphinxVerbatim}

The git log command can be appended with some arguments to display the
branch history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git log \PYGZhy{}\PYGZhy{}graph \PYGZhy{}\PYGZhy{}decorate \PYGZhy{}\PYGZhy{}oneline \PYGZhy{}\PYGZhy{}all
* d3e953b \PYG{o}{(}HEAD \PYGZhy{}\PYGZgt{} master\PYG{o}{)} Add VERSION file
* 62b05c5 Add three files a, b, and c
* 3e124c8 \PYG{o}{(}origin/master, origin/HEAD\PYG{o}{)} Initial commit

\PYGZdl{} cat VERSION
\PYG{l+m}{3}\PYGZhy{}dev

\PYGZdl{} git branch \PYGZhy{}a
* master
  remotes/origin/HEAD \PYGZhy{}\PYGZgt{} origin/master
  remotes/origin/master
\end{sphinxVerbatim}

Now, let’s create a notional ns\sphinxhyphen{}3.1 release.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout \PYGZhy{}b \PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.1\PYGZhy{}release\PYGZsq{}}
Switched to a new branch \PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.1\PYGZhy{}release\PYGZsq{}}
\end{sphinxVerbatim}

We change the VERSION field from ‘3\sphinxhyphen{}dev’ to ‘3.1’:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sed \PYGZhy{}i \PYG{l+s+s1}{\PYGZsq{}s/3\PYGZhy{}dev/3.1/g\PYGZsq{}} VERSION
\PYGZdl{} cat VERSION
\PYG{l+m}{3}.1
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Update VERSION to 3.1\PYGZdq{}} VERSION
\end{sphinxVerbatim}

Let’s release this.  Add a git annotated tag as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git tag \PYGZhy{}a \PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.1\PYGZsq{}} \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}ns\PYGZhy{}3.1 release\PYGZdq{}}
\end{sphinxVerbatim}

Now, let’s merge back to \sphinxcode{\sphinxupquote{master}}.  However, we want to avoid touching
the \sphinxcode{\sphinxupquote{VERSION}} file on \sphinxcode{\sphinxupquote{master}}; we want all other changes and tags
but this one.  We can accomplish this with a special merge as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout master
\PYGZdl{} git merge \PYGZhy{}\PYGZhy{}no\PYGZhy{}commit \PYGZhy{}\PYGZhy{}no\PYGZhy{}ff ns\PYGZhy{}3.1\PYGZhy{}release
Automatic merge went well\PYG{p}{;} stopped before committing as requested
\end{sphinxVerbatim}

Now, we want to reset VERSION to the previous string, which existed before
we branched.  We can use \sphinxcode{\sphinxupquote{git reset}} on this file and then finish the merge.
Recall its commit hash of \sphinxcode{\sphinxupquote{d3e953b}} from above

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git reset d3e953b VERSION
Unstaged changes after reset:
M     VERSION
\PYGZdl{} sed \PYGZhy{}i \PYG{l+s+s1}{\PYGZsq{}s/3.1/3\PYGZhy{}dev/g\PYGZsq{}} VERSION
\PYGZdl{} cat VERSION
\PYG{l+m}{3}\PYGZhy{}dev
\end{sphinxVerbatim}

Finally, commit the branch and delete our local release branch.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Merge ns\PYGZhy{}3.1\PYGZhy{}release branch\PYGZdq{}}
\PYGZdl{} git branch \PYGZhy{}d ns\PYGZhy{}3.1\PYGZhy{}release
\end{sphinxVerbatim}

The git history now looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git log \PYGZhy{}\PYGZhy{}graph \PYGZhy{}\PYGZhy{}decorate \PYGZhy{}\PYGZhy{}oneline \PYGZhy{}\PYGZhy{}all
*   80de6c5 \PYG{o}{(}HEAD \PYGZhy{}\PYGZgt{} master\PYG{o}{)} Merge ns\PYGZhy{}3.1\PYGZhy{}release branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|} * 5718d61 \PYG{o}{(}tag: ns\PYGZhy{}3.1, ns\PYGZhy{}3.1\PYGZhy{}release\PYG{o}{)} Update VERSION to \PYG{l+m}{3}.1
\PYG{p}{|}/
* d3e953b Add VERSION file
* 62b05c5 Add three files a, b, and c
* 3e124c8 \PYG{o}{(}origin/master, origin/HEAD\PYG{o}{)} Initial commit
\PYGZdl{} git tag
ns\PYGZhy{}3.1
\end{sphinxVerbatim}

This may now be pushed to \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} and development can continue.

\sphinxstylestrong{Note:}  When pushing to the remote, don’t forget to push the tags:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git push \PYGZhy{}\PYGZhy{}follow\PYGZhy{}tags
\end{sphinxVerbatim}

Future users who want to check out the ns\sphinxhyphen{}3.1 release will do something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout \PYGZhy{}b my\PYGZhy{}local\PYGZhy{}ns\PYGZhy{}3.1 ns\PYGZhy{}3.1
Switched to a new branch \PYG{l+s+s1}{\PYGZsq{}my\PYGZhy{}local\PYGZhy{}ns\PYGZhy{}3.1\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Note:}  It is a good idea to avoid naming the new branch the same as the tag
name; in this case, ‘ns\sphinxhyphen{}3.1’.

Let’s assume now that master evolves with new features and bugfixes.  They
are committed to \sphinxcode{\sphinxupquote{master}} on \sphinxcode{\sphinxupquote{nsnam/ns\sphinxhyphen{}3\sphinxhyphen{}dev.git}} as usual:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout master
... \PYG{o}{(}some changes\PYG{o}{)}
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}make some changes\PYGZdq{}} \PYGZhy{}a
\PYGZdl{} \PYG{n+nb}{echo} \PYG{l+s+s1}{\PYGZsq{}d\PYGZsq{}} \PYGZgt{}\PYGZgt{} d
\PYGZdl{} git add d
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Add new feature\PYGZdq{}} d
... \PYG{o}{(}some more changes\PYG{o}{)}
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}some more changes\PYGZdq{}} \PYGZhy{}a
... \PYG{o}{(}now fix a really important bug\PYG{o}{)}
\PYGZdl{} \PYG{n+nb}{echo} \PYG{l+s+s1}{\PYGZsq{}abc\PYGZsq{}} \PYGZgt{}\PYGZgt{} a
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Fix missing abc bug on file a\PYGZdq{}} a
\end{sphinxVerbatim}

Now the tree looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git log \PYGZhy{}\PYGZhy{}graph \PYGZhy{}\PYGZhy{}decorate \PYGZhy{}\PYGZhy{}oneline \PYGZhy{}\PYGZhy{}all
* ee37d41 \PYG{o}{(}HEAD \PYGZhy{}\PYGZgt{} master\PYG{o}{)} Fix missing abc bug on file a
* 9a3432a some more changes
* ba28d6d Add new feature
* e50015a make some changes
*   80de6c5 Merge ns\PYGZhy{}3.1\PYGZhy{}release branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|} * 5718d61 \PYG{o}{(}tag: ns\PYGZhy{}3.1\PYG{o}{)} Update VERSION to \PYG{l+m}{3}.1
\PYG{p}{|}/
* d3e953b Add VERSION file
* 62b05c5 Add three files a, b, and c
* 3e124c8 \PYG{o}{(}origin/master, origin/HEAD\PYG{o}{)} Initial commit
\end{sphinxVerbatim}

Let’s assume that the changeset \sphinxcode{\sphinxupquote{ee37d41}} is considered important to fix in
the ns\sphinxhyphen{}3.1 release, but we don’t want the other changes introduced since then.
The solution will be to create a new branch for a hotfix release, and follow
similar steps.  The branch for the hotfix should come from commit \sphinxcode{\sphinxupquote{5718d61}},
and should cherry\sphinxhyphen{}pick commit \sphinxcode{\sphinxupquote{ee37d41}} (which may require merge if it
doesn’t apply cleanly), and then the hotfix branch can be tagged and merged
as was done before.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout \PYGZhy{}b ns\PYGZhy{}3.1.1\PYGZhy{}release ns\PYGZhy{}3.1
\PYGZdl{} git cherry\PYGZhy{}pick ee37d41
... \PYG{o}{(}resolve any conflicts\PYG{o}{)}
\PYGZdl{} git add a
\PYGZdl{} git commit
\PYGZdl{} sed \PYGZhy{}i \PYG{l+s+s1}{\PYGZsq{}s/3.1/3.1.1/g\PYGZsq{}} VERSION
\PYGZdl{} cat VERSION
\PYG{l+m}{3}.1.1
\PYGZdl{} git commit \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}Update VERSION to 3.1.1\PYGZdq{}} VERSION
\PYGZdl{} git tag \PYGZhy{}a \PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.1.1\PYGZsq{}} \PYGZhy{}m\PYG{l+s+s2}{\PYGZdq{}ns\PYGZhy{}3.1.1 release\PYGZdq{}}
\end{sphinxVerbatim}

Now the merge:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git checkout master
\PYGZdl{} git merge \PYGZhy{}\PYGZhy{}no\PYGZhy{}commit \PYGZhy{}\PYGZhy{}no\PYGZhy{}ff ns\PYGZhy{}3.1.1\PYGZhy{}release
\end{sphinxVerbatim}

This time we see:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Auto\PYGZhy{}merging a
CONFLICT \PYG{o}{(}content\PYG{o}{)}: Merge conflict in a
Auto\PYGZhy{}merging VERSION
CONFLICT \PYG{o}{(}content\PYG{o}{)}: Merge conflict in VERSION
Automatic merge failed\PYG{p}{;} fix conflicts and \PYG{k}{then} commit the result.
\end{sphinxVerbatim}

And we can then do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git reset ee37d41 a
\PYGZdl{} git reset ee37d41 VERSION
\end{sphinxVerbatim}

Which leaves us with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Unstaged changes after reset:
M     VERSION
M     a
\end{sphinxVerbatim}

We can next hand\sphinxhyphen{}edit these files to restore them to original state, so that:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git status
On branch master
Your branch is ahead of \PYG{l+s+s1}{\PYGZsq{}origin/master\PYGZsq{}} by \PYG{l+m}{8} commits.
  \PYG{o}{(}use \PYG{l+s+s2}{\PYGZdq{}git push\PYGZdq{}} to publish your \PYG{n+nb}{local} commits\PYG{o}{)}

All conflicts fixed but you are still merging.
  \PYG{o}{(}use \PYG{l+s+s2}{\PYGZdq{}git commit\PYGZdq{}} to conclude merge\PYG{o}{)}

\PYGZdl{} git commit
\PYGZdl{} git branch \PYGZhy{}d ns\PYGZhy{}3.1.1\PYGZhy{}release
\end{sphinxVerbatim}

The new log should show:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git log \PYGZhy{}\PYGZhy{}graph \PYGZhy{}\PYGZhy{}decorate \PYGZhy{}\PYGZhy{}oneline \PYGZhy{}\PYGZhy{}all
*   815ce6e \PYG{o}{(}HEAD \PYGZhy{}\PYGZgt{} master\PYG{o}{)} Merge branch \PYG{l+s+s1}{\PYGZsq{}ns\PYGZhy{}3.1.1\PYGZhy{}release\PYGZsq{}}
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|} * 12a29ca \PYG{o}{(}tag: ns\PYGZhy{}3.1.1, ns\PYGZhy{}3.1.1\PYGZhy{}release\PYG{o}{)} Update VERSION to \PYG{l+m}{3}.1.1
\PYG{p}{|} * 21ebdbf Fix missing abc bug on file a
* \PYG{p}{|} ee37d41 Fix missing abc bug on file a
* \PYG{p}{|} 9a3432a some more changes
* \PYG{p}{|} ba28d6d Add new feature
* \PYG{p}{|} e50015a make some changes
* \PYG{p}{|}   80de6c5 Merge ns\PYGZhy{}3.1\PYGZhy{}release branch
\PYG{p}{|}\PYG{l+s+se}{\PYGZbs{} }\PYG{l+s+se}{\PYGZbs{}}
\PYG{p}{|} \PYG{p}{|}/
\PYG{p}{|} * 5718d61 \PYG{o}{(}tag: ns\PYGZhy{}3.1\PYG{o}{)} Update VERSION to \PYG{l+m}{3}.1
\PYG{p}{|}/
* d3e953b Add VERSION file
* 62b05c5 Add three files a, b, and c
* 3e124c8 \PYG{o}{(}origin/master, origin/HEAD\PYG{o}{)} Initial commit
\end{sphinxVerbatim}

And we can continue to commit on top of master going forward.  The two
tags are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git tag
ns\PYGZhy{}3.1
ns\PYGZhy{}3.1.1
\end{sphinxVerbatim}


\chapter{Random Variables}
\label{\detokenize{random-variables:random-variables}}\label{\detokenize{random-variables::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} contains a built\sphinxhyphen{}in pseudo\sphinxhyphen{}random number generator (PRNG). It is important
for serious users of the simulator to understand the functionality,
configuration, and usage of this PRNG, and to decide whether it is sufficient
for his or her research use.


\section{Quick Overview}
\label{\detokenize{random-variables:quick-overview}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} random numbers are provided via instances of
\sphinxcode{\sphinxupquote{ns3::RandomVariableStream}}.
\begin{itemize}
\item {} 
by default, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations use a fixed seed; if there is any randomness in
the simulation, each run of the program will yield identical results unless
the seed and/or run number is changed.

\item {} 
in \sphinxstyleemphasis{ns\sphinxhyphen{}3.3} and earlier, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations used a random seed by default; this
marks a change in policy starting with \sphinxstyleemphasis{ns\sphinxhyphen{}3.4}.

\item {} 
in \sphinxstyleemphasis{ns\sphinxhyphen{}3.14} and earlier, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations used a different wrapper class
called \sphinxcode{\sphinxupquote{ns3::RandomVariable}}.  As of \sphinxstyleemphasis{ns\sphinxhyphen{}3.15}, this class has been
replaced by \sphinxcode{\sphinxupquote{ns3::RandomVariableStream}}; the underlying pseudo\sphinxhyphen{}random
number generator has not changed.

\item {} 
to obtain randomness across multiple simulation runs, you must either set the
seed differently or set the run number differently.  To set a seed, call
\sphinxcode{\sphinxupquote{ns3::RngSeedManager::SetSeed()}} at the beginning of the program; to set
a run number with the same seed, call \sphinxcode{\sphinxupquote{ns3::RngSeedManager::SetRun()}} at
the beginning of the program; see {\hyperref[\detokenize{random-variables:seeding-and-independent-replications}]{\sphinxcrossref{\DUrole{std,std-ref}{Creating random variables}}}}.

\item {} 
each RandomVariableStream used in \sphinxstyleemphasis{ns\sphinxhyphen{}3} has a virtual random number generator
associated with it; all random variables use either a fixed or random seed
based on the use of the global seed (previous bullet);

\item {} 
if you intend to perform multiple runs of the same scenario, with different
random numbers, please be sure to read the section on how to perform
independent replications: {\hyperref[\detokenize{random-variables:seeding-and-independent-replications}]{\sphinxcrossref{\DUrole{std,std-ref}{Creating random variables}}}}.

\end{itemize}

Read further for more explanation about the random number facility for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\section{Background}
\label{\detokenize{random-variables:background}}
Simulations use a lot of random numbers; one study
found that most network simulations spend as much as 50\%
of the CPU generating random numbers.  Simulation users need
to be concerned with the quality of the (pseudo) random numbers and
the independence between different streams of random numbers.

Users need to be concerned with a few issues, such as:
\begin{itemize}
\item {} 
the seeding of the random number generator and whether a
simulation outcome is deterministic or not,

\item {} 
how to acquire different streams of random numbers that are
independent from one another, and

\item {} 
how long it takes for streams to cycle

\end{itemize}

We will introduce a few terms here:  a RNG provides a long sequence
of (pseudo) random numbers.
The length of this sequence is called the \sphinxstyleemphasis{cycle length}
or \sphinxstyleemphasis{period}, after which the RNG will repeat itself.
This sequence can
be  partitioned into disjoint \sphinxstyleemphasis{streams}.  A stream of a
RNG is a contiguous subset or block of the RNG sequence.
For instance, if the
RNG period is of length N, and two streams are provided from this
RNG, then
the first stream might use the first N/2 values and the second
stream might produce the second N/2 values.  An important property
here is that the two streams are uncorrelated.  Likewise, each
stream can be partitioned disjointedly to a number of
uncorrelated \sphinxstyleemphasis{substreams}.  The underlying RNG hopefully
produces a pseudo\sphinxhyphen{}random sequence of numbers with a very long
cycle length, and partitions this into streams and substreams in an
efficient manner.

\sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the same underlying random number generator as does \sphinxstyleemphasis{ns\sphinxhyphen{}2}:  the
MRG32k3a generator from Pierre L’Ecuyer.  A detailed description can be found in
\sphinxurl{http://www.iro.umontreal.ca/~lecuyer/myftp/papers/streams00.pdf}.  The MRG32k3a
generator provides \(1.8x10^{19}\) independent streams of random numbers,
each of which consists of \(2.3x10^{15}\) substreams. Each substream has a
period (\sphinxstyleemphasis{i.e.}, the number of random numbers before overlap) of
\(7.6x10^{22}\). The period of the entire generator is \(3.1x10^{57}\).

Class \sphinxcode{\sphinxupquote{ns3::RandomVariableStream}} is the public interface to this
underlying random number generator.  When users create new random variables
(such as \sphinxcode{\sphinxupquote{ns3::UniformRandomVariable}},
\sphinxcode{\sphinxupquote{ns3::ExponentialRandomVariable}}, etc.), they create an object that uses
one of the distinct, independent streams of the random number generator.
Therefore, each object of type \sphinxcode{\sphinxupquote{ns3::RandomVariableStream}} has,
conceptually, its own “virtual” RNG.  Furthermore, each
\sphinxcode{\sphinxupquote{ns3::RandomVariableStream}} can be configured to use one of the set of
substreams drawn from the main stream.

An alternate implementation would be to allow each RandomVariable to have its
own (differently seeded) RNG.  However, we cannot guarantee as strongly that the
different sequences would be uncorrelated in such a case; hence, we prefer to
use a single RNG and streams and substreams from it.


\section{Creating random variables}
\label{\detokenize{random-variables:creating-random-variables}}\label{\detokenize{random-variables:seeding-and-independent-replications}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} supports a number of random variable objects from the base class
\sphinxcode{\sphinxupquote{RandomVariableStream}}.  These objects derive from
\sphinxcode{\sphinxupquote{ns3::Object}} and are handled by smart pointers.

The correct way to create these objects is to use the templated
\sphinxtitleref{CreateObject\textless{}\textgreater{}} method, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}} \PYG{n}{x} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then you can access values by calling methods on the object such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myRandomNo} \PYG{o}{=} \PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetInteger} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If you try to instead do something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myRandomNo} \PYG{o}{=} \PYG{n}{UniformRandomVariable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{GetInteger} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

your program will encounter a segmentation fault, because the implementation
relies on some attribute construction that occurs only when \sphinxtitleref{CreateObject}
is called.

Much of the rest of this chapter now discusses the properties of the
stream of pseudo\sphinxhyphen{}random numbers generated from such objects, and how to
control the seeding of such objects.


\section{Seeding and independent replications}
\label{\detokenize{random-variables:id1}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations can be configured to produce deterministic or random results.
If the \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation is configured to use a fixed, deterministic seed with
the same run number, it should give the same output each time it is run.

By default, \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations use a fixed seed and run number.  These values
are stored in two \sphinxcode{\sphinxupquote{ns3::GlobalValue}} instances: \sphinxcode{\sphinxupquote{g\_rngSeed}} and
\sphinxcode{\sphinxupquote{g\_rngRun}}.

A typical use case is to run a simulation as a sequence of independent trials,
so as to compute statistics on a large number of independent runs.  The user can
either change the global seed and rerun the simulation, or can advance the
substream state of the RNG, which is referred to as incrementing the run number.

A class \sphinxcode{\sphinxupquote{ns3::RngSeedManager}} provides an API to control the seeding and
run number behavior.  This seeding and substream state setting must be called
before any random variables are created; e.g:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RngSeedManager}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetSeed} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Changes seed from default of 1 to 3}
\PYG{n}{RngSeedManager}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetRun} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// Changes run number from default of 1 to 7}
\PYG{c+c1}{// Now, create random variables}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}} \PYG{n}{x} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{UniformRandomVariable}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ExponentialRandomVariable}\PYG{o}{\PYGZgt{}} \PYG{n}{y} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ExponentialRandomVarlable}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

Which is better, setting a new seed or advancing the substream state?  There is
no guarantee that the streams produced by two random seeds will not overlap.
The only way to guarantee that two streams do not overlap is to use the
substream capability provided by the RNG implementation.  \sphinxstyleemphasis{Therefore, use the
substream capability to produce multiple independent runs of the same
simulation.} In other words, the more statistically rigorous way to configure
multiple independent replications is to use a fixed seed and to advance the run
number.  This implementation allows for a maximum of \(2.3x10^{15}\)
independent replications using the substreams.

For ease of use, it is not necessary to control the seed and run number from
within the program; the user can set the \sphinxcode{\sphinxupquote{NS\_GLOBAL\_VALUE}} environment
variable as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}GLOBAL\PYGZus{}VALUE}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}RngRun=3\PYGZdq{}} ./waf \PYGZhy{}\PYGZhy{}run program\PYGZhy{}name
\end{sphinxVerbatim}

Another way to control this is by passing a command\sphinxhyphen{}line argument; since this is
an \sphinxstyleemphasis{ns\sphinxhyphen{}3} GlobalValue instance, it is equivalently done such as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}s \PYGZhy{}\PYGZhy{}RngRun=3\PYGZdq{}} \PYGZhy{}\PYGZhy{}run program\PYGZhy{}name
\end{sphinxVerbatim}

or, if you are running programs directly outside of waf:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./build/optimized/scratch/program\PYGZhy{}name \PYGZhy{}\PYGZhy{}RngRun\PYG{o}{=}\PYG{l+m}{3}
\end{sphinxVerbatim}

The above command\sphinxhyphen{}line variants make it easy to run lots of different
runs from a shell script by just passing a different RngRun index.


\section{Class RandomVariableStream}
\label{\detokenize{random-variables:class-randomvariablestream}}
All random variables should derive from class \sphinxcode{\sphinxupquote{RandomVariable}}. This
base class provides a few methods for globally configuring the behavior
of the random number generator. Derived classes provide API for drawing random
variates from the particular distribution being supported.

Each RandomVariableStream created in the simulation is given a generator that is a
new RNGStream from the underlying PRNG. Used in this manner, the L’Ecuyer
implementation allows for a maximum of \(1.8x10^19\) random variables.  Each
random variable in a single replication can produce up to \(7.6x10^22\)
random numbers before overlapping.


\section{Base class public API}
\label{\detokenize{random-variables:base-class-public-api}}
Below are excerpted a few public methods of class \sphinxcode{\sphinxupquote{RandomVariableStream}}
that access the next value in the substream.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}brief Returns a random double from the underlying distribution}
\PYG{c+cm}{ * \PYGZbs{}return A floating point random value}
\PYG{c+cm}{ */}
\PYG{k+kt}{double} \PYG{n+nf}{GetValue} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}brief Returns a random integer from the underlying distribution}
\PYG{c+cm}{ * \PYGZbs{}return  Integer cast of ::GetValue()}
\PYG{c+cm}{ */}
\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n+nf}{GetInteger} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

We have already described the seeding configuration above. Different
RandomVariable subclasses may have additional API.


\section{Types of RandomVariables}
\label{\detokenize{random-variables:types-of-randomvariables}}
The following types of random variables are provided, and are documented in the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} Doxygen or by reading \sphinxcode{\sphinxupquote{src/core/model/random\sphinxhyphen{}variable\sphinxhyphen{}stream.h}}.  Users
can also create their own custom random variables by deriving from class
\sphinxcode{\sphinxupquote{RandomVariableStream}}.
\begin{itemize}
\item {} 
class \sphinxcode{\sphinxupquote{UniformRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{ConstantRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{SequentialRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{ExponentialRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{ParetoRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{WeibullRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{NormalRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{LogNormalRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{GammaRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{ErlangRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{TriangularRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{ZipfRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{ZetaRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{DeterministicRandomVariable}}

\item {} 
class \sphinxcode{\sphinxupquote{EmpiricalRandomVariable}}

\end{itemize}


\section{Semantics of RandomVariableStream objects}
\label{\detokenize{random-variables:semantics-of-randomvariablestream-objects}}
RandomVariableStream objects derive from \sphinxcode{\sphinxupquote{ns3::Object}} and are
handled by smart pointers.

RandomVariableStream instances can also be used in \sphinxstyleemphasis{ns\sphinxhyphen{}3} attributes, which means
that values can be set for them through the \sphinxstyleemphasis{ns\sphinxhyphen{}3} attribute system.
An example is in the propagation models for WifiNetDevice:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}
\PYG{n}{RandomPropagationDelayModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RandomPropagationDelayModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{PropagationDelayModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Propagation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{RandomPropagationDelayModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Variable}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The random variable which generates random delays (s).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::UniformRandomVariable}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakePointerAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{RandomPropagationDelayModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}variable}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakePointerChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{RandomVariableStream}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{;}
  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here, the \sphinxstyleemphasis{ns\sphinxhyphen{}3} user can change the default random variable for this
delay model (which is a UniformRandomVariable ranging from 0 to 1) through
the attribute system.


\section{Using other PRNG}
\label{\detokenize{random-variables:using-other-prng}}
There is presently no support for substituting a different underlying
random number generator (e.g., the GNU Scientific Library or the Akaroa
package).  Patches are welcome.


\section{Setting the stream number}
\label{\detokenize{random-variables:setting-the-stream-number}}
The underlying MRG32k3a generator provides 2\textasciicircum{}64 independent streams.
In ns\sphinxhyphen{}3, these are assigned sequentially starting from the first stream as
new RandomVariableStream instances make their first call to GetValue().

As a result of how these RandomVariableStream objects are assigned to
underlying streams, the assignment is sensitive to perturbations of
the simulation configuration.  The consequence is that if any aspect of the
simulation configuration is changed, the mapping of RandomVariables to
streams may (or may not) change.

As a concrete example, a user running a comparative study between routing
protocols may find that the act of changing one routing protocol for another
will notice that the underlying mobility pattern also changed.

Starting with ns\sphinxhyphen{}3.15, some control has been provided to users to allow
users to optionally fix the assignment of selected RandomVariableStream
objects to underlying streams.  This is the \sphinxcode{\sphinxupquote{Stream}} attribute, part
of the base class RandomVariableStream.

By partitioning the existing sequence of streams from before:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
stream 0                                                   stream (2\PYGZca{}64 \PYGZhy{} 1)
\end{sphinxVerbatim}

into two equal\sphinxhyphen{}sized sets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZca{}                                    \PYGZca{}\PYGZca{}                                    \PYGZca{}
|                                    ||                                    |
stream 0            stream (2\PYGZca{}63 \PYGZhy{} 1)  stream 2\PYGZca{}63         stream (2\PYGZca{}64 \PYGZhy{} 1)
\PYGZlt{}\PYGZhy{} automatically assigned \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZlt{}\PYGZhy{} assigned by user \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\end{sphinxVerbatim}

The first 2\textasciicircum{}63 streams continue to be automatically assigned, while
the last 2\textasciicircum{}63 are given stream indices starting with zero up to
2\textasciicircum{}63\sphinxhyphen{}1.

The assignment of streams to a fixed stream number is optional; instances
of RandomVariableStream that do not have a stream value assigned will
be assigned the next one from the pool of automatic streams.

To fix a RandomVariableStream to a particular underlying stream, assign
its \sphinxcode{\sphinxupquote{Stream}} attribute to a non\sphinxhyphen{}negative integer (the default value
of \sphinxhyphen{}1 means that a value will be automatically allocated).


\section{Publishing your results}
\label{\detokenize{random-variables:publishing-your-results}}
When you publish simulation results, a key piece of configuration
information that you should always state is how you used the
random number generator.
\begin{itemize}
\item {} 
what seeds you used,

\item {} 
what RNG you used if not the default,

\item {} 
how were independent runs performed,

\item {} 
for large simulations, how did you check that you did not cycle.

\end{itemize}

It is incumbent on the researcher publishing results to include enough
information to allow others to reproduce his or her results. It is also
incumbent on the researcher to convince oneself that the random numbers used
were statistically valid, and to state in the paper why such confidence is
assumed.


\section{Summary}
\label{\detokenize{random-variables:summary}}
Let’s review what things you should do when creating a simulation.
\begin{itemize}
\item {} 
Decide whether you are running with a fixed seed or random seed; a fixed seed
is the default,

\item {} 
Decide how you are going to manage independent replications, if applicable,

\item {} 
Convince yourself that you are not drawing more random values than the cycle
length, if you are running a very long simulation, and

\item {} 
When you publish, follow the guidelines above about documenting your use of
the random number generator.

\end{itemize}


\chapter{Hash Functions}
\label{\detokenize{hash-functions:hash-functions}}\label{\detokenize{hash-functions::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} provides a generic interface to general purpose hash functions.
In the simplest usage, the hash function returns the 32\sphinxhyphen{}bit or 64\sphinxhyphen{}bit
hash of a data buffer or string.  The default underlying hash function
is \sphinxhref{http://code.google.com/p/smhasher/wiki/MurmurHash3}{murmur3}, chosen because it has good hash function properties and
offers a 64\sphinxhyphen{}bit version.  The venerable \sphinxhref{http://isthe.com/chongo/tech/comp/fnv/}{FNV1a} hash is also available.

There is a straight\sphinxhyphen{}forward mechanism to
add (or provide at run time) alternative hash function implementations.


\section{Basic Usage}
\label{\detokenize{hash-functions:basic-usage}}
The simplest way to get a hash value of a data buffer or string is just:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/hash.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{ns3}\PYG{p}{;}

\PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{buffer} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{buffer\PYGZus{}size} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{k+kt}{uint32\PYGZus{}t}  \PYG{n}{buffer\PYGZus{}hash} \PYG{o}{=} \PYG{n}{Hash32} \PYG{p}{(} \PYG{n}{buffer}\PYG{p}{,} \PYG{n}{buffer\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{s}\PYG{p}{;}
\PYG{k+kt}{uint32\PYGZus{}t}  \PYG{n}{string\PYGZus{}hash} \PYG{o}{=} \PYG{n}{Hash32} \PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Equivalent functions are defined for 64\sphinxhyphen{}bit hash values.


\section{Incremental Hashing}
\label{\detokenize{hash-functions:incremental-hashing}}
In some situations it’s useful to compute the hash of multiple buffers,
as if they had been joined together.  (For example, you might want
the hash of a packet stream, but not want to assemble a single buffer
with the combined contents of all the packets.)

This is almost as straight\sphinxhyphen{}forward as the first example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/hash.h\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{ns3}\PYG{p}{;}

\PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{buffer}\PYG{p}{;}
\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{buffer\PYGZus{}size}\PYG{p}{;}

\PYG{n}{Hasher} \PYG{n}{hasher}\PYG{p}{;}  \PYG{c+c1}{// Use default hash function}

\PYG{k}{for} \PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{every} \PYG{n}{buffer}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
      \PYG{n}{buffer} \PYG{o}{=} \PYG{n}{get\PYGZus{}next\PYGZus{}buffer} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{hasher} \PYG{p}{(}\PYG{n}{buffer}\PYG{p}{,} \PYG{n}{buffer\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{combined\PYGZus{}hash} \PYG{o}{=} \PYG{n}{hasher}\PYG{p}{.}\PYG{n}{GetHash32} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

By default \sphinxcode{\sphinxupquote{Hasher}} preserves internal state to enable incremental
hashing.  If you want to reuse a \sphinxcode{\sphinxupquote{Hasher}} object (for example
because it’s configured with a non\sphinxhyphen{}default hash function), but don’t
want to add to the previously computed hash, you need to \sphinxcode{\sphinxupquote{clear()}}
first:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hasher}\PYG{p}{.}\PYG{n}{clear} \PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{GetHash32} \PYG{p}{(}\PYG{n}{buffer}\PYG{p}{,} \PYG{n}{buffer\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This reinitializes the internal state before hashing the buffer.


\section{Using an Alternative Hash Function}
\label{\detokenize{hash-functions:using-an-alternative-hash-function}}
The default hash function is \sphinxhref{http://code.google.com/p/smhasher/wiki/MurmurHash3}{murmur3}.  \sphinxhref{http://isthe.com/chongo/tech/comp/fnv/}{FNV1a} is also available.  To specify
the hash function explicitly, use this constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Hasher} \PYG{n}{hasher} \PYG{o}{=} \PYG{n}{Hasher} \PYG{p}{(} \PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{Hash}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Function}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Fnv1a}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Adding New Hash Function Implementations}
\label{\detokenize{hash-functions:adding-new-hash-function-implementations}}
To add the hash function \sphinxcode{\sphinxupquote{foo}}, follow the \sphinxcode{\sphinxupquote{hash\sphinxhyphen{}murmur3.h}}/\sphinxcode{\sphinxupquote{.cc}} pattern:
\begin{itemize}
\item {} 
Create a class declaration (\sphinxcode{\sphinxupquote{.h}}) and definition (\sphinxcode{\sphinxupquote{.cc}}) inheriting
from \sphinxcode{\sphinxupquote{Hash::Implementation}}.

\item {} 
\sphinxcode{\sphinxupquote{include}} the declaration in \sphinxcode{\sphinxupquote{hash.h}} (at the point where
\sphinxcode{\sphinxupquote{hash\sphinxhyphen{}murmur3.h}} is included.

\item {} 
In your own code, instantiate a \sphinxcode{\sphinxupquote{Hasher}} object via the constructor
\sphinxcode{\sphinxupquote{Hasher (Ptr\textless{}Hash::Function::Foo\textgreater{} ())}}

\end{itemize}

If your hash function is a single function, e.g. \sphinxcode{\sphinxupquote{hashf}}, you don’t
even need to create a new class derived from HashImplementation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Hasher} \PYG{n}{hasher} \PYG{o}{=}
  \PYG{n}{Hasher} \PYG{p}{(} \PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{Hash}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Function}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Hash32}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{hashf}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For this to compile, your \sphinxcode{\sphinxupquote{hashf}} has to match one of the function pointer
signatures:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{n+nf}{uint32\PYGZus{}t} \PYG{p}{(}\PYG{o}{*}\PYG{n}{Hash32Function\PYGZus{}ptr}\PYG{p}{)} \PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{typedef} \PYG{n+nf}{uint64\PYGZus{}t} \PYG{p}{(}\PYG{o}{*}\PYG{n}{Hash64Function\PYGZus{}ptr}\PYG{p}{)} \PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Sources for Hash Functions}
\label{\detokenize{hash-functions:sources-for-hash-functions}}
Sources for other hash function implementations include:
\begin{itemize}
\item {} 
Peter Kankowski: \sphinxurl{http://www.strchr.com}

\item {} 
Arash Partow:    \sphinxurl{http://www.partow.net/programming/hashfunctions/index.html}

\item {} 
SMHasher:        \sphinxurl{http://code.google.com/p/smhasher/}

\item {} 
Sanmayce:        \sphinxurl{http://www.sanmayce.com/Fastest\_Hash/index.html}

\end{itemize}


\chapter{Events and Simulator}
\label{\detokenize{events:events-and-simulator}}\label{\detokenize{events::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is a discrete\sphinxhyphen{}event network simulator.  Conceptually, the simulator
keeps track of a number of events that are scheduled to execute at a
specified simulation time.  The job of the simulator is to execute the
events in sequential time order.  Once the completion of an event occurs,
the simulator will move to the next event (or will exit if there are no
more events in the event queue).  If, for example, an event scheduled
for simulation time “100 seconds” is executed, and the next event is not
scheduled until “200 seconds”, the simulator will immediately jump from
100 seconds to 200 seconds (of simulation time) to execute the next event.
This is what is meant by “discrete\sphinxhyphen{}event” simulator.

To make this all happen, the simulator needs a few things:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
a simulator object that can access an event queue where events are
stored and that can manage the execution of events

\item {} 
a scheduler responsible for inserting and removing events from the queue

\item {} 
a way to represent simulation time

\item {} 
the events themselves

\end{enumerate}

This chapter of the manual describes these fundamental objects
(simulator, scheduler, time, event) and how they are used.


\section{Event}
\label{\detokenize{events:event}}
\sphinxstyleemphasis{To be completed}


\section{Simulator}
\label{\detokenize{events:simulator}}
The Simulator class is the public entry point to access event scheduling
facilities. Once a couple of events have been scheduled to start the
simulation, the user can start to execute them by entering the simulator
main loop (call \sphinxcode{\sphinxupquote{Simulator::Run}}). Once the main loop starts running, it
will sequentially execute all scheduled events in order from oldest to
most recent until there are either no more events left in the event
queue or Simulator::Stop has been called.

To schedule events for execution by the simulator main loop, the
Simulator class provides the Simulator::Schedule* family of functions.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
Handling event handlers with different signatures

\end{enumerate}

These functions are declared and implemented as C++ templates to handle
automatically the wide variety of C++ event handler signatures used in
the wild. For example, to schedule an event to execute 10 seconds in the
future, and invoke a C++ method or function with specific arguments, you
might write this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{handler} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arg0}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{arg1}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{handler called with argument arg0=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{arg0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and}
     \PYG{n}{arg1}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{}\PYGZlt{} arg1 \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{handler}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Which will output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
handler called with argument arg0=10 and arg1=5
\end{sphinxVerbatim}

Of course, these C++ templates can also handle transparently member
methods on C++ objects:

\sphinxstyleemphasis{To be completed:  member method example}

Notes:
\begin{itemize}
\item {} 
the ns\sphinxhyphen{}3 Schedule methods recognize automatically functions and
methods only if they take less than 5 arguments. If you need them to
support more arguments, please, file a bug report.

\item {} 
Readers familiar with the term ‘fully\sphinxhyphen{}bound functors’ will recognize
the Simulator::Schedule methods as a way to automatically construct such
objects.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
Common scheduling operations

\end{enumerate}

The Simulator API was designed to make it really simple to schedule most
events. It provides three variants to do so (ordered from most commonly
used to least commonly used):
\begin{itemize}
\item {} 
Schedule methods which allow you to schedule an event in the future
by providing the delay between the current simulation time and the
expiration date of the target event.

\item {} 
ScheduleNow methods which allow you to schedule an event for the
current simulation time: they will execute \_after\_ the current event is
finished executing but \_before\_ the simulation time is changed for the
next event.

\item {} 
ScheduleDestroy methods which allow you to hook in the shutdown
process of the Simulator to cleanup simulation resources: every
‘destroy’ event is executed when the user calls the Simulator::Destroy
method.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
Maintaining the simulation context

\end{enumerate}

There are two basic ways to schedule events, with and without \sphinxstyleemphasis{context}.
What does this mean?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule} \PYG{p}{(}\PYG{n}{Time} \PYG{k}{const} \PYG{o}{\PYGZam{}}\PYG{n}{time}\PYG{p}{,} \PYG{n}{MEM} \PYG{n}{mem\PYGZus{}ptr}\PYG{p}{,} \PYG{n}{OBJ} \PYG{n}{obj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

vs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ScheduleWithContext} \PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{context}\PYG{p}{,} \PYG{n}{Time} \PYG{k}{const} \PYG{o}{\PYGZam{}}\PYG{n}{time}\PYG{p}{,} \PYG{n}{MEM} \PYG{n}{mem\PYGZus{}ptr}\PYG{p}{,} \PYG{n}{OBJ} \PYG{n}{obj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Readers who invest time and effort in developing or using a non\sphinxhyphen{}trivial
simulation model will know the value of the ns\sphinxhyphen{}3 logging framework to
debug simple and complex simulations alike. One of the important
features that is provided by this logging framework is the automatic
display of the network node id associated with the ‘currently’ running
event.

The node id of the currently executing network node is in fact tracked
by the Simulator class. It can be accessed with the
Simulator::GetContext method which returns the ‘context’ (a 32\sphinxhyphen{}bit
integer) associated and stored in the currently\sphinxhyphen{}executing event. In some
rare cases, when an event is not associated with a specific network
node, its ‘context’ is set to 0xffffffff.

To associate a context to each event, the Schedule, and ScheduleNow
methods automatically reuse the context of the currently\sphinxhyphen{}executing event
as the context of the event scheduled for execution later.

In some cases, most notably when simulating the transmission of a packet
from a node to another, this behavior is undesirable since the expected
context of the reception event is that of the receiving node, not the
sending node. To avoid this problem, the Simulator class provides a
specific schedule method: ScheduleWithContext which allows one to
provide explicitly the node id of the receiving node associated with
the receive event.

\sphinxstyleemphasis{XXX: code example}

In some very rare cases, developers might need to modify or understand
how the context (node id) of the first event is set to that of its
associated node. This is accomplished by the NodeList class: whenever a
new node is created, the NodeList class uses ScheduleWithContext to
schedule a ‘initialize’ event for this node. The ‘initialize’ event thus executes
with a context set to that of the node id and can use the normal variety
of Schedule methods. It invokes the Node::Initialize method which propagates
the ‘initialize’ event by calling the DoInitialize method for each object
associated with the node. The DoInitialize method overridden in some of these
objects (most notably in the Application base class) will schedule some
events (most notably Application::StartApplication) which will in turn
scheduling traffic generation events which will in turn schedule
network\sphinxhyphen{}level events.

Notes:
\begin{itemize}
\item {} 
Users need to be careful to propagate DoInitialize methods across objects
by calling Initialize explicitly on their member objects

\item {} 
The context id associated with each ScheduleWithContext method has
other uses beyond logging: it is used by an experimental branch of ns\sphinxhyphen{}3
to perform parallel simulation on multicore systems using
multithreading.

\end{itemize}

The Simulator::* functions do not know what the context is: they
merely make sure that whatever context you specify with
ScheduleWithContext is available when the corresponding event executes
with ::GetContext.

It is up to the models implemented on top of Simulator::* to interpret
the context value. In ns\sphinxhyphen{}3, the network models interpret the context
as the node id of the node which generated an event. This is why it is
important to call ScheduleWithContext in ns3::Channel subclasses
because we are generating an event from node i to node j and we want
to make sure that the event which will run on node j has the right
context.


\section{Time}
\label{\detokenize{events:time}}
\sphinxstyleemphasis{To be completed}


\section{Scheduler}
\label{\detokenize{events:scheduler}}
\sphinxstyleemphasis{To be completed}


\chapter{Callbacks}
\label{\detokenize{callbacks:callbacks}}\label{\detokenize{callbacks::doc}}
Some new users to \sphinxstyleemphasis{ns\sphinxhyphen{}3} are unfamiliar with an extensively used programming
idiom used throughout the code: the \sphinxstyleemphasis{ns\sphinxhyphen{}3 callback}. This chapter provides some
motivation on the callback, guidance on how to use it, and details on its
implementation.


\section{Callbacks Motivation}
\label{\detokenize{callbacks:callbacks-motivation}}
Consider that you have two simulation models A and B, and you wish to have them
pass information between them during the simulation. One way that you can do
that is that you can make A and B each explicitly knowledgeable about the other,
so that they can invoke methods on each other:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{A} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{void} \PYG{n}{ReceiveInput} \PYG{p}{(} \PYG{c+c1}{// parameters );}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}

\PYG{p}{(}\PYG{n}{in} \PYG{n}{another} \PYG{n}{source} \PYG{n+nl}{file}\PYG{p}{:}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{B} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{void} \PYG{n}{DoSomething} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{k}{private}\PYG{o}{:}
  \PYG{n}{A}\PYG{o}{*} \PYG{n}{a\PYGZus{}instance}\PYG{p}{;} \PYG{c+c1}{// pointer to an A}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}
\PYG{n}{B}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DoSomething}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+c1}{// Tell a\PYGZus{}instance that something happened}
  \PYG{n}{a\PYGZus{}instance}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ReceiveInput} \PYG{p}{(} \PYG{c+c1}{// parameters);}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This certainly works, but it has the drawback that it introduces a dependency on
A and B to know about the other at compile time (this makes it harder to have
independent compilation units in the simulator) and is not generalized; if in a
later usage scenario, B needs to talk to a completely different C object, the
source code for B needs to be changed to add a \sphinxcode{\sphinxupquote{c\_instance}} and so forth. It
is easy to see that this is a brute force mechanism of communication that can
lead to programming cruft in the models.

This is not to say that objects should not know about one another if there is a
hard dependency between them, but that often the model can be made more flexible
if its interactions are less constrained at compile time.

This is not an abstract problem for network simulation research, but rather it
has been a source of problems in previous simulators, when researchers want to
extend or modify the system to do different things (as they are apt to do in
research). Consider, for example, a user who wants to add an IPsec security
protocol sublayer between TCP and IP:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}                   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}   \PYG{n}{TCP}    \PYG{o}{|}                   \PYG{o}{|}  \PYG{n}{TCP}    \PYG{o}{|}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}                   \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
     \PYG{o}{|}           \PYG{n}{becomes} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}        \PYG{o}{|}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}                    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}   \PYG{n}{IP}    \PYG{o}{|}                    \PYG{o}{|} \PYG{n}{IPsec}   \PYG{o}{|}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}                    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
                                   \PYG{o}{|}
                               \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
                               \PYG{o}{|}   \PYG{n}{IP}    \PYG{o}{|}
                               \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}

If the simulator has made assumptions, and hard coded into the code, that IP
always talks to a transport protocol above, the user may be forced to hack the
system to get the desired interconnections. This is clearly not an optimal way
to design a generic simulator.


\section{Callbacks Background}
\label{\detokenize{callbacks:callbacks-background}}
\begin{sphinxadmonition}{note}{Note:}
Readers familiar with programming callbacks may skip this tutorial
section.
\end{sphinxadmonition}

The basic mechanism that allows one to address the problem above is known as a
\sphinxstyleemphasis{callback}. The ultimate goal is to allow one piece of code to call a function
(or method in C++) without any specific inter\sphinxhyphen{}module dependency.

This ultimately means you need some kind of indirection \textendash{} you treat the address
of the called function as a variable.  This variable is called a
pointer\sphinxhyphen{}to\sphinxhyphen{}function variable. The relationship between function and
pointer\sphinxhyphen{}to\sphinxhyphen{}function pointer is really no different that that of object and
pointer\sphinxhyphen{}to\sphinxhyphen{}object.

In C the canonical example of a pointer\sphinxhyphen{}to\sphinxhyphen{}function is a
pointer\sphinxhyphen{}to\sphinxhyphen{}function\sphinxhyphen{}returning\sphinxhyphen{}integer (PFI). For a PFI taking one int parameter,
this could be declared like,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{*}\PYG{n}{pfi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

What you get from this is a variable named simply \sphinxcode{\sphinxupquote{pfi}} that is initialized to
the value 0. If you want to initialize this pointer to something meaningful, you
have to have a function with a matching signature. In this case:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{MyFunction} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If you have this target, you can initialize the variable to point to your
function like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pfi} \PYG{o}{=} \PYG{n}{MyFunction}\PYG{p}{;}
\end{sphinxVerbatim}

You can then call MyFunction indirectly using the more suggestive form of the
call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{result} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{pfi}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This is suggestive since it looks like you are dereferencing the function
pointer just like you would dereference any pointer. Typically, however, people
take advantage of the fact that the compiler knows what is going on and will
just use a shorter form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{result} \PYG{o}{=} \PYG{n}{pfi} \PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Notice that the function pointer obeys value semantics, so you can pass it
around like any other value. Typically, when you use an asynchronous interface
you will pass some entity like this to a function which will perform an action
and \sphinxstyleemphasis{call back} to let you know it completed. It calls back by following the
indirection and executing the provided function.

In C++ you have the added complexity of objects. The analogy with the PFI above
means you have a pointer to a member function returning an int (PMI) instead of
the pointer to function returning an int (PFI).

The declaration of the variable providing the indirection looks only slightly
different:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{p}{(}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

This declares a variable named \sphinxcode{\sphinxupquote{pmi}} just as the previous example declared a
variable named \sphinxcode{\sphinxupquote{pfi}}. Since the will be to call a method of an instance of a
particular class, one must declare that method in a class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyClass} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{MyMethod} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Given this class declaration, one would then initialize that variable like
this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pmi} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyMethod}\PYG{p}{;}
\end{sphinxVerbatim}

This assigns the address of the code implementing the method to the variable,
completing the indirection. In order to call a method, the code needs a \sphinxcode{\sphinxupquote{this}}
pointer. This, in turn, means there must be an object of MyClass to refer to. A
simplistic example of this is just calling a method indirectly (think virtual
function):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{p}{(}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{// Declare a PMI}
\PYG{n}{pmi} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyMethod}\PYG{p}{;}           \PYG{c+c1}{// Point at the implementation code}

\PYG{n}{MyClass} \PYG{n}{myClass}\PYG{p}{;}                    \PYG{c+c1}{// Need an instance of the class}
\PYG{p}{(}\PYG{n}{myClass}\PYG{p}{.}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}              \PYG{c+c1}{// Call the method with an object ptr}
\end{sphinxVerbatim}

Just like in the C example, you can use this in an asynchronous call to another
module which will \sphinxstyleemphasis{call back} using a method and an object pointer. The
straightforward extension one might consider is to pass a pointer to the object
and the PMI variable. The module would just do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{*}\PYG{n}{objectPtr}\PYG{p}{.}\PYG{o}{*}\PYG{n}{pmi}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

to execute the callback on the desired object.

One might ask at this time, \sphinxstyleemphasis{what’s the point}? The called module will have to
understand the concrete type of the calling object in order to properly make the
callback. Why not just accept this, pass the correctly typed object pointer and
do \sphinxcode{\sphinxupquote{object\sphinxhyphen{}\textgreater{}Method(1234)}} in the code instead of the callback?  This is
precisely the problem described above. What is needed is a way to decouple the
calling function from the called class completely. This requirement led to the
development of the \sphinxstyleemphasis{Functor}.

A functor is the outgrowth of something invented in the 1960s called a closure.
It is basically just a packaged\sphinxhyphen{}up function call, possibly with some state.

A functor has two parts, a specific part and a generic part, related through
inheritance. The calling code (the code that executes the callback) will execute
a generic overloaded \sphinxcode{\sphinxupquote{operator ()}} of a generic functor to cause the callback
to be called. The called code (the code that wants to be called back) will have
to provide a specialized implementation of the \sphinxcode{\sphinxupquote{operator ()}} that performs the
class\sphinxhyphen{}specific work that caused the close\sphinxhyphen{}coupling problem above.

With the specific functor and its overloaded \sphinxcode{\sphinxupquote{operator ()}} created, the called
code then gives the specialized code to the module that will execute the
callback (the calling code).

The calling code will take a generic functor as a parameter, so an implicit cast
is done in the function call to convert the specific functor to a generic
functor.  This means that the calling module just needs to understand the
generic functor type. It is decoupled from the calling code completely.

The information one needs to make a specific functor is the object pointer and
the pointer\sphinxhyphen{}to\sphinxhyphen{}method address.

The essence of what needs to happen is that the system declares a generic part
of the functor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Functor}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{virtual} \PYG{k+kt}{int} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{n}{T} \PYG{n}{arg}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The caller defines a specific part of the functor that really is just there to
implement the specific \sphinxcode{\sphinxupquote{operator()}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{p}{,} \PYG{k}{typename} \PYG{n}{ARG}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{SpecificFunctor} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Functor}\PYG{o}{\PYGZlt{}}\PYG{n}{ARG}\PYG{o}{\PYGZgt{}}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{SpecificFunctor}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{p}\PYG{p}{,} \PYG{k+kt}{int} \PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{m\PYGZus{}p} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
    \PYG{n}{m\PYGZus{}pmi} \PYG{o}{=} \PYG{n}{\PYGZus{}pmi}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{virtual} \PYG{k+kt}{int} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{T}\PYG{o}{*} \PYG{n}{m\PYGZus{}p}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Here is an example of the usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{A}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{n}{A} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a0}\PYG{p}{)} \PYG{o}{:} \PYG{n}{a} \PYG{p}{(}\PYG{n}{a0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{n}{Hello} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{b0}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello from A, a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{A} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{SpecificFunctor}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{sf}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{a}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{A}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Hello}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sf}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The previous code is not real ns\sphinxhyphen{}3 code.  It is simplistic example
code used only to illustrate the concepts involved and to help you understand
the system more.  Do not expect to find this code anywhere in the ns\sphinxhyphen{}3 tree.
\end{sphinxadmonition}

Notice that there are two variables defined in the class above.  The m\_p
variable is the object pointer and m\_pmi is the variable containing the
address of the function to execute.

Notice that when \sphinxcode{\sphinxupquote{operator()}} is called, it in turn calls the method provided
with the object pointer using the C++ PMI syntax.

To use this, one could then declare some model code that takes a generic functor
as a parameter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{LibraryFunction} \PYG{p}{(}\PYG{n}{Functor} \PYG{n}{functor}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The code that will talk to the model would build a specific functor and pass it to \sphinxcode{\sphinxupquote{LibraryFunction}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MyClass} \PYG{n}{myClass}\PYG{p}{;}
\PYG{n}{SpecificFunctor}\PYG{o}{\PYGZlt{}}\PYG{n}{MyClass}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{functor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{myclass}\PYG{p}{,} \PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyMethod}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

When \sphinxcode{\sphinxupquote{LibraryFunction}} is done, it executes the callback using the
\sphinxcode{\sphinxupquote{operator()}} on the generic functor it was passed, and in this particular
case, provides the integer argument:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{LibraryFunction} \PYG{p}{(}\PYG{n}{Functor} \PYG{n}{functor}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+c1}{// Execute the library function}
  \PYG{n}{functor}\PYG{p}{(}\PYG{l+m+mi}{1234}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Notice that \sphinxcode{\sphinxupquote{LibraryFunction}} is completely decoupled from the specific
type of the client.  The connection is made through the Functor polymorphism.

The Callback API in \sphinxstyleemphasis{ns\sphinxhyphen{}3} implements object\sphinxhyphen{}oriented callbacks using
the functor mechanism.  This callback API, being based on C++ templates, is
type\sphinxhyphen{}safe; that is, it performs static type checks to enforce proper signature
compatibility between callers and callees.  It is therefore more type\sphinxhyphen{}safe to
use than traditional function pointers, but the syntax may look imposing at
first.  This section is designed to walk you through the Callback system so
that you can be comfortable using it in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\section{Using the Callback API}
\label{\detokenize{callbacks:using-the-callback-api}}
The Callback API is fairly minimal, providing only two services:

1. callback type declaration: a way to declare a type of callback
with a given signature, and,

2. callback instantiation: a way to instantiate a
template\sphinxhyphen{}generated forwarding callback which can forward any calls
to another C++ class member method or C++ function.

This is best observed via walking through an example, based on
\sphinxcode{\sphinxupquote{samples/main\sphinxhyphen{}callback.cc}}.


\subsection{Using the Callback API with static functions}
\label{\detokenize{callbacks:using-the-callback-api-with-static-functions}}
Consider a function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{double}
\PYG{n+nf}{CbOne} \PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{invoke cbOne a=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, b=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{a}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Consider also the following main program snippet:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+c1}{// return type: double}
  \PYG{c+c1}{// first arg type: double}
  \PYG{c+c1}{// second arg type: double}
  \PYG{n}{Callback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{p}{,} \PYG{k+kt}{double}\PYG{p}{,} \PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{one}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is an example of a C\sphinxhyphen{}style callback \textendash{} one which does not include or need
a \sphinxcode{\sphinxupquote{this}} pointer.  The function template \sphinxcode{\sphinxupquote{Callback}} is essentially the
declaration of the variable containing the pointer\sphinxhyphen{}to\sphinxhyphen{}function.  In the example
above, we explicitly showed a pointer to a function that returned an integer and
took a single integer as a parameter,  The \sphinxcode{\sphinxupquote{Callback}} template function is
a generic version of that \textendash{} it is used to declare the type of a callback.

\begin{sphinxadmonition}{note}{Note:}
Readers unfamiliar with C++ templates may consult \sphinxurl{http://www.cplusplus.com/doc/tutorial/templates/}.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{Callback}} template requires one mandatory argument (the return type
of the function to be assigned to this callback) and up to five optional
arguments, which each specify the type of the arguments (if your particular
callback function has more than five arguments, then this can be handled
by extending the callback implementation).

So in the above example, we have a declared a callback named “one” that will
eventually hold a function pointer.  The signature of the function that it will
hold must return double and must support two double arguments.  If one tries
to pass a function whose signature does not match the declared callback,
a compilation error will occur.  Also, if one tries to assign to a callback
an incompatible one, compilation will succeed but a run\sphinxhyphen{}time
NS\_FATAL\_ERROR will be raised.  The sample program
\sphinxcode{\sphinxupquote{src/core/examples/main\sphinxhyphen{}callback.cc}} demonstrates both of these error cases
at the end of the \sphinxcode{\sphinxupquote{main()}} program.

Now, we need to tie together this callback instance and the actual target function
(CbOne).  Notice above that CbOne has the same function signature types as the
callback\textendash{} this is important.  We can pass in any such properly\sphinxhyphen{}typed function
to this callback.  Let’s look at this more closely:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}   \PYG{k+kt}{double} \PYG{n+nf}{CbOne} \PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{b}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
           \PYG{o}{\PYGZca{}}             \PYG{o}{\PYGZca{}}         \PYG{o}{\PYGZca{}}
           \PYG{o}{|}             \PYG{o}{|}         \PYG{o}{|}
           \PYG{o}{|}             \PYG{o}{|}         \PYG{o}{|}
\PYG{n}{Callback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{p}{,}       \PYG{k+kt}{double}\PYG{p}{,}   \PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{one}\PYG{p}{;}
\end{sphinxVerbatim}

You can only bind a function to a callback if they have the matching signature.
The first template argument is the return type, and the additional template
arguments are the types of the arguments of the function signature.

Now, let’s bind our callback “one” to the function that matches its signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// build callback instance which points to cbOne function}
\PYG{n}{one} \PYG{o}{=} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CbOne}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This call to \sphinxcode{\sphinxupquote{MakeCallback}} is, in essence, creating one of the specialized
functors mentioned above.  The variable declared using the \sphinxcode{\sphinxupquote{Callback}}
template function is going to be playing the part of the generic functor.  The
assignment \sphinxcode{\sphinxupquote{one = MakeCallback (\&CbOne)}} is the cast that converts the
specialized functor known to the callee to a generic functor known to the caller.

Then, later in the program, if the callback is needed, it can be used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}ASSERT} \PYG{p}{(}\PYG{o}{!}\PYG{n}{one}\PYG{p}{.}\PYG{n}{IsNull} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// invoke cbOne function through callback instance}
\PYG{k+kt}{double} \PYG{n}{retOne}\PYG{p}{;}
\PYG{n}{retOne} \PYG{o}{=} \PYG{n}{one} \PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The check for \sphinxcode{\sphinxupquote{IsNull()}} ensures that the callback is not null \textendash{} that there
is a function to call behind this callback.  Then, \sphinxcode{\sphinxupquote{one()}} executes the
generic \sphinxcode{\sphinxupquote{operator()}} which is really overloaded with a specific implementation
of \sphinxcode{\sphinxupquote{operator()}} and returns the same result as if \sphinxcode{\sphinxupquote{CbOne()}} had been
called directly.


\subsection{Using the Callback API with member functions}
\label{\detokenize{callbacks:using-the-callback-api-with-member-functions}}
Generally, you will not be calling static functions but instead public member
functions of an object.  In this case, an extra argument is needed to the
MakeCallback function, to tell the system on which object the function should be
invoked.  Consider this example, also from main\sphinxhyphen{}callback.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyCb} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{int} \PYG{n}{CbTwo} \PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{invoke cbTwo a=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
      \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{c+c1}{// return type: int}
  \PYG{c+c1}{// first arg type: double}
  \PYG{n}{Callback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{two}\PYG{p}{;}
  \PYG{n}{MyCb} \PYG{n}{cb}\PYG{p}{;}
  \PYG{c+c1}{// build callback instance which points to MyCb::cbTwo}
  \PYG{n}{two} \PYG{o}{=} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyCb}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CbTwo}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cb}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here, we pass an additional object pointer to the \sphinxcode{\sphinxupquote{MakeCallback\textless{}\textgreater{}}} function.
Recall from the background section above that \sphinxcode{\sphinxupquote{Operator()}} will use the pointer to
member syntax when it executes on an object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{int} \PYG{n+nf}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

And so we needed to provide the two variables (\sphinxcode{\sphinxupquote{m\_p}} and \sphinxcode{\sphinxupquote{m\_pmi}}) when
we made the specific functor.  The line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{two} \PYG{o}{=} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyCb}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CbTwo}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cb}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

does precisely that.  In this case, when \sphinxcode{\sphinxupquote{two ()}} is invoked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{result} \PYG{o}{=} \PYG{n}{two} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will result in a call to the \sphinxcode{\sphinxupquote{CbTwo}} member function (method) on the object
pointed to by \sphinxcode{\sphinxupquote{\&cb}}.


\subsection{Building Null Callbacks}
\label{\detokenize{callbacks:building-null-callbacks}}
It is possible for callbacks to be null; hence it may be wise to
check before using them.  There is a special construct for a null
callback, which is preferable to simply passing “0” as an argument;
it is the \sphinxcode{\sphinxupquote{MakeNullCallback\textless{}\textgreater{}}} construct:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{two} \PYG{o}{=} \PYG{n}{MakeNullCallback}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT} \PYG{p}{(}\PYG{n}{two}\PYG{p}{.}\PYG{n}{IsNull} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Invoking a null callback is just like invoking a null function pointer: it will
crash at runtime.


\section{Bound Callbacks}
\label{\detokenize{callbacks:bound-callbacks}}
A very useful extension to the functor concept is that of a Bound Callback.
Previously it was mentioned that closures were originally function calls
packaged up for later execution.  Notice that in all of the Callback
descriptions above, there is no way to package up any parameters for use
later \textendash{} when the \sphinxcode{\sphinxupquote{Callback}} is called via \sphinxcode{\sphinxupquote{operator()}}.  All of
the parameters are provided by the calling function.

What if it is desired to allow the client function (the one that provides the
callback) to provide some of the parameters?  \sphinxhref{http://erdani.com/book/main.html}{Alexandrescu} calls the process of
allowing a client to specify one of the parameters \sphinxstyleemphasis{“binding”}.  One of the
parameters of \sphinxcode{\sphinxupquote{operator()}} has been bound (fixed) by the client.

Some of our pcap tracing code provides a nice example of this.  There is a
function that needs to be called whenever a packet is received.  This function
calls an object that actually writes the packet to disk in the pcap file
format.  The signature of one of these functions will be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{void} \PYG{n+nf}{DefaultSink} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PcapFileWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{file}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The static keyword means this is a static function which does not need a
\sphinxcode{\sphinxupquote{this}} pointer, so it will be using C\sphinxhyphen{}style callbacks.  We don’t want the
calling code to have to know about anything but the Packet.  What we want in
the calling code is just a call that looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}promiscSnifferTrace} \PYG{p}{(}\PYG{n}{m\PYGZus{}currentPkt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

What we want to do is to \sphinxstyleemphasis{bind} the \sphinxcode{\sphinxupquote{Ptr\textless{}PcapFileWriter\textgreater{} file}} to the
specific callback implementation when it is created and arrange for the
\sphinxcode{\sphinxupquote{operator()}} of the Callback to provide that parameter for free.

We provide the \sphinxcode{\sphinxupquote{MakeBoundCallback}} template function for that purpose.  It
takes the same parameters as the \sphinxcode{\sphinxupquote{MakeCallback}} template function but also
takes the parameters to be bound.  In the case of the example above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeBoundCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{DefaultSink}\PYG{p}{,} \PYG{n}{file}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will create a specific callback implementation that knows to add in the extra
bound arguments.  Conceptually, it extends the specific functor described above
with one or more bound arguments:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{p}{,} \PYG{k}{typename} \PYG{n}{ARG}\PYG{p}{,} \PYG{k}{typename} \PYG{n}{BOUND\PYGZus{}ARG}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{SpecificFunctor} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Functor}
 \PYG{p}{\PYGZob{}}
 \PYG{k}{public}\PYG{o}{:}
    \PYG{n}{SpecificFunctor}\PYG{p}{(}\PYG{n}{T}\PYG{o}{*} \PYG{n}{p}\PYG{p}{,} \PYG{k+kt}{int} \PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{,} \PYG{n}{BOUND\PYGZus{}ARG} \PYG{n}{boundArg}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{m\PYGZus{}p} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}pmi} \PYG{o}{=} \PYG{n}{pmi}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}boundArg} \PYG{o}{=} \PYG{n}{boundArg}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{virtual} \PYG{k+kt}{int} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{m\PYGZus{}boundArg}\PYG{p}{,} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{k}{private}\PYG{o}{:}
    \PYG{k+kt}{void} \PYG{p}{(}\PYG{n}{T}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{ARG} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{T}\PYG{o}{*} \PYG{n}{m\PYGZus{}p}\PYG{p}{;}
    \PYG{n}{BOUND\PYGZus{}ARG} \PYG{n}{m\PYGZus{}boundArg}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

You can see that when the specific functor is created, the bound argument is saved
in the functor / callback object itself.  When the \sphinxcode{\sphinxupquote{operator()}} is invoked with
the single parameter, as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}promiscSnifferTrace} \PYG{p}{(}\PYG{n}{m\PYGZus{}currentPkt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

the implementation of \sphinxcode{\sphinxupquote{operator()}} adds the bound parameter into the actual
function call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}p}\PYG{p}{.}\PYG{o}{*}\PYG{n}{m\PYGZus{}pmi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{m\PYGZus{}boundArg}\PYG{p}{,} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It’s possible to bind two or three arguments as well.  Say we have a function with
signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{void} \PYG{n+nf}{NotifyEvent} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{o}{\PYGZgt{}} \PYG{n}{a}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{,} \PYG{n}{MyEventType} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

One can create bound callback binding first two arguments like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeBoundCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyEvent}\PYG{p}{,} \PYG{n}{a1}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

assuming \sphinxtitleref{a1} and \sphinxtitleref{b1} are objects of type \sphinxtitleref{A} and \sphinxtitleref{B} respectively.  Similarly for
three arguments one would have function with a signature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{void} \PYG{n+nf}{NotifyEvent} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{A}\PYG{o}{\PYGZgt{}} \PYG{n}{a}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{,} \PYG{n}{MyEventType} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Binding three arguments in done with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MakeBoundCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyEvent}\PYG{p}{,} \PYG{n}{a1}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{c1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

again assuming \sphinxtitleref{a1}, \sphinxtitleref{b1} and \sphinxtitleref{c1} are objects of type \sphinxtitleref{A}, \sphinxtitleref{B} and \sphinxtitleref{C} respectively.

This kind of binding can be used for exchanging information between objects in
simulation; specifically, bound callbacks can be used as traced callbacks, which will
be described in the next section.


\section{Traced Callbacks}
\label{\detokenize{callbacks:traced-callbacks}}
\sphinxstyleemphasis{Placeholder subsection}


\section{Callback locations in ns\sphinxhyphen{}3}
\label{\detokenize{callbacks:callback-locations-in-ns-3}}
Where are callbacks frequently used in \sphinxstyleemphasis{ns\sphinxhyphen{}3}?  Here are some of the
more visible ones to typical users:
\begin{itemize}
\item {} 
Socket API

\item {} 
Layer\sphinxhyphen{}2/Layer\sphinxhyphen{}3 API

\item {} 
Tracing subsystem

\item {} 
API between IP and routing subsystems

\end{itemize}


\section{Implementation details}
\label{\detokenize{callbacks:implementation-details}}
The code snippets above are simplistic and only designed to illustrate the mechanism
itself.  The actual Callback code is quite complicated and very template\sphinxhyphen{}intense and
a deep understanding of the code is not required.  If interested, expert users may
find the following useful.

The code was originally written based on the techniques described in
\sphinxurl{http://www.codeproject.com/cpp/TTLFunction.asp}.
It was subsequently rewritten to follow the architecture outlined in
\sphinxhref{http://www.moderncppdesign.com/book/main.html}{Modern C++ Design, Generic Programming and Design Patterns Applied, Alexandrescu, chapter 5, Generalized Functors}.

This code uses:
\begin{itemize}
\item {} 
default template parameters to saves users from having to
specify empty parameters when the number of parameters
is smaller than the maximum supported number

\item {} 
the pimpl idiom: the Callback class is passed around by
value and delegates the crux of the work to its pimpl pointer.

\item {} 
two pimpl implementations which derive from CallbackImpl
FunctorCallbackImpl can be used with any functor\sphinxhyphen{}type
while MemPtrCallbackImpl can be used with pointers to
member functions.

\item {} 
a reference list implementation to implement the Callback’s
value semantics.

\end{itemize}

This code most notably departs from the Alexandrescu implementation in that it
does not use type lists to specify and pass around the types of the callback
arguments. Of course, it also does not use copy\sphinxhyphen{}destruction semantics and
relies on a reference list rather than autoPtr to hold the pointer.


\chapter{Object model}
\label{\detokenize{object-model:object-model}}\label{\detokenize{object-model:id1}}\label{\detokenize{object-model::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is fundamentally a C++ object system. Objects can be declared and
instantiated as usual, per C++ rules. \sphinxstyleemphasis{ns\sphinxhyphen{}3} also adds some features to
traditional C++ objects, as described below, to provide greater functionality
and features. This manual chapter is intended to introduce the reader to the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} object model.

This section describes the C++ class design for \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects. In brief,
several design patterns in use include classic object\sphinxhyphen{}oriented design
(polymorphic interfaces and implementations), separation of interface and
implementation, the non\sphinxhyphen{}virtual public interface design pattern, an object
aggregation facility, and reference counting for memory management. Those
familiar with component models such as COM or Bonobo will recognize elements of
the design in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object aggregation model, although the \sphinxstyleemphasis{ns\sphinxhyphen{}3} design is
not strictly in accordance with either.


\section{Object\sphinxhyphen{}oriented behavior}
\label{\detokenize{object-model:object-oriented-behavior}}
C++ objects, in general, provide common object\sphinxhyphen{}oriented capabilities
(abstraction, encapsulation, inheritance, and polymorphism) that are part
of classic object\sphinxhyphen{}oriented design. \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects make use of these
properties; for instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Address}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{Address} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Address} \PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t} \PYG{n}{type}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{uint8\PYGZus{}t} \PYG{o}{*}\PYG{n}{buffer}\PYG{p}{,} \PYG{k+kt}{uint8\PYGZus{}t} \PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Address} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Address} \PYG{o}{\PYGZam{}} \PYG{n}{address}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Address} \PYG{o}{\PYGZam{}}\PYG{k}{operator} \PYG{o}{=} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Address} \PYG{o}{\PYGZam{}}\PYG{n}{address}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k+kt}{uint8\PYGZus{}t} \PYG{n}{m\PYGZus{}type}\PYG{p}{;}
  \PYG{k+kt}{uint8\PYGZus{}t} \PYG{n}{m\PYGZus{}len}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Object base classes}
\label{\detokenize{object-model:object-base-classes}}
There are three special base classes used in \sphinxstyleemphasis{ns\sphinxhyphen{}3}. Classes that inherit
from these base classes can instantiate objects with special properties.
These base classes are:
\begin{itemize}
\item {} 
class \sphinxcode{\sphinxupquote{Object}}

\item {} 
class \sphinxcode{\sphinxupquote{ObjectBase}}

\item {} 
class \sphinxcode{\sphinxupquote{SimpleRefCount}}

\end{itemize}

It is not required that \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects inherit from these class, but
those that do get special properties. Classes deriving from
class \sphinxcode{\sphinxupquote{Object}} get the following properties.
\begin{itemize}
\item {} 
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} type and attribute system (see {\hyperref[\detokenize{attributes:attributes}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration and Attributes}}}})

\item {} 
an object aggregation system

\item {} 
a smart\sphinxhyphen{}pointer reference counting system (class Ptr)

\end{itemize}

Classes that derive from class \sphinxcode{\sphinxupquote{ObjectBase}} get the first two
properties above, but do not get smart pointers. Classes that derive from class
\sphinxcode{\sphinxupquote{SimpleRefCount}}: get only the smart\sphinxhyphen{}pointer reference counting
system.

In practice, class \sphinxcode{\sphinxupquote{Object}} is the variant of the three above that
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} developer will most commonly encounter.


\section{Memory management and class Ptr}
\label{\detokenize{object-model:memory-management-and-class-ptr}}\label{\detokenize{object-model:id2}}
Memory management in a C++ program is a complex process, and is often done
incorrectly or inconsistently. We have settled on a reference counting design
described as follows.

All objects using reference counting maintain an internal reference count to
determine when an object can safely delete itself. Each time that a pointer is
obtained to an interface, the object’s reference count is incremented by calling
\sphinxcode{\sphinxupquote{Ref()}}. It is the obligation of the user of the pointer to explicitly
\sphinxcode{\sphinxupquote{Unref()}} the pointer when done. When the reference count falls to zero, the
object is deleted.
\begin{itemize}
\item {} 
When the client code obtains a pointer from the object itself through object
creation, or via GetObject, it does not have to increment the reference count.

\item {} 
When client code obtains a pointer from another source (e.g., copying a
pointer) it must call \sphinxcode{\sphinxupquote{Ref()}} to increment the reference count.

\item {} 
All users of the object pointer must call \sphinxcode{\sphinxupquote{Unref()}} to release the
reference.

\end{itemize}

The burden for calling \sphinxcode{\sphinxupquote{Unref()}} is somewhat relieved by the use of
the reference counting smart pointer class described below.

Users using a low\sphinxhyphen{}level API who wish to explicitly allocate
non\sphinxhyphen{}reference\sphinxhyphen{}counted objects on the heap, using operator new, are responsible
for deleting such objects.


\subsection{Reference counting smart pointer (Ptr)}
\label{\detokenize{object-model:reference-counting-smart-pointer-ptr}}
Calling \sphinxcode{\sphinxupquote{Ref()}} and \sphinxcode{\sphinxupquote{Unref()}} all the time would be cumbersome, so \sphinxstyleemphasis{ns\sphinxhyphen{}3}
provides a smart pointer class \sphinxcode{\sphinxupquote{Ptr}} similar to
\sphinxcode{\sphinxupquote{Boost::intrusive\_ptr}}. This smart\sphinxhyphen{}pointer class assumes that the
underlying type provides a pair of \sphinxcode{\sphinxupquote{Ref}} and \sphinxcode{\sphinxupquote{Unref}} methods that are
expected to increment and decrement the internal refcount of the object
instance.

This implementation allows you to manipulate the smart pointer as if it was a
normal pointer: you can compare it with zero, compare it against other pointers,
assign zero to it, etc.

It is possible to extract the raw pointer from this smart pointer with the
\sphinxcode{\sphinxupquote{GetPointer()}} and \sphinxcode{\sphinxupquote{PeekPointer()}} methods.

If you want to store a newed object into a smart pointer, we recommend you to
use the CreateObject template functions to create the object and store it in a
smart pointer to avoid memory leaks. These functions are really small
convenience functions and their goal is just to save you a small bit of typing.


\section{CreateObject and Create}
\label{\detokenize{object-model:createobject-and-create}}
Objects in C++ may be statically, dynamically, or automatically created.  This
holds true for \sphinxstyleemphasis{ns\sphinxhyphen{}3} also, but some objects in the system have some additional
frameworks available. Specifically, reference counted objects are usually
allocated using a templated Create or CreateObject method, as follows.

For objects deriving from class \sphinxcode{\sphinxupquote{Object}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{device} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Please do not create such objects using \sphinxcode{\sphinxupquote{operator new}}; create them using
\sphinxcode{\sphinxupquote{CreateObject()}} instead.

For objects deriving from class \sphinxcode{\sphinxupquote{SimpleRefCount}}, or other objects
that support usage of the smart pointer class, a templated helper function is
available and recommended to be used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}} \PYG{n}{b} \PYG{o}{=} \PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{B}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This is simply a wrapper around operator new that correctly handles the
reference counting system.

In summary, use \sphinxcode{\sphinxupquote{Create\textless{}B\textgreater{}}} if B is not an object but just uses reference
counting (e.g. \sphinxcode{\sphinxupquote{Packet}}), and use \sphinxcode{\sphinxupquote{CreateObject\textless{}B\textgreater{}}} if B derives
from \sphinxcode{\sphinxupquote{ns3::Object}}.


\section{Aggregation}
\label{\detokenize{object-model:aggregation}}
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} object aggregation system is motivated in strong part by a recognition
that a common use case for \sphinxstyleemphasis{ns\sphinxhyphen{}2} has been the use of inheritance and
polymorphism to extend protocol models. For instance, specialized versions of
TCP such as RenoTcpAgent derive from (and override functions from) class
TcpAgent.

However, two problems that have arisen in the \sphinxstyleemphasis{ns\sphinxhyphen{}2} model are downcasts and
“weak base class.” Downcasting refers to the procedure of using a base class
pointer to an object and querying it at run time to find out type information,
used to explicitly cast the pointer to a subclass pointer so that the subclass
API can be used. Weak base class refers to the problems that arise when a class
cannot be effectively reused (derived from) because it lacks necessary
functionality, leading the developer to have to modify the base class and
causing proliferation of base class API calls, some of which may not be
semantically correct for all subclasses.

\sphinxstyleemphasis{ns\sphinxhyphen{}3} is using a version of the query interface design pattern to avoid these
problems. This design is based on elements of the \sphinxhref{http://en.wikipedia.org/wiki/Component\_Object\_Model}{Component Object Model} and \sphinxhref{http://en.wikipedia.org/wiki/Bonobo\_(component\_model)}{GNOME Bonobo} although full
binary\sphinxhyphen{}level compatibility of replaceable components is not supported and we
have tried to simplify the syntax and impact on model developers.


\section{Examples}
\label{\detokenize{object-model:examples}}

\subsection{Aggregation example}
\label{\detokenize{object-model:aggregation-example}}
\sphinxcode{\sphinxupquote{Node}} is a good example of the use of aggregation in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  Note
that there are not derived classes of Nodes in \sphinxstyleemphasis{ns\sphinxhyphen{}3} such as class
\sphinxcode{\sphinxupquote{InternetNode}}.  Instead, components (protocols) are aggregated to a
node. Let’s look at how some Ipv4 protocols are added to a node.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{void}
\PYG{n+nf}{AddIpv4Stack}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{n}{node}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4L3Protocol}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4L3Protocol}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ipv4}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetNode} \PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AggregateObject} \PYG{p}{(}\PYG{n}{ipv4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4Impl}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4Impl} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4Impl}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ipv4Impl}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetIpv4} \PYG{p}{(}\PYG{n}{ipv4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AggregateObject} \PYG{p}{(}\PYG{n}{ipv4Impl}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Note that the Ipv4 protocols are created using \sphinxcode{\sphinxupquote{CreateObject()}}.
Then, they are aggregated to the node. In this manner, the Node base class does
not need to be edited to allow users with a base class Node pointer to access
the Ipv4 interface; users may ask the node for a pointer to its Ipv4 interface
at runtime. How the user asks the node is described in the next subsection.

Note that it is a programming error to aggregate more than one object of the
same type to an \sphinxcode{\sphinxupquote{ns3::Object}}. So, for instance, aggregation is not
an option for storing all of the active sockets of a node.


\subsection{GetObject example}
\label{\detokenize{object-model:getobject-example}}
GetObject is a type\sphinxhyphen{}safe way to achieve a safe downcasting and to allow
interfaces to be found on an object.

Consider a node pointer \sphinxcode{\sphinxupquote{m\_node}} that points to a Node object that has an
implementation of IPv4 previously aggregated to it. The client code wishes to
configure a default route. To do so, it must access an object within the node
that has an interface to the IP forwarding configuration. It performs the
following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4} \PYG{o}{=} \PYG{n}{m\PYGZus{}node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If the node in fact does not have an Ipv4 object aggregated to it, then the
method will return null. Therefore, it is good practice to check the return
value from such a function call. If successful, the user can now use the Ptr to
the Ipv4 object that was previously aggregated to the node.

Another example of how one might use aggregation is to add optional models to
objects. For instance, an existing Node object may have an “Energy Model” object
aggregated to it at run time (without modifying and recompiling the node class).
An existing model (such as a wireless net device) can then later “GetObject” for
the energy model and act appropriately if the interface has been either built in
to the underlying Node object or aggregated to it at run time.  However, other
nodes need not know anything about energy models.

We hope that this mode of programming will require much less need for developers
to modify the base classes.


\section{Object factories}
\label{\detokenize{object-model:object-factories}}
A common use case is to create lots of similarly configured objects. One can
repeatedly call \sphinxcode{\sphinxupquote{CreateObject()}} but there is also a factory design
pattern in use in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system. It is heavily used in the “helper” API.

Class \sphinxcode{\sphinxupquote{ObjectFactory}} can be used to instantiate objects and to
configure the attributes on those objects:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{SetTypeId} \PYG{p}{(}\PYG{n}{TypeId} \PYG{n}{tid}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{Set} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{k}{const} \PYG{n}{AttributeValue} \PYG{o}{\PYGZam{}}\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{Create} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

The first method allows one to use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} TypeId system to specify the type
of objects created. The second allows one to set attributes on the objects to be
created, and the third allows one to create the objects themselves.

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ObjectFactory} \PYG{n}{factory}\PYG{p}{;}
\PYG{c+c1}{// Make this factory create objects of type FriisPropagationLossModel}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{SetTypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::FriisPropagationLossModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{// Make this factory object change a default value of an attribute, for}
\PYG{c+c1}{// subsequently created objects}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SystemLoss}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Create one such object}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{n}{object} \PYG{o}{=} \PYG{n}{factory}\PYG{p}{.}\PYG{n}{Create} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SystemLoss}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Create another object with a different SystemLoss}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{n}{object} \PYG{o}{=} \PYG{n}{factory}\PYG{p}{.}\PYG{n}{Create} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Downcasting}
\label{\detokenize{object-model:downcasting}}
A question that has arisen several times is, “If I have a base class pointer
(Ptr) to an object and I want the derived class pointer, should I downcast (via
C++ dynamic cast) to get the derived pointer, or should I use the object
aggregation system to \sphinxcode{\sphinxupquote{GetObject\textless{}\textgreater{} ()}} to find a Ptr to the interface
to the subclass API?”

The answer to this is that in many situations, both techniques will work.
\sphinxstyleemphasis{ns\sphinxhyphen{}3} provides a templated function for making the syntax of Object
dynamic casting much more user friendly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T1}\PYG{p}{,} \PYG{k}{typename} \PYG{n}{T2}\PYG{o}{\PYGZgt{}}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{o}{\PYGZgt{}}
\PYG{n}{DynamicCast} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T2}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{dynamic\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{T1} \PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{PeekPointer} \PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

DynamicCast works when the programmer has a base type pointer and is testing
against a subclass pointer. GetObject works when looking for different objects
aggregated, but also works with subclasses, in the same way as DynamicCast. If
unsure, the programmer should use GetObject, as it works in all cases. If the
programmer knows the class hierarchy of the object under consideration, it is
more direct to just use DynamicCast.


\chapter{Configuration and Attributes}
\label{\detokenize{attributes:configuration-and-attributes}}\label{\detokenize{attributes:attributes}}\label{\detokenize{attributes::doc}}
In \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulations, there are two main aspects to configuration:
\begin{itemize}
\item {} 
The simulation topology and how objects are connected.

\item {} 
The values used by the models instantiated in the topology.

\end{itemize}

This chapter focuses on the second item above: how the many values in use in
\sphinxstyleemphasis{ns\sphinxhyphen{}3} are organized, documented, and modifiable by \sphinxstyleemphasis{ns\sphinxhyphen{}3} users. The \sphinxstyleemphasis{ns\sphinxhyphen{}3}
attribute system is also the underpinning of how traces and statistics are
gathered in the simulator.

In the course of this chapter we will discuss the various ways to set or
modify the values used by \sphinxstyleemphasis{ns\sphinxhyphen{}3} model objects.  In increasing order of
specificity, these are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Method
&\sphinxstyletheadfamily 
Scope
\\
\hline
Default Attribute values set when
Attributes are defined in
\sphinxcode{\sphinxupquote{GetTypeId ()}}.
&
Affect all instances of the class.
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{CommandLine}}
\item[] \sphinxcode{\sphinxupquote{Config::SetDefault()}}
\item[] \sphinxcode{\sphinxupquote{ConfigStore}}
\end{DUlineblock}
&
Affect all future instances.
\\
\hline
\sphinxcode{\sphinxupquote{ObjectFactory}}
&
Affects all instances created with
the factory.
\\
\hline
Helper methods with (string/
AttributeValue) parameter pairs
&
Affects all instances created by
the helper.
\\
\hline
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{MyClass::SetX ()}}
\item[] \sphinxcode{\sphinxupquote{Object::SetAttribute ()}}
\item[] \sphinxcode{\sphinxupquote{Config::Set()}}
\end{DUlineblock}
&
Alters this particular instance.
Generally this is the only form
which can be scheduled to alter
an instance once the simulation
is running.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

By “specificity” we mean that methods in later rows in the table
override the values set by, and typically affect fewer instances than,
earlier methods.

Before delving into details of the attribute value system, it will help to
review some basic properties of class \sphinxcode{\sphinxupquote{Object}}.


\section{Object Overview}
\label{\detokenize{attributes:object-overview}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is fundamentally a C++ object\sphinxhyphen{}based system. By this we mean that new C++
classes (types) can be declared, defined, and subclassed as usual.

Many \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects inherit from the \sphinxcode{\sphinxupquote{Object}} base class.  These
objects have some additional properties that we exploit for organizing the
system and improving the memory management of our objects:
\begin{itemize}
\item {} 
“Metadata” system that links the class name to a lot of meta\sphinxhyphen{}information
about the object, including:
\begin{itemize}
\item {} 
The base class of the subclass,

\item {} 
The set of accessible constructors in the subclass,

\item {} 
The set of “attributes” of the subclass,

\item {} 
Whether each attribute can be set, or is read\sphinxhyphen{}only,

\item {} 
The allowed range of values for each attribute.

\end{itemize}

\item {} 
Reference counting smart pointer implementation, for memory management.

\end{itemize}

\sphinxstyleemphasis{ns\sphinxhyphen{}3} objects that use the attribute system derive from either
\sphinxcode{\sphinxupquote{Object}} or \sphinxcode{\sphinxupquote{ObjectBase}}. Most \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects we
will discuss derive from \sphinxcode{\sphinxupquote{Object}}, but a few that are outside
the smart pointer memory management framework derive from
\sphinxcode{\sphinxupquote{ObjectBase}}.

Let’s review a couple of properties of these objects.


\subsection{Smart Pointers}
\label{\detokenize{attributes:smart-pointers}}
As introduced in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tutorial, \sphinxstyleemphasis{ns\sphinxhyphen{}3} objects are memory managed by a
\sphinxhref{http://en.wikipedia.org/wiki/Smart\_pointer}{reference counting smart pointer implementation}, class \sphinxcode{\sphinxupquote{Ptr}}.

Smart pointers are used extensively in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} APIs, to avoid passing
references to heap\sphinxhyphen{}allocated objects that may cause memory leaks.
For most basic usage (syntax), treat a smart pointer like a regular pointer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{n}{nd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CallSomeFunction} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// etc.}
\end{sphinxVerbatim}

So how do you get a smart pointer to an object, as in the first line
of this example?


\subsubsection{CreateObject}
\label{\detokenize{attributes:createobject}}
As we discussed above in {\hyperref[\detokenize{object-model:memory-management-and-class-ptr}]{\sphinxcrossref{\DUrole{std,std-ref}{Memory management and class Ptr}}}}, at the
lowest\sphinxhyphen{}level API, objects of type \sphinxcode{\sphinxupquote{Object}} are not instantiated
using \sphinxcode{\sphinxupquote{operator new}} as usual but instead by a templated function called
\sphinxcode{\sphinxupquote{CreateObject ()}}.

A typical way to create such an object is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{WifiNetDevice}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can think of this as being functionally equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{WifiNetDevice}\PYG{o}{*} \PYG{n}{nd} \PYG{o}{=} \PYG{k}{new} \PYG{n}{WifiNetDevice} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Objects that derive from \sphinxcode{\sphinxupquote{Object}} must be allocated on the heap
using \sphinxcode{\sphinxupquote{CreateObject ()}}. Those deriving from \sphinxcode{\sphinxupquote{ObjectBase}},
such as \sphinxstyleemphasis{ns\sphinxhyphen{}3} helper functions and packet headers and trailers,
can be allocated on the stack.

In some scripts, you may not see a lot of \sphinxcode{\sphinxupquote{CreateObject ()}} calls
in the code; this is because there are some helper objects in effect
that are doing the \sphinxcode{\sphinxupquote{CreateObject ()}} calls for you.


\subsection{TypeId}
\label{\detokenize{attributes:typeid}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} classes that derive from class \sphinxcode{\sphinxupquote{Object}} can include
a metadata class called \sphinxcode{\sphinxupquote{TypeId}} that records meta\sphinxhyphen{}information
about the class, for use in the object aggregation and component manager
systems:
\begin{itemize}
\item {} 
A unique string identifying the class.

\item {} 
The base class of the subclass, within the metadata system.

\item {} 
The set of accessible constructors in the subclass.

\item {} 
A list of publicly accessible properties (“attributes”) of the class.

\end{itemize}


\subsection{Object Summary}
\label{\detokenize{attributes:object-summary}}
Putting all of these concepts together, let’s look at a specific
example: class \sphinxcode{\sphinxupquote{Node}}.

The public header file \sphinxcode{\sphinxupquote{node.h}} has a declaration that includes
a static \sphinxcode{\sphinxupquote{GetTypeId ()}} function call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Node} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

This is defined in the \sphinxcode{\sphinxupquote{node.cc}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}
\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Node}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeviceList}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The list of devices associated to this Node.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{ObjectVectorValue} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeObjectVectorAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}devices}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeObjectVectorChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ApplicationList}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The list of applications associated to this Node.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{ObjectVectorValue} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeObjectVectorAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}applications}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeObjectVectorChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{Application}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Id}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The id (unique integer) of this Node.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{TypeId}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ATTR\PYGZus{}GET}\PYG{p}{,} \PYG{c+c1}{// allow only getting it.}
                   \PYG{n}{UintegerValue} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeUintegerAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Node}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeUintegerChecker}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{;}
  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Consider the \sphinxcode{\sphinxupquote{TypeId}} of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxcode{\sphinxupquote{Object}} class
as an extended form of run time type information (RTTI). The C++ language
includes a simple kind of RTTI in order to support \sphinxcode{\sphinxupquote{dynamic\_cast}} and
\sphinxcode{\sphinxupquote{typeid}} operators.

The \sphinxcode{\sphinxupquote{SetParent\textless{}Object\textgreater{} ()}} call in the definition above is used in
conjunction with our object aggregation mechanisms to allow safe up\sphinxhyphen{} and
down\sphinxhyphen{}casting in inheritance trees during \sphinxcode{\sphinxupquote{GetObject ()}}.
It also enables subclasses to inherit the Attributes of their parent class.

The \sphinxcode{\sphinxupquote{AddConstructor\textless{}Node\textgreater{} ()}} call is used in conjunction
with our abstract object factory mechanisms to allow us to construct
C++ objects without forcing a user to know the concrete class of
the object she is building.

The three calls to \sphinxcode{\sphinxupquote{AddAttribute ()}} associate a given string
with a strongly typed value in the class. Notice that you must provide
a help string which may be displayed, for example, \sphinxstyleemphasis{via} command line
processors. Each \sphinxcode{\sphinxupquote{Attribute}} is associated with mechanisms
for accessing the underlying member variable in the object (for example,
\sphinxcode{\sphinxupquote{MakeUintegerAccessor ()}} tells the generic \sphinxcode{\sphinxupquote{Attribute}}
code how to get to the node ID above). There are also “Checker” methods which
are used to validate values against range limitations, such as maximum
and minimum allowed values.

When users want to create Nodes, they will usually call some form of
\sphinxcode{\sphinxupquote{CreateObject ()}},:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{n}{n} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or more abstractly, using an object factory, you can create a
\sphinxcode{\sphinxupquote{Node}} object without even knowing the concrete C++ type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ObjectFactory} \PYG{n}{factory}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{typeId} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Node\PYGZsq{}\PYGZsq{};}
\PYG{n}{factory}\PYG{p}{.}\PYG{n}{SetTypeId} \PYG{p}{(}\PYG{n}{typeId}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{n}{node} \PYG{o}{=} \PYG{n}{factory}\PYG{p}{.}\PYG{n}{Create} \PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Both of these methods result in fully initialized attributes being available
in the resulting \sphinxcode{\sphinxupquote{Object}} instances.

We next discuss how attributes (values associated with member variables or
functions of the class) are plumbed into the above \sphinxcode{\sphinxupquote{TypeId}}.


\section{Attributes}
\label{\detokenize{attributes:id1}}
The goal of the attribute system is to organize the access of
internal member objects of a simulation. This goal arises because,
typically in simulation, users will cut and paste/modify existing
simulation scripts, or will use higher\sphinxhyphen{}level simulation constructs,
but often will be interested in studying or tracing particular
internal variables.  For instance, use cases such as:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{“I want to trace the packets on the wireless interface only on the first
access point.”}

\item {} 
\sphinxstyleemphasis{“I want to trace the value of the TCP congestion window (every time it
changes) on a particular TCP socket.”}

\item {} 
\sphinxstyleemphasis{“I want a dump of all values that were used in my simulation.”}

\end{itemize}

Similarly, users may want fine\sphinxhyphen{}grained access to internal variables in the
simulation, or may want to broadly change the initial value used for a
particular parameter in all subsequently created objects. Finally, users may
wish to know what variables are settable and retrievable in a simulation
configuration. This is not just for direct simulation interaction on the command
line; consider also a (future) graphical user interface that would like to be
able to provide a feature whereby a user might right\sphinxhyphen{}click on an node on the
canvas and see a hierarchical, organized list of parameters that are settable on
the node and its constituent member objects, and help text and default values
for each parameter.


\subsection{Defining Attributes}
\label{\detokenize{attributes:defining-attributes}}
We provide a way for users to access values deep in the system, without having
to plumb accessors (pointers) through the system and walk pointer chains to get
to them. Consider a class \sphinxcode{\sphinxupquote{QueueBase}} that has a member variable
\sphinxcode{\sphinxupquote{m\_maxSize}} controlling the depth of the queue.

If we look at the declaration of \sphinxcode{\sphinxupquote{QueueBase}}, we see
the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{QueueBase} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Object} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{k}{private}\PYG{o}{:}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{n}{QueueSize} \PYG{n}{m\PYGZus{}maxSize}\PYG{p}{;}                \PYG{c+c1}{//!\PYGZlt{} max queue size}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{QueueSize}} is a special type in \sphinxstyleemphasis{ns\sphinxhyphen{}3} that allows size
to be represented in different units:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{QueueSizeUnit}
\PYG{p}{\PYGZob{}}
  \PYG{n}{PACKETS}\PYG{p}{,}     \PYG{c+cm}{/**\PYGZlt{} Use number of packets for queue size */}
  \PYG{n}{BYTES}\PYG{p}{,}       \PYG{c+cm}{/**\PYGZlt{} Use number of bytes for queue size */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{QueueSize}
\PYG{p}{\PYGZob{}}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{n}{QueueSizeUnit} \PYG{n}{m\PYGZus{}unit}\PYG{p}{;} \PYG{c+c1}{//!\PYGZlt{} unit}
  \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{m\PYGZus{}value}\PYG{p}{;}     \PYG{c+c1}{//!\PYGZlt{} queue size [bytes or packets]}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Finally, the class \sphinxcode{\sphinxupquote{DropTailQueue}} inherits from this base
class and provides the semantics that packets that are submitted to
a full queue will be dropped from the back of the queue (“drop tail”).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}ingroup queue}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * \PYGZbs{}brief A FIFO packet queue that drops tail\PYGZhy{}end packets on overflow}
\PYG{c+cm}{ */}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Item}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{DropTailQueue} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Let’s consider things that a user may want to do with the value of
\sphinxcode{\sphinxupquote{m\_maxSize}}:
\begin{itemize}
\item {} 
Set a default value for the system, such that whenever a new
\sphinxcode{\sphinxupquote{DropTailQueue}} is created, this member is initialized
to that default.

\item {} 
Set or get the value on an already instantiated queue.

\end{itemize}

The above things typically require providing \sphinxcode{\sphinxupquote{Set ()}} and \sphinxcode{\sphinxupquote{Get ()}}
functions, and some type of global default value.

In the \sphinxstyleemphasis{ns\sphinxhyphen{}3} attribute system, these value definitions and accessor function
registrations are moved into the \sphinxcode{\sphinxupquote{TypeId}} class; \sphinxstyleemphasis{e.g}.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED} \PYG{p}{(}\PYG{n}{QueueBase}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId}
\PYG{n}{QueueBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::DropTailQueue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The max queue size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{QueueSizeValue} \PYG{p}{(}\PYG{n}{QueueSize} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeQueueSizeAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{QueueBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetMaxSize}\PYG{p}{,}
                                          \PYG{o}{\PYGZam{}}\PYG{n}{QueueBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetMaxSize}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeQueueSizeChecker} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{p}{;}

  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{AddAttribute ()}} method is performing a number of things for the
\sphinxcode{\sphinxupquote{m\_maxSize}} value:
\begin{itemize}
\item {} 
Binding the (usually private) member variable \sphinxcode{\sphinxupquote{m\_maxSize}}
to a public string \sphinxcode{\sphinxupquote{"MaxSize"}}.

\item {} 
Providing a default value (0 packets).

\item {} 
Providing some help text defining the meaning of the value.

\item {} 
Providing a “Checker” (not used in this example) that can be used to set
bounds on the allowable range of values.

\end{itemize}

The key point is that now the value of this variable and its default value are
accessible in the attribute namespace, which is based on strings such as
\sphinxcode{\sphinxupquote{"MaxSize"}} and \sphinxcode{\sphinxupquote{TypeId}} name strings. In the next section,
we will provide an example script that shows how users may manipulate
these values.

Note that initialization of the attribute relies on the macro
\sphinxcode{\sphinxupquote{NS\_OBJECT\_ENSURE\_REGISTERED (QueueBase)}} being called; if you leave this
out of your new class implementation, your attributes will not be initialized
correctly.

While we have described how to create attributes, we still haven’t described how
to access and manage these values. For instance, there is no \sphinxcode{\sphinxupquote{globals.h}}
header file where these are stored; attributes are stored with their classes.
Questions that naturally arise are how do users easily learn about all of the
attributes of their models, and how does a user access these attributes, or
document their values as part of the record of their simulation?

Detailed documentation of the actual attributes defined for a type,
and a global list of all defined attributes, are available in
the API documentation.  For the rest of this document we are going
to demonstrate the various ways of getting and setting attribute values.


\subsection{Setting Default Values}
\label{\detokenize{attributes:setting-default-values}}

\subsubsection{Config::SetDefault and CommandLine}
\label{\detokenize{attributes:config-setdefault-and-commandline}}
Let’s look at how a user script might access a specific attribute value.
We’re going to use the
\sphinxcode{\sphinxupquote{src/point\sphinxhyphen{}to\sphinxhyphen{}point/examples/main\sphinxhyphen{}attribute\sphinxhyphen{}value.cc}}
script for illustration, with some details stripped out.  The \sphinxcode{\sphinxupquote{main}}
function begins:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a basic example of how to use the attribute system to}
\PYG{c+c1}{// set and get a value in the underlying system; namely, the maximum}
\PYG{c+c1}{// size of the FIFO queue in the PointToPointNetDevice}
\PYG{c+c1}{//}

\PYG{k+kt}{int}
\PYG{n+nf}{main} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{c+c1}{// Queues in ns\PYGZhy{}3 are objects that hold items (other objects) in}
  \PYG{c+c1}{// a queue structure.  The C++ implementation uses templates to}
  \PYG{c+c1}{// allow queues to hold various types of items, but the most}
  \PYG{c+c1}{// common is a pointer to a packet (Ptr\PYGZlt{}Packet\PYGZgt{}).}
  \PYG{c+c1}{//}
  \PYG{c+c1}{// The maximum queue size can either be enforced in bytes (\PYGZsq{}b\PYGZsq{}) or}
  \PYG{c+c1}{// packets (\PYGZsq{}p\PYGZsq{}).  A special type called the ns3::QueueSize can}
  \PYG{c+c1}{// hold queue size values in either unit (bytes or packets).  The}
  \PYG{c+c1}{// queue base class ns3::QueueBase has a MaxSize attribute that can}
  \PYG{c+c1}{// be set to a QueueSize.}

  \PYG{c+c1}{// By default, the MaxSize attribute has a value of 100 packets (\PYGZsq{}100p\PYGZsq{})}
  \PYG{c+c1}{// (this default can be observed in the function QueueBase::GetTypeId)}
  \PYG{c+c1}{//}
  \PYG{c+c1}{// Here, we set it to 80 packets.  We could use one of two value types:}
  \PYG{c+c1}{// a string\PYGZhy{}based value or a QueueSizeValue value}
  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::QueueBase::MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{80p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{c+c1}{// The below function call is redundant}
  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::QueueBase::MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{QueueSizeValue} \PYG{p}{(}\PYG{n}{QueueSize} \PYG{p}{(}\PYG{n}{QueueSizeUnit}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PACKETS}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The main thing to notice in the above are the two equivalent calls to
\sphinxcode{\sphinxupquote{Config::SetDefault ()}}.  This is how we set the default value
for all subsequently instantiated \sphinxcode{\sphinxupquote{DropTailQueue}}s.  We illustrate
that two types of \sphinxcode{\sphinxupquote{Value}} classes, a \sphinxcode{\sphinxupquote{StringValue}} and
a \sphinxcode{\sphinxupquote{QueueSizeValue}} class, can be used to assign the value
to the attribute named by “ns3::QueueBase::MaxSize”.

It is also possible to manipulate Attributes using the \sphinxcode{\sphinxupquote{CommandLine}};
we saw some examples early in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Tutorial.  In particular, it is
straightforward to add a shorthand argument name, such as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}maxSize}},
for an Attribute that is particular relevant for your model, in this case
\sphinxcode{\sphinxupquote{"ns3::QueueBase::MaxSize"}}.  This has the additional feature that
the help string for the Attribute will be printed as part of the usage
message for the script.  For more information see
the \sphinxcode{\sphinxupquote{CommandLine}} API documentation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Allow the user to override any of the defaults and the above}
\PYG{c+c1}{// SetDefaults() at run\PYGZhy{}time, via command\PYGZhy{}line arguments}
\PYG{c+c1}{// For example, via \PYGZdq{}\PYGZhy{}\PYGZhy{}ns3::QueueBase::MaxSize=80p\PYGZdq{}}
\PYG{n}{CommandLine} \PYG{n}{cmd}\PYG{p}{;}
\PYG{c+c1}{// This provides yet another way to set the value from the command line:}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{maxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::QueueBase::MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{Parse} \PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, we will create a few objects using the low\sphinxhyphen{}level API.  Our
newly created queues will not have \sphinxcode{\sphinxupquote{m\_maxSize}} initialized to
0 packets, as defined in the \sphinxcode{\sphinxupquote{QueueBase::GetTypeId ()}}
function, but to 80 packets, because of what we did above with
default values.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{n}{n0} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{net0} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{n0}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddDevice} \PYG{p}{(}\PYG{n}{net0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{q} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DropTailQueue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{net0}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddQueue}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

At this point, we have created a single \sphinxcode{\sphinxupquote{Node}} (\sphinxcode{\sphinxupquote{n0}})
and a single \sphinxcode{\sphinxupquote{PointToPointNetDevice}} (\sphinxcode{\sphinxupquote{net0}}),
and added a \sphinxcode{\sphinxupquote{DropTailQueue}} (\sphinxcode{\sphinxupquote{q}}) to \sphinxcode{\sphinxupquote{net0}}.


\subsubsection{Constructors, Helpers and ObjectFactory}
\label{\detokenize{attributes:constructors-helpers-and-objectfactory}}
Arbitrary combinations of attributes can be set and fetched from
the helper and low\sphinxhyphen{}level APIs; either from the constructors themselves:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{GridPositionAllocator}\PYG{o}{\PYGZgt{}} \PYG{n}{p} \PYG{o}{=}
  \PYG{n}{CreateObjectWithAttributes}\PYG{o}{\PYGZlt{}}\PYG{n}{GridPositionAllocator}\PYG{o}{\PYGZgt{}}
    \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GridWidth}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{UintegerValue} \PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LayoutType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RowFirst}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or from the higher\sphinxhyphen{}level helper APIs, such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mobility}\PYG{p}{.}\PYG{n}{SetPositionAllocator}
    \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::GridPositionAllocator}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MinY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DeltaY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DoubleValue} \PYG{p}{(}\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GridWidth}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{UintegerValue} \PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LayoutType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RowFirst}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We don’t illustrate it here, but you can also configure an
\sphinxcode{\sphinxupquote{ObjectFactory}} with new values for specific attributes.
Instances created by the \sphinxcode{\sphinxupquote{ObjectFactory}} will have those
attributes set during construction.  This is very similar to using
one of the helper APIs for the class.

To review, there are several ways to set values for attributes for
class instances \sphinxstyleemphasis{to be created in the future:}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Config::SetDefault ()}}

\item {} 
\sphinxcode{\sphinxupquote{CommandLine::AddValue ()}}

\item {} 
\sphinxcode{\sphinxupquote{CreateObjectWithAttributes\textless{}\textgreater{} ()}}

\item {} 
Various helper APIs

\end{itemize}

But what if you’ve already created an instance, and you want
to change the value of the attribute?  In this example, how can we
manipulate the \sphinxcode{\sphinxupquote{m\_maxSize}} value of the already instantiated
\sphinxcode{\sphinxupquote{DropTailQueue}}?  Here are various ways to do that.


\subsection{Changing Values}
\label{\detokenize{attributes:changing-values}}

\subsubsection{SmartPointer}
\label{\detokenize{attributes:smartpointer}}
Assume that a smart pointer (\sphinxcode{\sphinxupquote{Ptr}}) to a relevant network device
is in hand; in the current example, it is the \sphinxcode{\sphinxupquote{net0}} pointer.

One way to change the value is to access a pointer to the underlying queue and
modify its attribute.

First, we observe that we can get a pointer to the (base class)
\sphinxcode{\sphinxupquote{Queue}} \sphinxstyleemphasis{via} the
\sphinxcode{\sphinxupquote{PointToPointNetDevice}} attributes, where it is called
\sphinxcode{\sphinxupquote{"TxQueue"}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PointerValue} \PYG{n}{ptr}\PYG{p}{;}
\PYG{n}{net0}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TxQueue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ptr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{txQueue} \PYG{o}{=} \PYG{n}{ptr}\PYG{p}{.}\PYG{n}{Get}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Using the \sphinxcode{\sphinxupquote{GetObject ()}} function, we can perform a safe downcast
to a \sphinxcode{\sphinxupquote{DropTailQueue}}.  The \sphinxtitleref{NS\_ASSERT} checks that the pointer is
valid.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DropTailQueue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{dtq} \PYG{o}{=} \PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject} \PYG{o}{\PYGZlt{}}\PYG{n}{DropTailQueue}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT} \PYG{p}{(}\PYG{n}{dtq} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, we can get the value of an attribute on this queue.  We have introduced
wrapper \sphinxcode{\sphinxupquote{Value}} classes for the underlying data types, similar
to Java wrappers around these types, since the attribute system stores values
serialized to strings, and not disparate types.  Here, the attribute value
is assigned to a \sphinxcode{\sphinxupquote{QueueSizeValue}}, and the \sphinxcode{\sphinxupquote{Get ()}}
method on this value produces the (unwrapped) \sphinxcode{\sphinxupquote{QueueSize}}.  That is,
the variable \sphinxtitleref{limit} is written into by the GetAttribute method.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QueueSizeValue} \PYG{n}{limit}\PYG{p}{;}
\PYG{n}{dtq}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.  dtq limit: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that the above downcast is not really needed; we could have gotten
the attribute value directly from \sphinxcode{\sphinxupquote{txQueue}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2.  txQueue limit: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, let’s set it to another value (60 packets).  Let’s also make
use of the StringValue shorthand notation to set the size by
passing in a string (the string must be a positive integer suffixed
by either the \sphinxtitleref{p} or \sphinxtitleref{b} character).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{60p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3.  txQueue limit changed: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Config Namespace Path}
\label{\detokenize{attributes:config-namespace-path}}
An alternative way to get at the attribute is to use the configuration
namespace.  Here, this attribute resides on a known path in this namespace; this
approach is useful if one doesn’t have access to the underlying pointers and
would like to configure a specific attribute with a single statement.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/0/DeviceList/0/TxQueue/MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
             \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{25p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4.  txQueue limit changed through namespace: }\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The configuration path often has the form of
\sphinxcode{\sphinxupquote{".../\textless{}container name\textgreater{}/\textless{}index\textgreater{}/.../\textless{}attribute\textgreater{}/\textless{}attribute\textgreater{}"}}
to refer to a specific instance by index of an object in the container.
In this case the first container is the list of all \sphinxcode{\sphinxupquote{Node}}s;
the second container is the list of all \sphinxcode{\sphinxupquote{NetDevice}}s on
the chosen \sphinxcode{\sphinxupquote{Node}}.  Finally, the configuration path usually
ends with a succession of member attributes, in this case the \sphinxcode{\sphinxupquote{"MaxSize"}}
attribute of the \sphinxcode{\sphinxupquote{"TxQueue"}} of the chosen \sphinxcode{\sphinxupquote{NetDevice}}.

We could have also used wildcards to set this value for all nodes and all net
devices (which in this simple example has the same effect as the previous
\sphinxcode{\sphinxupquote{Config::Set ()}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/DeviceList/*/TxQueue/MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
             \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{15p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{txQueue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MaxSize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5.  txQueue limit changed through wildcarded namespace: }\PYG{l+s}{\PYGZdq{}}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{limit}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If you run this program from the command line, you should see the following
output corresponding to the steps we took above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run main\PYGZhy{}attribute\PYGZhy{}value
\PYG{l+m}{1}.  dtq limit: 80p
\PYG{l+m}{2}.  txQueue limit: 80p
\PYG{l+m}{3}.  txQueue limit changed: 60p
\PYG{l+m}{4}.  txQueue limit changed through namespace: 25p
\PYG{l+m}{5}.  txQueue limit changed through wildcarded namespace: 15p
\end{sphinxVerbatim}


\subsubsection{Object Name Service}
\label{\detokenize{attributes:object-name-service}}
Another way to get at the attribute is to use the object name service facility.
The object name service allows us to add items to the configuration
namespace under the \sphinxcode{\sphinxupquote{"/Names/"}} path with a user\sphinxhyphen{}defined name string.
This approach is useful if one doesn’t have access to the underlying
pointers and it is difficult to determine the required concrete configuration
namespace path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{net0}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/server/eth0/TxQueue/MaxPackets}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{UintegerValue} \PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here we’ve added the path elements \sphinxcode{\sphinxupquote{"server"}} and \sphinxcode{\sphinxupquote{"eth0"}} under
the \sphinxcode{\sphinxupquote{"/Names/"}} namespace, then used the resulting configuration path
to set the attribute.

See {\hyperref[\detokenize{object-names:object-names}]{\sphinxcrossref{\DUrole{std,std-ref}{Object names}}}} for a fuller treatment of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration namespace.


\section{Implementation Details}
\label{\detokenize{attributes:implementation-details}}

\subsection{Value Classes}
\label{\detokenize{attributes:value-classes}}
Readers will note the \sphinxcode{\sphinxupquote{TypeValue}} classes which are subclasses of the
\sphinxcode{\sphinxupquote{AttributeValue}} base class. These can be thought of as
intermediate classes which are used to convert from raw types to the
\sphinxcode{\sphinxupquote{AttributeValue}}s that are used by the attribute system.
Recall that this database is holding objects of many types serialized
to strings. Conversions to this type can either be done using
an intermediate class (such as \sphinxcode{\sphinxupquote{IntegerValue}},
or \sphinxcode{\sphinxupquote{DoubleValue}} for floating point numbers)
or \sphinxstyleemphasis{via} strings. Direct implicit conversion of types to
\sphinxcode{\sphinxupquote{AttributeValue}} is not really practical.
So in the above, users have a choice of using strings or values:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cwnd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// string\PYGZhy{}based setter}
\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Set} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cwnd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{IntegerValue} \PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// integer\PYGZhy{}based setter}
\end{sphinxVerbatim}

The system provides some macros that help users declare and define
new AttributeValue subclasses for new types that they want to introduce into
the attribute system:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ATTRIBUTE\_HELPER\_HEADER}}

\item {} 
\sphinxcode{\sphinxupquote{ATTRIBUTE\_HELPER\_CPP}}

\end{itemize}

See the API documentation for these constructs for more information.


\subsection{Initialization Order}
\label{\detokenize{attributes:initialization-order}}
Attributes in the system must not depend on the state of any other Attribute in
this system. This is because an ordering of Attribute initialization is not
specified, nor enforced, by the system. A specific example of this can be seen
in automated configuration programs such as \sphinxcode{\sphinxupquote{ConfigStore}}.
Although a given model may arrange it so that Attributes are initialized in a
particular order, another automatic configurator may decide independently to
change Attributes in, for example, alphabetic order.

Because of this non\sphinxhyphen{}specific ordering, no Attribute in the system may have any
dependence on any other Attribute. As a corollary, Attribute setters must never
fail due to the state of another Attribute. No Attribute setter may change (set)
any other Attribute value as a result of changing its value.

This is a very strong restriction and there are cases where Attributes must set
consistently to allow correct operation. To this end we do allow for consistency
checking \sphinxstyleemphasis{when the attribute is used} (\sphinxstyleemphasis{cf}. \sphinxcode{\sphinxupquote{NS\_ASSERT\_MSG}}
or \sphinxcode{\sphinxupquote{NS\_ABORT\_MSG}}).

In general, the attribute code to assign values to the underlying class member
variables is executed after an object is constructed. But what if you need the
values assigned before the constructor body executes, because you need them in
the logic of the constructor? There is a way to do this, used for example in the
class \sphinxcode{\sphinxupquote{ConfigStore}}: call \sphinxcode{\sphinxupquote{ObjectBase::ConstructSelf ()}} as
follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ConfigStore}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ConfigStore} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{ObjectBase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ConstructSelf} \PYG{p}{(}\PYG{n}{AttributeConstructionList} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{c+c1}{// continue on with constructor.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Beware that the object and all its derived classes must also implement
a \sphinxcode{\sphinxupquote{GetInstanceTypeId ()}} method. Otherwise
the \sphinxcode{\sphinxupquote{ObjectBase::ConstructSelf ()}} will not be able to read
the attributes.


\subsection{Adding Attributes}
\label{\detokenize{attributes:adding-attributes}}
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} system will place a number of internal values under the attribute
system, but undoubtedly users will want to extend this to pick up ones we have
missed, or to add their own classes to the system.

There are three typical use cases:
\begin{itemize}
\item {} 
Making an existing class data member accessible as an Attribute,
when it isn’t already.

\item {} 
Making a new class able to expose some data members as Attributes
by giving it a TypeId.

\item {} 
Creating an \sphinxcode{\sphinxupquote{AttributeValue}} subclass for a new class
so that it can be accessed as an Attribute.

\end{itemize}


\subsubsection{Existing Member Variable}
\label{\detokenize{attributes:existing-member-variable}}
Consider this variable in \sphinxcode{\sphinxupquote{TcpSocket}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{m\PYGZus{}cWnd}\PYG{p}{;}   \PYG{c+c1}{// Congestion window}
\end{sphinxVerbatim}

Suppose that someone working with TCP wanted to get or set the value of that
variable using the metadata system. If it were not already provided by \sphinxstyleemphasis{ns\sphinxhyphen{}3},
the user could declare the following addition in the runtime metadata system (to
the \sphinxcode{\sphinxupquote{GetTypeId()}} definition for \sphinxcode{\sphinxupquote{TcpSocket}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Congestion window}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
               \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tcp congestion window (bytes)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
               \PYG{n}{UintegerValue} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{MakeUintegerAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{TcpSocket}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}cWnd}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{MakeUintegerChecker}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Now, the user with a pointer to a \sphinxcode{\sphinxupquote{TcpSocket}} instance
can perform operations such as
setting and getting the value, without having to add these functions explicitly.
Furthermore, access controls can be applied, such as allowing the parameter to
be read and not written, or bounds checking on the permissible values can be
applied.


\subsubsection{New Class TypeId}
\label{\detokenize{attributes:new-class-typeid}}
Here, we discuss the impact on a user who wants to add a new class to \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
What additional things must be done to enable it to hold attributes?

Let’s assume our new class, called \sphinxcode{\sphinxupquote{ns3::MyMobility}},
is a type of mobility model.  First, the class should inherit from
its parent class, \sphinxcode{\sphinxupquote{ns3::MobilityModel}}.
In the \sphinxcode{\sphinxupquote{my\sphinxhyphen{}mobility.h}} header file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}

\PYG{k}{class} \PYG{n+nc}{MyMobility} \PYG{o}{:} \PYG{k}{public} \PYG{n}{MobilityModel}
\PYG{p}{\PYGZob{}}
\end{sphinxVerbatim}

This requires we declare the \sphinxcode{\sphinxupquote{GetTypeId ()}} function.
This is a one\sphinxhyphen{}line public function declaration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public}\PYG{o}{:}
  \PYG{c+cm}{/**}
\PYG{c+cm}{   *  Register this type.}
\PYG{c+cm}{   *  \PYGZbs{}return The object TypeId.}
\PYG{c+cm}{   */}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We’ve already introduced what a \sphinxcode{\sphinxupquote{TypeId}} definition will look like
in the \sphinxcode{\sphinxupquote{my\sphinxhyphen{}mobility.cc}} implementation file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED} \PYG{p}{(}\PYG{n}{MyMobility}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId}
\PYG{n}{MyMobility}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::MyMobility}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{MobilityModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mobility}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{MyMobility}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bounds}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bounds of the area to cruise.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{RectangleValue} \PYG{p}{(}\PYG{n}{Rectangle} \PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{100.0}\PYG{p}{,} \PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeRectangleAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyMobility}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}bounds}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeRectangleChecker} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Change current direction and speed after moving for this delay.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{TimeValue} \PYG{p}{(}\PYG{n}{Seconds} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeTimeAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyMobility}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}modeTime}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakeTimeChecker} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{// etc (more parameters).}
    \PYG{p}{;}
  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If we don’t want to subclass from an existing class, in the header file
we just inherit from \sphinxcode{\sphinxupquote{ns3::Object}}, and in the object file
we set the parent class to \sphinxcode{\sphinxupquote{ns3::Object}} with
\sphinxcode{\sphinxupquote{.SetParent\textless{}Object\textgreater{} ()}}.

Typical mistakes here involve:
\begin{itemize}
\item {} 
Not calling \sphinxcode{\sphinxupquote{NS\_OBJECT\_ENSURE\_REGISTERED ()}}

\item {} 
Not calling the \sphinxcode{\sphinxupquote{SetParent ()}} method,
or calling it with the wrong type.

\item {} 
Not calling the \sphinxcode{\sphinxupquote{AddConstructor ()}} method,
or calling it with the wrong type.

\item {} 
Introducing a typographical error in the name of the \sphinxcode{\sphinxupquote{TypeId}}
in its constructor.

\item {} 
Not using the fully\sphinxhyphen{}qualified C++ typename of the enclosing C++ class as the
name of the \sphinxcode{\sphinxupquote{TypeId}}.  Note that \sphinxcode{\sphinxupquote{"ns3::"}} is required.

\end{itemize}

None of these mistakes can be detected by the \sphinxstyleemphasis{ns\sphinxhyphen{}3} codebase, so users
are advised to check carefully multiple times that they got these right.


\subsubsection{New AttributeValue Type}
\label{\detokenize{attributes:new-attributevalue-type}}
From the perspective of the user who writes a new class in the system and wants
it to be accessible as an attribute, there is mainly the matter of writing the
conversions to/from strings and attribute values.  Most of this can be
copy/pasted with macro\sphinxhyphen{}ized code.  For instance, consider a class declaration
for \sphinxcode{\sphinxupquote{Rectangle}} in the \sphinxcode{\sphinxupquote{src/mobility/model}} directory:


\paragraph{Header File}
\label{\detokenize{attributes:header-file}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * \PYGZbs{}brief a 2d rectangle}
\PYG{c+cm}{ */}
\PYG{k}{class} \PYG{n+nc}{Rectangle}
\PYG{p}{\PYGZob{}}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

  \PYG{k+kt}{double} \PYG{n}{xMin}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{xMax}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{yMin}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{yMax}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

One macro call and two operators, must be added below the class declaration in
order to turn a Rectangle into a value usable by the \sphinxcode{\sphinxupquote{Attribute}} system:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{k}{operator} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Rectangle} \PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{k}{operator} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{Rectangle} \PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ATTRIBUTE\PYGZus{}HELPER\PYGZus{}HEADER} \PYG{p}{(}\PYG{n}{Rectangle}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Implementation File}
\label{\detokenize{attributes:implementation-file}}
In the class definition (\sphinxcode{\sphinxupquote{.cc}} file), the code looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ATTRIBUTE\PYGZus{}HELPER\PYGZus{}CPP} \PYG{p}{(}\PYG{n}{Rectangle}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}
\PYG{k}{operator} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Rectangle} \PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{os} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|}\PYG{l+s}{\PYGZdq{}}
     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMax}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{os}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream} \PYG{o}{\PYGZam{}}
\PYG{k}{operator} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istream} \PYG{o}{\PYGZam{}}\PYG{n}{is}\PYG{p}{,} \PYG{n}{Rectangle} \PYG{o}{\PYGZam{}}\PYG{n}{rectangle}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{char} \PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2}\PYG{p}{,} \PYG{n}{c3}\PYG{p}{;}
  \PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{xMax} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c2} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{c3}
     \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rectangle}\PYG{p}{.}\PYG{n}{yMax}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{c1} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{|}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{|}\PYG{o}{|}
      \PYG{n}{c2} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{|}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{|}\PYG{o}{|}
      \PYG{n}{c3} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{|}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{is}\PYG{p}{.}\PYG{n}{setstate} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ios\PYGZus{}base}\PYG{o}{:}\PYG{o}{:}\PYG{n}{failbit}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{is}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

These stream operators simply convert from a string representation of the
Rectangle (\sphinxcode{\sphinxupquote{"xMin|xMax|yMin|yMax"}}) to the underlying Rectangle.  The modeler
must specify these operators and the string syntactical representation of an
instance of the new class.


\section{ConfigStore}
\label{\detokenize{attributes:configstore}}
Values for \sphinxstyleemphasis{ns\sphinxhyphen{}3} attributes can be stored in an ASCII or XML text file
and loaded into a future simulation run.  This feature is known as the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} ConfigStore.  The \sphinxcode{\sphinxupquote{ConfigStore}} is a specialized database for attribute values and default values.

Although it is a separately maintained module in the
\sphinxcode{\sphinxupquote{src/config\sphinxhyphen{}store/}} directory, we document it here because of its
sole dependency on \sphinxstyleemphasis{ns\sphinxhyphen{}3} core module and attributes.

We can explore this system by using an example from
\sphinxcode{\sphinxupquote{src/config\sphinxhyphen{}store/examples/config\sphinxhyphen{}store\sphinxhyphen{}save.cc}}.

First, all users of the \sphinxcode{\sphinxupquote{ConfigStore}} must include
the following statement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/config\PYGZhy{}store\PYGZhy{}module.h\PYGZdq{}}
\end{sphinxVerbatim}

Next, this program adds a sample object \sphinxcode{\sphinxupquote{ConfigExample}}
to show how the system is extended:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ConfigExample} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::A}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
      \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
      \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{help text}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                     \PYG{n}{IntegerValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
                     \PYG{n}{MakeIntegerAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{A}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}int16}\PYG{p}{)}\PYG{p}{,}
                     \PYG{n}{MakeIntegerChecker}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int16\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{;}
      \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{k+kt}{int16\PYGZus{}t} \PYG{n}{m\PYGZus{}int16}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED} \PYG{p}{(}\PYG{n}{ConfigExample}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, we use the Config subsystem to override the defaults in a couple of
ways:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigExample::TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{IntegerValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}obj} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ABORT\PYGZus{}MSG\PYGZus{}UNLESS} \PYG{p}{(}\PYG{n}{a\PYGZus{}obj}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}int16} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}
                     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot set ConfigExample\PYGZsq{}s integer attribute via Config::SetDefault}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}} \PYG{n}{a2\PYGZus{}obj} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ConfigExample}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{a2\PYGZus{}obj}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{IntegerValue} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntegerValue} \PYG{n}{iv}\PYG{p}{;}
\PYG{n}{a2\PYGZus{}obj}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TestInt16}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{iv}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ABORT\PYGZus{}MSG\PYGZus{}UNLESS} \PYG{p}{(}\PYG{n}{iv}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}
                     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot set ConfigExample\PYGZsq{}s integer attribute via SetAttribute}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The next statement is necessary to make sure that (one of) the objects
created is rooted in the configuration namespace as an object instance.
This normally happens when you aggregate objects to a \sphinxcode{\sphinxupquote{ns3::Node}}
or \sphinxcode{\sphinxupquote{ns3::Channel}} instance,
but here, since we are working at the core level, we need to create a
new root namespace object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{RegisterRootNamespaceObject} \PYG{p}{(}\PYG{n}{a2\PYGZus{}obj}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Writing}
\label{\detokenize{attributes:writing}}
Next, we want to output the configuration store.  The examples show how
to do it in two formats, XML and raw text.  In practice, one should perform
this step just before calling \sphinxcode{\sphinxupquote{Simulator::Run ()}} to save the
final configuration just before running the simulation.

There are three Attributes that govern the behavior of the ConfigStore:
\sphinxcode{\sphinxupquote{"Mode"}}, \sphinxcode{\sphinxupquote{"Filename"}}, and \sphinxcode{\sphinxupquote{"FileFormat"}}.  The Mode (default \sphinxcode{\sphinxupquote{"None"}})
configures whether \sphinxstyleemphasis{ns\sphinxhyphen{}3} should load configuration from a previously saved file
(specify \sphinxcode{\sphinxupquote{"Mode=Load"}}) or save it to a file (specify \sphinxcode{\sphinxupquote{"Mode=Save"}}).
The Filename (default \sphinxcode{\sphinxupquote{""}}) is where the ConfigStore should read or write
its data.  The FileFormat (default \sphinxcode{\sphinxupquote{"RawText"}}) governs whether
the ConfigStore format is plain text or Xml (\sphinxcode{\sphinxupquote{"FileFormat=Xml"}})

The example shows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZhy{}attributes.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Save}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ConfigStore} \PYG{n}{outputConfig}\PYG{p}{;}
\PYG{n}{outputConfig}\PYG{p}{.}\PYG{n}{ConfigureDefaults} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{outputConfig}\PYG{p}{.}\PYG{n}{ConfigureAttributes} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Output config store to txt format}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZhy{}attributes.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RawText}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Save}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ConfigStore} \PYG{n}{outputConfig2}\PYG{p}{;}
\PYG{n}{outputConfig2}\PYG{p}{.}\PYG{n}{ConfigureDefaults} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{outputConfig2}\PYG{p}{.}\PYG{n}{ConfigureAttributes} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Run} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Destroy} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note the placement of these statements just prior to the
\sphinxcode{\sphinxupquote{Simulator::Run ()}} statement.  This output logs all of the
values in place just prior to starting the simulation (\sphinxstyleemphasis{i.e}. after
all of the configuration has taken place).

After running, you can open the \sphinxcode{\sphinxupquote{output\sphinxhyphen{}attributes.txt}} file and see:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
...
default ns3::ErrorModel::IsEnabled \PYGZdq{}true\PYGZdq{}
default ns3::RateErrorModel::ErrorUnit \PYGZdq{}ERROR\PYGZus{}UNIT\PYGZus{}BYTE\PYGZdq{}
default ns3::RateErrorModel::ErrorRate \PYGZdq{}0\PYGZdq{}
default ns3::RateErrorModel::RanVar \PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}
default ns3::BurstErrorModel::ErrorRate \PYGZdq{}0\PYGZdq{}
default ns3::BurstErrorModel::BurstStart \PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}
default ns3::BurstErrorModel::BurstSize \PYGZdq{}ns3::UniformRandomVariable[Min=1|Max=4]\PYGZdq{}
default ns3::PacketSocket::RcvBufSize \PYGZdq{}131072\PYGZdq{}
default ns3::PcapFileWrapper::CaptureSize \PYGZdq{}65535\PYGZdq{}
default ns3::PcapFileWrapper::NanosecMode \PYGZdq{}false\PYGZdq{}
default ns3::SimpleNetDevice::PointToPointMode \PYGZdq{}false\PYGZdq{}
default ns3::SimpleNetDevice::TxQueue \PYGZdq{}ns3::DropTailQueue\PYGZlt{}Packet\PYGZgt{}\PYGZdq{}
default ns3::SimpleNetDevice::DataRate \PYGZdq{}0bps\PYGZdq{}
default ns3::PacketSocketClient::MaxPackets \PYGZdq{}100\PYGZdq{}
default ns3::PacketSocketClient::Interval \PYGZdq{}+1000000000.0ns\PYGZdq{}
default ns3::PacketSocketClient::PacketSize \PYGZdq{}1024\PYGZdq{}
default ns3::PacketSocketClient::Priority \PYGZdq{}0\PYGZdq{}
default ns3::ConfigStore::Mode \PYGZdq{}Save\PYGZdq{}
default ns3::ConfigStore::Filename \PYGZdq{}output\PYGZhy{}attributes.txt\PYGZdq{}
default ns3::ConfigStore::FileFormat \PYGZdq{}RawText\PYGZdq{}
default ns3::ConfigExample::TestInt16 \PYGZdq{}\PYGZhy{}5\PYGZdq{}
global SimulatorImplementationType \PYGZdq{}ns3::DefaultSimulatorImpl\PYGZdq{}
global SchedulerType \PYGZdq{}ns3::MapScheduler\PYGZdq{}
global RngSeed \PYGZdq{}1\PYGZdq{}
global RngRun \PYGZdq{}1\PYGZdq{}
global ChecksumEnabled \PYGZdq{}false\PYGZdq{}
value /\PYGZdl{}ns3::ConfigExample/TestInt16 \PYGZdq{}\PYGZhy{}3\PYGZdq{}
\end{sphinxVerbatim}

In the above, several of the default values for attributes for the core
and network modules are shown.  Then, all the values for the \sphinxstyleemphasis{ns\sphinxhyphen{}3} global values
are recorded.  Finally, the value of the instance of \sphinxcode{\sphinxupquote{ConfigExample}}
that was rooted in the configuration namespace is shown.  In a real
\sphinxstyleemphasis{ns\sphinxhyphen{}3} program, many more models, attributes, and defaults would be shown.

An XML version also exists in \sphinxcode{\sphinxupquote{output\sphinxhyphen{}attributes.xml}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}?\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ns3}\PYG{n+nt}{\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ErrorModel::IsEnabled\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}true\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::RateErrorModel::ErrorUnit\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ERROR\PYGZus{}UNIT\PYGZus{}BYTE\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::RateErrorModel::ErrorRate\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::RateErrorModel::RanVar\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::BurstErrorModel::ErrorRate\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::BurstErrorModel::BurstStart\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::UniformRandomVariable[Min=0.0|Max=1.0]\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::BurstErrorModel::BurstSize\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::UniformRandomVariable[Min=1|Max=4]\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocket::RcvBufSize\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}131072\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PcapFileWrapper::CaptureSize\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}65535\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PcapFileWrapper::NanosecMode\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::SimpleNetDevice::PointToPointMode\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::SimpleNetDevice::TxQueue\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::DropTailQueue\PYGZam{}lt;Packet\PYGZam{}gt;\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::SimpleNetDevice::DataRate\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0bps\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::MaxPackets\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}100\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::Interval\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}+1000000000.0ns\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::PacketSize\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}1024\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::PacketSocketClient::Priority\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigStore::Mode\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}Save\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigStore::Filename\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}output\PYGZhy{}attributes.xml\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigStore::FileFormat\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}Xml\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}default} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ns3::ConfigExample::TestInt16\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}\PYGZhy{}5\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}global} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}SimulatorImplementationType\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::DefaultSimulatorImpl\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}global} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}SchedulerType\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}ns3::MapScheduler\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}global} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}RngSeed\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}global} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}RngRun\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}global} \PYG{n+na}{name=}\PYG{l+s}{\PYGZdq{}ChecksumEnabled\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
 \PYG{n+nt}{\PYGZlt{}value} \PYG{n+na}{path=}\PYG{l+s}{\PYGZdq{}/\PYGZdl{}ns3::ConfigExample/TestInt16\PYGZdq{}} \PYG{n+na}{value=}\PYG{l+s}{\PYGZdq{}\PYGZhy{}3\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/ns3\PYGZgt{}}
\end{sphinxVerbatim}

This file can be archived with your simulation script and output data.


\subsection{Reading}
\label{\detokenize{attributes:reading}}
Next, we discuss configuring simulations \sphinxstyleemphasis{via} a stored input
configuration file.  There are a couple of key differences
compared to writing the final simulation configuration.  First, we
need to place statements such as these at the beginning of the program,
before simulation configuration statements are written (so the values
are registered before being used in object construction).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{input\PYGZhy{}defaults.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Load}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ConfigStore} \PYG{n}{inputConfig}\PYG{p}{;}
\PYG{n}{inputConfig}\PYG{p}{.}\PYG{n}{ConfigureDefaults} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, note that loading of input configuration data is limited to Attribute
default (\sphinxstyleemphasis{i.e}. not instance) values, and global values.  Attribute instance
values are not supported because at this stage of the simulation, before
any objects are constructed, there are no such object instances around.
(Note, future enhancements to the config store may change this behavior).

Second, while the output of \sphinxcode{\sphinxupquote{ConfigStore}} state
will list everything in the database, the input file need only contain
the specific values to be overridden.  So, one way to use this class
for input file configuration is to generate an initial configuration
using the output (\sphinxcode{\sphinxupquote{"Save"}}) \sphinxcode{\sphinxupquote{"Mode"}} described above, extract from
that configuration file only the elements one wishes to change,
and move these minimal elements to a new configuration file
which can then safely be edited and loaded in a subsequent simulation run.

When the \sphinxcode{\sphinxupquote{ConfigStore}} object is instantiated, its attributes
\sphinxcode{\sphinxupquote{"Filename"}}, \sphinxcode{\sphinxupquote{"Mode"}}, and \sphinxcode{\sphinxupquote{"FileFormat"}} must be set,
either \sphinxstyleemphasis{via} command\sphinxhyphen{}line or \sphinxstyleemphasis{via} program statements.


\subsection{Reading/Writing Example}
\label{\detokenize{attributes:reading-writing-example}}
As a more complicated example, let’s assume that we want to read in a
configuration of defaults from an input file named \sphinxcode{\sphinxupquote{input\sphinxhyphen{}defaults.xml}}, and
write out the resulting attributes to a separate file called
\sphinxcode{\sphinxupquote{output\sphinxhyphen{}attributes.xml}}.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/config\PYGZhy{}store\PYGZhy{}module.h\PYGZdq{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{int} \PYG{n}{main} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{input\PYGZhy{}defaults.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Load}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::FileFormat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ConfigStore} \PYG{n}{inputConfig}\PYG{p}{;}
  \PYG{n}{inputConfig}\PYG{p}{.}\PYG{n}{ConfigureDefaults} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{//}
  \PYG{c+c1}{// Allow the user to override any of the defaults and the above Bind () at}
  \PYG{c+c1}{// run\PYGZhy{}time, viacommand\PYGZhy{}line arguments}
  \PYG{c+c1}{//}
  \PYG{n}{CommandLine} \PYG{n}{cmd}\PYG{p}{;}
  \PYG{n}{cmd}\PYG{p}{.}\PYG{n}{Parse} \PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// setup topology}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

  \PYG{c+c1}{// Invoke just before entering Simulator::Run ()}
  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Filename}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output\PYGZhy{}attributes.xml}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetDefault} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ConfigStore::Mode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Save}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ConfigStore} \PYG{n}{outputConfig}\PYG{p}{;}
  \PYG{n}{outputConfig}\PYG{p}{.}\PYG{n}{ConfigureAttributes} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Run} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{ConfigStore GUI}
\label{\detokenize{attributes:configstore-gui}}
There is a GTK\sphinxhyphen{}based front end for the ConfigStore.  This allows users to use a
GUI to access and change variables.  Screenshots of this feature are available
in the \sphinxhref{http://www.nsnam.org/docs/ns-3-overview.pdf}{|ns3| Overview}
presentation.

To use this feature, one must install \sphinxcode{\sphinxupquote{libgtk}} and \sphinxcode{\sphinxupquote{libgtk\sphinxhyphen{}dev}}; an example
Ubuntu installation command is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo apt\PYGZhy{}get install libgtk2.0\PYGZhy{}0 libgtk2.0\PYGZhy{}dev
\end{sphinxVerbatim}

To check whether it is configured or not, check the output of the step:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Summary of optional NS\PYGZhy{}3 features:
Python Bindings               : enabled
Python API Scanning Support   : enabled
NS\PYGZhy{}3 Click Integration        : enabled
GtkConfigStore                : not enabled \PYG{o}{(}library \PYG{l+s+s1}{\PYGZsq{}gtk+\PYGZhy{}2.0 \PYGZgt{}= 2.12\PYGZsq{}} not found\PYG{o}{)}
\end{sphinxVerbatim}

In the above example, it was not enabled, so it cannot be used until a suitable
version is installed and:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{} ./waf
\end{sphinxVerbatim}

is rerun.

Usage is almost the same as the non\sphinxhyphen{}GTK\sphinxhyphen{}based version, but there
are no \sphinxcode{\sphinxupquote{ConfigStore}} attributes involved:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Invoke just before entering Simulator::Run ()}
\PYG{n}{GtkConfigStore} \PYG{n}{config}\PYG{p}{;}
\PYG{n}{config}\PYG{p}{.}\PYG{n}{ConfigureDefaults} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{config}\PYG{p}{.}\PYG{n}{ConfigureAttributes} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, when you run the script, a GUI should pop up, allowing you to open menus of
attributes on different nodes/objects, and then launch the simulation execution
when you are done.


\chapter{Object names}
\label{\detokenize{object-names:object-names}}\label{\detokenize{object-names:id1}}\label{\detokenize{object-names::doc}}
\sphinxstyleemphasis{Placeholder chapter}


\chapter{Logging}
\label{\detokenize{logging:logging}}\label{\detokenize{logging::doc}}
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} logging facility can be used to monitor or debug the progress
of simulation programs.  Logging output can be enabled by program statements
in your \sphinxcode{\sphinxupquote{main()}} program or by the use of the \sphinxcode{\sphinxupquote{NS\_LOG}} environment variable.

Logging statements are not compiled into optimized builds of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  To use
logging, one must build the (default) debug build of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

The project makes no guarantee about whether logging output will remain
the same over time.  Users are cautioned against building simulation output
frameworks on top of logging code, as the output and the way the output
is enabled may change over time.


\section{Overview}
\label{\detokenize{logging:overview}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} logging statements are typically used to log various program
execution events, such as the occurrence of simulation events or the
use of a particular function.

For example, this code snippet is from \sphinxcode{\sphinxupquote{Ipv4L3Protocol::IsDestinationAddress()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{address} \PYG{o}{=}\PYG{o}{=} \PYG{n}{iaddr}\PYG{p}{.}\PYG{n}{GetBroadcast} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{NS\PYGZus{}LOG\PYGZus{}LOGIC} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{For me (interface broadcast address)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If logging has been enabled for the \sphinxcode{\sphinxupquote{Ipv4L3Protocol}} component at a severity
of \sphinxcode{\sphinxupquote{LOGIC}} or above (see below about log severity), the statement
will be printed out; otherwise, it will be suppressed.


\subsection{Enabling Output}
\label{\detokenize{logging:enabling-output}}
There are two ways that users typically control log output.  The
first is by setting the \sphinxcode{\sphinxupquote{NS\_LOG}} environment variable; e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}} ./waf \PYGZhy{}\PYGZhy{}run first
\end{sphinxVerbatim}

will run the \sphinxcode{\sphinxupquote{first}} tutorial program with all logging output.  (The
specifics of the \sphinxcode{\sphinxupquote{NS\_LOG}} format will be discussed below.)

This can be made more granular by selecting individual components:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Ipv4L3Protocol\PYGZdq{}} ./waf \PYGZhy{}\PYGZhy{}run first
\end{sphinxVerbatim}

The output can be further tailored with prefix options.

The second way to enable logging is to use explicit statements in your
program, such as in the \sphinxcode{\sphinxupquote{first}} tutorial program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}
\PYG{n+nf}{main} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{LogComponentEnable} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{UdpEchoClientApplication}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{LogComponentEnable} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{UdpEchoServerApplication}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

(The meaning of \sphinxcode{\sphinxupquote{LOG\_LEVEL\_INFO}}, and other possible values,
will be discussed below.)


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{NS\_LOG}} Syntax}
\label{\detokenize{logging:ns-log-syntax}}
The \sphinxcode{\sphinxupquote{NS\_LOG}} environment variable contains a list of log components
and options.  Log components are separated by \textasciigrave{}:’ characters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}:\PYGZlt{}log\PYGZhy{}component\PYGZgt{}...\PYGZdq{}}
\end{sphinxVerbatim}

Options for each log component are given as flags after
each log component:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}=\PYGZlt{}option\PYGZgt{}|\PYGZlt{}option\PYGZgt{}...:\PYGZlt{}log\PYGZhy{}component\PYGZgt{}...\PYGZdq{}}
\end{sphinxVerbatim}

Options control the severity and level for that component,
and whether optional information should be included, such as the
simulation time, simulation node, function name, and the symbolic severity.


\subsection{Log Components}
\label{\detokenize{logging:log-components}}
Generally a log component refers to a single source code \sphinxcode{\sphinxupquote{.cc}} file,
and encompasses the entire file.

Some helpers have special methods to enable the logging of all components
in a module, spanning different compilation units, but logically grouped
together, such as the \sphinxstyleemphasis{ns\sphinxhyphen{}3} wifi code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{WifiHelper} \PYG{n}{wifiHelper}\PYG{p}{;}
\PYG{n}{wifiHelper}\PYG{p}{.}\PYG{n}{EnableLogComponents} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{NS\_LOG}} log component wildcard \textasciigrave{}*’ will enable all components.

To see what log components are defined, any of these will work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}print\PYGZhy{}list\PYGZdq{}} ./waf \PYGZhy{}\PYGZhy{}run ...

\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}foo\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} a token not matching any log\PYGZhy{}component}
\end{sphinxVerbatim}

The first form will print the name and enabled flags for all log components
which are linked in; try it with \sphinxcode{\sphinxupquote{scratch\sphinxhyphen{}simulator}}.
The second form prints all registered log components,
then exit with an error.


\subsection{Severity and Level Options}
\label{\detokenize{logging:severity-and-level-options}}
Individual messages belong to a single “severity class,” set by the macro
creating the message.  In the example above,
\sphinxcode{\sphinxupquote{NS\_LOG\_LOGIC(..)}} creates the message in the \sphinxcode{\sphinxupquote{LOG\_LOGIC}} severity class.

The following severity classes are defined as \sphinxcode{\sphinxupquote{enum}} constants:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Severity Class
&\sphinxstyletheadfamily 
Meaning
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_NONE}}
&
The default, no logging
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_ERROR}}
&
Serious error messages only
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_WARN}}
&
Warning messages
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_DEBUG}}
&
For use in debugging
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_INFO}}
&
Informational
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_FUNCTION}}
&
Function tracing
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LOGIC}}
&
Control flow tracing within functions
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Typically one wants to see messages at a given severity class \sphinxstyleemphasis{and higher}.
This is done by defining inclusive logging “levels”:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Level
&\sphinxstyletheadfamily 
Meaning
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_ERROR}}
&
Only \sphinxcode{\sphinxupquote{LOG\_ERROR}} severity class messages.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_WARN}}
&
\sphinxcode{\sphinxupquote{LOG\_WARN}} and above.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_DEBUG}}
&
\sphinxcode{\sphinxupquote{LOG\_DEBUG}} and above.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_INFO}}
&
\sphinxcode{\sphinxupquote{LOG\_INFO}} and above.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_FUNCTION}}
&
\sphinxcode{\sphinxupquote{LOG\_FUNCTION}} and above.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_LOGIC}}
&
\sphinxcode{\sphinxupquote{LOG\_LOGIC}} and above.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LEVEL\_ALL}}
&
All severity classes.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_ALL}}
&
Synonym for \sphinxcode{\sphinxupquote{LOG\_LEVEL\_ALL}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The severity class and level options can be given in the \sphinxcode{\sphinxupquote{NS\_LOG}}
environment variable by these tokens:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Class
&\sphinxstyletheadfamily 
Level
\\
\hline
\sphinxcode{\sphinxupquote{error}}
&
\sphinxcode{\sphinxupquote{level\_error}}
\\
\hline
\sphinxcode{\sphinxupquote{warn}}
&
\sphinxcode{\sphinxupquote{level\_warn}}
\\
\hline
\sphinxcode{\sphinxupquote{debug}}
&
\sphinxcode{\sphinxupquote{level\_debug}}
\\
\hline
\sphinxcode{\sphinxupquote{info}}
&
\sphinxcode{\sphinxupquote{level\_info}}
\\
\hline
\sphinxcode{\sphinxupquote{function}}
&
\sphinxcode{\sphinxupquote{level\_function}}
\\
\hline
\sphinxcode{\sphinxupquote{logic}}
&
\sphinxcode{\sphinxupquote{level\_logic}}
\\
\hline&
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{level\_all}}
\item[] \sphinxcode{\sphinxupquote{all}}
\item[] \sphinxcode{\sphinxupquote{*}}
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Using a severity class token enables log messages at that severity only.
For example, \sphinxcode{\sphinxupquote{NS\_LOG="*=warn"}} won’t output messages with severity \sphinxcode{\sphinxupquote{error}}.
\sphinxcode{\sphinxupquote{NS\_LOG="*=level\_debug"}} will output messages at severity levels
\sphinxcode{\sphinxupquote{debug}} and above.

Severity classes and levels can be combined with the \textasciigrave{}|’ operator:
\sphinxcode{\sphinxupquote{NS\_LOG="*=level\_warn|logic"}} will output messages at severity levels
\sphinxcode{\sphinxupquote{error}}, \sphinxcode{\sphinxupquote{warn}} and \sphinxcode{\sphinxupquote{logic}}.

The \sphinxcode{\sphinxupquote{NS\_LOG}} severity level wildcard \textasciigrave{}*’ and \sphinxcode{\sphinxupquote{all}}
are synonyms for \sphinxcode{\sphinxupquote{level\_all}}.

For log components merely mentioned in \sphinxcode{\sphinxupquote{NS\_LOG}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}:...\PYGZdq{}}
\end{sphinxVerbatim}

the default severity is \sphinxcode{\sphinxupquote{LOG\_LEVEL\_ALL}}.


\subsection{Prefix Options}
\label{\detokenize{logging:prefix-options}}
A number of prefixes can help identify
where and when a message originated, and at what severity.

The available prefix options (as \sphinxcode{\sphinxupquote{enum}} constants) are


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Prefix Symbol
&\sphinxstyletheadfamily 
Meaning
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_FUNC}}
&
Prefix the name of the calling function.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_TIME}}
&
Prefix the simulation time.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_NODE}}
&
Prefix the node id.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_LEVEL}}
&
Prefix the severity level.
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_PREFIX\_ALL}}
&
Enable all prefixes.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The prefix options are described briefly below.

The options can be given in the \sphinxcode{\sphinxupquote{NS\_LOG}}
environment variable by these tokens:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Token
&\sphinxstyletheadfamily 
Alternate
\\
\hline
\sphinxcode{\sphinxupquote{prefix\_func}}
&
\sphinxcode{\sphinxupquote{func}}
\\
\hline
\sphinxcode{\sphinxupquote{prefix\_time}}
&
\sphinxcode{\sphinxupquote{time}}
\\
\hline
\sphinxcode{\sphinxupquote{prefix\_node}}
&
\sphinxcode{\sphinxupquote{node}}
\\
\hline
\sphinxcode{\sphinxupquote{prefix\_level}}
&
\sphinxcode{\sphinxupquote{level}}
\\
\hline
\sphinxcode{\sphinxupquote{prefix\_all}}
&
\begin{DUlineblock}{0em}
\item[] \sphinxcode{\sphinxupquote{all}}
\item[] \sphinxcode{\sphinxupquote{*}}
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

For log components merely mentioned in \sphinxcode{\sphinxupquote{NS\_LOG}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZlt{}log\PYGZhy{}component\PYGZgt{}:...\PYGZdq{}}
\end{sphinxVerbatim}

the default prefix options are \sphinxcode{\sphinxupquote{LOG\_PREFIX\_ALL}}.


\subsubsection{Severity Prefix}
\label{\detokenize{logging:severity-prefix}}
The severity class of a message can be included with the options
\sphinxcode{\sphinxupquote{prefix\_level}} or \sphinxcode{\sphinxupquote{level}}.  For example, this value of \sphinxcode{\sphinxupquote{NS\_LOG}}
enables logging for all log components (\textasciigrave{}*’) and all severity
classes (\sphinxcode{\sphinxupquote{=all}}), and prefixes the message with the severity
class (\sphinxcode{\sphinxupquote{|prefix\_level}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=all|prefix\PYGZus{}level\PYGZdq{}} ./waf \PYGZhy{}\PYGZhy{}run scratch\PYGZhy{}simulator
Scratch Simulator
\PYG{o}{[}ERROR\PYG{o}{]} error message
\PYG{o}{[}WARN\PYG{o}{]} warn message
\PYG{o}{[}DEBUG\PYG{o}{]} debug message
\PYG{o}{[}INFO\PYG{o}{]} info message
\PYG{o}{[}FUNCT\PYG{o}{]} \PYG{k}{function} message
\PYG{o}{[}LOGIC\PYG{o}{]} logic message
\end{sphinxVerbatim}


\subsubsection{Time Prefix}
\label{\detokenize{logging:time-prefix}}
The simulation time can be included with the options
\sphinxcode{\sphinxupquote{prefix\_time}} or \sphinxcode{\sphinxupquote{time}}.  This prints the simulation time in seconds.


\subsubsection{Node Prefix}
\label{\detokenize{logging:node-prefix}}
The simulation node id can be included with the options
\sphinxcode{\sphinxupquote{prefix\_node}} or \sphinxcode{\sphinxupquote{node}}.


\subsubsection{Function Prefix}
\label{\detokenize{logging:function-prefix}}
The name of the calling function can be included with the options
\sphinxcode{\sphinxupquote{prefix\_func}} or \sphinxcode{\sphinxupquote{func}}.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{NS\_LOG}} Wildcards}
\label{\detokenize{logging:ns-log-wildcards}}
The log component wildcard \textasciigrave{}*’ will enable all components.  To
enable all components at a specific severity level
use \sphinxcode{\sphinxupquote{*=\textless{}severity\textgreater{}}}.

The severity level option wildcard \textasciigrave{}*’ is a synonym for \sphinxcode{\sphinxupquote{all}}.
This must occur before any \textasciigrave{}|’ characters separating options.
To enable all severity classes, use \sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=*}},
or \sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=*|\textless{}options\textgreater{}}}.

The option wildcard \textasciigrave{}*’ or token \sphinxcode{\sphinxupquote{all}} enables all prefix options,
but must occur \sphinxstyleemphasis{after} a \textasciigrave{}|’ character.  To enable a specific
severity class or level, and all prefixes, use
\sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=\textless{}severity\textgreater{}|*}}.

The combined option wildcard \sphinxcode{\sphinxupquote{**}} enables all severities and all prefixes;
for example, \sphinxcode{\sphinxupquote{\textless{}log\sphinxhyphen{}component\textgreater{}=**}}.

The uber\sphinxhyphen{}wildcard \sphinxcode{\sphinxupquote{***}} enables all severities and all prefixes
for all log components.  These are all equivalent:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}***\PYGZdq{}} ...      \PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=all|*\PYGZdq{}} ...        \PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=*|all\PYGZdq{}} ...
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=**\PYGZdq{}} ...     \PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=level\PYGZus{}all|*\PYGZdq{}} ...  \PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=*|prefix\PYGZus{}all\PYGZdq{}} ...
\PYGZdl{} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}*=*|*\PYGZdq{}} ...
\end{sphinxVerbatim}

Be advised:  even the trivial \sphinxcode{\sphinxupquote{scratch\sphinxhyphen{}simulator}} produces over
46K lines of output with \sphinxcode{\sphinxupquote{NS\_LOG="***"}}!


\section{How to add logging to your code}
\label{\detokenize{logging:how-to-add-logging-to-your-code}}
Adding logging to your code is very simple:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_COMPONENT\_DEFINE (...);}} macro
inside of \sphinxcode{\sphinxupquote{namespace ns3}}.

\end{enumerate}
\begin{quote}

Create a unique string identifier (usually based on the name of the file
and/or class defined within the file) and register it with a macro call
such as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}

\PYG{n}{NS\PYGZus{}LOG\PYGZus{}COMPONENT\PYGZus{}DEFINE} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Ipv4L3Protocol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

This registers \sphinxcode{\sphinxupquote{Ipv4L3Protocol}} as a log component.

(The macro was carefully written to permit inclusion either within or
outside of namespace \sphinxcode{\sphinxupquote{ns3}}, and usage will vary across the codebase, but
the original intent was to register this \sphinxstyleemphasis{outside} of namespace \sphinxcode{\sphinxupquote{ns3}}
at file global scope.)
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Add logging statements (macro calls) to your functions and function bodies.

\end{enumerate}

In case you want to add logging statements to the methods of your template class
(which are defined in an header file):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_TEMPLATE\_DECLARE;}} macro in the private section of
your class declaration. For instance:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Item}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Queue} \PYG{o}{:} \PYG{k}{public} \PYG{n}{QueueBase}
\PYG{p}{\PYGZob{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{list}\PYG{o}{\PYGZlt{}}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}packets}\PYG{p}{;}          \PYG{c+c1}{//!\PYGZlt{} the items in the queue}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}TEMPLATE\PYGZus{}DECLARE}\PYG{p}{;}                  \PYG{c+c1}{//!\PYGZlt{} the log component}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

This requires you to perform these steps for all the subclasses of your class.
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_TEMPLATE\_DEFINE (...);}} macro in the constructor of
your class by providing the name of a log component registered by calling
the \sphinxcode{\sphinxupquote{NS\_LOG\_COMPONENT\_DEFINE (...);}} macro in some module. For instance:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Item}\PYG{o}{\PYGZgt{}}
\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Queue} \PYG{p}{(}\PYG{p}{)}
  \PYG{o}{:} \PYG{n}{NS\PYGZus{}LOG\PYGZus{}TEMPLATE\PYGZus{}DEFINE} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Queue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Add logging statements (macro calls) to the methods of your class.

\end{enumerate}

In case you want to add logging statements to a static member template
(which is defined in an header file):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Invoke the \sphinxcode{\sphinxupquote{NS\_LOG\_STATIC\_TEMPLATE\_DEFINE (...);}} macro in your static
method by providing the name of a log component registered by calling
the \sphinxcode{\sphinxupquote{NS\_LOG\_COMPONENT\_DEFINE (...);}} macro in some module. For instance:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Item}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void}
\PYG{n}{NetDeviceQueue}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PacketEnqueued} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Queue}\PYG{o}{\PYGZlt{}}\PYG{n}{Item}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{queue}\PYG{p}{,}
                                \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDeviceQueueInterface}\PYG{o}{\PYGZgt{}} \PYG{n}{ndqi}\PYG{p}{,}
                                \PYG{k+kt}{uint8\PYGZus{}t} \PYG{n}{txq}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{Item}\PYG{o}{\PYGZgt{}} \PYG{n}{item}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}STATIC\PYGZus{}TEMPLATE\PYGZus{}DEFINE} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NetDeviceQueueInterface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Add logging statements (macro calls) to your static method.

\end{enumerate}


\section{Controlling timestamp precision}
\label{\detokenize{logging:controlling-timestamp-precision}}
Timestamps are printed out in units of seconds.  When used with the default
\sphinxstyleemphasis{ns\sphinxhyphen{}3} time resolution of nanoseconds, the default timestamp precision is 9
digits, with fixed format, to allow for 9 digits to be consistently printed
to the right of the decimal point.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{l+m+mf}{0.000123456}\PYG{n}{s} \PYG{n+nl}{RandomVariableStream}\PYG{p}{:}\PYG{n}{SetAntithetic}\PYG{p}{(}\PYG{l+m+mh}{0x805040}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

When the \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation uses higher time resolution such as picoseconds
or femtoseconds, the precision is expanded accordingly; e.g. for picosecond:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{l+m+mf}{0.000123456789}\PYG{n}{s} \PYG{n+nl}{RandomVariableStream}\PYG{p}{:}\PYG{n}{SetAntithetic}\PYG{p}{(}\PYG{l+m+mh}{0x805040}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

When the \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation uses a time resolution lower than microseconds,
the default C++ precision is used.

An example program at \sphinxcode{\sphinxupquote{src\textbackslash{}core\textbackslash{}examples\textbackslash{}sample\sphinxhyphen{}log\sphinxhyphen{}time\sphinxhyphen{}format.cc}}
demonstrates how to change the timestamp formatting.

The maximum useful precision is 20 decimal digits, since Time is signed 64
bits.


\subsection{Logging Macros}
\label{\detokenize{logging:logging-macros}}\begin{quote}

The logging macros and associated severity levels are


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Severity Class
&\sphinxstyletheadfamily 
Macro
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_NONE}}
&
(none needed)
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_ERROR}}
&
\sphinxcode{\sphinxupquote{NS\_LOG\_ERROR (...);}}
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_WARN}}
&
\sphinxcode{\sphinxupquote{NS\_LOG\_WARN (...);}}
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_DEBUG}}
&
\sphinxcode{\sphinxupquote{NS\_LOG\_DEBUG (...);}}
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_INFO}}
&
\sphinxcode{\sphinxupquote{NS\_LOG\_INFO (...);}}
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_FUNCTION}}
&
\sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION (...);}}
\\
\hline
\sphinxcode{\sphinxupquote{LOG\_LOGIC}}
&
\sphinxcode{\sphinxupquote{NS\_LOG\_LOGIC (...);}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The macros function as output streamers, so anything you can send to
\sphinxcode{\sphinxupquote{std::cout}}, joined by \sphinxcode{\sphinxupquote{\textless{}\textless{}}} operators, is allowed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{MyClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Check} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{value}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{item}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION} \PYG{p}{(}\PYG{k}{this} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{arg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{item}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{arg} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{NS\PYGZus{}LOG\PYGZus{}ERROR} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{encountered bad value }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{value} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ while checking }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{name} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Note that \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION}} automatically inserts a \textasciigrave{}\sphinxcode{\sphinxupquote{,}}’
(comma\sphinxhyphen{}space) separator between each of its arguments.
This simplifies logging of function arguments;
just concatenate them with \sphinxcode{\sphinxupquote{\textless{}\textless{}}} as in the example above.
\end{quote}


\subsection{Unconditional Logging}
\label{\detokenize{logging:unconditional-logging}}
As a convenience, the \sphinxcode{\sphinxupquote{NS\_LOG\_UNCOND (...);}} macro will always log its
arguments, even if the associated log\sphinxhyphen{}component is not enabled at any
severity.  This macro does not use any of the prefix options.  Note that
logging is only enabled in debug builds; this macro won’t produce
output in optimized builds.


\subsection{Guidelines}
\label{\detokenize{logging:guidelines}}\begin{itemize}
\item {} 
Start every class method with \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION (this \textless{}\textless{} args...);}}
This enables easy function call tracing.
\begin{itemize}
\item {} 
Except:  don’t log operators or explicit copy constructors,
since these will cause infinite recursion and stack overflow.

\item {} 
For methods without arguments use the same form:
\sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION (this);}}

\item {} 
For static functions:
\begin{itemize}
\item {} 
With arguments use \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION (...);}} as normal.

\item {} 
Without arguments use \sphinxcode{\sphinxupquote{NS\_LOG\_FUNCTION\_NOARGS ();}}

\end{itemize}

\end{itemize}

\item {} 
Use \sphinxcode{\sphinxupquote{NS\_LOG\_ERROR}} for serious error conditions that probably
invalidate the simulation execution.

\item {} 
Use \sphinxcode{\sphinxupquote{NS\_LOG\_WARN}} for unusual conditions that may be correctable.
Please give some hints as to the nature of the problem and how
it might be corrected.

\item {} 
\sphinxcode{\sphinxupquote{NS\_LOG\_DEBUG}} is usually used in an \sphinxstyleemphasis{ad hoc} way to understand
the execution of a model.

\item {} 
Use \sphinxcode{\sphinxupquote{NS\_LOG\_INFO}} for additional information about the execution,
such as the size of a data structure when adding/removing from it.

\item {} 
Use \sphinxcode{\sphinxupquote{NS\_LOG\_LOGIC}} to trace important logic branches within a function.

\item {} 
Test that your logging changes do not break the code.
Run some example programs with all log components turned on (e.g.
\sphinxcode{\sphinxupquote{NS\_LOG="***"}}).

\item {} 
Use an explicit cast for any variable of type uint8\_t or int8\_t,
e.g., \sphinxcode{\sphinxupquote{NS\_LOG\_LOGIC ("Variable i is " \textless{}\textless{} static\_cast\textless{}int\textgreater{} (i));}}.
Without the cast, the integer is interpreted as a char, and the result
will be most likely not in line with the expectations.
This is a well documented C++ ‘feature’.

\end{itemize}


\chapter{Tracing}
\label{\detokenize{tracing:tracing}}\label{\detokenize{tracing::doc}}
The tracing subsystem is one of the most important mechanisms to understand in
\sphinxstyleemphasis{ns\sphinxhyphen{}3}. In most cases, \sphinxstyleemphasis{ns\sphinxhyphen{}3} users will have a brilliant idea for some new and
improved networking feature. In order to verify that this idea works, the
researcher will make changes to an existing system and then run experiments to
see how the new feature behaves by gathering statistics that capture the
behavior of the feature.

In other words, the whole point of running a simulation is to generate output
for further study. In \sphinxstyleemphasis{ns\sphinxhyphen{}3}, the subsystem that enables a researcher to do this
is the tracing subsystem.


\section{Tracing Motivation}
\label{\detokenize{tracing:tracing-motivation}}
There are many ways to get information out of a program. The most
straightforward way is to just directly print the information to the standard
output, as in,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{int} \PYG{n}{main} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The value of x is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is workable in small environments, but as your simulations get more and
more complicated, you end up with more and more prints and the task of parsing
and performing computations on the output begins to get harder and harder.

Another thing to consider is that every time a new tidbit is needed, the
software core must be edited and another print introduced. There is no
standardized way to control all of this output, so the amount of output tends to
grow without bounds. Eventually, the bandwidth required for simply outputting
this information begins to limit the running time of the simulation. The output
files grow to enormous sizes and parsing them becomes a problem.

\sphinxstyleemphasis{ns\sphinxhyphen{}3} provides a simple mechanism for logging and providing some control over
output via \sphinxstyleemphasis{Log Components}, but the level of control is not very fine grained
at all. The logging module is a relatively blunt instrument.

It is desirable to have a facility that allows one to reach into the core system
and only get the information required without having to change and recompile the
core system. Even better would be a system that notified the user when an item
of interest changed or an interesting event happened.

The \sphinxstyleemphasis{ns\sphinxhyphen{}3} tracing system is designed to work along those lines and is
well\sphinxhyphen{}integrated with the Attribute and Config substems allowing for relatively
simple use scenarios.


\section{Overview}
\label{\detokenize{tracing:overview}}
The tracing subsystem relies heavily on the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Callback and Attribute
mechanisms. You should read and understand the corresponding sections of the
manual before attempting to understand the tracing system.

The \sphinxstyleemphasis{ns\sphinxhyphen{}3} tracing system is built on the concepts of independent tracing sources
and tracing sinks; along with a uniform mechanism for connecting sources to
sinks.

Trace sources are entities that can signal events that happen in a simulation
and provide access to interesting underlying data. For example, a trace source
could indicate when a packet is received by a net device and provide access to
the packet contents for interested trace sinks. A trace source might also
indicate when an interesting state change happens in a model. For example, the
congestion window of a TCP model is a prime candidate for a trace source.

Trace sources are not useful by themselves; they must be connected to other
pieces of code that actually do something useful with the information provided
by the source.  The entities that consume trace information are called trace
sinks. Trace sources are generators of events and trace sinks are consumers.

This explicit division allows for large numbers of trace sources to be scattered
around the system in places which model authors believe might be useful. Unless
a user connects a trace sink to one of these sources, nothing is output. This
arrangement allows relatively unsophisticated users to attach new types of sinks
to existing tracing sources, without requiring editing and recompiling the core
or models of the simulator.

There can be zero or more consumers of trace events generated by a trace source.
One can think of a trace source as a kind of point\sphinxhyphen{}to\sphinxhyphen{}multipoint information
link.

The “transport protocol” for this conceptual point\sphinxhyphen{}to\sphinxhyphen{}multipoint link is an
\sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxcode{\sphinxupquote{Callback}}.

Recall from the Callback Section that callback facility is a way to allow two
modules in the system to communicate via function calls while at the same time
decoupling the calling function from the called class completely. This is the
same requirement as outlined above for the tracing system.

Basically, a trace source \sphinxstyleemphasis{is} a callback to which multiple functions may be
registered. When a trace sink expresses interest in receiving trace events, it
adds a callback to a list of callbacks held by the trace source. When an
interesting event happens, the trace source invokes its \sphinxcode{\sphinxupquote{operator()}} providing
zero or more parameters. This tells the source to go through its list of
callbacks invoking each one in turn. In this way, the parameter(s) are
communicated to the trace sinks, which are just functions.


\subsection{The Simplest Example}
\label{\detokenize{tracing:the-simplest-example}}
It will be useful to go walk a quick example just to reinforce what we’ve
said.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/object.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/uinteger.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/traced\PYGZhy{}value.h\PYGZdq{}\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/trace\PYGZhy{}source\PYGZhy{}accessor.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{ns3}\PYG{p}{;}
\end{sphinxVerbatim}

The first thing to do is include the required files. As mentioned above, the
trace system makes heavy use of the Object and Attribute systems. The first two
includes bring in the declarations for those systems. The file,
\sphinxcode{\sphinxupquote{traced\sphinxhyphen{}value.h}} brings in the required declarations for tracing data that
obeys value semantics.

In general, value semantics just means that you can pass the object around, not
an address. In order to use value semantics at all you have to have an object
with an associated copy constructor and assignment operator available. We extend
the requirements to talk about the set of operators that are pre\sphinxhyphen{}defined for
plain\sphinxhyphen{}old\sphinxhyphen{}data (POD) types. Operator=, operator++, operator\textendash{}, operator+,
operator==, etc.

What this all means is that you will be able to trace changes to an object
made using those operators.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyObject} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyObject}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
      \PYG{p}{.}\PYG{n}{SetParent} \PYG{p}{(}\PYG{n}{Object}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{MyObject}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
      \PYG{p}{.}\PYG{n}{AddTraceSource} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyInteger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{An integer value to trace.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{n}{MakeTraceSourceAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{MyObject}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}myInt}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{;}
    \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{n}{MyObject} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{TracedValue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}myInt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Since the tracing system is integrated with Attributes, and Attributes work with
Objects, there must be an \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxcode{\sphinxupquote{Object}} for the trace source to live in. The
two important lines of code are the \sphinxcode{\sphinxupquote{.AddTraceSource}} and the \sphinxcode{\sphinxupquote{TracedValue}}
declaration.

The \sphinxcode{\sphinxupquote{.AddTraceSource}} provides the “hooks” used for connecting the trace
source to the outside world. The \sphinxcode{\sphinxupquote{TracedValue}} declaration provides the
infrastructure that overloads the operators mentioned above and drives the
callback process.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{IntTrace} \PYG{p}{(}\PYG{n}{Int} \PYG{n}{oldValue}\PYG{p}{,} \PYG{n}{Int} \PYG{n}{newValue}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Traced }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldValue} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ to }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{newValue} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is the definition of the trace sink. It corresponds directly to a callback
function. This function will be called whenever one of the operators of the
\sphinxcode{\sphinxupquote{TracedValue}} is executed.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}
\PYG{n+nf}{main} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{MyObject}\PYG{o}{\PYGZgt{}} \PYG{n}{myObject} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{MyObject}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnectWithoutContext} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyInteger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{IntTrace}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}myInt} \PYG{o}{=} \PYG{l+m+mi}{1234}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In this snippet, the first thing that needs to be done is to create the object
in which the trace source lives.

The next step, the \sphinxcode{\sphinxupquote{TraceConnectWithoutContext}}, forms the connection between
the trace source and the trace sink. Notice the \sphinxcode{\sphinxupquote{MakeCallback}} template
function. Recall from the Callback section that this creates the specialized
functor responsible for providing the overloaded \sphinxcode{\sphinxupquote{operator()}} used to “fire”
the callback. The overloaded operators (++, \textendash{}, etc.) will use this
\sphinxcode{\sphinxupquote{operator()}} to actually invoke the callback. The
\sphinxcode{\sphinxupquote{TraceConnectWithoutContext}}, takes a string parameter that provides the name
of the Attribute assigned to the trace source. Let’s ignore the bit about
context for now since it is not important yet.

Finally, the line,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{myObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}myInt} \PYG{o}{=} \PYG{l+m+mi}{1234}\PYG{p}{;}
\end{sphinxVerbatim}

should be interpreted as an invocation of \sphinxcode{\sphinxupquote{operator=}} on the member variable
\sphinxcode{\sphinxupquote{m\_myInt}} with the integer \(1234\) passed as a parameter. It turns out
that this operator is defined (by \sphinxcode{\sphinxupquote{TracedValue}}) to execute a callback that
returns void and takes two integer values as parameters \textendash{} an old value and a
new value for the integer in question. That is exactly the function signature
for the callback function we provided \textendash{} \sphinxcode{\sphinxupquote{IntTrace}}.

To summarize, a trace source is, in essence, a variable that holds a list of
callbacks. A trace sink is a function used as the target of a callback. The
Attribute and object type information systems are used to provide a way to
connect trace sources to trace sinks. The act of “hitting” a trace source is
executing an operator on the trace source which fires callbacks. This results in
the trace sink callbacks registering interest in the source being called with
the parameters provided by the source.


\subsection{Using the Config Subsystem to Connect to Trace Sources}
\label{\detokenize{tracing:using-the-config-subsystem-to-connect-to-trace-sources}}
The \sphinxcode{\sphinxupquote{TraceConnectWithoutContext}} call shown above in the simple example is
actually very rarely used in the system. More typically, the \sphinxcode{\sphinxupquote{Config}}
subsystem is used to allow selecting a trace source in the system using what is
called a \sphinxstyleemphasis{config path}.

For example, one might find something that looks like the following in the
system (taken from \sphinxcode{\sphinxupquote{examples/tcp\sphinxhyphen{}large\sphinxhyphen{}transfer.cc}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{CwndTracer} \PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{oldval}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{newval}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ConnectWithoutContext} \PYG{p}{(}
  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/0/\PYGZdl{}ns3::TcpL4Protocol/SocketList/0/CongestionWindow}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CwndTracer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This should look very familiar. It is the same thing as the previous example,
except that a static member function of class \sphinxcode{\sphinxupquote{Config}} is being called instead
of a method on \sphinxcode{\sphinxupquote{Object}}; and instead of an \sphinxcode{\sphinxupquote{Attribute}} name, a path is being
provided.

The first thing to do is to read the path backward. The last segment of the path
must be an \sphinxcode{\sphinxupquote{Attribute}} of an \sphinxcode{\sphinxupquote{Object}}. In fact, if you had a pointer to the
\sphinxcode{\sphinxupquote{Object}} that has the “CongestionWindow” \sphinxcode{\sphinxupquote{Attribute}} handy (call it
\sphinxcode{\sphinxupquote{theObject}}), you could write this just like the previous example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{CwndTracer} \PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{oldval}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{newval}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{theObject}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnectWithoutContext} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CongestionWindow}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CwndTracer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It turns out that the code for \sphinxcode{\sphinxupquote{Config::ConnectWithoutContext}} does exactly
that. This function takes a path that represents a chain of \sphinxcode{\sphinxupquote{Object}} pointers
and follows them until it gets to the end of the path and interprets the last
segment as an \sphinxcode{\sphinxupquote{Attribute}} on the last object. Let’s walk through what
happens.

The leading “/” character in the path refers to a so\sphinxhyphen{}called namespace. One of the
predefined namespaces in the config system is “NodeList” which is a list of all of
the nodes in the simulation. Items in the list are referred to by indices into the
list, so “/NodeList/0” refers to the zeroth node in the list of nodes created by
the simulation. This node is actually a \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} and so is a subclass of
an \sphinxcode{\sphinxupquote{ns3::Object}}.

As described in the {\hyperref[\detokenize{object-model:object-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Object model}}}} section, \sphinxstyleemphasis{ns\sphinxhyphen{}3} supports an object
aggregation model. The next path segment begins with the “\$” character which
indicates a \sphinxcode{\sphinxupquote{GetObject}} call should be made looking for the type that follows.
When a node is initialized by an \sphinxcode{\sphinxupquote{InternetStackHelper}} a number of interfaces
are aggregated to the node. One of these is the TCP level four protocol. The
runtime type of this protocol object is \sphinxcode{\sphinxupquote{ns3::TcpL4Protocol\textquotesingle{}\textquotesingle{}. When the
\textasciigrave{}\textasciigrave{}GetObject}} is executed, it returns a pointer to the object of this type.

The \sphinxcode{\sphinxupquote{TcpL4Protocol}} class defines an Attribute called “SocketList” which is a
list of sockets.  Each socket is actually an \sphinxcode{\sphinxupquote{ns3::Object}} with its own
\sphinxcode{\sphinxupquote{Attributes}}.  The items in the list of sockets are referred to by index just
as in the NodeList, so “SocketList/0” refers to the zeroth socket in the list of
sockets on the zeroth node in the NodeList \textendash{} the first node constructed in the
simulation.

This socket, the type of which turns out to be an \sphinxcode{\sphinxupquote{ns3::TcpSocketImpl}} defines
an attribute called “CongestionWindow” which is a \sphinxcode{\sphinxupquote{TracedValue\textless{}uint32\_t\textgreater{}}}.
The \sphinxcode{\sphinxupquote{Config::ConnectWithoutContext}} now does a,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{object}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnectWithoutContext} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CongestionWindow}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CwndTracer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

using the object pointer from “SocketList/0” which makes the connection between
the trace source defined in the socket to the callback \textendash{} \sphinxcode{\sphinxupquote{CwndTracer}}.

Now, whenever a change is made to the \sphinxcode{\sphinxupquote{TracedValue\textless{}uint32\_t\textgreater{}}} representing the
congestion window in the TCP socket, the registered callback will be executed
and the function \sphinxcode{\sphinxupquote{CwndTracer}} will be called printing out the old and new
values of the TCP congestion window.


\section{Using the Tracing API}
\label{\detokenize{tracing:using-the-tracing-api}}
There are three levels of interaction with the tracing system:
\begin{itemize}
\item {} 
Beginning user can easily control which objects are participating in tracing;

\item {} 
Intermediate users can extend the tracing system to modify the output format
generated or use existing trace sources in different ways, without modifying
the core of the simulator;

\item {} 
Advanced users can modify the simulator core to add new tracing sources and
sinks.

\end{itemize}


\section{Using Trace Helpers}
\label{\detokenize{tracing:using-trace-helpers}}
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace helpers provide a rich environment for configuring and selecting
different trace events and writing them to files. In previous sections,
primarily “Building Topologies,” we have seen several varieties of the trace
helper methods designed for use inside other (device) helpers.

Perhaps you will recall seeing some of these variations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pointToPoint}\PYG{p}{.}\PYG{n}{EnablePcapAll} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{second}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pointToPoint}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{second}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{p2pNodes}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetId} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csma}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{third}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{csmaDevices}\PYG{p}{.}\PYG{n}{Get} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pointToPoint}\PYG{p}{.}\PYG{n}{EnableAsciiAll} \PYG{p}{(}\PYG{n}{ascii}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myfirst.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

What may not be obvious, though, is that there is a consistent model for all of
the trace\sphinxhyphen{}related methods found in the system. We will now take a little time
and take a look at the “big picture”.

There are currently two primary use cases of the tracing helpers in \sphinxstyleemphasis{ns\sphinxhyphen{}3}:
Device helpers and protocol helpers. Device helpers look at the problem of
specifying which traces should be enabled through a node, device pair.  For
example, you may want to specify that pcap tracing should be enabled on a
particular device on a specific node. This follows from the \sphinxstyleemphasis{ns\sphinxhyphen{}3} device
conceptual model, and also the conceptual models of the various device helpers.
Following naturally from this, the files created follow a
\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node\textgreater{}\sphinxhyphen{}\textless{}device\textgreater{} naming convention.

Protocol helpers look at the problem of specifying which traces should be
enabled through a protocol and interface pair. This follows from the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
protocol stack conceptual model, and also the conceptual models of internet
stack helpers. Naturally, the trace files should follow a
\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}protocol\textgreater{}\sphinxhyphen{}\textless{}interface\textgreater{} naming convention.

The trace helpers therefore fall naturally into a two\sphinxhyphen{}dimensional taxonomy.
There are subtleties that prevent all four classes from behaving identically,
but we do strive to make them all work as similarly as possible; and whenever
possible there are analogs for all methods in all classes.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
pcap
&\sphinxstyletheadfamily 
ascii
\\
\hline
Device Helper
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
Protocol Helper
&
\(\checkmark\)
&
\(\checkmark\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

We use an approach called a \sphinxcode{\sphinxupquote{mixin}} to add tracing functionality to our helper
classes. A \sphinxcode{\sphinxupquote{mixin}} is a class that provides functionality to that is
inherited by a subclass. Inheriting from a mixin is not considered a form of
specialization but is really a way to collect functionality.

Let’s take a quick look at all four of these cases and their respective
\sphinxcode{\sphinxupquote{mixins}}.


\subsection{Pcap Tracing Device Helpers}
\label{\detokenize{tracing:pcap-tracing-device-helpers}}
The goal of these helpers is to make it easy to add a consistent pcap trace
facility to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} device. We want all of the various flavors of pcap tracing
to work the same across all devices, so the methods of these helpers are
inherited by device helpers. Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you
want to follow the discussion while looking at real code.

The class \sphinxcode{\sphinxupquote{PcapHelperForDevice}} is a \sphinxcode{\sphinxupquote{mixin}} provides the high level
functionality for using pcap tracing in an \sphinxstyleemphasis{ns\sphinxhyphen{}3} device. Every device must
implement a single virtual method inherited from this class.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{EnablePcapInternal} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{promiscuous}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The signature of this method reflects the device\sphinxhyphen{}centric view of the situation
at this level. All of the public methods inherited from class
\sphinxcode{\sphinxupquote{PcapUserHelperForDevice}} reduce to calling this single device\sphinxhyphen{}dependent
implementation method. For example, the lowest level pcap method,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{explicitFilename} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will call the device implementation of \sphinxcode{\sphinxupquote{EnablePcapInternal}} directly. All
other public pcap tracing methods build on this implementation to provide
additional user\sphinxhyphen{}level functionality. What this means to the user is that all
device helpers in the system will have all of the pcap trace methods available;
and these methods will all work in the same way across devices if the device
implements \sphinxcode{\sphinxupquote{EnablePcapInternal}} correctly.


\subsubsection{Pcap Tracing Device Helper Methods}
\label{\detokenize{tracing:pcap-tracing-device-helper-methods}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{,}
                 \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{explicitFilename} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ndName}\PYG{p}{,}
                 \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{explicitFilename} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{NetDeviceContainer} \PYG{n}{d}\PYG{p}{,}
                 \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{,}
                 \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{nodeid}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{deviceid}\PYG{p}{,}
                 \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapAll} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In each of the methods shown above, there is a default parameter called
\sphinxcode{\sphinxupquote{promiscuous}} that defaults to false. This parameter indicates that the trace
should not be gathered in promiscuous mode. If you do want your traces to
include all traffic seen by the device (and if the device supports a promiscuous
mode) simply add a true parameter to any of the calls above. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nd}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will enable promiscuous mode captures on the \sphinxcode{\sphinxupquote{NetDevice}} specified by \sphinxcode{\sphinxupquote{nd}}.

The first two methods also include a default parameter called
\sphinxcode{\sphinxupquote{explicitFilename}} that will be discussed below.

You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{PcapHelperForDevice}} to
find the details of these methods; but to summarize …

You can enable pcap tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} to an \sphinxcode{\sphinxupquote{EnablePcap}} method. The \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} is implicit
since the net device must belong to exactly one \sphinxcode{\sphinxupquote{Node}}. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an \sphinxcode{\sphinxupquote{EnablePcap}}
method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} is looked up from the name string.  Again, the
\sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit since the named net device must belong to exactly one
\sphinxcode{\sphinxupquote{Node}}.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/ath0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NetDeviceContainer}}. For each \sphinxcode{\sphinxupquote{NetDevice}} in the container the
type is checked.  For each device of the proper type (the same type as is
managed by the device helper), tracing is enabled. Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is
implicit since the found net device must belong to exactly one \sphinxcode{\sphinxupquote{Node}}. For
example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NetDeviceContainer} \PYG{n}{d} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} its
attached \sphinxcode{\sphinxupquote{NetDevices}} are iterated.  For each \sphinxcode{\sphinxupquote{NetDevice}} attached to each
node in the container, the type of that device is checked.  For each device of
the proper type (the same type as is managed by the device helper), tracing is
enabled.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on the basis of node ID and device ID as well as
with explicit \sphinxcode{\sphinxupquote{Ptr}}. Each \sphinxcode{\sphinxupquote{Node}} in the system has an integer node ID and
each device connected to a node has an integer device ID.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Finally, you can enable pcap tracing for all devices in the system, with the
same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapAll} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Pcap Tracing Device Helper Filename Selection}
\label{\detokenize{tracing:pcap-tracing-device-helper-filename-selection}}
Implicit in the method descriptions above is the construction of a complete
filename by the implementation method. By convention, pcap traces in the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
system are of the form \sphinxcode{\sphinxupquote{\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.pcap}}

As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id; and every device will have an interface index (also called a device id)
relative to its node. By default, then, a pcap trace file created as a result
of enabling tracing on the first device of node 21 using the prefix “prefix”
would be \sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}21\sphinxhyphen{}1.pcap}}.

You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.  For
example, if you use the object name service to assign the name “server” to node
21, the resulting pcap trace file name will automatically become,
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}1.pcap}} and if you also assign the name “eth0” to the device,
your pcap file name will automatically pick this up and be called
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}eth0.pcap}}.

Finally, two of the methods shown above,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{explicitFilename} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcap} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ndName}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{promiscuous} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{explicitFilename} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

have a default parameter called \sphinxcode{\sphinxupquote{explicitFilename}}. When set to true, this
parameter disables the automatic filename completion mechanism and allows you to
create an explicit filename. This option is only available in the methods which
enable pcap tracing on a single device.

For example, in order to arrange for a device helper to create a single
promiscuous pcap capture file of a specific name (\sphinxcode{\sphinxupquote{my\sphinxhyphen{}pcap\sphinxhyphen{}file.pcap}}) on a
given device, one could:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcap} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZhy{}pcap\PYGZhy{}file.pcap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nd}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first \sphinxcode{\sphinxupquote{true}} parameter enables promiscuous mode traces and the second
tells the helper to interpret the \sphinxcode{\sphinxupquote{prefix}} parameter as a complete filename.


\subsection{Ascii Tracing Device Helpers}
\label{\detokenize{tracing:ascii-tracing-device-helpers}}
The behavior of the ASCII trace helper \sphinxcode{\sphinxupquote{mixin}} is substantially similar to
the pcap version. Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you want to
follow the discussion while looking at real code.

The class \sphinxcode{\sphinxupquote{AsciiTraceHelperForDevice}} adds the high level functionality for
using ASCII tracing to a device helper class. As in the pcap case, every device
must implement a single virtual method inherited from the ASCII trace
\sphinxcode{\sphinxupquote{mixin}}.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiInternal} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The signature of this method reflects the device\sphinxhyphen{}centric view of the situation
at this level; and also the fact that the helper may be writing to a shared
output stream. All of the public ASCII\sphinxhyphen{}trace\sphinxhyphen{}related methods inherited from
class \sphinxcode{\sphinxupquote{AsciiTraceHelperForDevice}} reduce to calling this single device\sphinxhyphen{}
dependent implementation method. For example, the lowest level ASCII trace
methods,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will call the device implementation of \sphinxcode{\sphinxupquote{EnableAsciiInternal}} directly,
providing either a valid prefix or stream.  All other public ASCII tracing
methods will build on these low\sphinxhyphen{}level functions to provide additional user\sphinxhyphen{}level
functionality. What this means to the user is that all device helpers in the
system will have all of the ASCII trace methods available; and these methods
will all work in the same way across devices if the devices implement
\sphinxcode{\sphinxupquote{EnablAsciiInternal}} correctly.


\subsubsection{Ascii Tracing Device Helper Methods}
\label{\detokenize{tracing:ascii-tracing-device-helper-methods}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ndName}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ndName}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{NetDeviceContainer} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{NetDeviceContainer} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{nodeid}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{deviceid}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAscii} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{nodeid}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{deviceid}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiAll} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiAll} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{TraceHelperForDevice}} to
find the details of these methods; but to summarize …

There are twice as many methods available for ASCII tracing as there were for
pcap tracing. This is because, in addition to the pcap\sphinxhyphen{}style model where traces
from each unique node/device pair are written to a unique file, we support a
model in which trace information for many node/device pairs is written to a
common file.  This means that the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node\textgreater{}\sphinxhyphen{}\textless{}device\textgreater{} file name generation
mechanism is replaced by a mechanism to refer to a common file; and the number
of API methods is doubled to allow all combinations.

Just as in pcap tracing, you can enable ASCII tracing on a particular
node/net\sphinxhyphen{}device pair by providing a \sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} to an \sphinxcode{\sphinxupquote{EnableAscii}}
method. The \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} is implicit since the net device must belong to
exactly one \sphinxcode{\sphinxupquote{Node}}. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this case, no trace contexts are written to the ASCII trace file since they
would be redundant. The system will pick the file name to be created using the
same rules as described in the pcap section, except that the file will have the
suffix “.tr” instead of “.pcap”.

If you want to enable ASCII tracing on more than one net device and have all
traces sent to a single file, you can do that as well by using an object to
refer to a single file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd1}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{NetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd2}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream} \PYG{o}{=} \PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{nd1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{nd2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this case, trace contexts are written to the ASCII trace file since they
are required to disambiguate traces from the two devices.  Note that since the
user is completely specifying the file name, the string should include the “.tr”
for consistency.

You can enable ASCII tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an
\sphinxcode{\sphinxupquote{EnablePcap}} method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}NetDevice\textgreater{}}} is looked up from the name
string.  Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit since the named net device must
belong to exactly one \sphinxcode{\sphinxupquote{Node}}.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in two files named \sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}client\sphinxhyphen{}eth0.tr}} and
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}eth0.tr}} with traces for each device in the respective trace
file. Since all of the EnableAscii functions are overloaded to take a stream
wrapper, you can use that form as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream} \PYG{o}{=} \PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{client/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{server/eth0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a single trace file called \sphinxcode{\sphinxupquote{trace\sphinxhyphen{}file\sphinxhyphen{}name.tr}} that
contains all of the trace events for both devices. The events would be
disambiguated by trace context strings.

You can enable ASCII tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NetDeviceContainer}}. For each \sphinxcode{\sphinxupquote{NetDevice}} in the container the
type is checked. For each device of the proper type (the same type as is managed
by the device helper), tracing is enabled. Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit
since the found net device must belong to exactly one \sphinxcode{\sphinxupquote{Node}}.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NetDeviceContainer} \PYG{n}{d} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NetDeviceContainer} \PYG{n}{d} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream} \PYG{o}{=} \PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable ascii tracing on a collection of node/net\sphinxhyphen{}device pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} its
attached \sphinxcode{\sphinxupquote{NetDevices}} are iterated.  For each \sphinxcode{\sphinxupquote{NetDevice}} attached to each
node in the container, the type of that device is checked.  For each device of
the proper type (the same type as is managed by the device helper), tracing is
enabled.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

You can enable pcap tracing on the basis of node ID and device ID as well as
with explicit \sphinxcode{\sphinxupquote{Ptr}}. Each \sphinxcode{\sphinxupquote{Node}} in the system has an integer node ID and
each device connected to a node has an integer device ID.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAscii} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Of course, the traces can be combined into a single file as shown above.

Finally, you can enable pcap tracing for all devices in the system, with the
same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiAll} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a number of ASCII trace files being created, one for
every device in the system of the type managed by the helper. All of these
files will follow the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining
all of the traces into a single file is accomplished similarly to the examples
above.


\subsubsection{Ascii Tracing Device Helper Filename Selection}
\label{\detokenize{tracing:ascii-tracing-device-helper-filename-selection}}
Implicit in the prefix\sphinxhyphen{}style method descriptions above is the construction of
the complete filenames by the implementation method. By convention, ASCII traces
in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system are of the form \sphinxcode{\sphinxupquote{\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr}}.

As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id; and every device will have an interface index (also called a device id)
relative to its node.  By default, then, an ASCII trace file created as a result
of enabling tracing on the first device of node 21, using the prefix “prefix”,
would be \sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}21\sphinxhyphen{}1.tr}}.

You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.  For
example, if you use the object name service to assign the name “server” to node
21, the resulting ASCII trace file name will automatically become,
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}1.tr}} and if you also assign the name “eth0” to the device,
your ASCII trace file name will automatically pick this up and be called
\sphinxcode{\sphinxupquote{prefix\sphinxhyphen{}server\sphinxhyphen{}eth0.tr}}.


\subsection{Pcap Tracing Protocol Helpers}
\label{\detokenize{tracing:pcap-tracing-protocol-helpers}}
The goal of these \sphinxcode{\sphinxupquote{mixins}} is to make it easy to add a consistent pcap trace
facility to protocols. We want all of the various flavors of pcap tracing to
work the same across all protocols, so the methods of these helpers are
inherited by stack helpers. Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you
want to follow the discussion while looking at real code.

In this section we will be illustrating the methods as applied to the protocol
\sphinxcode{\sphinxupquote{Ipv4}}.  To specify traces in similar protocols, just substitute the
appropriate type.  For example, use a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv6\textgreater{}}} instead of a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}}
and call \sphinxcode{\sphinxupquote{EnablePcapIpv6}} instead of \sphinxcode{\sphinxupquote{EnablePcapIpv4}}.

The class \sphinxcode{\sphinxupquote{PcapHelperForIpv4}} provides the high level functionality for using
pcap tracing in the \sphinxcode{\sphinxupquote{Ipv4}} protocol.  Each protocol helper enabling these
methods must implement a single virtual method inherited from this class.  There
will be a separate implementation for \sphinxcode{\sphinxupquote{Ipv6}}, for example, but the only
difference will be in the method names and signatures.  Different method names
are required to disambiguate class \sphinxcode{\sphinxupquote{Ipv4}} from \sphinxcode{\sphinxupquote{Ipv6}} which are both derived
from class \sphinxcode{\sphinxupquote{Object}}, and methods that share the same signature.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4Internal} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The signature of this method reflects the protocol and interface\sphinxhyphen{}centric view of
the situation at this level. All of the public methods inherited from class
\sphinxcode{\sphinxupquote{PcapHelperForIpv4}} reduce to calling this single device\sphinxhyphen{}dependent
implementation method.  For example, the lowest level pcap method,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will call the device implementation of \sphinxcode{\sphinxupquote{EnablePcapIpv4Internal}} directly.  All
other public pcap tracing methods build on this implementation to provide
additional user\sphinxhyphen{}level functionality. What this means to the user is that all
protocol helpers in the system will have all of the pcap trace methods
available; and these methods will all work in the same way across protocols if
the helper implements \sphinxcode{\sphinxupquote{EnablePcapIpv4Internal}} correctly.


\subsubsection{Pcap Tracing Protocol Helper Methods}
\label{\detokenize{tracing:pcap-tracing-protocol-helper-methods}}
These methods are designed to be in one\sphinxhyphen{}to\sphinxhyphen{}one correspondence with the \sphinxcode{\sphinxupquote{Node}}\sphinxhyphen{}
and \sphinxcode{\sphinxupquote{NetDevice}}\sphinxhyphen{} centric versions of the device versions. Instead of
\sphinxcode{\sphinxupquote{Node}} and \sphinxcode{\sphinxupquote{NetDevice}} pair constraints, we use protocol and interface
constraints.

Note that just like in the device version, there are six methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ipv4Name}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ipv4InterfaceContainer} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{nodeid}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnablePcapIpv4All} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{PcapHelperForIpv4}} to find
the details of these methods; but to summarize …

You can enable pcap tracing on a particular protocol/interface pair by providing
a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} and \sphinxcode{\sphinxupquote{interface}} to an \sphinxcode{\sphinxupquote{EnablePcap}} method.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4} \PYG{o}{=} \PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ipv4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on a particular node/net\sphinxhyphen{}device pair by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an \sphinxcode{\sphinxupquote{EnablePcap}}
method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} is looked up from the name string.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{serverIPv4}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{serverIpv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on a collection of protocol/interface pairs by
providing an \sphinxcode{\sphinxupquote{Ipv4InterfaceContainer}}. For each \sphinxcode{\sphinxupquote{Ipv4}} / interface pair in
the container the protocol type is checked. For each protocol of the proper type
(the same type as is managed by the device helper), tracing is enabled for the
corresponding interface.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{nodes}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{NetDeviceContainer} \PYG{n}{devices} \PYG{o}{=} \PYG{n}{deviceHelper}\PYG{p}{.}\PYG{n}{Install} \PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ipv4AddressHelper} \PYG{n}{ipv4}\PYG{p}{;}
\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{SetBase} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.1.1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4InterfaceContainer} \PYG{n}{interfaces} \PYG{o}{=} \PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{Assign} \PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interfaces}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on a collection of protocol/interface pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} the
appropriate protocol is found. For each protocol, its interfaces are enumerated
and tracing is enabled on the resulting pairs. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable pcap tracing on the basis of node ID and interface as well. In
this case, the node\sphinxhyphen{}id is translated to a \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} and the appropriate
protocol is looked up in the node. The resulting protocol and interface are used
to specify the resulting trace source.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Finally, you can enable pcap tracing for all interfaces in the system, with
associated protocol being the same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnablePcapIpv4All} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Pcap Tracing Protocol Helper Filename Selection}
\label{\detokenize{tracing:pcap-tracing-protocol-helper-filename-selection}}
Implicit in all of the method descriptions above is the construction of the
complete filenames by the implementation method. By convention, pcap traces
taken for devices in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system are of the form \sphinxcode{\sphinxupquote{\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node
id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.pcap}}. In the case of protocol traces, there is a one\sphinxhyphen{}to\sphinxhyphen{}one
correspondence between protocols and \sphinxcode{\sphinxupquote{Nodes}}. This is because protocol
\sphinxcode{\sphinxupquote{Objects}} are aggregated to \sphinxcode{\sphinxupquote{Node Objects}}. Since there is no global
protocol id in the system, we use the corresponding node id in file naming.
Therefore there is a possibility for file name collisions in automatically
chosen trace file names. For this reason, the file name convention is changed
for protocol traces.

As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id. Since there is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence between protocol instances
and node instances we use the node id. Each interface has an interface id
relative to its protocol. We use the convention “\textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}i\textless{}interface
id\textgreater{}.pcap” for trace file naming in protocol helpers.

Therefore, by default, a pcap trace file created as a result of enabling tracing
on interface 1 of the Ipv4 protocol of node 21 using the prefix “prefix”
would be “prefix\sphinxhyphen{}n21\sphinxhyphen{}i1.pcap”.

You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.
For example, if you use the object name service to assign the name “serverIpv4”
to the Ptr\textless{}Ipv4\textgreater{} on node 21, the resulting pcap trace file name will
automatically become, “prefix\sphinxhyphen{}nserverIpv4\sphinxhyphen{}i1.pcap”.


\subsection{Ascii Tracing Protocol Helpers}
\label{\detokenize{tracing:ascii-tracing-protocol-helpers}}
The behavior of the ASCII trace helpers is substantially similar to the pcap
case.  Take a look at \sphinxcode{\sphinxupquote{src/network/helper/trace\sphinxhyphen{}helper.h}} if you want to follow the
discussion while looking at real code.

In this section we will be illustrating the methods as applied to the protocol
\sphinxcode{\sphinxupquote{Ipv4}}. To specify traces in similar protocols, just substitute the
appropriate type. For example, use a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv6\textgreater{}}} instead of a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}}
and call \sphinxcode{\sphinxupquote{EnableAsciiIpv6}} instead of \sphinxcode{\sphinxupquote{EnableAsciiIpv4}}.

The class \sphinxcode{\sphinxupquote{AsciiTraceHelperForIpv4}} adds the high level functionality for
using ASCII tracing to a protocol helper. Each protocol that enables these
methods must implement a single virtual method inherited from this class.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4Internal} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,}
                                      \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The signature of this method reflects the protocol\sphinxhyphen{} and interface\sphinxhyphen{}centric view
of the situation at this level; and also the fact that the helper may be writing
to a shared output stream.  All of the public methods inherited from class
\sphinxcode{\sphinxupquote{PcapAndAsciiTraceHelperForIpv4}} reduce to calling this single device\sphinxhyphen{}
dependent implementation method. For example, the lowest level ascii trace
methods,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will call the device implementation of \sphinxcode{\sphinxupquote{EnableAsciiIpv4Internal}} directly,
providing either the prefix or the stream. All other public ascii tracing
methods will build on these low\sphinxhyphen{}level functions to provide additional user\sphinxhyphen{}level
functionality. What this means to the user is that all device helpers in the
system will have all of the ascii trace methods available; and these methods
will all work in the same way across protocols if the protocols implement
\sphinxcode{\sphinxupquote{EnablAsciiIpv4Internal}} correctly.


\subsubsection{Ascii Tracing Device Helper Methods}
\label{\detokenize{tracing:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ipv4Name}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{ipv4Name}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{Ipv4InterfaceContainer} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{Ipv4InterfaceContainer} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{nodeid}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{deviceid}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{nodeid}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4All} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{prefix}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{EnableAsciiIpv4All} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You are encouraged to peruse the Doxygen for class \sphinxcode{\sphinxupquote{PcapAndAsciiHelperForIpv4}}
to find the details of these methods; but to summarize …

There are twice as many methods available for ASCII tracing as there were for
pcap tracing. This is because, in addition to the pcap\sphinxhyphen{}style model where traces
from each unique protocol/interface pair are written to a unique file, we
support a model in which trace information for many protocol/interface pairs is
written to a common file. This means that the \textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}interface\textgreater{}
file name generation mechanism is replaced by a mechanism to refer to a common
file; and the number of API methods is doubled to allow all combinations.

Just as in pcap tracing, you can enable ASCII tracing on a particular
protocol/interface pair by providing a \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} and an \sphinxcode{\sphinxupquote{interface}} to an
\sphinxcode{\sphinxupquote{EnableAscii}} method.  For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ipv4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this case, no trace contexts are written to the ASCII trace file since they
would be redundant. The system will pick the file name to be created using the
same rules as described in the pcap section, except that the file will have the
suffix “.tr” instead of “.pcap”.

If you want to enable ASCII tracing on more than one interface and have all
traces sent to a single file, you can do that as well by using an object to
refer to a single file. We have already something similar to this in the “cwnd”
example above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{protocol1} \PYG{o}{=} \PYG{n}{node1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{protocol2} \PYG{o}{=} \PYG{n}{node2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream} \PYG{o}{=} \PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{protocol1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{protocol2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this case, trace contexts are written to the ASCII trace file since they are
required to disambiguate traces from the two interfaces. Note that since the
user is completely specifying the file name, the string should include the “.tr”
for consistency.

You can enable ASCII tracing on a particular protocol by providing a
\sphinxcode{\sphinxupquote{std::string}} representing an object name service string to an \sphinxcode{\sphinxupquote{EnablePcap}}
method.  The \sphinxcode{\sphinxupquote{Ptr\textless{}Ipv4\textgreater{}}} is looked up from the name string.  The \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} in
the resulting filenames is implicit since there is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence
between protocol instances and nodes, For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in two files named “prefix\sphinxhyphen{}nnode1Ipv4\sphinxhyphen{}i1.tr” and
“prefix\sphinxhyphen{}nnode2Ipv4\sphinxhyphen{}i1.tr” with traces for each interface in the respective
trace file. Since all of the EnableAscii functions are overloaded to take a
stream wrapper, you can use that form as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream} \PYG{o}{=} \PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node1Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node2Ipv4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a single trace file called “trace\sphinxhyphen{}file\sphinxhyphen{}name.tr” that
contains all of the trace events for both interfaces. The events would be
disambiguated by trace context strings.

You can enable ASCII tracing on a collection of protocol/interface pairs by
providing an \sphinxcode{\sphinxupquote{Ipv4InterfaceContainer}}. For each protocol of the proper type
(the same type as is managed by the device helper), tracing is enabled for the
corresponding interface.  Again, the \sphinxcode{\sphinxupquote{\textless{}Node\textgreater{}}} is implicit since there is a
one\sphinxhyphen{}to\sphinxhyphen{}one correspondence between each protocol and its node. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{nodes}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{NetDeviceContainer} \PYG{n}{devices} \PYG{o}{=} \PYG{n}{deviceHelper}\PYG{p}{.}\PYG{n}{Install} \PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ipv4AddressHelper} \PYG{n}{ipv4}\PYG{p}{;}
\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{SetBase} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.1.1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4InterfaceContainer} \PYG{n}{interfaces} \PYG{o}{=} \PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{Assign} \PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interfaces}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}i\textless{}interface\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{nodes}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{NetDeviceContainer} \PYG{n}{devices} \PYG{o}{=} \PYG{n}{deviceHelper}\PYG{p}{.}\PYG{n}{Install} \PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ipv4AddressHelper} \PYG{n}{ipv4}\PYG{p}{;}
\PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{SetBase} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.1.1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4InterfaceContainer} \PYG{n}{interfaces} \PYG{o}{=} \PYG{n}{ipv4}\PYG{p}{.}\PYG{n}{Assign} \PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{OutputStreamWrapper}\PYG{o}{\PYGZgt{}} \PYG{n}{stream} \PYG{o}{=} \PYG{n}{asciiTraceHelper}\PYG{p}{.}\PYG{n}{CreateFileStream} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{trace\PYGZhy{}file\PYGZhy{}name.tr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{interfaces}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can enable ASCII tracing on a collection of protocol/interface pairs by
providing a \sphinxcode{\sphinxupquote{NodeContainer}}. For each \sphinxcode{\sphinxupquote{Node}} in the \sphinxcode{\sphinxupquote{NodeContainer}} the
appropriate protocol is found.  For each protocol, its interfaces are enumerated
and tracing is enabled on the resulting pairs. For example,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{n}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a number of ASCII trace files being created, each of which
follows the \textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr convention. Combining all of the
traces into a single file is accomplished similarly to the examples above:

You can enable pcap tracing on the basis of node ID and device ID as well. In
this case, the node\sphinxhyphen{}id is translated to a \sphinxcode{\sphinxupquote{Ptr\textless{}Node\textgreater{}}} and the appropriate
protocol is looked up in the node.  The resulting protocol and interface are
used to specify the resulting trace source.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Of course, the traces can be combined into a single file as shown above.

Finally, you can enable ASCII tracing for all interfaces in the system, with
associated protocol being the same type as that managed by the device helper.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{helper}\PYG{p}{.}\PYG{n}{EnableAsciiIpv4All} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{prefix}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This would result in a number of ASCII trace files being created, one for
every interface in the system related to a protocol of the type managed by the
helper. All of these files will follow the \textless{}prefix\textgreater{}\sphinxhyphen{}n\textless{}node id\textgreater{}\sphinxhyphen{}i\textless{}interface.tr
convention. Combining all of the traces into a single file is accomplished
similarly to the examples above.


\subsubsection{Ascii Tracing Device Helper Filename Selection}
\label{\detokenize{tracing:id2}}
Implicit in the prefix\sphinxhyphen{}style method descriptions above is the construction of
the complete filenames by the implementation method. By convention, ASCII traces
in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system are of the form “\textless{}prefix\textgreater{}\sphinxhyphen{}\textless{}node id\textgreater{}\sphinxhyphen{}\textless{}device id\textgreater{}.tr.”

As previously mentioned, every node in the system will have a system\sphinxhyphen{}assigned
node id. Since there is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence between protocols and nodes
we use to node\sphinxhyphen{}id to identify the protocol identity. Every interface on a given
protocol will have an interface index (also called simply an interface) relative
to its protocol. By default, then, an ASCII trace file created as a result of
enabling tracing on the first device of node 21, using the prefix “prefix”,
would be “prefix\sphinxhyphen{}n21\sphinxhyphen{}i1.tr”. Use the prefix to disambiguate multiple protocols
per node.

You can always use the \sphinxstyleemphasis{ns\sphinxhyphen{}3} object name service to make this more clear.
For example, if you use the object name service to assign the name “serverIpv4”
to the protocol on node 21, and also specify interface one, the resulting ASCII
trace file name will automatically become, “prefix\sphinxhyphen{}nserverIpv4\sphinxhyphen{}1.tr”.


\section{Tracing implementation details}
\label{\detokenize{tracing:tracing-implementation-details}}

\chapter{Data Collection}
\label{\detokenize{data-collection:data-collection}}\label{\detokenize{data-collection::doc}}
This chapter describes the ns\sphinxhyphen{}3 Data Collection Framework (DCF), which
provides capabilities to obtain data generated by models in the simulator,
to perform on\sphinxhyphen{}line reduction and data processing, and to marshal raw
or transformed data into various output formats.

The framework presently supports standalone ns\sphinxhyphen{}3 runs that don’t rely on
any external program execution control.  The objects provided by the
DCF may be hooked to \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources to enable data processing.

The source code for the classes lives in the directory \sphinxcode{\sphinxupquote{src/stats}}.

This chapter is organized as follows.  First, an overview of the architecture
is presented.  Next, the helpers for these classes are presented; this
initial treatment should allow basic use of the data collection framework
for many use cases.  Users who wish to produce output outside of the
scope of the current helpers, or who wish to create their own data
collection objects, should read the remainder of the chapter, which
goes into detail about all of the basic DCF object types and provides
low\sphinxhyphen{}level coding examples.


\section{Design}
\label{\detokenize{data-collection-overview:design}}\label{\detokenize{data-collection-overview::doc}}
The DCF consists of three basic classes:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Probe} is a mechanism to instrument and control the output of
simulation data that is used to monitor interesting events. It
produces output in the form of one or more \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources.
Probe objects are hooked up to one or more trace \sphinxstyleemphasis{sinks} (called
\sphinxstyleemphasis{Collectors}), which process samples on\sphinxhyphen{}line and prepare them for
output.

\item {} 
\sphinxstyleemphasis{Collector} consumes the data generated by one or more Probe objects.
It performs transformations on the data, such as normalization, reduction, and
the computation of basic statistics. Collector objects do not produce
data that is directly output by the ns\sphinxhyphen{}3 run; instead, they output data
downstream to another type of object, called \sphinxstyleemphasis{Aggregator}, which performs
that function.  Typically, Collectors output their data in the form of
trace sources as well, allowing collectors to be chained in series.

\item {} 
\sphinxstyleemphasis{Aggregator} is the end point of the data collected by a network of Probes and Collectors.
The main responsibility of the Aggregator is to marshal data and their
corresponding metadata, into different output
formats such as plain text files, spreadsheet files, or databases.

\end{itemize}

All three of these classes provide the capability to dynamically turn themselves on or off throughout a simulation.

Any standalone \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation run that uses the DCF will typically create
at least one instance of each of the three classes above.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{dcf-overview}.pdf}
\caption{Data Collection Framework overview}\label{\detokenize{data-collection-overview:id1}}\label{\detokenize{data-collection-overview:dcf-overview}}\end{figure}

The overall flow of data processing is depicted in {\hyperref[\detokenize{data-collection-overview:dcf-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Collection Framework overview}}}}.  On
the left side, a running \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation is depicted.  In the course
of running the simulation, data is made available by models through
trace sources, or via other means.  The diagram depicts that probes
can be connected to these trace sources to receive data asynchronously,
or probes can poll for data.  Data is then passed to a collector object
that transforms the data.  Finally, an aggregator can be connected
to the outputs of the collector, to generate plots, files, or databases.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{dcf-overview-with-aggregation}.pdf}
\caption{Data Collection Framework aggregation}\label{\detokenize{data-collection-overview:id2}}\label{\detokenize{data-collection-overview:dcf-overview-with-aggregation}}\end{figure}

A variation on the above figure is provided
in {\hyperref[\detokenize{data-collection-overview:dcf-overview-with-aggregation}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Collection Framework aggregation}}}}.
This second figure illustrates that the DCF objects may be chained
together in a manner that downstream objects take inputs from multiple
upstream objects.  The figure conceptually shows that multiple probes
may generate output that is fed into a single collector; as an example,
a collector that outputs a ratio of two counters would typically acquire
each counter data from separate probes.  Multiple collectors can also
feed into a single aggregator, which (as its name implies) may collect
a number of data streams for inclusion into a single plot, file, or
database.


\section{Data Collection Helpers}
\label{\detokenize{data-collection-helpers:data-collection-helpers}}\label{\detokenize{data-collection-helpers::doc}}
The full flexibility of the data collection framework is provided by
the interconnection of probes, collectors, and aggregators.  Performing
all of these interconnections leads to many configuration statements
in user programs.  For ease of use, some of the most common operations
can be combined and encapsulated in helper functions.  In addition,
some statements involving \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources do not have Python
bindings, due to limitations in the bindings.


\subsection{Data Collection Helpers Overview}
\label{\detokenize{data-collection-helpers:data-collection-helpers-overview}}
In this section, we provide an overview of some helper classes that
have been created to ease the configuration of the data collection
framework for some common use cases.  The helpers allow users to form
common operations with only a few statements in their C++ or Python
programs.  But, this ease of use comes at the cost of significantly
less flexibility than low\sphinxhyphen{}level configuration can provide, and the
need to explicitly code support for new Probe types into the helpers
(to work around an issue described below).

The emphasis on the current helpers is to marshal data out of \sphinxstyleemphasis{ns\sphinxhyphen{}3}
trace sources into gnuplot plots or text files, without a high degree
of output customization or statistical processing (initially).  Also,
the use is constrained to the available probe types in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  Later
sections of this documentation will go into more detail about creating
new Probe types, as well as details about hooking together Probes,
Collectors, and Aggregators in custom arrangements.

To date, two Data Collection helpers have been implemented:
\begin{itemize}
\item {} 
GnuplotHelper

\item {} 
FileHelper

\end{itemize}


\subsection{GnuplotHelper}
\label{\detokenize{data-collection-helpers:gnuplothelper}}
The GnuplotHelper is a helper class for producing output files used to
make gnuplots.  The overall goal is to provide the ability for users
to quickly make plots from data exported in \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources.  By
default, a minimal amount of data transformation is performed; the
objective is to generate plots with as few (default) configuration
statements as possible.


\subsubsection{GnuplotHelper Overview}
\label{\detokenize{data-collection-helpers:gnuplothelper-overview}}
The GnuplotHelper will create 3 different files at the end of the
simulation:
\begin{itemize}
\item {} 
A space separated gnuplot data file

\item {} 
A gnuplot control file

\item {} 
A shell script to generate the gnuplot

\end{itemize}

There are two configuration statements that are needed to produce plots.
The first statement configures the plot (filename, title, legends, and
output type, where the output type defaults to PNG if unspecified):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{ConfigurePlot} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{outputFileNameWithoutExtension}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{xLegend}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{yLegend}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{terminalType} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The second statement hooks the trace source of interest:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{PlotProbe} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{typeId}\PYG{p}{,}
                \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{path}\PYG{p}{,}
                \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{probeTraceSource}\PYG{p}{,}
                \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The arguments are as follows:
\begin{itemize}
\item {} 
typeId:  The \sphinxstyleemphasis{ns\sphinxhyphen{}3} TypeId of the Probe

\item {} 
path:  The path in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration namespace to one or more trace sources

\item {} 
probeTraceSource:  Which output of the probe (itself a trace source) should be plotted

\item {} 
title:  The title to associate with the dataset(s) (in the gnuplot legend)

\end{itemize}

A variant on the PlotProbe above is to specify a fifth optional argument
that controls where in the plot the key (legend) is placed.

A fully worked example (from \sphinxcode{\sphinxupquote{seventh.cc}}) is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the gnuplot helper.}
\PYG{n}{GnuplotHelper} \PYG{n}{plotHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the plot.}
\PYG{c+c1}{// Configure the plot.  The first argument is the file name prefix}
\PYG{c+c1}{// for the output files generated.  The second, third, and fourth}
\PYG{c+c1}{// arguments are, respectively, the plot title, x\PYGZhy{}axis, and y\PYGZhy{}axis labels}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{ConfigurePlot} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count vs. Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Specify the probe type, trace source path (in configuration namespace), and}
\PYG{c+c1}{// probe output trace source (\PYGZdq{}OutputBytes\PYGZdq{}) to plot.  The fourth argument}
\PYG{c+c1}{// specifies the name of the data series label on the plot.  The last}
\PYG{c+c1}{// argument formats the plot by specifying where the key should be placed.}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{PlotProbe} \PYG{p}{(}\PYG{n}{probeType}\PYG{p}{,}
                      \PYG{n}{tracePath}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}BELOW}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this example, the \sphinxcode{\sphinxupquote{probeType}} and \sphinxcode{\sphinxupquote{tracePath}} are as follows (for IPv4):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{probeType} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{tracePath} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

The probeType is a key parameter for this helper to work.  This TypeId
must be registered in the system, and the signature on the Probe’s trace
sink must match that of the trace source it is being hooked to.  Probe
types are pre\sphinxhyphen{}defined for a number of data types corresponding to \sphinxstyleemphasis{ns\sphinxhyphen{}3}
traced values, and for a few other trace source signatures such as the
‘Tx’ trace source of \sphinxcode{\sphinxupquote{ns3::Ipv4L3Protocol}} class.

Note that the trace source path specified may contain wildcards.
In this case, multiple
datasets are plotted on one plot; one for each matched path.

The main output produced will be three files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{seventh}\PYG{o}{\PYGZhy{}}\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{n}{byte}\PYG{o}{\PYGZhy{}}\PYG{n}{count}\PYG{p}{.}\PYG{n}{dat}
\PYG{n}{seventh}\PYG{o}{\PYGZhy{}}\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{n}{byte}\PYG{o}{\PYGZhy{}}\PYG{n}{count}\PYG{p}{.}\PYG{n}{plt}
\PYG{n}{seventh}\PYG{o}{\PYGZhy{}}\PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{n}{byte}\PYG{o}{\PYGZhy{}}\PYG{n}{count}\PYG{p}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

At this point, users can either hand edit the .plt file for further
customizations, or just run it through gnuplot.  Running
\sphinxtitleref{sh seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count.sh} simply runs the plot through gnuplot,
as shown below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{seventh-packet-byte-count}.png}
\caption{2\sphinxhyphen{}D Gnuplot Created by seventh.cc Example.}\label{\detokenize{data-collection-helpers:id3}}\label{\detokenize{data-collection-helpers:seventh-packet-byte-count}}\end{figure}

It can be seen that the key elements (legend, title, legend placement,
xlabel, ylabel, and path for the data) are all placed on the plot.
Since there were two matches to the configuration path provided, the
two data series are shown:
\begin{itemize}
\item {} 
Packet Byte Count\sphinxhyphen{}0 corresponds to /NodeList/0/\$ns3::Ipv4L3Protocol/Tx

\item {} 
Packet Byte Count\sphinxhyphen{}1 corresponds to /NodeList/1/\$ns3::Ipv4L3Protocol/Tx

\end{itemize}


\subsubsection{GnuplotHelper ConfigurePlot}
\label{\detokenize{data-collection-helpers:gnuplothelper-configureplot}}
The GnuplotHelper’s \sphinxcode{\sphinxupquote{ConfigurePlot()}} function can be used
to configure plots.

It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{ConfigurePlot} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{outputFileNameWithoutExtension}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{xLegend}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{yLegend}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{terminalType} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Argument
&\sphinxstyletheadfamily 
Description
\\
\hline
outputFileNameWithoutExtension
&
Name of gnuplot related files
to write with no extension.
\\
\hline
title
&
Plot title string to use for
this plot.
\\
\hline
xLegend
&
The legend for the x
horizontal axis.
\\
\hline
yLegend
&
The legend for the y
vertical axis.
\\
\hline
terminalType
&
Terminal type setting string
for output.  The default
terminal type is “png”.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The GnuplotHelper’s \sphinxcode{\sphinxupquote{ConfigurePlot()}} function configures plot
related parameters for this gnuplot helper so
that it will create a space separated gnuplot data file named
outputFileNameWithoutExtension + “.dat”, a gnuplot control file
named outputFileNameWithoutExtension + “.plt”, and a shell script
to generate the gnuplot named outputFileNameWithoutExtension +
“.sh”.

An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{ConfigurePlot} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count vs. Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{GnuplotHelper PlotProbe}
\label{\detokenize{data-collection-helpers:gnuplothelper-plotprobe}}
The GnuplotHelper’s \sphinxcode{\sphinxupquote{PlotProbe()}} function can be used
to plot values generated by probes.

It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{PlotProbe} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{typeId}\PYG{p}{,}
                \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{path}\PYG{p}{,}
                \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{probeTraceSource}\PYG{p}{,}
                \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{title}\PYG{p}{,}
                \PYG{k}{enum} \PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KeyLocation} \PYG{n}{keyLocation} \PYG{o}{=} \PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}INSIDE}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Argument
&\sphinxstyletheadfamily 
Description
\\
\hline
typeId
&
The type ID for the probe
created by this helper.
\\
\hline
path
&
Config path to access the
trace source.
\\
\hline
probeTraceSource
&
The probe trace source to
access.
\\
\hline
title
&
The title to be associated
to this dataset
\\
\hline
keyLocation
&
The location of the key in
the plot.  The default
location is inside.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The GnuplotHelper’s \sphinxcode{\sphinxupquote{PlotProbe()}} function
plots a dataset generated by hooking the \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source with a
probe created by the helper, and then plotting the values from the
probeTraceSource.
The dataset will have the provided title, and will consist of
the ‘newValue’ at each timestamp.

If the config path has more than one match in the system because
there is a wildcard, then one dataset for each match will
be plotted.  The dataset titles will be suffixed with the matched
characters for each of the wildcards in the config path,
separated by spaces.  For example, if the proposed dataset title
is the string “bytes”, and there are two wildcards in the path,
then dataset titles like “bytes\sphinxhyphen{}0 0” or “bytes\sphinxhyphen{}12 9” will be
possible as labels for the datasets that are plotted.

An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used (with
variable substitution) as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{PlotProbe} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Packet Byte Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}BELOW}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Other Examples}
\label{\detokenize{data-collection-helpers:other-examples}}

\paragraph{Gnuplot Helper Example}
\label{\detokenize{data-collection-helpers:gnuplot-helper-example}}
A slightly simpler example than the \sphinxcode{\sphinxupquote{seventh.cc}} example can be
found in \sphinxcode{\sphinxupquote{src/stats/examples/gnuplot\sphinxhyphen{}helper\sphinxhyphen{}example.cc}}.  The
following 2\sphinxhyphen{}D gnuplot was created using the example.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gnuplot-helper-example}.png}
\caption{2\sphinxhyphen{}D Gnuplot Created by gnuplot\sphinxhyphen{}helper\sphinxhyphen{}example.cc Example.}\label{\detokenize{data-collection-helpers:id4}}\label{\detokenize{data-collection-helpers:id1}}\end{figure}

In this example, there is an Emitter object that increments
its counter according to a Poisson process and then emits the counter’s
value as a trace source.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{n}{emitter} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that because there are no wildcards in the path
used below, only 1 datastream was drawn in the plot.
This single datastream in the plot is simply labeled
“Emitter Count”, with no extra suffixes like one would
see if there were wildcards in the path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the gnuplot helper.}
\PYG{n}{GnuplotHelper} \PYG{n}{plotHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the plot.}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{ConfigurePlot} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gnuplot\PYGZhy{}helper\PYGZhy{}example}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Emitter Counts vs. Time}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Emitter Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot the values generated by the probe.  The path that we provide}
\PYG{c+c1}{// helps to disambiguate the source of the trace.}
\PYG{n}{plotHelper}\PYG{p}{.}\PYG{n}{PlotProbe} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Uinteger32Probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Emitter Count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}INSIDE}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{FileHelper}
\label{\detokenize{data-collection-helpers:filehelper}}
The FileHelper is a helper class used to put data values into a file.
The overall goal is to provide the ability for users
to quickly make formatted text files from data exported in \sphinxstyleemphasis{ns\sphinxhyphen{}3}
trace sources.  By default, a minimal amount of data transformation is
performed; the objective is to generate files with as few (default)
configuration statements as possible.


\subsubsection{FileHelper Overview}
\label{\detokenize{data-collection-helpers:filehelper-overview}}
The FileHelper will create 1 or more text files at the end of the
simulation.

The FileHelper can create 4 different types of text files:
\begin{itemize}
\item {} 
Formatted

\item {} 
Space separated (the default)

\item {} 
Comma separated

\item {} 
Tab separated

\end{itemize}

Formatted files use C\sphinxhyphen{}style format strings and the sprintf() function
to print their values in the file being written.

The following text file with 2 columns of formatted values named
\sphinxcode{\sphinxupquote{seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}0.txt}} was created using more new
code that was added to the original \sphinxstyleemphasis{ns\sphinxhyphen{}3} Tutorial example’s code.
Only the first 10 lines of this file are shown here for brevity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time (Seconds) = 1.000e+00    Packet Byte Count = 40
Time (Seconds) = 1.004e+00    Packet Byte Count = 40
Time (Seconds) = 1.004e+00    Packet Byte Count = 576
Time (Seconds) = 1.009e+00    Packet Byte Count = 576
Time (Seconds) = 1.009e+00    Packet Byte Count = 576
Time (Seconds) = 1.015e+00    Packet Byte Count = 512
Time (Seconds) = 1.017e+00    Packet Byte Count = 576
Time (Seconds) = 1.017e+00    Packet Byte Count = 544
Time (Seconds) = 1.025e+00    Packet Byte Count = 576
Time (Seconds) = 1.025e+00    Packet Byte Count = 544

...
\end{sphinxVerbatim}

The following different text file with 2 columns of formatted
values named \sphinxcode{\sphinxupquote{seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}1.txt}} was also
created using the same new code that was added to the original
\sphinxstyleemphasis{ns\sphinxhyphen{}3} Tutorial example’s code.  Only the first 10 lines of this
file are shown here for brevity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time (Seconds) = 1.002e+00    Packet Byte Count = 40
Time (Seconds) = 1.007e+00    Packet Byte Count = 40
Time (Seconds) = 1.013e+00    Packet Byte Count = 40
Time (Seconds) = 1.020e+00    Packet Byte Count = 40
Time (Seconds) = 1.028e+00    Packet Byte Count = 40
Time (Seconds) = 1.036e+00    Packet Byte Count = 40
Time (Seconds) = 1.045e+00    Packet Byte Count = 40
Time (Seconds) = 1.053e+00    Packet Byte Count = 40
Time (Seconds) = 1.061e+00    Packet Byte Count = 40
Time (Seconds) = 1.069e+00    Packet Byte Count = 40

...
\end{sphinxVerbatim}

The new code that was added to produce the two text files is below.
More details about this API will be covered in a later section.

Note that because there were 2 matches for the wildcard in the path,
2 separate text files were created.  The first text file, which is
named “seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}0.txt”, corresponds to the
wildcard match with the “*” replaced with “0”.  The second text file,
which is named “seventh\sphinxhyphen{}packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}1.txt”, corresponds to
the wildcard match with the “*” replaced with “1”.  Also, note that
the function call to \sphinxcode{\sphinxupquote{WriteProbe()}} will give an error message if
there are no matches for a path that contains wildcards.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the file helper.}
\PYG{n}{FileHelper} \PYG{n}{fileHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the file to be written.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{ConfigureFile} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for this formatted output file.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{Set2dFormat} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds) = \PYGZpc{}.3e}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Packet Byte Count = \PYGZpc{}.0f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the values generated by the probe.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{WriteProbe} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{FileHelper ConfigureFile}
\label{\detokenize{data-collection-helpers:filehelper-configurefile}}
The FileHelper’s \sphinxcode{\sphinxupquote{ConfigureFile()}} function can be used
to configure text files.

It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{ConfigureFile} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{outputFileNameWithoutExtension}\PYG{p}{,}
                    \PYG{k}{enum} \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FileType} \PYG{n}{fileType} \PYG{o}{=} \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SPACE\PYGZus{}SEPARATED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Argument
&\sphinxstyletheadfamily 
Description
\\
\hline
outputFileNameWithoutExtension
&
Name of output file to write
with no extension.
\\
\hline
fileType
&
Type of file to write.  The
default type of file is space
separated.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The FileHelper’s \sphinxcode{\sphinxupquote{ConfigureFile()}} function configures text file
related parameters for the file helper so that
it will create a file named outputFileNameWithoutExtension plus
possible extra information from wildcard matches plus “.txt” with
values printed as specified by fileType.  The default file type
is space\sphinxhyphen{}separated.

An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{ConfigureFile} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{seventh\PYGZhy{}packet\PYGZhy{}byte\PYGZhy{}count}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{FileHelper WriteProbe}
\label{\detokenize{data-collection-helpers:filehelper-writeprobe}}
The FileHelper’s \sphinxcode{\sphinxupquote{WriteProbe()}} function can be used
to write values generated by probes to text files.

It has the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{WriteProbe} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{typeId}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{path}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{probeTraceSource}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It has the following arguments:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Argument
&\sphinxstyletheadfamily 
Description
\\
\hline
typeId
&
The type ID for the probe
to be created.
\\
\hline
path
&
Config path to access the
trace source.
\\
\hline
probeTraceSource
&
The probe trace source to
access.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

The FileHelper’s \sphinxcode{\sphinxupquote{WriteProbe()}} function
creates output text files generated by hooking the ns\sphinxhyphen{}3 trace source
with a probe created by the helper, and then writing the values from the
probeTraceSource. The output file names will have the text stored
in the member variable  m\_outputFileNameWithoutExtension plus “.txt”,
and will consist of the ‘newValue’ at each timestamp.

If the config path has more than one match in the system because
there is a wildcard, then one output file for each match
will be created.  The output file names will contain the text in
m\_outputFileNameWithoutExtension plus the matched characters for
each of the wildcards in the config path, separated by dashes,
plus “.txt”.  For example, if the value in
m\_outputFileNameWithoutExtension is the string
“packet\sphinxhyphen{}byte\sphinxhyphen{}count”, and there are two wildcards in the path,
then output file names like “packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}0\sphinxhyphen{}0.txt” or
“packet\sphinxhyphen{}byte\sphinxhyphen{}count\sphinxhyphen{}12\sphinxhyphen{}9.txt” will be possible as names for the
files that will be created.

An example of how to use this function can be seen in the
\sphinxcode{\sphinxupquote{seventh.cc}} code described above where it was used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{WriteProbe} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/*/\PYGZdl{}ns3::Ipv4L3Protocol/Tx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Other Examples}
\label{\detokenize{data-collection-helpers:id2}}

\paragraph{File Helper Example}
\label{\detokenize{data-collection-helpers:file-helper-example}}
A slightly simpler example than the \sphinxcode{\sphinxupquote{seventh.cc}} example can be
found in \sphinxcode{\sphinxupquote{src/stats/examples/file\sphinxhyphen{}helper\sphinxhyphen{}example.cc}}.
This example only uses the FileHelper.

The following text file with 2 columns of formatted values named
\sphinxcode{\sphinxupquote{file\sphinxhyphen{}helper\sphinxhyphen{}example.txt}} was created using the example.
Only the first 10 lines of this file are shown here for brevity.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time (Seconds) = 0.203  Count = 1
Time (Seconds) = 0.702  Count = 2
Time (Seconds) = 1.404  Count = 3
Time (Seconds) = 2.368  Count = 4
Time (Seconds) = 3.364  Count = 5
Time (Seconds) = 3.579  Count = 6
Time (Seconds) = 5.873  Count = 7
Time (Seconds) = 6.410  Count = 8
Time (Seconds) = 6.472  Count = 9
...
\end{sphinxVerbatim}

In this example, there is an Emitter object that increments
its counter according to a Poisson process and then emits the counter’s
value as a trace source.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{n}{emitter} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that because there are no wildcards in the path
used below, only 1 text file was created.
This single text file is simply named
“file\sphinxhyphen{}helper\sphinxhyphen{}example.txt”, with no extra suffixes like
you would see if there were wildcards in the path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Create the file helper.}
\PYG{n}{FileHelper} \PYG{n}{fileHelper}\PYG{p}{;}

\PYG{c+c1}{// Configure the file to be written.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{ConfigureFile} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}helper\PYGZhy{}example}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                          \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for this formatted output file.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{Set2dFormat} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (Seconds) = \PYGZpc{}.3e}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Count = \PYGZpc{}.0f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the values generated by the probe.  The path that we}
\PYG{c+c1}{// provide helps to disambiguate the source of the trace.}
\PYG{n}{fileHelper}\PYG{p}{.}\PYG{n}{WriteProbe} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Uinteger32Probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Scope and Limitations}
\label{\detokenize{data-collection-helpers:scope-and-limitations}}
Currently, only these Probes have been implemented and connected
to the GnuplotHelper and to the FileHelper:
\begin{itemize}
\item {} 
BooleanProbe

\item {} 
DoubleProbe

\item {} 
Uinteger8Probe

\item {} 
Uinteger16Probe

\item {} 
Uinteger32Probe

\item {} 
TimeProbe

\item {} 
PacketProbe

\item {} 
ApplicationPacketProbe

\item {} 
Ipv4PacketProbe

\end{itemize}

These Probes, therefore, are the only TypeIds available to be used
in \sphinxcode{\sphinxupquote{PlotProbe()}} and \sphinxcode{\sphinxupquote{WriteProbe()}}.

In the next few sections, we cover each of the fundamental object
types (Probe, Collector, and Aggregator) in more detail, and show
how they can be connected together using lower\sphinxhyphen{}level API.


\section{Probes}
\label{\detokenize{probe:probes}}\label{\detokenize{probe::doc}}
This section details the functionalities provided by the Probe class
to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation, and gives examples on how to code them in a
program. This section is meant for users interested in developing
simulations with the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tools and using the Data Collection
Framework, of which the Probe class is a part, to generate data output
with their simulation’s results.


\subsection{Probe Overview}
\label{\detokenize{probe:probe-overview}}
A Probe object is supposed to be connected to a variable from the
simulation whose values throughout the experiment are relevant to the user.
The Probe will record what were values assumed by the variable throughout
the simulation and pass such data to another member of the Data Collection
Framework.  While it is out of this section’s scope to discuss what happens
after the Probe produces its output, it is sufficient to say that, by the
end of the simulation, the user will have detailed information about what
values were stored inside the variable being probed during the simulation.

Typically, a Probe is connected to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source.  In this manner,
whenever the trace source exports a new value, the Probe consumes the
value (and exports it downstream to another object via its own trace source).

The Probe can be thought of as kind of a filter on trace sources.  The
main reasons for possibly hooking to a Probe rather than directly to a
trace source are as follows:
\begin{itemize}
\item {} 
Probes may be dynamically turned on and off during the simulation
with calls to \sphinxcode{\sphinxupquote{Enable()}} and \sphinxcode{\sphinxupquote{Disable()}}.  For example, the
outputting of data may be turned off during the simulation warmup
phase.

\item {} 
Probes may perform operations on the data to extract values from more
complicated structures; for instance, outputting the packet size value
from a received ns3::Packet.

\item {} 
Probes register a name in the ns3::Config namespace (using
\sphinxcode{\sphinxupquote{Names::Add ()}}) so that other objects may refer to them.

\item {} 
Probes provide a static method that allows one to manipulate a Probe
by name, such as what is done in ns2measure \sphinxcite{probe:cic06}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Stat}\PYG{o}{:}\PYG{o}{:}\PYG{n}{put} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZus{}metric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ID}\PYG{p}{,} \PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The ns\sphinxhyphen{}3 equivalent of the above ns2measure code is, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DoubleProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetValueByPath} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/path/to/probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{Creation}
\label{\detokenize{probe:creation}}
Note that a Probe base class object can not be created because it
is an abstract base class, i.e. it has pure virtual functions that
have not been implemented.  An object of type DoubleProbe,
which is a subclass of the Probe class, will be created here to
show what needs to be done.

One declares a DoubleProbe in dynamic memory by using the smart pointer class
(Ptr\textless{}T\textgreater{}). To create a DoubleProbe in dynamic memory with smart pointers, one
just needs to call the \sphinxstyleemphasis{ns\sphinxhyphen{}3} method \sphinxcode{\sphinxupquote{CreateObject()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{myprobe} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The declaration above creates DoubleProbes using the default values for its
attributes.  There are four attributes in the DoubleProbe class; two in the
base class object DataCollectionObject, and two in the Probe base class:
\begin{itemize}
\item {} 
“Name” (DataCollectionObject), a StringValue

\item {} 
“Enabled” (DataCollectionObject), a BooleanValue

\item {} 
“Start” (Probe), a TimeValue

\item {} 
“Stop” (Probe), a TimeValue

\end{itemize}

One can set such attributes at object creation by using the following
method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{myprobe} \PYG{o}{=} \PYG{n}{CreateObjectWithAttributes}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myprobe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enabled}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{BooleanValue} \PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Start}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{TimeValue} \PYG{p}{(}\PYG{n}{Seconds} \PYG{p}{(}\PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Stop}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{TimeValue} \PYG{p}{(}\PYG{n}{Seconds} \PYG{p}{(}\PYG{l+m+mf}{1000.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Start and Stop are Time variables which determine the interval of action
of the Probe. The Probe will only output data if the current time of the
Simulation is inside of that interval.  The special time value of 0 seconds
for Stop will disable this attribute (i.e. keep the Probe on for the whole
simulation).  Enabled is a flag that turns the
Probe on or off, and must be set to true for the Probe to export data.
The Name is the object’s name in the DCF framework.


\subsubsection{Importing and exporting data}
\label{\detokenize{probe:importing-and-exporting-data}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} trace sources are strongly typed, so the mechanisms for hooking
Probes to a trace source and for exporting data belong to its
subclasses.  For instance, the default distribution of \sphinxstyleemphasis{ns\sphinxhyphen{}3} provides
a class DoubleProbe that is designed to hook to a trace source
exporting a double value.  We’ll next detail the operation of the
DoubleProbe, and then discuss how other Probe classes may be defined
by the user.


\subsection{DoubleProbe Overview}
\label{\detokenize{probe:doubleprobe-overview}}
The DoubleProbe connects to a double\sphinxhyphen{}valued \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source, and itself
exports a different double\sphinxhyphen{}valued \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source.

The following code, drawn from
\sphinxcode{\sphinxupquote{src/stats/examples/double\sphinxhyphen{}probe\sphinxhyphen{}example.cc}}, shows the basic
operations of plumbing the DoubleProbe into a simulation, where it is
probing a Counter exported by an emitter object (class Emitter).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{n}{emitter} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{probe1} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Connect the probe to the emitter\PYGZsq{}s Counter}
\PYG{k+kt}{bool} \PYG{n}{connected} \PYG{o}{=} \PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByObject} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The following code is probing the same Counter exported by the same
emitter object.  This DoubleProbe, however, is using a path in the
configuration namespace to make the connection.  Note that the emitter
registered itself in the configuration namespace after it was created;
otherwise, the ConnectByPath would not work.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{probe2} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Note, no return value is checked here}
\PYG{n}{probe2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByPath} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The next DoubleProbe shown that is shown below will have its value set using
its path in the configuration namespace.  Note that this time the
DoubleProbe registered itself in the configuration namespace after it was
created.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{probe3} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// We must add it to the config database}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Probes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetName} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{probe3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The emitter’s Count() function is now able to set the value for this DoubleProbe as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n}{Emitter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Count} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{n}{m\PYGZus{}counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
  \PYG{n}{DoubleProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetValueByPath} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m\PYGZus{}counter}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The above example shows how the code calling the Probe does not have to
have an explicit reference to the Probe, but can direct the value
setting through the Config namespace.  This is similar in functionality
to the \sphinxtitleref{Stat::Put} method introduced by ns2measure paper \sphinxcite{probe:cic06}, and allows
users to temporarily insert Probe statements like \sphinxtitleref{printf} statements within
existing \sphinxstyleemphasis{ns\sphinxhyphen{}3} models.  Note that in order to be able to use the DoubleProbe in this example like this, 2 things were necessary:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
the stats module header file was included in the example .cc file

\item {} 
the example was made dependent on the stats module in its wscript file.

\end{enumerate}

Analogous things need to be done in order to add other Probes in other places in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} code base.

The values for the DoubleProbe can also be set using the function
DoubleProbe::SetValue(), while the values for the DoubleProbe can be gotten
using the function DoubleProbe::GetValue().

The DoubleProbe exports double values in its “Output” trace source;
a downstream object can hook a trace sink (NotifyViaProbe) to this as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connected} \PYG{o}{=} \PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnect} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetName} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyViaProbe}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Other probes}
\label{\detokenize{probe:other-probes}}
Besides the DoubleProbe, the following Probes are also available:
\begin{itemize}
\item {} 
Uinteger8Probe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting an uint8\_t.

\item {} 
Uinteger16Probe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting an uint16\_t.

\item {} 
Uinteger32Probe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting an uint32\_t.

\item {} 
PacketProbe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting a packet.

\item {} 
ApplicationPacketProbe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting a packet and a socket address.

\item {} 
Ipv4PacketProbe connects to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} trace source exporting a packet, an IPv4 object, and an interface.

\end{itemize}


\subsection{Creating new Probe types}
\label{\detokenize{probe:creating-new-probe-types}}
To create a new Probe type, you need to perform the following steps:
\begin{itemize}
\item {} 
Be sure that your new Probe class is derived from the Probe base class.

\item {} 
Be sure that the pure virtual functions that your new Probe class
inherits from the Probe base class are implemented.

\item {} 
Find an existing Probe class that uses a trace source that is
closest in type to the type of trace source your Probe will be
using.

\item {} 
Copy that existing Probe class’s header file (.h) and implementation
file (.cc) to two new files with names matching your new Probe.

\item {} 
Replace the types, arguments, and variables in the copied files with
the appropriate type for your Probe.

\item {} 
Make necessary modifications to make the code compile and to make it
behave as you would like.

\end{itemize}


\subsection{Examples}
\label{\detokenize{probe:examples}}
Two examples will be discussed in detail here:
\begin{itemize}
\item {} 
Double Probe Example

\item {} 
IPv4 Packet Plot Example

\end{itemize}


\subsubsection{Double Probe Example}
\label{\detokenize{probe:double-probe-example}}
The double probe example has been discussed previously.  The example
program can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/double\sphinxhyphen{}probe\sphinxhyphen{}example.cc}}.  To
summarize what occurs in this program, there is an emitter that
exports a counter that increments according to a Poisson process.  In
particular, two ways of emitting data are shown:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
through a traced variable hooked to one Probe:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TracedValue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}counter}\PYG{p}{;}  \PYG{c+c1}{// normally this would be integer type}
\end{sphinxVerbatim}

\item {} 
through a counter whose value is posted to a second Probe, referenced by its name in the Config system:

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n}{Emitter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Count} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION} \PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}DEBUG} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counting at }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Now} \PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{GetSeconds} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{m\PYGZus{}counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
  \PYG{n}{DoubleProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetValueByPath} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m\PYGZus{}counter}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule} \PYG{p}{(}\PYG{n}{Seconds} \PYG{p}{(}\PYG{n}{m\PYGZus{}var}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetValue} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{Emitter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Count}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

Let’s look at the Probe more carefully.  Probes can receive their values
in a multiple ways:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
by the Probe accessing the trace source directly and connecting
a trace sink to it

\item {} 
by the Probe accessing the trace source through the config namespace
and connecting a trace sink to it

\item {} 
by the calling code explicitly calling the Probe’s \sphinxtitleref{SetValue()} method

\item {} 
by the calling code explicitly calling \sphinxtitleref{SetValueByPath (“/path/through/Config/namespace”, …)}

\end{enumerate}

The first two techniques are expected to be the most common.  Also in the
example, the hooking of a normal callback function is shown,
as is typically done in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  This callback function is not associated
with a Probe object.  We’ll call this case 0) below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a function to test hooking a raw function to the trace source}
\PYG{k+kt}{void}
\PYG{n+nf}{NotifyViaTraceSource} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{context}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{oldVal}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{newVal}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}DEBUG} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{context: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{context} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ old }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldVal} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ new }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{newVal}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

First, the emitter needs to be setup:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{n}{emitter} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Emitter}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// The Emitter object is not associated with an ns\PYGZhy{}3 node, so}
\PYG{c+c1}{// it won\PYGZsq{}t get started automatically, so we need to do this ourselves}
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Schedule} \PYG{p}{(}\PYG{n}{Seconds} \PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{Emitter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Start}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The various DoubleProbes interact with the emitter in the example as
shown below.

Case 0):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// The below shows typical functionality without a probe}
\PYG{c+c1}{// (connect a sink function to a trace source)}
\PYG{c+c1}{//}
\PYG{n}{connected} \PYG{o}{=} \PYG{n}{emitter}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnect} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sample context}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyViaTraceSource}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG} \PYG{p}{(}\PYG{n}{connected}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trace source not connected}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

case 1):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Probe1 will be hooked directly to the Emitter trace source object}
\PYG{c+c1}{//}

\PYG{c+c1}{// probe1 will be hooked to the Emitter trace source}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{probe1} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// the probe\PYGZsq{}s name can serve as its context in the tracing}
\PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ObjectProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Connect the probe to the emitter\PYGZsq{}s Counter}
\PYG{n}{connected} \PYG{o}{=} \PYG{n}{probe1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByObject} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{emitter}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG} \PYG{p}{(}\PYG{n}{connected}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trace source not connected to probe1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

case 2):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Probe2 will be hooked to the Emitter trace source object by}
\PYG{c+c1}{// accessing it by path name in the Config database}
\PYG{c+c1}{//}

\PYG{c+c1}{// Create another similar probe; this will hook up via a Config path}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{probe2} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{probe2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PathProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Note, no return value is checked here}
\PYG{n}{probe2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ConnectByPath} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Emitter/Counter}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

case 4) (case 3 is not shown in this example):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Probe3 will be called by the emitter directly through the}
\PYG{c+c1}{// static method SetValueByPath().}
\PYG{c+c1}{//}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{n}{probe3} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{DoubleProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{StaticallyAccessedProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// We must add it to the config database}
\PYG{n}{Names}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Probes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetName} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{probe3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

And finally, the example shows how the probes can be hooked to
generate output:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// The probe itself should generate output.  The context that we provide}
\PYG{c+c1}{// to this probe (in this case, the probe name) will help to disambiguate}
\PYG{c+c1}{// the source of the trace}
\PYG{n}{connected} \PYG{o}{=} \PYG{n}{probe3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{TraceConnect} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                                  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Names/Probes/StaticallyAccessedProbe/Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                                  \PYG{n}{MakeCallback} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{NotifyViaProbe}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NS\PYGZus{}ASSERT\PYGZus{}MSG} \PYG{p}{(}\PYG{n}{connected}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Trace source not .. connected to probe3 Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

The following callback is hooked to the Probe in this example for
illustrative purposes; normally, the Probe would be hooked to a
Collector object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a function to test hooking it to the probe output}
\PYG{k+kt}{void}
\PYG{n+nf}{NotifyViaProbe} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{context}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{oldVal}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{newVal}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}DEBUG} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{context: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{context} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ old }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{oldVal} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ new }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{newVal}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{IPv4 Packet Plot Example}
\label{\detokenize{probe:ipv4-packet-plot-example}}
The IPv4 packet plot example is based on the fifth.cc example from the \sphinxstyleemphasis{ns\sphinxhyphen{}3}
Tutorial.  It can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/ipv4\sphinxhyphen{}packet\sphinxhyphen{}plot\sphinxhyphen{}example.cc}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      node 0                 node 1
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|    ns\PYGZhy{}3 TCP    |    |    ns\PYGZhy{}3 TCP    |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
|    10.1.1.1    |    |    10.1.1.2    |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
| point\PYGZhy{}to\PYGZhy{}point |    | point\PYGZhy{}to\PYGZhy{}point |
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
        |                     |
        +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{sphinxVerbatim}

We’ll just look at the Probe, as it illustrates that Probes may also
unpack values from structures (in this case, packets) and report
those values as trace source outputs, rather than just passing through
the same type of data.

There are other aspects of this example that will be explained later in
the documentation.  The two types of data that are exported are the packet
itself (\sphinxtitleref{Output}) and a count of the number of bytes in the packet
(\sphinxtitleref{OutputBytes}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId}
\PYG{n}{Ipv4PacketProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::Ipv4PacketProbe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Probe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4PacketProbe}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddTraceSource} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Output}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The packet plus its IPv4 object and interface that serve as the output for this probe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{n}{MakeTraceSourceAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Ipv4PacketProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}output}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddTraceSource} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OutputBytes}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The number of bytes in the packet}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                      \PYG{n}{MakeTraceSourceAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{Ipv4PacketProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}outputBytes}\PYG{p}{)}\PYG{p}{)}
  \PYG{p}{;}
  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

When the Probe’s trace sink gets a packet, if the Probe is enabled, then
it will output the packet on its \sphinxtitleref{Output} trace source, but it will also
output the number of bytes on the \sphinxtitleref{OutputBytes} trace source.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n}{Ipv4PacketProbe}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TraceSink} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{packet}\PYG{p}{,} \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Ipv4}\PYG{o}{\PYGZgt{}} \PYG{n}{ipv4}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{interface}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION} \PYG{p}{(}\PYG{k}{this} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{packet} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipv4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{IsEnabled} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{m\PYGZus{}packet}    \PYG{o}{=} \PYG{n}{packet}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}ipv4}      \PYG{o}{=} \PYG{n}{ipv4}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}interface} \PYG{o}{=} \PYG{n}{interface}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}output} \PYG{p}{(}\PYG{n}{packet}\PYG{p}{,} \PYG{n}{ipv4}\PYG{p}{,} \PYG{n}{interface}\PYG{p}{)}\PYG{p}{;}

      \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{packetSizeNew} \PYG{o}{=} \PYG{n}{packet}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetSize} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}outputBytes} \PYG{p}{(}\PYG{n}{m\PYGZus{}packetSizeOld}\PYG{p}{,} \PYG{n}{packetSizeNew}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}packetSizeOld} \PYG{o}{=} \PYG{n}{packetSizeNew}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{References}
\label{\detokenize{probe:references}}

\section{Collectors}
\label{\detokenize{collector:collectors}}\label{\detokenize{collector::doc}}
This section is a placeholder to detail the functionalities provided by
the Collector
class to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation, and gives examples on how to code them
in a program.

\sphinxstylestrong{Note:} As of ns\sphinxhyphen{}3.18, Collectors are still under development and
not yet provided as part of the framework.


\section{Aggregators}
\label{\detokenize{aggregator:aggregators}}\label{\detokenize{aggregator::doc}}
This section details the functionalities provided by the Aggregator
class to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation. This section is meant for users
interested in developing simulations with the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tools and using
the Data Collection Framework, of which the Aggregator class is a
part, to generate data output with their simulation’s results.


\subsection{Aggregator Overview}
\label{\detokenize{aggregator:aggregator-overview}}
An Aggregator object is supposed to be hooked to one or more trace
sources in order to receive input. Aggregators are the end point of
the data collected by the network of Probes and Collectors during the
simulation.  It is the Aggregator’s job to take these values and
transform them into their final output format such as plain text
files, spreadsheet files, plots, or databases.

Typically, an aggregator is connected to one or more Collectors.  In
this manner, whenever the Collectors’ trace sources export new values,
the Aggregator can process the value so that it can be used in the
final output format where the data values will reside after the
simulation.

Note the following about Aggregators:
\begin{itemize}
\item {} 
Aggregators may be dynamically turned on and off during the
simulation with calls to \sphinxcode{\sphinxupquote{Enable()}} and \sphinxcode{\sphinxupquote{Disable()}}.  For
example, the aggregating of data may be turned off during the
simulation warmup phase, which means those values won’t be included
in the final output medium.

\item {} 
Aggregators receive data from Collectors via callbacks. When a
Collector is associated to an aggregator, a call to TraceConnect is
made to establish the Aggregator’s trace sink method as a callback.

\end{itemize}

To date, two Aggregators have been implemented:
\begin{itemize}
\item {} 
GnuplotAggregator

\item {} 
FileAggregator

\end{itemize}


\subsection{GnuplotAggregator}
\label{\detokenize{aggregator:gnuplotaggregator}}
The GnuplotAggregator produces output files used to make gnuplots.

The GnuplotAggregator will create 3 different files at the end of the
simulation:
\begin{itemize}
\item {} 
A space separated gnuplot data file

\item {} 
A gnuplot control file

\item {} 
A shell script to generate the gnuplot

\end{itemize}


\subsubsection{Creation}
\label{\detokenize{aggregator:creation}}
An object of type GnuplotAggregator will be created here to show what needs
to be done.

One declares a GnuplotAggregator in dynamic memory by using the smart
pointer class (Ptr\textless{}T\textgreater{}). To create a GnuplotAggregator in dynamic
memory with smart pointers, one just needs to call the \sphinxstyleemphasis{ns\sphinxhyphen{}3} method
\sphinxcode{\sphinxupquote{CreateObject()}}.  The following code from
\sphinxcode{\sphinxupquote{src/stats/examples/gnuplot\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}} shows
how to do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{fileNameWithoutExtension} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gnuplot\PYGZhy{}aggregator}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Create an aggregator.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}} \PYG{n}{aggregator} \PYG{o}{=}
  \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{fileNameWithoutExtension}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first argument for the constructor, fileNameWithoutExtension, is
the name of the gnuplot related files to write with no extension.
This GnuplotAggregator will create a space separated gnuplot data file
named “gnuplot\sphinxhyphen{}aggregator.dat”, a gnuplot control file named
“gnuplot\sphinxhyphen{}aggregator.plt”, and a shell script to generate the gnuplot
named + “gnuplot\sphinxhyphen{}aggregator.sh”.

The gnuplot that is created can have its key in 4 different locations:
\begin{itemize}
\item {} 
No key

\item {} 
Key inside the plot (the default)

\item {} 
Key above the plot

\item {} 
Key below the plot

\end{itemize}

The following gnuplot key location enum values are allowed to specify the key’s position:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{KeyLocation} \PYG{p}{\PYGZob{}}
  \PYG{n}{NO\PYGZus{}KEY}\PYG{p}{,}
  \PYG{n}{KEY\PYGZus{}INSIDE}\PYG{p}{,}
  \PYG{n}{KEY\PYGZus{}ABOVE}\PYG{p}{,}
  \PYG{n}{KEY\PYGZus{}BELOW}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

If it was desired to have the key below rather than the default position of inside, then you could do the following.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetKeyLocation}\PYG{p}{(}\PYG{n}{GnuplotAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{KEY\PYGZus{}BELOW}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Examples}
\label{\detokenize{aggregator:examples}}
One example will be discussed in detail here:
\begin{itemize}
\item {} 
Gnuplot Aggregator Example

\end{itemize}


\paragraph{Gnuplot Aggregator Example}
\label{\detokenize{aggregator:gnuplot-aggregator-example}}
An example that exercises the GnuplotAggregator can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/gnuplot\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}}.

The following 2\sphinxhyphen{}D gnuplot was created using the example.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gnuplot-aggregator}.png}
\caption{2\sphinxhyphen{}D Gnuplot Created by gnuplot\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc Example.}\label{\detokenize{aggregator:id3}}\label{\detokenize{aggregator:gnuplot-aggregator}}\end{figure}

This code from the example shows how to construct the
GnuplotAggregator as was discussed above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{Create2dPlot} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

  \PYG{n}{string} \PYG{n}{fileNameWithoutExtension} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gnuplot\PYGZhy{}aggregator}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{plotTitle}                \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Gnuplot Aggregator Plot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{plotXAxisHeading}         \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time (seconds)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{plotYAxisHeading}         \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Double Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{plotDatasetLabel}         \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Data Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{datasetContext}           \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dataset/Context/String}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

  \PYG{c+c1}{// Create an aggregator.}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}} \PYG{n}{aggregator} \PYG{o}{=}
    \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{GnuplotAggregator}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{fileNameWithoutExtension}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Various GnuplotAggregator attributes are set including the 2\sphinxhyphen{}D dataset
that will be plotted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Set the aggregator\PYGZsq{}s properties.}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetTerminal} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetLegend} \PYG{p}{(}\PYG{n}{plotXAxisHeading}\PYG{p}{,} \PYG{n}{plotYAxisHeading}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Add a data set to the aggregator.}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Add2dDataset} \PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,} \PYG{n}{plotDatasetLabel}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// aggregator must be turned on}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Enable} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, the 2\sphinxhyphen{}D values are calculated, and each one is individually
written to the GnuplotAggregator using the \sphinxcode{\sphinxupquote{Write2d()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{value}\PYG{p}{;}

  \PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{time} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{time} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
      \PYG{c+c1}{//}
      \PYG{c+c1}{//                   2}
      \PYG{c+c1}{//     value  =  time   .}
      \PYG{c+c1}{//}
      \PYG{n}{value} \PYG{o}{=} \PYG{n}{time} \PYG{o}{*} \PYG{n}{time}\PYG{p}{;}

      \PYG{c+c1}{// Add this point to the plot.}
      \PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Write2d} \PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Disable logging of data for the aggregator.}
  \PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Disable} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{FileAggregator}
\label{\detokenize{aggregator:fileaggregator}}
The FileAggregator sends the values it receives to a file.

The FileAggregator can create 4 different types of files:
\begin{itemize}
\item {} 
Formatted

\item {} 
Space separated (the default)

\item {} 
Comma separated

\item {} 
Tab separated

\end{itemize}

Formatted files use C\sphinxhyphen{}style format strings and the sprintf() function
to print their values in the file being written.


\subsubsection{Creation}
\label{\detokenize{aggregator:id1}}
An object of type FileAggregator will be created here to show what needs
to be done.

One declares a FileAggregator in dynamic memory by using the smart
pointer class (Ptr\textless{}T\textgreater{}). To create a FileAggregator in dynamic memory
with smart pointers, one just needs to call the \sphinxstyleemphasis{ns\sphinxhyphen{}3} method
CreateObject.  The following code from
\sphinxcode{\sphinxupquote{src/stats/examples/file\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}} shows how
to do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{n}{fileName}       \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}aggregator\PYGZhy{}formatted\PYGZhy{}values.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Create an aggregator that will have formatted values.}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}} \PYG{n}{aggregator} \PYG{o}{=}
  \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{fileName}\PYG{p}{,} \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first argument for the constructor, filename, is the name of the
file to write; the second argument, fileType, is type of file to
write. This FileAggregator will create a file named
“file\sphinxhyphen{}aggregator\sphinxhyphen{}formatted\sphinxhyphen{}values.txt” with its values printed as
specified by fileType, i.e., formatted in this case.

The following file type enum values are allowed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{FileType} \PYG{p}{\PYGZob{}}
  \PYG{n}{FORMATTED}\PYG{p}{,}
  \PYG{n}{SPACE\PYGZus{}SEPARATED}\PYG{p}{,}
  \PYG{n}{COMMA\PYGZus{}SEPARATED}\PYG{p}{,}
  \PYG{n}{TAB\PYGZus{}SEPARATED}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Examples}
\label{\detokenize{aggregator:id2}}
One example will be discussed in detail here:
\begin{itemize}
\item {} 
File Aggregator Example

\end{itemize}


\paragraph{File Aggregator Example}
\label{\detokenize{aggregator:file-aggregator-example}}
An example that exercises the FileAggregator can be found in
\sphinxcode{\sphinxupquote{src/stats/examples/file\sphinxhyphen{}aggregator\sphinxhyphen{}example.cc}}.

The following text file with 2 columns of values separated by commas
was created using the example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{25}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{16}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}
\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{16}
\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{25}
\end{sphinxVerbatim}

This code from the example shows how to construct the
FileAggregator as was discussed above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{CreateCommaSeparatedFile} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

  \PYG{n}{string} \PYG{n}{fileName}       \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}aggregator\PYGZhy{}comma\PYGZhy{}separated.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{datasetContext} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dataset/Context/String}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

  \PYG{c+c1}{// Create an aggregator.}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}} \PYG{n}{aggregator} \PYG{o}{=}
    \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{fileName}\PYG{p}{,} \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{COMMA\PYGZus{}SEPARATED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

FileAggregator attributes are set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// aggregator must be turned on}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Enable} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, the 2\sphinxhyphen{}D values are calculated, and each one is individually
written to the FileAggregator using the \sphinxcode{\sphinxupquote{Write2d()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{value}\PYG{p}{;}

  \PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{time} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{time} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
      \PYG{c+c1}{//}
      \PYG{c+c1}{//                   2}
      \PYG{c+c1}{//     value  =  time   .}
      \PYG{c+c1}{//}
      \PYG{n}{value} \PYG{o}{=} \PYG{n}{time} \PYG{o}{*} \PYG{n}{time}\PYG{p}{;}

      \PYG{c+c1}{// Add this point to the plot.}
      \PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Write2d} \PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Disable logging of data for the aggregator.}
  \PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Disable} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The following text file with 2 columns of formatted values was also
created using the example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.000e+00}     \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{25}
\PYG{n}{Time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.000e+00}     \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{16}
\PYG{n}{Time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.000e+00}     \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{9}
\PYG{n}{Time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.000e+00}     \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{Time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.000e+00}     \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{Time} \PYG{o}{=} \PYG{l+m+mf}{0.000e+00}      \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{Time} \PYG{o}{=} \PYG{l+m+mf}{1.000e+00}      \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{Time} \PYG{o}{=} \PYG{l+m+mf}{2.000e+00}      \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{Time} \PYG{o}{=} \PYG{l+m+mf}{3.000e+00}      \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{9}
\PYG{n}{Time} \PYG{o}{=} \PYG{l+m+mf}{4.000e+00}      \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{16}
\PYG{n}{Time} \PYG{o}{=} \PYG{l+m+mf}{5.000e+00}      \PYG{n}{Value} \PYG{o}{=} \PYG{l+m+mi}{25}
\end{sphinxVerbatim}

This code from the example shows how to construct the
FileAggregator as was discussed above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{CreateFormattedFile} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

  \PYG{n}{string} \PYG{n}{fileName}       \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZhy{}aggregator\PYGZhy{}formatted\PYGZhy{}values.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{string} \PYG{n}{datasetContext} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dataset/Context/String}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

  \PYG{c+c1}{// Create an aggregator that will have formatted values.}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}} \PYG{n}{aggregator} \PYG{o}{=}
    \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{FileAggregator}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{fileName}\PYG{p}{,} \PYG{n}{FileAggregator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FORMATTED}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

FileAggregator attributes are set, including the C\sphinxhyphen{}style format string
to use.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Set the format for the values.}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Set2dFormat} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time = \PYGZpc{}.3e}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Value = \PYGZpc{}.0f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// aggregator must be turned on}
\PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Enable} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next, the 2\sphinxhyphen{}D values are calculated, and each one is individually
written to the FileAggregator using the \sphinxcode{\sphinxupquote{Write2d()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{k+kt}{double} \PYG{n}{time}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{value}\PYG{p}{;}

  \PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{time} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{time} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{time} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
      \PYG{c+c1}{//}
      \PYG{c+c1}{//                   2}
      \PYG{c+c1}{//     value  =  time   .}
      \PYG{c+c1}{//}
      \PYG{n}{value} \PYG{o}{=} \PYG{n}{time} \PYG{o}{*} \PYG{n}{time}\PYG{p}{;}

      \PYG{c+c1}{// Add this point to the plot.}
      \PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Write2d} \PYG{p}{(}\PYG{n}{datasetContext}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// Disable logging of data for the aggregator.}
  \PYG{n}{aggregator}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Disable} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Adaptors}
\label{\detokenize{adaptor:adaptors}}\label{\detokenize{adaptor::doc}}
This section details the functionalities provided by the Adaptor
class to an \sphinxstyleemphasis{ns\sphinxhyphen{}3} simulation. This section is meant for users
interested in developing simulations with the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tools and using
the Data Collection Framework, of which the Adaptor class is a
part, to generate data output with their simulation’s results.

Note:  the term ‘adaptor’ may also be spelled ‘adapter’; we chose
the spelling aligned with the C++ standard.


\subsection{Adaptor Overview}
\label{\detokenize{adaptor:adaptor-overview}}
An Adaptor is used to make connections between different types of DCF
objects.

To date, one Adaptor has been implemented:
\begin{itemize}
\item {} 
TimeSeriesAdaptor

\end{itemize}


\subsection{Time Series Adaptor}
\label{\detokenize{adaptor:time-series-adaptor}}
The TimeSeriesAdaptor lets Probes connect directly to Aggregators
without needing any Collector in between.

Both of the implemented DCF helpers utilize TimeSeriesAdaptors
in order to take probed values of different types and output the
current time plus the value with both converted to doubles.

The role of the TimeSeriesAdaptor class is that of an adaptor, which
takes raw\sphinxhyphen{}valued probe data of different types and outputs a tuple of
two double values.  The first is a timestamp, which may be set to
different resolutions (e.g. Seconds, Milliseconds, etc.) in the future
but which is presently hardcoded to Seconds.
The second is the conversion of a non\sphinxhyphen{}double
value to a double value (possibly with loss of precision).


\section{Scope/Limitations}
\label{\detokenize{scope-and-limitations:scope-limitations}}\label{\detokenize{scope-and-limitations::doc}}
This section discusses the scope and limitations of the Data
Collection Framework.

Currently, only these Probes have been implemented in DCF:
\begin{itemize}
\item {} 
BooleanProbe

\item {} 
DoubleProbe

\item {} 
Uinteger8Probe

\item {} 
Uinteger16Probe

\item {} 
Uinteger32Probe

\item {} 
TimeProbe

\item {} 
PacketProbe

\item {} 
ApplicationPacketProbe

\item {} 
Ipv4PacketProbe

\end{itemize}

Currently, no Collectors are available in the DCF, although a
BasicStatsCollector is under development.

Currently, only these Aggregators have been implemented in DCF:
\begin{itemize}
\item {} 
GnuplotAggregator

\item {} 
FileAggregator

\end{itemize}

Currently, only this Adaptor has been implemented in DCF:

Time\sphinxhyphen{}Series Adaptor.


\subsection{Future Work}
\label{\detokenize{scope-and-limitations:future-work}}
This section discusses the future work to be done on the Data
Collection Framework.

Here are some things that still need to be done:
\begin{itemize}
\item {} 
Hook up more trace sources in \sphinxstyleemphasis{ns\sphinxhyphen{}3} code to get more values out of the simulator.

\item {} 
Implement more types of Probes than there currently are.

\item {} 
Implement more than just the single current 2\sphinxhyphen{}D Collector, BasicStatsCollector.

\item {} 
Implement more Aggregators.

\item {} 
Implement more than just Adaptors.

\end{itemize}


\chapter{Statistical Framework}
\label{\detokenize{statistics:statistical-framework}}\label{\detokenize{statistics::doc}}
This chapter outlines work on simulation data collection and the
statistical framework for ns\sphinxhyphen{}3.

The source code for the statistical framework lives in the directory
\sphinxcode{\sphinxupquote{src/stats}}.


\section{Goals}
\label{\detokenize{statistics:goals}}
Primary objectives for this effort are the following:
\begin{itemize}
\item {} 
Provide functionality to record, calculate, and present data and statistics for analysis of network simulations.

\item {} 
Boost simulation performance by reducing the need to generate extensive trace logs in order to collect data.

\item {} 
Enable simulation control via online statistics, e.g. terminating simulations or repeating trials.

\end{itemize}

Derived sub\sphinxhyphen{}goals and other target features include the following:
\begin{itemize}
\item {} 
Integration with the existing ns\sphinxhyphen{}3 tracing system as the basic instrumentation framework of the internal simulation engine, e.g. network stacks, net devices, and channels.

\item {} 
Enabling users to utilize the statistics framework without requiring use of the tracing system.

\item {} 
Helping users create, aggregate, and analyze data over multiple trials.

\item {} 
Support for user created instrumentation, e.g. of application specific events and measures.

\item {} 
Low memory and CPU overhead when the package is not in use.

\item {} 
Leveraging existing analysis and output tools as much as possible.  The framework may provide some basic statistics, but the focus is on collecting data and making it accessible for manipulation in established tools.

\item {} 
Eventual support for distributing independent replications is important but not included in the first round of features.

\end{itemize}


\section{Overview}
\label{\detokenize{statistics:overview}}
The statistics framework includes the following features:
\begin{itemize}
\item {} 
The core framework and two basic data collectors: A counter, and a min/max/avg/total observer.

\item {} 
Extensions of those to easily work with times and packets.

\item {} 
Plaintext output formatted for \sphinxhref{http://www.omnetpp.org}{OMNet++}.

\item {} 
Database output using \sphinxhref{http://www.sqlite.org}{SQLite}, a standalone, lightweight, high performance SQL engine.

\item {} 
Mandatory and open ended metadata for describing and working with runs.

\item {} 
An example based on the notional experiment of examining the properties of NS\sphinxhyphen{}3’s default ad hoc WiFi performance.  It incorporates the following:
\begin{itemize}
\item {} 
Constructs of a two node ad hoc WiFi network, with the nodes a parameterized distance apart.

\item {} 
UDP traffic source and sink applications with slightly different behavior and measurement hooks than the stock classes.

\item {} 
Data collection from the NS\sphinxhyphen{}3 core via existing trace signals, in particular data on frames transmitted and received by the WiFi MAC objects.

\item {} 
Instrumentation of custom applications by connecting new trace signals to the stat framework, as well as via direct updates.  Information is recorded about total packets sent and received, bytes transmitted, and end\sphinxhyphen{}to\sphinxhyphen{}end delay.

\item {} 
An example of using packet tags to track end\sphinxhyphen{}to\sphinxhyphen{}end delay.

\item {} 
A simple control script which runs a number of trials of the experiment at varying distances and queries the resulting database to produce a graph using GNUPlot.

\end{itemize}

\end{itemize}


\section{To\sphinxhyphen{}Do}
\label{\detokenize{statistics:to-do}}
High priority items include:
\begin{itemize}
\item {} 
Inclusion of online statistics code, e.g. for memory efficient confidence intervals.

\item {} 
Provisions in the data collectors for terminating runs, i.e. when a threshold or confidence is met.

\item {} 
Data collectors for logging samples over time, and output to the various formats.

\item {} 
Demonstrate writing simple cyclic event glue to regularly poll some value.

\end{itemize}

Each of those should prove straightforward to incorporate in the current framework.


\section{Approach}
\label{\detokenize{statistics:approach}}
The framework is based around the following core principles:
\begin{itemize}
\item {} 
One experiment trial is conducted by one instance of a simulation program, whether in parallel or serially.

\item {} 
A control script executes instances of the simulation, varying parameters as necessary.

\item {} 
Data is collected and stored for plotting and analysis using external scripts and existing tools.

\item {} 
Measures within the ns\sphinxhyphen{}3 core are taken by connecting the stat framework to existing trace signals.

\item {} 
Trace signals or direct manipulation of the framework may be used to instrument custom simulation code.

\end{itemize}

Those basic components of the framework and their interactions are depicted in the following figure.

\noindent\sphinxincludegraphics{{Stat-framework-arch}.png}


\section{Example}
\label{\detokenize{statistics:example}}
This section goes through the process of constructing an experiment in the framework and producing data for analysis (graphs) from it, demonstrating the structure and API along the way.


\subsection{Question}
\label{\detokenize{statistics:question}}
‘’What is the (simulated) performance of ns\sphinxhyphen{}3’s WiFi NetDevices (using the default settings)?  How far apart can wireless nodes be in a simulation before they cannot communicate reliably?’’
\begin{itemize}
\item {} 
Hypothesis: Based on knowledge of real life performance, the nodes should communicate reasonably well to at least 100m apart.  Communication beyond 200m shouldn’t be feasible.

\end{itemize}

Although not a very common question in simulation contexts, this is an important property of which simulation developers should have a basic understanding.  It is also a common study done on live hardware.


\subsection{Simulation Program}
\label{\detokenize{statistics:simulation-program}}
The first thing to do in implementing this experiment is developing the simulation program.  The code for this example can be found in \sphinxcode{\sphinxupquote{examples/stats/wifi\sphinxhyphen{}example\sphinxhyphen{}sim.cc}}.  It does the following main steps.
\begin{itemize}
\item {} 
Declaring parameters and parsing the command line using \sphinxcode{\sphinxupquote{ns3::CommandLine}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double} \PYG{n}{distance} \PYG{o}{=} \PYG{l+m+mf}{50.0}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{format} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OMNet++}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{experiment} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wifi\PYGZhy{}distance\PYGZhy{}test}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n+nf}{strategy} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wifi\PYGZhy{}default}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{runID}\PYG{p}{;}

\PYG{n}{COMMANDLINE} \PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{distance}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Distance apart to place nodes (in meters).}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{distance}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{format}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}     \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Format to use for data output.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}             \PYG{n}{format}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{experiment}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Identifier for experiment.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}                 \PYG{n}{experiment}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{strategy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Identifier for strategy.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}                   \PYG{n}{strategy}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{run}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Identifier for run.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}                        \PYG{n}{runID}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cmd}\PYG{p}{.}\PYG{n}{Parse} \PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Creating nodes and network stacks using \sphinxcode{\sphinxupquote{ns3::NodeContainer}}, \sphinxcode{\sphinxupquote{ns3::WiFiHelper}}, and \sphinxcode{\sphinxupquote{ns3::InternetStackHelper}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NodeContainer} \PYG{n}{nodes}\PYG{p}{;}
\PYG{n}{nodes}\PYG{p}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{WifiHelper} \PYG{n}{wifi}\PYG{p}{;}
\PYG{n}{wifi}\PYG{p}{.}\PYG{n}{SetMac}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::AdhocWifiMac}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wifi}\PYG{p}{.}\PYG{n}{SetPhy}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::WifiPhy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{NetDeviceContainer} \PYG{n}{nodeDevices} \PYG{o}{=} \PYG{n}{wifi}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{InternetStackHelper} \PYG{n}{internet}\PYG{p}{;}
\PYG{n}{internet}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ipv4AddressHelper} \PYG{n}{ipAddrs}\PYG{p}{;}
\PYG{n}{ipAddrs}\PYG{p}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{192.168.0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ipAddrs}\PYG{p}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{nodeDevices}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Positioning the nodes using \sphinxcode{\sphinxupquote{ns3::MobilityHelper}}.  By default the nodes have static mobility and won’t move, but must be positioned the given distance apart.  There are several ways to do this; it is done here using \sphinxcode{\sphinxupquote{ns3::ListPositionAllocator}}, which draws positions from a given list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MobilityHelper} \PYG{n}{mobility}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ListPositionAllocator}\PYG{o}{\PYGZgt{}} \PYG{n}{positionAlloc} \PYG{o}{=}
  \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{ListPositionAllocator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{positionAlloc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{positionAlloc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{distance}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mobility}\PYG{p}{.}\PYG{n}{SetPositionAllocator}\PYG{p}{(}\PYG{n}{positionAlloc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mobility}\PYG{p}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Installing a traffic generator and a traffic sink.  The stock \sphinxcode{\sphinxupquote{Applications}} could be used, but the example includes custom objects in \sphinxcode{\sphinxupquote{src/test/test02\sphinxhyphen{}apps.(cc|h)}}.  These have a simple behavior, generating a given number of packets spaced at a given interval.  As there is only one of each they are installed manually; for a larger set the \sphinxcode{\sphinxupquote{ns3::ApplicationHelper}} class could be used.  The commented\sphinxhyphen{}out \sphinxcode{\sphinxupquote{Config::Set}} line changes the destination of the packets, set to broadcast by default in this example.  Note that in general WiFi may have different performance for broadcast and unicast frames due to different rate control and MAC retransmission policies.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{n}{appSource} \PYG{o}{=} \PYG{n}{NodeList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetNode}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Sender}\PYG{o}{\PYGZgt{}} \PYG{n}{sender} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Sender}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{appSource}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddApplication}\PYG{p}{(}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sender}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Node}\PYG{o}{\PYGZgt{}} \PYG{n}{appSink} \PYG{o}{=} \PYG{n}{NodeList}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetNode}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Receiver}\PYG{o}{\PYGZgt{}} \PYG{n}{receiver} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{Receiver}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{appSink}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{AddApplication}\PYG{p}{(}\PYG{n}{receiver}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{receiver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//  Config::Set(\PYGZdq{}/NodeList/*/ApplicationList/*/\PYGZdl{}Sender/Destination\PYGZdq{},}
\PYG{c+c1}{//              Ipv4AddressValue(\PYGZdq{}192.168.0.2\PYGZdq{}));}
\end{sphinxVerbatim}

\item {} 
Configuring the data and statistics to be collected.  The basic paradigm is that an \sphinxcode{\sphinxupquote{ns3::DataCollector}} object is created to hold information about this particular run, to which observers and calculators are attached to actually generate data.  Importantly, run information includes labels for the ‘’experiment’’, ‘’strategy’’, ‘’input’’, and ‘’run’’.  These are used to later identify and easily group data from multiple trials.
\begin{itemize}
\item {} 
The experiment is the study of which this trial is a member.  Here it is on WiFi performance and distance.

\item {} 
The strategy is the code or parameters being examined in this trial.  In this example it is fixed, but an obvious extension would be to investigate different WiFi bit rates, each of which would be a different strategy.

\item {} 
The input is the particular problem given to this trial.  Here it is simply the distance between the two nodes.

\item {} 
The runID is a unique identifier for this trial with which it’s information is tagged for identification in later analysis.  If no run ID is given the example program makes a (weak) run ID using the current time.

\end{itemize}

Those four pieces of metadata are required, but more may be desired.  They may be added to the record using the \sphinxcode{\sphinxupquote{ns3::DataCollector::AddMetadata()}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DataCollector} \PYG{n}{data}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{DescribeRun}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,} \PYG{n}{strategy}\PYG{p}{,} \PYG{n}{input}\PYG{p}{,} \PYG{n}{runID}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{AddMetadata}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{author}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tjkopena}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Actual observation and calculating is done by \sphinxcode{\sphinxupquote{ns3::DataCalculator}} objects, of which several different types exist.  These are created by the simulation program, attached to reporting or sampling code, and then registered with the \sphinxcode{\sphinxupquote{ns3::DataCollector}} so they will be queried later for their output.  One easy observation mechanism is to use existing trace sources, for example to instrument objects in the ns\sphinxhyphen{}3 core without changing their code.  Here a counter is attached directly to a trace signal in the WiFi MAC layer on the target node.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PacketCounterCalculator}\PYG{o}{\PYGZgt{}} \PYG{n}{totalRx} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{PacketCounterCalculator}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{totalRx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetKey}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wifi\PYGZhy{}rx\PYGZhy{}frames}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Connect}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/NodeList/1/DeviceList/*/\PYGZdl{}ns3::WifiNetDevice/Rx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                \PYG{n}{MakeCallback}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{PacketCounterCalculator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FrameUpdate}\PYG{p}{,} \PYG{n}{totalRx}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{AddDataCalculator}\PYG{p}{(}\PYG{n}{totalRx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Calculators may also be manipulated directly.  In this example, a counter is created and passed to the traffic sink application to be updated when packets are received.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{CounterCalculator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{appRx} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{CounterCalculator}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{appRx}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetKey}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{receiver\PYGZhy{}rx\PYGZhy{}packets}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{receiver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetCounter}\PYG{p}{(}\PYG{n}{appRx}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{data}\PYG{p}{.}\PYG{n}{AddDataCalculator}\PYG{p}{(}\PYG{n}{appRx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

To increment the count, the sink’s packet processing code then calls one of the calculator’s update methods.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}calc}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Update}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The program includes several other examples as well, using both the primitive calculators such as \sphinxcode{\sphinxupquote{ns3::CounterCalculator}} and those adapted for observing packets and times.  In \sphinxcode{\sphinxupquote{src/test/test02\sphinxhyphen{}apps.(cc|h)}} it also creates a simple custom tag which it uses to track end\sphinxhyphen{}to\sphinxhyphen{}end delay for generated packets, reporting results to a \sphinxcode{\sphinxupquote{ns3::TimeMinMaxAvgTotalCalculator}} data calculator.

\item {} 
Running the simulation, which is very straightforward once constructed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Generating either \sphinxhref{http://www.omnetpp.org}{OMNet++} or \sphinxhref{http://www.sqlite.org}{SQLite} output, depending on the command line arguments.  To do this a \sphinxcode{\sphinxupquote{ns3::DataOutputInterface}} object is created and configured.  The specific type of this will determine the output format.  This object is then given the \sphinxcode{\sphinxupquote{ns3::DataCollector}} object which it interrogates to produce the output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{DataOutputInterface}\PYG{o}{\PYGZgt{}} \PYG{n}{output}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{format} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OMNet++}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating OMNet++ formatted data output.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{output} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{OmnetDataOutput}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{   ifdef STAT\PYGZus{}USE\PYGZus{}DB}
    \PYG{n}{NS\PYGZus{}LOG\PYGZus{}INFO}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Creating SQLite formatted data output.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{output} \PYG{o}{=} \PYG{n}{CreateObject}\PYG{o}{\PYGZlt{}}\PYG{n}{SqliteDataOutput}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{   endif}
\PYG{p}{\PYGZcb{}}

\PYG{n}{output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Output}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Freeing any memory used by the simulation.  This should come at the end of the main function for the example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulator}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{Logging}
\label{\detokenize{statistics:logging}}
To see what the example program, applications, and stat framework are doing in detail, set the \sphinxcode{\sphinxupquote{NS\_LOG}} variable appropriately.  The following will provide copious output from all three.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{NS\PYGZus{}LOG}\PYG{o}{=}WiFiDistanceExperiment:WiFiDistanceApps
\end{sphinxVerbatim}

Note that this slows down the simulation extraordinarily.


\subsubsection{Sample Output}
\label{\detokenize{statistics:sample-output}}
Compiling and simply running the test program will append \sphinxhref{http://www.omnetpp.org}{OMNet++} formatted output such as the following to \sphinxcode{\sphinxupquote{data.sca}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
run run\PYGZhy{}1212239121

attr experiment \PYGZdq{}wifi\PYGZhy{}distance\PYGZhy{}test\PYGZdq{}
attr strategy \PYGZdq{}wifi\PYGZhy{}default\PYGZdq{}
attr input \PYGZdq{}50\PYGZdq{}
attr description \PYGZdq{}\PYGZdq{}

attr \PYGZdq{}author\PYGZdq{} \PYGZdq{}tjkopena\PYGZdq{}

scalar wifi\PYGZhy{}tx\PYGZhy{}frames count 30
scalar wifi\PYGZhy{}rx\PYGZhy{}frames count 30
scalar sender\PYGZhy{}tx\PYGZhy{}packets count 30
scalar receiver\PYGZhy{}rx\PYGZhy{}packets count 30
scalar tx\PYGZhy{}pkt\PYGZhy{}size count 30
scalar tx\PYGZhy{}pkt\PYGZhy{}size total 1920
scalar tx\PYGZhy{}pkt\PYGZhy{}size average 64
scalar tx\PYGZhy{}pkt\PYGZhy{}size max 64
scalar tx\PYGZhy{}pkt\PYGZhy{}size min 64
scalar delay count 30
scalar delay total 5884980ns
scalar delay average 196166ns
scalar delay max 196166ns
scalar delay min 196166ns
\end{sphinxVerbatim}


\subsection{Control Script}
\label{\detokenize{statistics:control-script}}
In order to automate data collection at a variety of inputs (distances), a simple Bash script is used to execute a series of simulations.  It can be found at \sphinxcode{\sphinxupquote{examples/stats/wifi\sphinxhyphen{}example\sphinxhyphen{}db.sh}}.  The script is meant to be run from the \sphinxcode{\sphinxupquote{examples/stats/}} directory.

The script runs through a set of distances, collecting the results into an \sphinxhref{http://www.sqlite.org}{SQLite} database.  At each distance five trials are conducted to give a better picture of expected performance.  The entire experiment takes only a few dozen seconds to run on a low end machine as there is no output during the simulation and little traffic is generated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}

\PYG{n+nv}{DISTANCES}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}25 50 75 100 125 145 147 150 152 155 157 160 162 165 167 170 172 175 177 180\PYGZdq{}}
\PYG{n+nv}{TRIALS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}1 2 3 4 5\PYGZdq{}}

\PYG{n+nb}{echo} WiFi Experiment Example

\PYG{k}{if} \PYG{o}{[} \PYGZhy{}e data.db \PYG{o}{]}
\PYG{k}{then}
  \PYG{n+nb}{echo} Kill data.db?
  \PYG{n+nb}{read} ANS
  \PYG{k}{if} \PYG{o}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}ANS}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}yes\PYGZdq{}} \PYGZhy{}o \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}ANS}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}y\PYGZdq{}} \PYG{o}{]}
  \PYG{k}{then}
    \PYG{n+nb}{echo} Deleting database
    rm data.db
  \PYG{k}{fi}
\PYG{k}{fi}

\PYG{k}{for} trial in \PYG{n+nv}{\PYGZdl{}TRIALS}
\PYG{k}{do}
  \PYG{k}{for} distance in \PYG{n+nv}{\PYGZdl{}DISTANCES}
  \PYG{k}{do}
    \PYG{n+nb}{echo} Trial \PYG{n+nv}{\PYGZdl{}trial}, distance \PYG{n+nv}{\PYGZdl{}distance}
    ./bin/test02 \PYGZhy{}\PYGZhy{}format\PYG{o}{=}db \PYGZhy{}\PYGZhy{}distance\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}distance} \PYGZhy{}\PYGZhy{}run\PYG{o}{=}run\PYGZhy{}\PYG{n+nv}{\PYGZdl{}distance}\PYGZhy{}\PYG{n+nv}{\PYGZdl{}trial}
  \PYG{k}{done}
\PYG{k}{done}
\end{sphinxVerbatim}


\subsection{Analysis and Conclusion}
\label{\detokenize{statistics:analysis-and-conclusion}}
Once all trials have been conducted, the script executes a simple SQL query over the database using the \sphinxhref{http://www.sqlite.org}{SQLite} command line program.  The query computes average packet loss in each set of trials associated with each distance.  It does not take into account different strategies, but the information is present in the database to make some simple extensions and do so.  The collected data is then passed to GNUPlot for graphing.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMD}\PYG{o}{=}\PYG{l+s+ss}{\PYGZdq{}select exp.input,avg(100\PYGZhy{}((rx.value*100)/tx.value)) \PYGZbs{}}
\PYG{l+s+ss}{    from Singletons rx, Singletons tx, Experiments exp \PYGZbs{}}
\PYG{l+s+ss}{    where rx.run = tx.run AND \PYGZbs{}}
\PYG{l+s+ss}{          rx.run = exp.run AND \PYGZbs{}}
\PYG{l+s+ss}{          rx.name=\PYGZsq{}receiver\PYGZhy{}rx\PYGZhy{}packets\PYGZsq{} AND \PYGZbs{}}
\PYG{l+s+ss}{          tx.name=\PYGZsq{}sender\PYGZhy{}tx\PYGZhy{}packets\PYGZsq{} \PYGZbs{}}
\PYG{l+s+ss}{    group by exp.input \PYGZbs{}}
\PYG{l+s+ss}{    order by abs(exp.input) ASC;\PYGZdq{}}

\PYG{n}{sqlite3} \PYG{o}{\PYGZhy{}}\PYG{n}{noheader} \PYG{k}{data}\PYG{p}{.}\PYG{n}{db} \PYG{l+s+ss}{\PYGZdq{}\PYGZdl{}CMD\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{n}{wifi}\PYG{o}{\PYGZhy{}}\PYG{k}{default}\PYG{p}{.}\PYG{k}{data}
\PYG{n}{sed} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{l+s+ss}{\PYGZdq{}s/|/   /\PYGZdq{}} \PYG{n}{wifi}\PYG{o}{\PYGZhy{}}\PYG{k}{default}\PYG{p}{.}\PYG{k}{data}
\PYG{n}{gnuplot} \PYG{n}{wifi}\PYG{o}{\PYGZhy{}}\PYG{n}{example}\PYG{p}{.}\PYG{n}{gnuplot}
\end{sphinxVerbatim}

The GNUPlot script found at \sphinxcode{\sphinxupquote{examples/stats/wifi\sphinxhyphen{}example.gnuplot}} simply defines the output format and some basic formatting for the graph.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set} terminal postscript portrait enhanced lw \PYG{l+m}{2} \PYG{l+s+s2}{\PYGZdq{}Helvetica\PYGZdq{}} \PYG{l+m}{14}

\PYG{n+nb}{set} size \PYG{l+m}{1}.0, \PYG{l+m}{0}.66

\PYG{c+c1}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nb}{set} out \PYG{l+s+s2}{\PYGZdq{}wifi\PYGZhy{}default.eps\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}set title \PYGZdq{}Packet Loss Over Distance\PYGZdq{}}
\PYG{n+nb}{set} xlabel \PYG{l+s+s2}{\PYGZdq{}Distance (m) \PYGZhy{}\PYGZhy{}\PYGZhy{} average of 5 trials per point\PYGZdq{}}
\PYG{n+nb}{set} xrange \PYG{o}{[}\PYG{l+m}{0}:200\PYG{o}{]}
\PYG{n+nb}{set} ylabel \PYG{l+s+s2}{\PYGZdq{}\PYGZpc{} Packet Loss\PYGZdq{}}
\PYG{n+nb}{set} yrange \PYG{o}{[}\PYG{l+m}{0}:110\PYG{o}{]}

plot \PYG{l+s+s2}{\PYGZdq{}wifi\PYGZhy{}default.data\PYGZdq{}} with lines title \PYG{l+s+s2}{\PYGZdq{}WiFi Defaults\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{End Result}
\label{\detokenize{statistics:end-result}}
The resulting graph provides no evidence that the default WiFi model’s performance is necessarily unreasonable and lends some confidence to an at least token faithfulness to reality.  More importantly, this simple investigation has been carried all the way through using the statistical framework.  Success!

\noindent\sphinxincludegraphics{{Wifi-default}.png}


\chapter{RealTime}
\label{\detokenize{realtime:realtime}}\label{\detokenize{realtime::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} has been designed for integration into testbed and virtual machine
environments. To integrate with real network stacks and emit/consume packets, a
real\sphinxhyphen{}time scheduler is needed to try to lock the simulation clock with the
hardware clock. We describe here a component of this: the RealTime scheduler.

The purpose of the realtime scheduler is to cause the progression of the
simulation clock to occur synchronously with respect to some external time base.
Without the presence of an external time base (wall clock), simulation time
jumps instantly from one simulated time to the next.


\section{Behavior}
\label{\detokenize{realtime:behavior}}
When using a non\sphinxhyphen{}realtime scheduler (the default in \sphinxstyleemphasis{ns\sphinxhyphen{}3}), the simulator
advances the simulation time to the next scheduled event. During event
execution, simulation time is frozen. With the realtime scheduler, the behavior
is similar from the perspective of simulation models (i.e., simulation time is
frozen during event execution), but between events, the simulator will attempt
to keep the simulation clock aligned with the machine clock.

When an event is finished executing, and the scheduler moves to the next event,
the scheduler compares the next event execution time with the machine clock.  If
the next event is scheduled for a future time, the simulator sleeps until that
realtime is reached and then executes the next event.

It may happen that, due to the processing inherent in the execution of
simulation events, that the simulator cannot keep up with realtime.  In such a
case, it is up to the user configuration what to do. There are two \sphinxstyleemphasis{ns\sphinxhyphen{}3}
attributes that govern the behavior. The first is
\sphinxcode{\sphinxupquote{ns3::RealTimeSimulatorImpl::SynchronizationMode}}. The two entries possible
for this attribute are \sphinxcode{\sphinxupquote{BestEffort}} (the default) or \sphinxcode{\sphinxupquote{HardLimit}}. In
“BestEffort” mode, the simulator will just try to catch up to realtime by
executing events until it reaches a point where the next event is in the
(realtime) future, or else the simulation ends. In BestEffort mode, then, it is
possible for the simulation to consume more time than the wall clock time. The
other option “HardLimit” will cause the simulation to abort if the tolerance
threshold is exceeded.  This attribute is
\sphinxcode{\sphinxupquote{ns3::RealTimeSimulatorImpl::HardLimit}} and the default is 0.1 seconds.

A different mode of operation is one in which simulated time is \sphinxstylestrong{not} frozen
during an event execution. This mode of realtime simulation was implemented but
removed from the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tree because of questions of whether it would be useful.
If users are interested in a realtime simulator for which simulation time does
not freeze during event execution (i.e., every call to \sphinxcode{\sphinxupquote{Simulator::Now()}}
returns the current wall clock time, not the time at which the event started
executing), please contact the ns\sphinxhyphen{}developers mailing list.


\section{Usage}
\label{\detokenize{realtime:usage}}
The usage of the realtime simulator is straightforward, from a scripting
perspective.  Users just need to set the attribute
\sphinxcode{\sphinxupquote{SimulatorImplementationType}} to the Realtime simulator, such as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GlobalValue}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bind} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SimulatorImplementationType}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{StringValue} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RealtimeSimulatorImpl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

There is a script in \sphinxcode{\sphinxupquote{examples/realtime/realtime\sphinxhyphen{}udp\sphinxhyphen{}echo.cc}} that
has an example of how to configure the realtime behavior.  Try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run realtime\PYGZhy{}udp\PYGZhy{}echo
\end{sphinxVerbatim}

Whether the simulator will work in a best effort or hard limit policy fashion is
governed by the attributes explained in the previous section.


\section{Implementation}
\label{\detokenize{realtime:implementation}}
The implementation is contained in the following files:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{src/core/model/realtime\sphinxhyphen{}simulator\sphinxhyphen{}impl.\{cc,h\}}}

\item {} 
\sphinxcode{\sphinxupquote{src/core/model/wall\sphinxhyphen{}clock\sphinxhyphen{}synchronizer.\{cc,h\}}}

\end{itemize}

In order to create a realtime scheduler, to a first approximation you just want
to cause simulation time jumps to consume real time. We propose doing this using
a combination of sleep\sphinxhyphen{} and busy\sphinxhyphen{} waits. Sleep\sphinxhyphen{}waits cause the calling process
(thread) to yield the processor for some amount of time. Even though this
specified amount of time can be passed to nanosecond resolution, it is actually
converted to an OS\sphinxhyphen{}specific granularity. In Linux, the granularity is called a
Jiffy. Typically this resolution is insufficient for our needs (on the order of
a ten milliseconds), so we round down and sleep for some smaller number of
Jiffies. The process is then awakened after the specified number of Jiffies has
passed. At this time, we have some residual time to wait. This time is generally
smaller than the minimum sleep time, so we busy\sphinxhyphen{}wait for the remainder of the
time. This means that the thread just sits in a for loop consuming cycles until
the desired time arrives. After the combination of sleep\sphinxhyphen{} and busy\sphinxhyphen{}waits, the
elapsed realtime (wall) clock should agree with the simulation time of the next
event and the simulation proceeds.


\chapter{Helpers}
\label{\detokenize{helpers:helpers}}\label{\detokenize{helpers::doc}}
The above chapters introduced you to various \sphinxstyleemphasis{ns\sphinxhyphen{}3} programming concepts such as
smart pointers for reference\sphinxhyphen{}counted memory management, attributes, namespaces,
callbacks, etc. Users who work at this low\sphinxhyphen{}level API can interconnect \sphinxstyleemphasis{ns\sphinxhyphen{}3}
objects with fine granularity. However, a simulation program written entirely
using the low\sphinxhyphen{}level API would be quite long and tedious to code. For this
reason, a separate so\sphinxhyphen{}called “helper API” has been overlaid on the core \sphinxstyleemphasis{ns\sphinxhyphen{}3}
API. If you have read the \sphinxstyleemphasis{ns\sphinxhyphen{}3} tutorial, you will already be familiar with the
helper API, since it is the API that new users are typically introduced to
first.  In this chapter, we introduce the design philosophy of the helper API
and contrast it to the low\sphinxhyphen{}level API. If you become a heavy user of \sphinxstyleemphasis{ns\sphinxhyphen{}3}, you
will likely move back and forth between these APIs even in the same program.

The helper API has a few goals:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
the rest of \sphinxcode{\sphinxupquote{src/}} has no dependencies on the helper API; anything that can
be done with the helper API can be coded also at the low\sphinxhyphen{}level API

\item {} 
\sphinxstylestrong{Containers:} Often simulations will need to do a number of identical
actions to groups of objects. The helper API makes heavy use of containers of
similar objects to which similar or identical operations can be performed.

\item {} 
The helper API is not generic; it does not strive to maximize code reuse. So,
programming constructs such as polymorphism and templates that achieve code
reuse are not as prevalent. For instance, there are separate CsmaNetDevice
helpers and PointToPointNetDevice helpers but they do not derive from a
common NetDevice base class.

\item {} 
The helper API typically works with stack\sphinxhyphen{}allocated (vs. heap\sphinxhyphen{}allocated)
objects. For some programs, \sphinxstyleemphasis{ns\sphinxhyphen{}3} users may not need to worry about any low
level Object Create or Ptr handling; they can make do with containers of
objects and stack\sphinxhyphen{}allocated helpers that operate on them.

\end{enumerate}

The helper API is really all about making \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs easier to write and
read, without taking away the power of the low\sphinxhyphen{}level interface. The rest of this
chapter provides some examples of the programming conventions of the helper API.


\chapter{Utilities}
\label{\detokenize{utilities:utilities}}\label{\detokenize{utilities:id1}}\label{\detokenize{utilities::doc}}

\section{Print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen}
\label{\detokenize{utilities:print-introspected-doxygen}}
\sphinxtitleref{print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen} is used to generate doxygen documentation
using various TypeIds defined throughout the \sphinxstyleemphasis{ns\sphinxhyphen{}3} source code.
The tool returns the various config paths, attributes, trace sources,
etc. for the various files in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Invocation}
\label{\detokenize{utilities:invocation}}
This tool is run automatically by the build system when generating
the Doxygen API docs, so you don’t normally have to run it by hand.

However, since it does give a fair bit of information about TypeIds
it can be useful to run from the command line and
search for specific information.

To run it, simply open terminal and type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run print\PYGZhy{}introspected\PYGZhy{}doxygen
\end{sphinxVerbatim}

This will give all the output, formatted for Doxygen, which can be viewed
in a text editor.

One way to use this is to capture it to a file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run print\PYGZhy{}introspected\PYGZhy{}doxygen \PYGZgt{} doc.html
\end{sphinxVerbatim}

Some users might prefer to use tools like grep
to locate the required piece of information from the documentation
instead of using an editor. For such uses\sphinxhyphen{}cases and more,
\sphinxtitleref{print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen} can return plain text:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}print\PYGZhy{}introspected\PYGZhy{}doxygen \PYGZhy{}\PYGZhy{}output\PYGZhy{}text\PYGZdq{}}
\end{sphinxVerbatim}

(Note the quotes around the inner command and options.)
\begin{quote}

\$ ./waf \textendash{}run “print\sphinxhyphen{}introspected\sphinxhyphen{}doxygen \textendash{}output\sphinxhyphen{}text” | grep “hello”
\end{quote}

This will output the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* HelloInterval: HELLO messages emission interval.
* DeletePeriod: DeletePeriod is intended to provide an upper bound on the \PYG{n+nb}{time} \PYG{k}{for} which an upstream node A can have a neighbor B as an active next hop \PYG{k}{for} destination D, \PYG{k}{while} B has invalidated the route to D. \PYG{o}{=} \PYG{l+m}{5} * max \PYG{o}{(}HelloInterval, ActiveRouteTimeout\PYG{o}{)}
* AllowedHelloLoss: Number of hello messages which may be loss \PYG{k}{for} valid link.
* EnableHello: Indicates whether a hello messages enable.
* HelloInterval: HELLO messages emission interval.
* HelloInterval: HELLO messages emission interval.
* DeletePeriod: DeletePeriod is intended to provide an upper bound on the \PYG{n+nb}{time} \PYG{k}{for} which an upstream node A can have a neighbor B as an active next hop \PYG{k}{for} destination D, \PYG{k}{while} B has invalidated the route to D. \PYG{o}{=} \PYG{l+m}{5} * max \PYG{o}{(}HelloInterval, ActiveRouteTimeout\PYG{o}{)}
* AllowedHelloLoss: Number of hello messages which may be loss \PYG{k}{for} valid link.
* EnableHello: Indicates whether a hello messages enable.
* HelloInterval: HELLO messages emission interval.
\end{sphinxVerbatim}


\section{Bench\sphinxhyphen{}simulator}
\label{\detokenize{utilities:bench-simulator}}
This tool is used to benchmark the scheduler algorithms used in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Command\sphinxhyphen{}line Arguments}
\label{\detokenize{utilities:command-line-arguments}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}bench\PYGZhy{}simulator \PYGZhy{}\PYGZhy{}help\PYGZdq{}}

Program Options:
    \PYGZhy{}\PYGZhy{}cal:    use CalendarSheduler \PYG{o}{[}false\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}heap:   use HeapScheduler \PYG{o}{[}false\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}list:   use ListSheduler \PYG{o}{[}false\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}map:    use MapScheduler \PYG{o}{(}default\PYG{o}{)} \PYG{o}{[}true\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}debug:  \PYG{n+nb}{enable} debugging output \PYG{o}{[}false\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}pop:    event population size \PYG{o}{(}default 1E5\PYG{o}{)} \PYG{o}{[}\PYG{l+m}{100000}\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}total:  total number of events to run \PYG{o}{(}default 1E6\PYG{o}{)} \PYG{o}{[}\PYG{l+m}{1000000}\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}runs:   number of runs \PYG{o}{(}default \PYG{l+m}{1}\PYG{o}{)} \PYG{o}{[}\PYG{l+m}{1}\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}file:   file of relative event \PYG{n+nb}{times} \PYG{o}{[}\PYG{o}{]}
    \PYGZhy{}\PYGZhy{}prec:   printed output precision \PYG{o}{[}\PYG{l+m}{6}\PYG{o}{]}
\end{sphinxVerbatim}

You can change the Scheduler being benchmarked by passing
the appropriate flags, for example if you want to
benchmark the CalendarScheduler pass \sphinxtitleref{\textendash{}cal} to the program.

The default total number of events, runs or population size
can be overridden by passing \sphinxtitleref{\textendash{}total=value}, \sphinxtitleref{\textendash{}runs=value}
and \sphinxtitleref{\textendash{}pop=value} respectively.

If you want to use event distribution which is stored in a file,
you can pass the file option by \sphinxtitleref{\textendash{}file=FILE\_NAME}.

\sphinxtitleref{\textendash{}prec} can be used to change the output precision value and
\sphinxtitleref{\textendash{}debug} as the name suggests enables debugging.


\subsection{Invocation}
\label{\detokenize{utilities:id2}}
To run it, simply open the terminal and type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run bench\PYGZhy{}simulator
\end{sphinxVerbatim}

It will show something like this depending upon the scheduler being benchmarked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug:
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: scheduler: ns3::MapScheduler
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: population: \PYG{l+m}{100000}
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: total events: \PYG{l+m}{1000000}
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: runs: \PYG{l+m}{1}
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: using default exponential distribution

Run        Inititialization:                   Simulation:
            Time \PYG{o}{(}s\PYG{o}{)}    Rate \PYG{o}{(}ev/s\PYG{o}{)} Per \PYG{o}{(}s/ev\PYG{o}{)}  Time \PYG{o}{(}s\PYG{o}{)}    Rate \PYG{o}{(}ev/s\PYG{o}{)} Per \PYG{o}{(}s/ev\PYG{o}{)}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{o}{(}prime\PYG{o}{)}     \PYG{l+m}{0}.4         \PYG{l+m}{250000}      4e\PYGZhy{}06       \PYG{l+m}{1}.84        \PYG{l+m}{543478}      \PYG{l+m}{1}.84e\PYGZhy{}06
\PYG{l+m}{0}           \PYG{l+m}{0}.15        \PYG{l+m}{666667}      \PYG{l+m}{1}.5e\PYGZhy{}06     \PYG{l+m}{1}.86        \PYG{l+m}{537634}      \PYG{l+m}{1}.86e\PYGZhy{}06
\end{sphinxVerbatim}

Suppose we had to benchmark \sphinxtitleref{CalendarScheduler} instead, we would have written

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}bench\PYGZhy{}simulator \PYGZhy{}\PYGZhy{}cal\PYGZdq{}}
\end{sphinxVerbatim}

And the output would look something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug:
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: scheduler: ns3::CalendarScheduler
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: population: \PYG{l+m}{100000}
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: total events: \PYG{l+m}{1000000}
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: runs: \PYG{l+m}{1}
ns3\PYGZhy{}dev\PYGZhy{}bench\PYGZhy{}simulator\PYGZhy{}debug: using default exponential distribution

Run        Inititialization:                   Simulation:
            Time \PYG{o}{(}s\PYG{o}{)}    Rate \PYG{o}{(}ev/s\PYG{o}{)} Per \PYG{o}{(}s/ev\PYG{o}{)}  Time \PYG{o}{(}s\PYG{o}{)}    Rate \PYG{o}{(}ev/s\PYG{o}{)} Per \PYG{o}{(}s/ev\PYG{o}{)}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{o}{(}prime\PYG{o}{)}     \PYG{l+m}{1}.19        \PYG{l+m}{84033}.6     \PYG{l+m}{1}.19e\PYGZhy{}05    \PYG{l+m}{32}.03       \PYG{l+m}{31220}.7     \PYG{l+m}{3}.203e\PYGZhy{}05
\PYG{l+m}{0}           \PYG{l+m}{0}.99        \PYG{l+m}{101010}      \PYG{l+m}{9}.9e\PYGZhy{}06     \PYG{l+m}{31}.22       \PYG{l+m}{32030}.7     \PYG{l+m}{3}.122e\PYGZhy{}05
\PYG{l+s+sb}{`}\PYG{l+s+sb}{`}\PYG{l+s+sb}{`}
\end{sphinxVerbatim}


\chapter{Making Plots using the Gnuplot Class}
\label{\detokenize{gnuplot:making-plots-using-the-gnuplot-class}}\label{\detokenize{gnuplot::doc}}
There are 2 common methods to make a plot using \sphinxstyleemphasis{ns\sphinxhyphen{}3} and gnuplot (\sphinxurl{http://www.gnuplot.info}):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Create a gnuplot control file using \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class.

\item {} 
Create a gnuplot data file using values generated by \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

\end{enumerate}

This section is about method 1, i.e. it is about how to make a plot using \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class.  If you are interested in method 2, see the “A Real Example” subsection under the “Tracing” section in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxhref{http://www.nsnam.org/tutorials.html}{Tutorial}.


\section{Creating Plots Using the Gnuplot Class}
\label{\detokenize{gnuplot:creating-plots-using-the-gnuplot-class}}
The following steps must be taken in order to create a plot using \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Modify your code so that is uses the Gnuplot class and its functions.

\item {} 
Run your code so that it creates a gnuplot control file.

\item {} 
Call gnuplot with the name of the gnuplot control file.

\item {} 
View the graphics file that was produced in your favorite graphics viewer.

\end{enumerate}

See the code from the example plots that are discussed below for details on step 1.


\section{An Example Program that Uses the Gnuplot Class}
\label{\detokenize{gnuplot:an-example-program-that-uses-the-gnuplot-class}}
An example program that uses \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Gnuplot class can be found here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src/stats/examples/gnuplot\PYGZhy{}example.cc
\end{sphinxVerbatim}

In order to run this example, do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run src/stats/examples/gnuplot\PYGZhy{}example
\end{sphinxVerbatim}

This should produce the following gnuplot control files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plot\PYGZhy{}2d.plt
plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.plt
plot\PYGZhy{}3d.plt
\end{sphinxVerbatim}

In order to process these gnuplot control files, do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} gnuplot plot\PYGZhy{}2d.plt
\PYGZdl{} gnuplot plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.plt
\PYGZdl{} gnuplot plot\PYGZhy{}3d.plt
\end{sphinxVerbatim}

This should produce the following graphics files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
plot\PYGZhy{}2d.png
plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.png
plot\PYGZhy{}3d.png
\end{sphinxVerbatim}

You can view these graphics files in your favorite graphics viewer.  If you have gimp installed on your machine, for example, you can do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} gimp plot\PYGZhy{}2d.png
\PYGZdl{} gimp plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars.png
\PYGZdl{} gimp plot\PYGZhy{}3d.png
\end{sphinxVerbatim}


\section{An Example 2\sphinxhyphen{}Dimensional Plot}
\label{\detokenize{gnuplot:an-example-2-dimensional-plot}}
The following 2\sphinxhyphen{}Dimensional plot

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{plot-2d}.png}
\end{figure}

was created using the following code from gnuplot\sphinxhyphen{}example.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{n}{string} \PYG{n}{fileNameWithNoExtension} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZhy{}2d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{graphicsFileName}        \PYG{o}{=} \PYG{n}{fileNameWithNoExtension} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{plotFileName}            \PYG{o}{=} \PYG{n}{fileNameWithNoExtension} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{plotTitle}               \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Plot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{dataTitle}               \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the plot and set its title.}
\PYG{n}{Gnuplot} \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{graphicsFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the graphics file, which the plot file will create when it}
\PYG{c+c1}{// is used with Gnuplot, be a PNG file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTerminal} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for each axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetLegend} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{X Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the range for the x axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xrange [\PYGZhy{}6:+6]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the dataset, set its title, and make the points be}
\PYG{c+c1}{// plotted along with connecting lines.}
\PYG{n}{Gnuplot2dDataset} \PYG{n}{dataset}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{dataTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetStyle} \PYG{p}{(}\PYG{n}{Gnuplot2dDataset}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LINES\PYGZus{}POINTS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n}{y}\PYG{p}{;}

\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
    \PYG{c+c1}{//}
    \PYG{c+c1}{//            2}
    \PYG{c+c1}{//     y  =  x   .}
    \PYG{c+c1}{//}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{x}\PYG{p}{;}

    \PYG{c+c1}{// Add this point.}
    \PYG{n}{dataset}\PYG{p}{.}\PYG{n}{Add} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Add the dataset to the plot.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AddDataset} \PYG{p}{(}\PYG{n}{dataset}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Open the plot file.}
\PYG{n}{ofstream} \PYG{n+nf}{plotFile} \PYG{p}{(}\PYG{n}{plotFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the plot file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{GenerateOutput} \PYG{p}{(}\PYG{n}{plotFile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Close the plot file.}
\PYG{n}{plotFile}\PYG{p}{.}\PYG{n}{close} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{An Example 2\sphinxhyphen{}Dimensional Plot with Error Bars}
\label{\detokenize{gnuplot:an-example-2-dimensional-plot-with-error-bars}}
The following 2\sphinxhyphen{}Dimensional plot with error bars in the x and y directions

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{plot-2d-with-error-bars}.png}
\end{figure}

was created using the following code from gnuplot\sphinxhyphen{}example.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{n}{string} \PYG{n}{fileNameWithNoExtension} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZhy{}2d\PYGZhy{}with\PYGZhy{}error\PYGZhy{}bars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{graphicsFileName}        \PYG{o}{=} \PYG{n}{fileNameWithNoExtension} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{plotFileName}            \PYG{o}{=} \PYG{n}{fileNameWithNoExtension} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{plotTitle}               \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Plot With Error Bars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{dataTitle}               \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2\PYGZhy{}D Data With Error Bars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the plot and set its title.}
\PYG{n}{Gnuplot} \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{graphicsFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the graphics file, which the plot file will create when it}
\PYG{c+c1}{// is used with Gnuplot, be a PNG file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTerminal} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for each axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetLegend} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{X Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Y Values}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the range for the x axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xrange [\PYGZhy{}6:+6]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the dataset, set its title, and make the points be}
\PYG{c+c1}{// plotted with no connecting lines.}
\PYG{n}{Gnuplot2dDataset} \PYG{n}{dataset}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{dataTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetStyle} \PYG{p}{(}\PYG{n}{Gnuplot2dDataset}\PYG{o}{:}\PYG{o}{:}\PYG{n}{POINTS}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the dataset have error bars in both the x and y directions.}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetErrorBars} \PYG{p}{(}\PYG{n}{Gnuplot2dDataset}\PYG{o}{:}\PYG{o}{:}\PYG{n}{XY}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n}{xErrorDelta}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n}{y}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n}{yErrorDelta}\PYG{p}{;}

\PYG{c+c1}{// Create the 2\PYGZhy{}D dataset.}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Calculate the 2\PYGZhy{}D curve}
    \PYG{c+c1}{//}
    \PYG{c+c1}{//            2}
    \PYG{c+c1}{//     y  =  x   .}
    \PYG{c+c1}{//}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{x}\PYG{p}{;}

    \PYG{c+c1}{// Make the uncertainty in the x direction be constant and make}
    \PYG{c+c1}{// the uncertainty in the y direction be a constant fraction of}
    \PYG{c+c1}{// y\PYGZsq{}s value.}
    \PYG{n}{xErrorDelta} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
    \PYG{n}{yErrorDelta} \PYG{o}{=} \PYG{l+m+mf}{0.1} \PYG{o}{*} \PYG{n}{y}\PYG{p}{;}

    \PYG{c+c1}{// Add this point with uncertainties in both the x and y}
    \PYG{c+c1}{// direction.}
    \PYG{n}{dataset}\PYG{p}{.}\PYG{n}{Add} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{xErrorDelta}\PYG{p}{,} \PYG{n}{yErrorDelta}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Add the dataset to the plot.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AddDataset} \PYG{p}{(}\PYG{n}{dataset}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Open the plot file.}
\PYG{n}{ofstream} \PYG{n+nf}{plotFile} \PYG{p}{(}\PYG{n}{plotFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the plot file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{GenerateOutput} \PYG{p}{(}\PYG{n}{plotFile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Close the plot file.}
\PYG{n}{plotFile}\PYG{p}{.}\PYG{n}{close} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{An Example 3\sphinxhyphen{}Dimensional Plot}
\label{\detokenize{gnuplot:an-example-3-dimensional-plot}}
The following 3\sphinxhyphen{}Dimensional plot

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{plot-3d}.png}
\end{figure}

was created using the following code from gnuplot\sphinxhyphen{}example.cc:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{n}{string} \PYG{n}{fileNameWithNoExtension} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZhy{}3d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{graphicsFileName}        \PYG{o}{=} \PYG{n}{fileNameWithNoExtension} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{plotFileName}            \PYG{o}{=} \PYG{n}{fileNameWithNoExtension} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{plotTitle}               \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3\PYGZhy{}D Plot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{string} \PYG{n}{dataTitle}               \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3\PYGZhy{}D Data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the plot and set its title.}
\PYG{n}{Gnuplot} \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{graphicsFileName}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{plotTitle}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the graphics file, which the plot file will create when it}
\PYG{c+c1}{// is used with Gnuplot, be a PNG file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{SetTerminal} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{png}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Rotate the plot 30 degrees around the x axis and then rotate the}
\PYG{c+c1}{// plot 120 degrees around the new z axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set view 30, 120, 1.0, 1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Make the zero for the z\PYGZhy{}axis be in the x\PYGZhy{}axis and y\PYGZhy{}axis plane.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set ticslevel 0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the labels for each axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xlabel \PYGZsq{}X Values\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set ylabel \PYGZsq{}Y Values\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set zlabel \PYGZsq{}Z Values\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set the ranges for the x and y axis.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set xrange [\PYGZhy{}5:+5]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AppendExtra} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{set yrange [\PYGZhy{}5:+5]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Instantiate the dataset, set its title, and make the points be}
\PYG{c+c1}{// connected by lines.}
\PYG{n}{Gnuplot3dDataset} \PYG{n}{dataset}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetTitle} \PYG{p}{(}\PYG{n}{dataTitle}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dataset}\PYG{p}{.}\PYG{n}{SetStyle} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{with lines}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{double} \PYG{n}{x}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n}{y}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n}{z}\PYG{p}{;}

\PYG{c+c1}{// Create the 3\PYGZhy{}D dataset.}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{5.0}\PYG{p}{;} \PYG{n}{y} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Calculate the 3\PYGZhy{}D surface}
        \PYG{c+c1}{//}
        \PYG{c+c1}{//            2      2}
        \PYG{c+c1}{//     z  =  x   *  y   .}
        \PYG{c+c1}{//}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y} \PYG{o}{*} \PYG{n}{y}\PYG{p}{;}

        \PYG{c+c1}{// Add this point.}
        \PYG{n}{dataset}\PYG{p}{.}\PYG{n}{Add} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{// The blank line is necessary at the end of each x value\PYGZsq{}s data}
  \PYG{c+c1}{// points for the 3\PYGZhy{}D surface grid to work.}
  \PYG{n}{dataset}\PYG{p}{.}\PYG{n}{AddEmptyLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Add the dataset to the plot.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{AddDataset} \PYG{p}{(}\PYG{n}{dataset}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Open the plot file.}
\PYG{n}{ofstream} \PYG{n+nf}{plotFile} \PYG{p}{(}\PYG{n}{plotFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Write the plot file.}
\PYG{n}{plot}\PYG{p}{.}\PYG{n}{GenerateOutput} \PYG{p}{(}\PYG{n}{plotFile}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Close the plot file.}
\PYG{n}{plotFile}\PYG{p}{.}\PYG{n}{close} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Using Python to Run \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{python:using-python-to-run-ns3}}\label{\detokenize{python::doc}}
Python bindings allow the C++ code in \sphinxstyleemphasis{ns\sphinxhyphen{}3} to be called from Python.

This chapter shows you how to create a Python script that can run \sphinxstyleemphasis{ns\sphinxhyphen{}3} and also the process of creating Python bindings for a C++ \sphinxstyleemphasis{ns\sphinxhyphen{}3} module.


\section{Introduction}
\label{\detokenize{python:introduction}}
Python bindings provide support for importing \sphinxstyleemphasis{ns\sphinxhyphen{}3} model libraries as Python
modules.  Coverage of most of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} C++ API is provided.  The intent
has been to allow the programmer to write complete simulation scripts in
Python, to allow integration of \sphinxstyleemphasis{ns\sphinxhyphen{}3} with other Python tools and workflows.
The intent is not to provide a different language choice to author new
\sphinxstyleemphasis{ns\sphinxhyphen{}3} models implemented in Python.

Python bindings for \sphinxstyleemphasis{ns\sphinxhyphen{}3} use a tool called PyBindGen (\sphinxurl{https://github.com/gjcarneiro/pybindgen}) to create Python modules from the C++ libraries built by
Waf.  The Python bindings that PyBindGen uses are maintained in a
\sphinxcode{\sphinxupquote{bindings}} directory in each module, and must be maintained to match the
C++ API of that ns\sphinxhyphen{}3 module.  If the C++ API changes, the Python bindings file
must either be modified by hand accordingly, or the bindings must be
regenerated by an automated scanning process.

If a user is not interested in Python, he or she may disable the use of
Python bindings at Waf configure time.  In this case, changes to the C++
API of a provided module will not cause the module to fail to compile.

The process for automatically generating Python bindings relies on a toolchain
involving a development installation of the Clang compiler, a program called
CastXML (\sphinxurl{https://github.com/CastXML/CastXML}), and a program called
pygccxml (\sphinxurl{https://github.com/gccxml/pygccxml}).  The toolchain can be installed
using the ns\sphinxhyphen{}3 \sphinxcode{\sphinxupquote{bake}} build tool.


\section{An Example Python Script that Runs \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{python:an-example-python-script-that-runs-ns3}}
Here is some example code that is written in Python and that runs \sphinxstyleemphasis{ns\sphinxhyphen{}3}, which is written in C++.  This Python example can be found in \sphinxcode{\sphinxupquote{examples/tutorial/first.py}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{applications}
\PYG{k+kn}{import} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{core}
\PYG{k+kn}{import} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{internet}
\PYG{k+kn}{import} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{network}
\PYG{k+kn}{import} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{point\PYGZus{}to\PYGZus{}point}

\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LogComponentEnable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UdpEchoClientApplication}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LogComponentEnable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UdpEchoServerApplication}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{LOG\PYGZus{}LEVEL\PYGZus{}INFO}\PYG{p}{)}

\PYG{n}{nodes} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{NodeContainer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{nodes}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{pointToPoint} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{point\PYGZus{}to\PYGZus{}point}\PYG{o}{.}\PYG{n}{PointToPointHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pointToPoint}\PYG{o}{.}\PYG{n}{SetDeviceAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DataRate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5Mbps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pointToPoint}\PYG{o}{.}\PYG{n}{SetChannelAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Delay}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{StringValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2ms}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{devices} \PYG{o}{=} \PYG{n}{pointToPoint}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{stack} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{InternetStackHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{stack}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{address} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{Ipv4AddressHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{address}\PYG{o}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Address}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10.1.1.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Mask}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{255.255.255.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{interfaces} \PYG{o}{=} \PYG{n}{address}\PYG{o}{.}\PYG{n}{Assign} \PYG{p}{(}\PYG{n}{devices}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{echoServer} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{applications}\PYG{o}{.}\PYG{n}{UdpEchoServerHelper}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}

\PYG{n}{serverApps} \PYG{o}{=} \PYG{n}{echoServer}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{serverApps}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{echoClient} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{applications}\PYG{o}{.}\PYG{n}{UdpEchoClientHelper}\PYG{p}{(}\PYG{n}{interfaces}\PYG{o}{.}\PYG{n}{GetAddress}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MaxPackets}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Interval}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{TimeValue}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{SetAttribute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PacketSize}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{UintegerValue}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{clientApps} \PYG{o}{=} \PYG{n}{echoClient}\PYG{o}{.}\PYG{n}{Install}\PYG{p}{(}\PYG{n}{nodes}\PYG{o}{.}\PYG{n}{Get}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clientApps}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clientApps}\PYG{o}{.}\PYG{n}{Stop}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Seconds}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ns}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Running Python Scripts}
\label{\detokenize{python:running-python-scripts}}
waf contains some options that automatically update the python path to find the ns3 module.  To run example programs, there are two ways to use waf to take care of this.  One is to run a waf shell; e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf shell
\PYGZdl{} python examples/wireless/mixed\PYGZhy{}wireless.py
\end{sphinxVerbatim}

and the other is to use the \textendash{}pyrun option to waf:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}pyrun examples/wireless/mixed\PYGZhy{}wireless.py
\end{sphinxVerbatim}

As of ns\sphinxhyphen{}3.30, a \textendash{}pyrun\sphinxhyphen{}no\sphinxhyphen{}build option was added to allow the running of
a program without invoking a project rebuild.  This option may be useful
to improve execution time when running the same program repeatedly but with
different arguments, such as from scripts. It can be used in place of
\textendash{}pyrun such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}pyrun\PYGZhy{}no\PYGZhy{}build examples/wireless/mixed\PYGZhy{}wireless.py
\end{sphinxVerbatim}

To run a python script under the C debugger:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf shell
\PYGZdl{} gdb \PYGZhy{}\PYGZhy{}args python examples/wireless/mixed\PYGZhy{}wireless.py
\end{sphinxVerbatim}

To run your own Python script that calls \sphinxstyleemphasis{ns\sphinxhyphen{}3} and that has this path, \sphinxcode{\sphinxupquote{/path/to/your/example/my\sphinxhyphen{}script.py}}, do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf shell
\PYGZdl{} python /path/to/your/example/my\PYGZhy{}script.py
\end{sphinxVerbatim}


\section{Caveats}
\label{\detokenize{python:caveats}}
Python bindings for \sphinxstyleemphasis{ns\sphinxhyphen{}3} are a work in progress, and some limitations are known by developers.  Some of these limitations (not all) are listed here.


\subsection{Incomplete Coverage}
\label{\detokenize{python:incomplete-coverage}}
First of all, keep in mind that not 100\% of the API is supported in Python.  Some of the reasons are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
some of the APIs involve pointers, which require knowledge of what kind of memory passing semantics (who owns what memory). Such knowledge is not part of the function signatures, and is either documented or sometimes not even documented.  Annotations are needed to bind those functions;

\item {} 
Sometimes a unusual fundamental data type or C++ construct is used which is not yet supported by PyBindGen;

\item {} 
GCC\sphinxhyphen{}XML does not report template based classes unless they are instantiated. (Note:  Need to confirm this limitation still exists with CastXML)

\end{enumerate}

Most of the missing APIs can be wrapped, given enough time, patience, and expertise, and will likely be wrapped if bug reports are submitted.  However, don’t file a bug report saying “bindings are incomplete”, because we do not have manpower to complete 100\% of the bindings.


\subsection{Conversion Constructors}
\label{\detokenize{python:conversion-constructors}}
\sphinxhref{http://publib.boulder.ibm.com/infocenter/compbgpl/v9v111/topic/com.ibm.xlcpp9.bg.doc/language\_ref/cplr384.htm}{Conversion constructors} are not fully supported yet by PyBindGen, and they always act as explicit constructors when translating an API into Python.  For example, in C++ you can do this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ipv4AddressHelper} \PYG{n}{ipAddrs}\PYG{p}{;}
\PYG{n}{ipAddrs}\PYG{p}{.}\PYG{n}{SetBase} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{192.168.0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{255.255.255.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ipAddrs}\PYG{p}{.}\PYG{n}{Assign} \PYG{p}{(}\PYG{n}{backboneDevices}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In Python, for the time being you have to do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ipAddrs} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{internet}\PYG{o}{.}\PYG{n}{Ipv4AddressHelper}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ipAddrs}\PYG{o}{.}\PYG{n}{SetBase}\PYG{p}{(}\PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Address}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{192.168.0.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Ipv4Mask}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{255.255.255.0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ipAddrs}\PYG{o}{.}\PYG{n}{Assign}\PYG{p}{(}\PYG{n}{backboneDevices}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{CommandLine}
\label{\detokenize{python:commandline}}
\sphinxcode{\sphinxupquote{CommandLine::AddValue()}} works differently in Python than it does in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  In Python, the first parameter is a string that represents the command\sphinxhyphen{}line option name.  When the option is set, an attribute with the same name as the option name is set on the \sphinxcode{\sphinxupquote{CommandLine()}} object.  Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NUM\PYGZus{}NODES\PYGZus{}SIDE\PYGZus{}DEFAULT} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{n}{cmd} \PYG{o}{=} \PYG{n}{ns3}\PYG{o}{.}\PYG{n}{CommandLine}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{NumNodesSide} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{AddValue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NumNodesSide}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Grid side number of nodes (total number of nodes will be this number squared)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{)}

\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}

\PYG{k}{if} \PYG{n}{cmd}\PYG{o}{.}\PYG{n}{NumNodesSide} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
    \PYG{n}{num\PYGZus{}nodes\PYGZus{}side} \PYG{o}{=} \PYG{n}{NUM\PYGZus{}NODES\PYGZus{}SIDE\PYGZus{}DEFAULT}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{num\PYGZus{}nodes\PYGZus{}side} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{cmd}\PYG{o}{.}\PYG{n}{NumNodesSide}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Tracing}
\label{\detokenize{python:tracing}}
Callback based tracing is not yet properly supported for Python, as new \sphinxstyleemphasis{ns\sphinxhyphen{}3} API needs to be provided for this to be supported.

Pcap file writing is supported via the normal API.

ASCII tracing is supported since \sphinxstyleemphasis{ns\sphinxhyphen{}3}.4 via the normal C++ API translated to Python.  However, ASCII tracing requires the creation of an ostream object to pass into the ASCII tracing methods.  In Python, the C++ std::ofstream has been minimally wrapped to allow this.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ascii} \PYG{o}{=} \PYG{n}{ns3}\PYG{o}{.}\PYG{n}{ofstream}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wifi\PYGZhy{}ap.tr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create the file}
\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{YansWifiPhyHelper}\PYG{o}{.}\PYG{n}{EnableAsciiAll}\PYG{p}{(}\PYG{n}{ascii}\PYG{p}{)}
\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Run}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ns3}\PYG{o}{.}\PYG{n}{Simulator}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ascii}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} close the file}
\end{sphinxVerbatim}

There is one caveat: you must not allow the file object to be garbage collected while \sphinxstyleemphasis{ns\sphinxhyphen{}3} is still using it.  That means that the ‘ascii’ variable above must not be allowed to go out of scope or else the program will crash.


\section{Working with Python Bindings}
\label{\detokenize{python:working-with-python-bindings}}
Python bindings are built on a module\sphinxhyphen{}by\sphinxhyphen{}module basis, and can be found in each module’s  \sphinxcode{\sphinxupquote{bindings}} directory.


\subsection{Overview}
\label{\detokenize{python:overview}}
The python bindings are generated into an ‘ns’ namespace.  Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{network} \PYG{k+kn}{import} \PYG{n}{Node}
\PYG{n}{n1} \PYG{o}{=} \PYG{n}{Node}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ns}\PYG{n+nn}{.}\PYG{n+nn}{network}
\PYG{n}{n1} \PYG{o}{=} \PYG{n}{ns}\PYG{o}{.}\PYG{n}{network}\PYG{o}{.}\PYG{n}{Node}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

The best way to explore the bindings is to look at the various example
programs provided in \sphinxstyleemphasis{ns\sphinxhyphen{}3}; some C++ examples have a corresponding Python
example.  There is no structured documentation for the Python bindings
like there is Doxygen for the C++ API, but the Doxygen can be consulted
to understand how the C++ API works.


\subsection{Python Bindings Workflow}
\label{\detokenize{python:python-bindings-workflow}}
The process by which Python bindings are handled is the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Periodically a developer uses a CastXML (\sphinxurl{https://github.com/CastXML/CastXML}) based API scanning script, which saves the scanned API definition as \sphinxcode{\sphinxupquote{bindings/python/ns3\_module\_*.py}} files or as Python files in each modules’ \sphinxcode{\sphinxupquote{bindings}} directory.  These files are kept under version control in the main \sphinxstyleemphasis{ns\sphinxhyphen{}3} repository;

\item {} 
Other developers clone the repository and use the already scanned API definitions;

\item {} 
When configuring \sphinxstyleemphasis{ns\sphinxhyphen{}3}, pybindgen will be automatically downloaded if not already installed.  Released \sphinxstyleemphasis{ns\sphinxhyphen{}3} tarballs will ship a copy of pybindgen.

\end{enumerate}

If something goes wrong with compiling Python bindings and you just want to ignore them and move on with C++, you can disable Python with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}disable\PYGZhy{}python ...
\end{sphinxVerbatim}

To add support for modular bindings to an existing or new \sphinxstyleemphasis{ns\sphinxhyphen{}3} module, simply add the following line to its wscript build() function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bld}\PYG{o}{.}\PYG{n}{ns3\PYGZus{}python\PYGZus{}bindings}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

One must also provide the bindings files (usually by running the scanning
framework).


\subsection{Regenerating the Python bindings}
\label{\detokenize{python:regenerating-the-python-bindings}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} will fail to successfully compile the Python bindings if the C++
headers are changed and no longer align with the stored Python bindings.
In this case, the developer has two main choices:  1) disable Python
as described above, or 2) update the bindings to align with the new C++
API.


\subsubsection{Process Overview}
\label{\detokenize{python:process-overview}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} has an automated process to regenerate Python bindings from the C++
header files.  The process is only supported for Linux at the moment
(ns\sphinxhyphen{}3.29) because we are in the midst of transition to new tools.  The
current process is outlined below.  In short, the process currently
requires the following steps.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Prepare the system for scanning by installing the prerequisites,
including a development version of \sphinxcode{\sphinxupquote{clang}}, the \sphinxcode{\sphinxupquote{CastXML}} package,
and \sphinxcode{\sphinxupquote{pygccxml}}.

\item {} 
Perform a scan of the module of interest or all modules

\end{enumerate}


\subsubsection{Installing a clang development environment}
\label{\detokenize{python:installing-a-clang-development-environment}}
Make sure you have a development version of the clang compiler installed
on your system.  This can take a long time to build from source.  Linux
distributions provide binary library packages such as \sphinxcode{\sphinxupquote{clang\sphinxhyphen{}dev}} or
\sphinxcode{\sphinxupquote{clang\sphinxhyphen{}devel}}.  The version should not be too important; version 3.8 is
known to work.  Note that there is a problem with the Ubuntu
package installation of \sphinxcode{\sphinxupquote{clang\sphinxhyphen{}dev}}; see the Installation wiki page for
details on how to fix using some symlinks.


\subsubsection{Installing other prerequisites}
\label{\detokenize{python:installing-other-prerequisites}}
\sphinxcode{\sphinxupquote{cxxfilt}} is a new requirement, typically installed using \sphinxcode{\sphinxupquote{pip}}; e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo pip install cxxfilt
\end{sphinxVerbatim}

See also the wiki for installation notes for your system.


\subsubsection{Set up a \sphinxstyleliteralintitle{\sphinxupquote{bake}} build environment}
\label{\detokenize{python:set-up-a-bake-build-environment}}
Try the following commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} bake
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{BAKE\PYGZus{}HOME}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{pwd}\PYG{l+s+sb}{`}
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PATH}:\PYG{n+nv}{\PYGZdl{}BAKE\PYGZus{}HOME}/build/bin
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}LD\PYGZus{}LIBRARY\PYGZus{}PATH}:\PYG{n+nv}{\PYGZdl{}BAKE\PYGZus{}HOME}/build/lib
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PYTHONPATH}:\PYG{n+nv}{\PYGZdl{}BAKE\PYGZus{}HOME}/build/lib
\PYGZdl{} mkdir \PYGZhy{}p build/lib
\end{sphinxVerbatim}


\subsubsection{Configure}
\label{\detokenize{python:configure}}
Perform a configuration at the bake level:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./bake.py configure \PYGZhy{}e ns\PYGZhy{}3\PYGZhy{}dev \PYGZhy{}e pygccxml\PYGZhy{}1.9.1
\end{sphinxVerbatim}

The output of \sphinxcode{\sphinxupquote{bake show}} should show something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./bake.py show
\end{sphinxVerbatim}

Should say:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{} System Dependencies \PYGZhy{}\PYGZhy{}
 \PYGZgt{} clang\PYGZhy{}dev \PYGZhy{} OK
 \PYGZgt{} g++ \PYGZhy{} OK
 \PYGZgt{} libxml2\PYGZhy{}dev \PYGZhy{} OK
 \PYGZgt{} pygoocanvas \PYGZhy{} OK
 \PYGZgt{} pygraphviz \PYGZhy{} OK
 \PYGZgt{} python\PYGZhy{}dev \PYGZhy{} OK
 \PYGZgt{} qt \PYGZhy{} OK
 \PYGZgt{} setuptools \PYGZhy{} OK
\end{sphinxVerbatim}


\subsubsection{Download}
\label{\detokenize{python:download}}
Try the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./bake.py download
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency python\PYGZhy{}dev \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency clang\PYGZhy{}dev \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency g++ \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency setuptools \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency pygoocanvas \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency pygraphviz \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Searching \PYG{k}{for} system dependency qt \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Downloading castxml \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Downloading netanim \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Downloading pygccxml\PYGZhy{}1.9.1 \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Downloading pygccxml \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Downloading pybindgen \PYGZhy{} OK
 \PYGZgt{}\PYGZgt{} Downloading ns\PYGZhy{}3\PYGZhy{}dev \PYGZhy{} OK
\end{sphinxVerbatim}


\subsubsection{Build}
\label{\detokenize{python:build}}
Try the following commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mkdir \PYGZhy{}p build/lib
\PYGZdl{} ./bake.py build
\end{sphinxVerbatim}

It should fail on the \sphinxstyleemphasis{ns\sphinxhyphen{}3} bindings complilation.

The output of ‘./waf configure’ can be inspected to see if Python API scanning
support is enabled:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Python API Scanning Support   : enabled
\end{sphinxVerbatim}

It may say something like this, if the support is not active:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Python API Scanning Support   : not enabled (Missing \PYGZsq{}pygccxml\PYGZsq{} Python module)
\end{sphinxVerbatim}

In this case, the user must take steps to install castxml and pygccxml;
castxml binary must be in the shell’s path, and pygccxml must be in the
Python path.


\subsubsection{LP64 vs ILP32 bindings}
\label{\detokenize{python:lp64-vs-ilp32-bindings}}
Linux (64\sphinxhyphen{}bit, as most modern installations use) and MacOS use different
data models, as explained here:  \sphinxurl{https://www.ibm.com/support/knowledgecenter/en/SSLTBW\_2.3.0/com.ibm.zos.v2r3.cbcpx01/datatypesize64.htm}

Linux uses the LP64 model, and MacOS (as well as 32\sphinxhyphen{}bit Linux) use the ILP32
model.  Users will note that there are two versions of bindings files in
each ns\sphinxhyphen{}3 module directory; one with an ILP32.py suffix and one with
an LP64.py suffix.  Only one is used on any given platform.  The main
difference is in the representation of the 64 bit integer type as either
a ‘long’ (LP64) or ‘long long’ (ILP32).

The process (only supported on Linux at present) generates the LP64
bindings using the toolchain and then copies the LP64 bindings to the
ILP32 bindings with some type subsitutions automated by Waf scripts.


\subsubsection{Rescanning a module}
\label{\detokenize{python:rescanning-a-module}}
To re\sphinxhyphen{}scan a module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} source/ns\PYGZhy{}3\PYGZhy{}dev
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}apiscan\PYG{o}{=}wifi
\end{sphinxVerbatim}

To re\sphinxhyphen{}scan all modules:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} source/ns\PYGZhy{}3\PYGZhy{}dev
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}apiscan\PYG{o}{=}all
\end{sphinxVerbatim}


\subsubsection{Generating bindings on MacOS}
\label{\detokenize{python:generating-bindings-on-macos}}
In principle, this should work (and should generate the 32\sphinxhyphen{}bit bindings).
However, maintainers have not been able to complete this port as of ns\sphinxhyphen{}3.29.
We would welcome suggestions on how to enable scanning for MacOS.


\subsection{Organization of the Modular Python Bindings}
\label{\detokenize{python:organization-of-the-modular-python-bindings}}
The \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/bindings}} directory may contain the following files, some of them optional:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{callbacks\_list.py}}: this is a scanned file, DO NOT TOUCH.  Contains a list of Callback\textless{}…\textgreater{} template instances found in the scanned headers;

\item {} 
\sphinxcode{\sphinxupquote{modulegen\_\_gcc\_LP64.py}}: this is a scanned file, DO NOT TOUCH.  Scanned API definitions for the GCC, LP64 architecture (64\sphinxhyphen{}bit)

\item {} 
\sphinxcode{\sphinxupquote{modulegen\_\_gcc\_ILP32.py}}: this is a scanned file, DO NOT TOUCH.  Scanned API definitions for the GCC, ILP32 architecture (32\sphinxhyphen{}bit)

\item {} 
\sphinxcode{\sphinxupquote{modulegen\_customizations.py}}: you may optionally add this file in order to customize the pybindgen code generation

\item {} 
\sphinxcode{\sphinxupquote{scan\sphinxhyphen{}header.h}}: you may optionally add this file to customize what header file is scanned for the module.  Basically this file is scanned instead of ns3/\textless{}module\textgreater{}\sphinxhyphen{}module.h.  Typically, the first statement is \#include “ns3/\textless{}module\textgreater{}\sphinxhyphen{}module.h”, plus some other stuff to force template instantiations;

\item {} 
\sphinxcode{\sphinxupquote{module\_helpers.cc}}: you may add additional files, such as this, to be linked to python extension module, but they have to be registered in the wscript. Look at src/core/wscript for an example of how to do so;

\item {} 
\sphinxcode{\sphinxupquote{\textless{}module\textgreater{}.py}}: if this file exists, it becomes the “frontend” python module for the ns3 module, and the extension module (.so file) becomes \_\textless{}module\textgreater{}.so instead of \textless{}module\textgreater{}.so.  The \textless{}module\textgreater{}.py file has to import all symbols from the module \_\textless{}module\textgreater{} (this is more tricky than it sounds, see src/core/bindings/core.py for an example), and then can add some additional pure\sphinxhyphen{}python definitions.

\end{itemize}


\section{More Information for Developers}
\label{\detokenize{python:more-information-for-developers}}
If you are a developer and need more information on \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s Python bindings, please see the \sphinxhref{http://www.nsnam.org/wiki/NS-3\_Python\_Bindings}{Python Bindings wiki page}.


\chapter{Tests}
\label{\detokenize{tests:tests}}\label{\detokenize{tests::doc}}

\section{Overview}
\label{\detokenize{test-overview:overview}}\label{\detokenize{test-overview::doc}}
This chapter is concerned with the testing and validation of \sphinxstyleemphasis{ns\sphinxhyphen{}3} software.

This chapter provides
\begin{itemize}
\item {} 
background about terminology and software testing

\item {} 
a description of the ns\sphinxhyphen{}3 testing framework

\item {} 
a guide to model developers or new model contributors for how to write tests

\end{itemize}


\section{Background}
\label{\detokenize{test-background:background}}\label{\detokenize{test-background::doc}}
\sphinxstylestrong{This chapter may be skipped by readers familiar with the basics of
software testing.}

Writing defect\sphinxhyphen{}free software is a difficult proposition.  There are many
dimensions to the problem and there is much confusion regarding what is
meant by different terms in different contexts.  We have found it worthwhile
to spend a little time reviewing the subject and defining some terms.

Software testing may be loosely defined as the process of executing a program
with the intent of finding errors.  When one enters a discussion regarding
software testing, it quickly becomes apparent that there are many distinct
mind\sphinxhyphen{}sets with which one can approach the subject.

For example, one could break the process into broad functional categories
like ‘’correctness testing,’’ ‘’performance testing,’’ ‘’robustness testing’’
and ‘’security testing.’’  Another way to look at the problem is by life\sphinxhyphen{}cycle:
‘’requirements testing,’’ ‘’design testing,’’ ‘’acceptance testing,’’ and
‘’maintenance testing.’’  Yet another view is by the scope of the tested system.
In this case one may speak of ‘’unit testing,’’ ‘’component testing,’’
‘’integration testing,’’ and ‘’system testing.’’  These terms are also not
standardized in any way, and so ‘’maintenance testing’’ and ‘’regression
testing’’ may be heard interchangeably.  Additionally, these terms are often
misused.

There are also a number of different philosophical approaches to software
testing.  For example, some organizations advocate writing test programs
before actually implementing the desired software, yielding ‘’test\sphinxhyphen{}driven
development.’’  Some organizations advocate testing from a customer perspective
as soon as possible, following a parallel with the agile development process:
‘’test early and test often.’’  This is sometimes called ‘’agile testing.’’  It
seems that there is at least one approach to testing for every development
methodology.

The \sphinxstyleemphasis{ns\sphinxhyphen{}3} project is not in the business of advocating for any one of
these processes, but the project as a whole has requirements that help inform
the test process.

Like all major software products, \sphinxstyleemphasis{ns\sphinxhyphen{}3} has a number of qualities that
must be present for the product to succeed.  From a testing perspective, some
of these qualities that must be addressed are that \sphinxstyleemphasis{ns\sphinxhyphen{}3} must be
‘’correct,’’ ‘’robust,’’  ‘’performant’’ and ‘’maintainable.’’  Ideally there
should be metrics for each of these dimensions that are checked by the tests
to identify when the product fails to meet its expectations / requirements.


\subsection{Correctness}
\label{\detokenize{test-background:correctness}}
The essential purpose of testing is to determine that a piece of software
behaves ‘’correctly.’’  For \sphinxstyleemphasis{ns\sphinxhyphen{}3} this means that if we simulate
something, the simulation should faithfully represent some physical entity or
process to a specified accuracy and precision.

It turns out that there are two perspectives from which one can view
correctness.  Verifying that a particular model is implemented according
to its specification is generically called \sphinxstyleemphasis{verification}.  The process of
deciding that the model is correct for its intended use is generically called
\sphinxstyleemphasis{validation}.


\subsection{Validation and Verification}
\label{\detokenize{test-background:validation-and-verification}}
A computer model is a mathematical or logical representation of something. It
can represent a vehicle, an elephant (see
\sphinxhref{http://simutools.org/2009/}{David Harel’s talk about modeling an elephant at SIMUTools 2009}, or a networking card.  Models can also represent
processes such as global warming, freeway traffic flow or a specification of a
networking protocol.  Models can be completely faithful representations of a
logical process specification, but they necessarily can never completely
simulate a physical object or process.  In most cases, a number of
simplifications are made to the model to make simulation computationally
tractable.

Every model has a \sphinxstyleemphasis{target system} that it is attempting to simulate.  The
first step in creating a simulation model is to identify this target system and
the level of detail and accuracy that the simulation is desired to reproduce.
In the case of a logical process, the target system may be identified as ‘’TCP
as defined by RFC 793.’’  In this case, it will probably be desirable to create
a model that completely and faithfully reproduces RFC 793.  In the case of a
physical process this will not be possible. If, for example, you would like to
simulate a wireless networking card, you may determine that you need,  ‘’an
accurate MAC\sphinxhyphen{}level implementation of the 802.11 specification and {[}…{]} a
not\sphinxhyphen{}so\sphinxhyphen{}slow PHY\sphinxhyphen{}level model of the 802.11a specification.’’

Once this is done, one can develop an abstract model of the target system.  This
is typically an exercise in managing the tradeoffs between complexity, resource
requirements and accuracy.  The process of developing an abstract model has been
called \sphinxstyleemphasis{model qualification} in the literature.  In the case of a TCP
protocol, this process results in a design for a collection of objects,
interactions and behaviors that will fully implement RFC 793 in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
In the case of the wireless card, this process results in a number of tradeoffs
to allow the physical layer to be simulated and the design of a network device
and channel for ns\sphinxhyphen{}3, along with the desired objects, interactions and behaviors.

This abstract model is then developed into an \sphinxstyleemphasis{ns\sphinxhyphen{}3} model that
implements the abstract model as a computer program.  The process of getting the
implementation to agree with the abstract model is called \sphinxstyleemphasis{model
verification} in the literature.

The process so far is open loop. What remains is to make a determination that a
given ns\sphinxhyphen{}3 model has some connection to some reality \textendash{} that a model is an
accurate representation of a real system, whether a logical process or a physical
entity.

If one is going to use a simulation model to try and predict how some real
system is going to behave, there must be some reason to believe your results \textendash{}
i.e., can one trust that an inference made from the model translates into a
correct prediction for the real system.  The process of getting the ns\sphinxhyphen{}3 model
behavior to agree with the desired target system behavior as defined by the model
qualification process is called \sphinxstyleemphasis{model validation} in the literature. In the
case of a TCP implementation, you may want to compare the behavior of your ns\sphinxhyphen{}3
TCP model to some reference implementation in order to validate your model.  In
the case of a wireless physical layer simulation, you may want to compare the
behavior of your model to that of real hardware in a controlled setting,

The \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing environment provides tools to allow for both model
validation and testing, and encourages the publication of validation results.


\subsection{Robustness}
\label{\detokenize{test-background:robustness}}
Robustness is the quality of being able to withstand stresses, or changes in
environments, inputs or calculations, etc.  A system or design is ‘’robust’’
if it can deal with such changes with minimal loss of functionality.

This kind of testing is usually done with a particular focus.  For example, the
system as a whole can be run on many different system configurations to
demonstrate that it can perform correctly in a large number of environments.

The system can be also be stressed by operating close to or beyond capacity by
generating or simulating resource exhaustion of various kinds.  This genre of
testing is called ‘’stress testing.’’

The system and its components may be exposed to so\sphinxhyphen{}called ‘’clean tests’’ that
demonstrate a positive result \textendash{} that is that the system operates correctly in
response to a large variation of expected configurations.

The system and its components may also be exposed to ‘’dirty tests’’ which
provide inputs outside the expected range.  For example, if a module expects a
zero\sphinxhyphen{}terminated string representation of an integer, a dirty test might provide
an unterminated string of random characters to verify that the system does not
crash as a result of this unexpected input.  Unfortunately, detecting such
‘’dirty’’ input and taking preventive measures to ensure the system does not
fail catastrophically can require a huge amount of development overhead.  In
order to reduce development time, a decision was taken early on in the project
to minimize the amount of parameter validation and error handling in the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} codebase.  For this reason, we do not spend much time on dirty
testing \textendash{} it would just uncover the results of the design decision we know
we took.

We do want to demonstrate that \sphinxstyleemphasis{ns\sphinxhyphen{}3} software does work across some set
of conditions.  We borrow a couple of definitions to narrow this down a bit.
The \sphinxstyleemphasis{domain of applicability} is a set of prescribed conditions for which
the model has been tested, compared against reality to the extent possible, and
judged  suitable for use.  The \sphinxstyleemphasis{range of accuracy} is an agreement between
the computerized model and reality within a domain of applicability.

The \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing environment provides tools to allow for setting up
and running test environments over multiple systems (buildbot) and provides
classes to encourage clean tests to verify the operation of the system over the
expected ‘’domain of applicability’’ and ‘’range of accuracy.’’


\subsection{Performant}
\label{\detokenize{test-background:performant}}
Okay, ‘’performant’’ isn’t a real English word.  It is, however, a very concise
neologism that is quite often used to describe what we want \sphinxstyleemphasis{ns\sphinxhyphen{}3} to
be: powerful and fast enough to get the job done.

This is really about the broad subject of software performance testing.  One of
the key things that is done is to compare two systems to find which performs
better (cf benchmarks).  This is used to demonstrate that, for example,
\sphinxstyleemphasis{ns\sphinxhyphen{}3} can perform a basic kind of simulation at least as fast as a
competing tool, or can be used to identify parts of the system that perform
badly.

In the \sphinxstyleemphasis{ns\sphinxhyphen{}3} test framework, we provide support for timing various kinds
of tests.


\subsection{Maintainability}
\label{\detokenize{test-background:maintainability}}
A software product must be maintainable.  This is, again, a very broad
statement, but a testing framework can help with the task.  Once a model has
been developed, validated and verified, we can repeatedly execute the suite
of tests for the entire system to ensure that it remains valid and verified
over its lifetime.

When a feature stops functioning as intended after some kind of change to the
system is integrated, it is called generically a \sphinxstyleemphasis{regression}.
Originally the
term regression referred to a change that caused a previously fixed bug to
reappear, but the term has evolved to describe any kind of change that breaks
existing functionality.  There are many kinds of regressions that may occur
in practice.

A \sphinxstyleemphasis{local regression} is one in which a change affects the changed component
directly.  For example, if a component is modified to allocate and free memory
but stale pointers are used, the component itself fails.

A \sphinxstyleemphasis{remote regression} is one in which a change to one component breaks
functionality in another component.  This reflects violation of an implied but
possibly unrecognized contract between components.

An \sphinxstyleemphasis{unmasked regression} is one that creates a situation where a previously
existing bug that had no affect is suddenly exposed in the system.  This may
be as simple as exercising a code path for the first time.

A \sphinxstyleemphasis{performance regression} is one that causes the performance requirements
of the system to be violated.  For example, doing some work in a low level
function that may be repeated large numbers of times may suddenly render the
system unusable from certain perspectives.

The \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing framework provides tools for automating the process
used to validate and verify the code in nightly test suites to help quickly
identify possible regressions.


\section{Testing framework}
\label{\detokenize{test-framework:testing-framework}}\label{\detokenize{test-framework::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} consists of a simulation core engine, a set of models, example programs,
and tests.  Over time, new contributors contribute models, tests, and
examples.  A Python test program \sphinxcode{\sphinxupquote{test.py}} serves as the test
execution manager; \sphinxcode{\sphinxupquote{test.py}} can run test code and examples to
look for regressions, can output the results into a number of forms, and
can manage code coverage analysis tools.  On top of this, we layer
\sphinxstyleemphasis{buildslaves} that are automated build robots that perform
robustness testing by running the test framework on different systems
and with different configuration options.


\subsection{Buildslaves}
\label{\detokenize{test-framework:buildslaves}}
At the highest level of \sphinxstyleemphasis{ns\sphinxhyphen{}3} testing are the buildslaves (build robots).
If you are unfamiliar with
this system look at \sphinxurl{https://ns-buildmaster.ee.washington.edu:8010/}.
This is an open\sphinxhyphen{}source automated system that allows \sphinxstyleemphasis{ns\sphinxhyphen{}3} to be rebuilt
and tested daily.  By running the buildbots on a number
of different systems we can ensure that \sphinxstyleemphasis{ns\sphinxhyphen{}3} builds and executes
properly on all of its supported systems.

Users (and developers) typically will not interact with the buildslave system other
than to read its messages regarding test results.  If a failure is detected in
one of the automated build and test jobs, the buildbot will send an email to the
\sphinxstyleemphasis{ns\sphinxhyphen{}commits} mailing list.  This email will look something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[Ns\PYGZhy{}commits] Build failed in Jenkins: daily\PYGZhy{}ubuntu\PYGZhy{}without\PYGZhy{}valgrind » Ubuntu\PYGZhy{}64\PYGZhy{}15.04 \PYGZsh{}926

...
281 of 285 tests passed (281 passed, 3 skipped, 1 failed, 0 crashed, 0 valgrind errors)
List of SKIPped tests:
  ns3\PYGZhy{}tcp\PYGZhy{}cwnd
  ns3\PYGZhy{}tcp\PYGZhy{}interoperability
  nsc\PYGZhy{}tcp\PYGZhy{}loss
List of FAILed tests:
  random\PYGZhy{}variable\PYGZhy{}stream\PYGZhy{}generators
+ exit 1
Build step \PYGZsq{}Execute shell\PYGZsq{} marked build as failure
\end{sphinxVerbatim}

In the full details URL shown in the email, one can find links to the detailed test output.

The buildslave system will do its job quietly if there are no errors, and the
system will undergo build and test cycles every day to verify that all is well.


\subsection{Test.py}
\label{\detokenize{test-framework:test-py}}
The buildbots use a Python program, \sphinxcode{\sphinxupquote{test.py}}, that is responsible for
running all of the tests and collecting the resulting reports into a human\sphinxhyphen{}
readable form.  This program is also available for use by users and developers
as well.

\sphinxcode{\sphinxupquote{test.py}} is very flexible in allowing the user to specify the number
and kind of tests to run; and also the amount and kind of output to generate.

Before running \sphinxcode{\sphinxupquote{test.py}}, make sure that ns3’s examples and tests
have been built by doing the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{} ./waf build
\end{sphinxVerbatim}

By default, \sphinxcode{\sphinxupquote{test.py}} will run all available tests and report status
back in a very concise form.  Running the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py
\end{sphinxVerbatim}

will result in a number of \sphinxcode{\sphinxupquote{PASS}}, \sphinxcode{\sphinxupquote{FAIL}}, \sphinxcode{\sphinxupquote{CRASH}} or \sphinxcode{\sphinxupquote{SKIP}}
indications followed by the kind of test that was run and its display name.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
Waf: Leaving directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
\PYGZsq{}build\PYGZsq{} finished successfully (0.939s)
FAIL: TestSuite propagation\PYGZhy{}loss\PYGZhy{}model
PASS: TestSuite object\PYGZhy{}name\PYGZhy{}service
PASS: TestSuite pcap\PYGZhy{}file\PYGZhy{}object
PASS: TestSuite ns3\PYGZhy{}tcp\PYGZhy{}cwnd
...
PASS: TestSuite ns3\PYGZhy{}tcp\PYGZhy{}interoperability
PASS: Example csma\PYGZhy{}broadcast
PASS: Example csma\PYGZhy{}multicast
\end{sphinxVerbatim}

This mode is intended to be used by users who are interested in determining if
their distribution is working correctly, and by developers who are interested
in determining if changes they have made have caused any regressions.

There are a number of options available to control the behavior of \sphinxcode{\sphinxupquote{test.py}}.
if you run \sphinxcode{\sphinxupquote{test.py \sphinxhyphen{}\sphinxhyphen{}help}} you should see a command summary like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Usage: test.py [options]

Options:
  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit
  \PYGZhy{}b BUILDPATH, \PYGZhy{}\PYGZhy{}buildpath=BUILDPATH
                        specify the path where ns\PYGZhy{}3 was built (defaults to the
                        build directory for the current variant)
  \PYGZhy{}c KIND, \PYGZhy{}\PYGZhy{}constrain=KIND
                        constrain the test\PYGZhy{}runner by kind of test
  \PYGZhy{}e EXAMPLE, \PYGZhy{}\PYGZhy{}example=EXAMPLE
                        specify a single example to run (no relative path is
                        needed)
  \PYGZhy{}d, \PYGZhy{}\PYGZhy{}duration        print the duration of each test suite and example
  \PYGZhy{}e EXAMPLE, \PYGZhy{}\PYGZhy{}example=EXAMPLE
                        specify a single example to run (no relative path is
                        needed)
  \PYGZhy{}u, \PYGZhy{}\PYGZhy{}update\PYGZhy{}data     If examples use reference data files, get them to re\PYGZhy{}
                        generate them
  \PYGZhy{}f FULLNESS, \PYGZhy{}\PYGZhy{}fullness=FULLNESS
                        choose the duration of tests to run: QUICK, EXTENSIVE,
                        or TAKES\PYGZus{}FOREVER, where EXTENSIVE includes QUICK and
                        TAKES\PYGZus{}FOREVER includes QUICK and EXTENSIVE (only QUICK
                        tests are run by default)
  \PYGZhy{}g, \PYGZhy{}\PYGZhy{}grind           run the test suites and examples using valgrind
  \PYGZhy{}k, \PYGZhy{}\PYGZhy{}kinds           print the kinds of tests available
  \PYGZhy{}l, \PYGZhy{}\PYGZhy{}list            print the list of known tests
  \PYGZhy{}m, \PYGZhy{}\PYGZhy{}multiple        report multiple failures from test suites and test
                        cases
  \PYGZhy{}n, \PYGZhy{}\PYGZhy{}nowaf           do not run waf before starting testing
  \PYGZhy{}p PYEXAMPLE, \PYGZhy{}\PYGZhy{}pyexample=PYEXAMPLE
                        specify a single python example to run (with relative
                        path)
  \PYGZhy{}r, \PYGZhy{}\PYGZhy{}retain          retain all temporary files (which are normally
                        deleted)
  \PYGZhy{}s TEST\PYGZhy{}SUITE, \PYGZhy{}\PYGZhy{}suite=TEST\PYGZhy{}SUITE
                        specify a single test suite to run
  \PYGZhy{}t TEXT\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}text=TEXT\PYGZhy{}FILE
                        write detailed test results into TEXT\PYGZhy{}FILE.txt
  \PYGZhy{}v, \PYGZhy{}\PYGZhy{}verbose         print progress and informational messages
  \PYGZhy{}w HTML\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}web=HTML\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}html=HTML\PYGZhy{}FILE
                        write detailed test results into HTML\PYGZhy{}FILE.html
  \PYGZhy{}x XML\PYGZhy{}FILE, \PYGZhy{}\PYGZhy{}xml=XML\PYGZhy{}FILE
                        write detailed test results into XML\PYGZhy{}FILE.xml
\end{sphinxVerbatim}

If one specifies an optional output style, one can generate detailed descriptions
of the tests and status.  Available styles are \sphinxcode{\sphinxupquote{text}} and \sphinxcode{\sphinxupquote{HTML}}.
The buildbots will select the HTML option to generate HTML test reports for the
nightly builds using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}html\PYG{o}{=}nightly.html
\end{sphinxVerbatim}

In this case, an HTML file named ‘’nightly.html’’ would be created with a pretty
summary of the testing done.  A ‘’human readable’’ format is available for users
interested in the details.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}text\PYG{o}{=}results.txt
\end{sphinxVerbatim}

In the example above, the test suite checking the \sphinxstyleemphasis{ns\sphinxhyphen{}3} wireless
device propagation loss models failed.  By default no further information is
provided.

To further explore the failure, \sphinxcode{\sphinxupquote{test.py}} allows a single test suite
to be specified.  Running the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}suite\PYG{o}{=}propagation\PYGZhy{}loss\PYGZhy{}model
\end{sphinxVerbatim}

or equivalently

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}s propagation\PYGZhy{}loss\PYGZhy{}model
\end{sphinxVerbatim}

results in that single test suite being run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FAIL: TestSuite propagation\PYGZhy{}loss\PYGZhy{}model
\end{sphinxVerbatim}

To find detailed information regarding the failure, one must specify the kind
of output desired.  For example, most people will probably be interested in
a text file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}suite\PYG{o}{=}propagation\PYGZhy{}loss\PYGZhy{}model \PYGZhy{}\PYGZhy{}text\PYG{o}{=}results.txt
\end{sphinxVerbatim}

This will result in that single test suite being run with the test status written to
the file ‘’results.txt’’.

You should find something similar to the following in that file

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FAIL: Test Suite \PYGZsq{}\PYGZsq{}propagation\PYGZhy{}loss\PYGZhy{}model\PYGZsq{}\PYGZsq{} (real 0.02 user 0.01 system 0.00)
PASS: Test Case \PYGZdq{}Check ... Friis ... model ...\PYGZdq{} (real 0.01 user 0.00 system 0.00)
FAIL: Test Case \PYGZdq{}Check ... Log Distance ... model\PYGZdq{} (real 0.01 user 0.01 system 0.00)
  Details:
    Message:   Got unexpected SNR value
    Condition: [long description of what actually failed]
    Actual:    176.395
    Limit:     176.407 +\PYGZhy{} 0.0005
    File:      ../src/test/ns3wifi/propagation\PYGZhy{}loss\PYGZhy{}models\PYGZhy{}test\PYGZhy{}suite.cc
    Line:      360
\end{sphinxVerbatim}

Notice that the Test Suite is composed of two Test Cases.  The first test case
checked the Friis propagation loss model and passed.  The second test case
failed checking the Log Distance propagation model.  In this case, an SNR of
176.395 was found, and the test expected a value of 176.407 correct to three
decimal places.  The file which implemented the failing test is listed as well
as the line of code which triggered the failure.

If you desire, you could just as easily have written an HTML file using the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}html}} option as described above.

Typically a user will run all tests at least once after downloading
\sphinxstyleemphasis{ns\sphinxhyphen{}3} to ensure that his or her environment has been built correctly
and is generating correct results according to the test suites.  Developers
will typically run the test suites before and after making a change to ensure
that they have not introduced a regression with their changes.  In this case,
developers may not want to run all tests, but only a subset.  For example,
the developer might only want to run the unit tests periodically while making
changes to a repository.  In this case, \sphinxcode{\sphinxupquote{test.py}} can be told to constrain
the types of tests being run to a particular class of tests.  The following
command will result in only the unit tests being run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}constrain\PYG{o}{=}unit
\end{sphinxVerbatim}

To see a quick list of the legal kinds of constraints, you can ask for them
to be listed.  The following command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}kinds
\end{sphinxVerbatim}

will result in the following list being displayed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
Waf: Leaving directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
\PYGZsq{}build\PYGZsq{} finished successfully (0.939s)Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
core:        Run all TestSuite\PYGZhy{}based tests (exclude examples)
example:     Examples (to see if example programs run successfully)
performance: Performance Tests (check to see if the system is as fast as expected)
system:      System Tests (spans modules to check integration of modules)
unit:        Unit Tests (within modules to check basic functionality)
\end{sphinxVerbatim}

Any of these kinds of test can be provided as a constraint using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}constraint}}
option.

To see a quick list of all of the test suites available, you can ask for them
to be listed.  The following command,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}list
\end{sphinxVerbatim}

will result in a list of the test suite being displayed, similar to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Waf: Entering directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
Waf: Leaving directory `/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build\PYGZsq{}
\PYGZsq{}build\PYGZsq{} finished successfully (0.939s)

Test Type    Test Name
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
performance  many\PYGZhy{}uniform\PYGZhy{}random\PYGZhy{}variables\PYGZhy{}one\PYGZhy{}get\PYGZhy{}value\PYGZhy{}call
performance  one\PYGZhy{}uniform\PYGZhy{}random\PYGZhy{}variable\PYGZhy{}many\PYGZhy{}get\PYGZhy{}value\PYGZhy{}calls
performance  type\PYGZhy{}id\PYGZhy{}perf
system       buildings\PYGZhy{}pathloss\PYGZhy{}test
system       buildings\PYGZhy{}shadowing\PYGZhy{}test
system       devices\PYGZhy{}mesh\PYGZhy{}dot11s\PYGZhy{}regression
system       devices\PYGZhy{}mesh\PYGZhy{}flame\PYGZhy{}regression
system       epc\PYGZhy{}gtpu
...
unit         wimax\PYGZhy{}phy\PYGZhy{}layer
unit         wimax\PYGZhy{}service\PYGZhy{}flow
unit         wimax\PYGZhy{}ss\PYGZhy{}mac\PYGZhy{}layer
unit         wimax\PYGZhy{}tlv
example      adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy
example      adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}matrix\PYGZhy{}propagation\PYGZhy{}loss\PYGZhy{}model
example      adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}with\PYGZhy{}microwave\PYGZhy{}oven
example      aodv
...
\end{sphinxVerbatim}

Any of these listed suites can be selected to be run by itself using the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}suite}} option as shown above.

To run multiple test suites at once it is possible to use a ‘Unix filename pattern matching’
style, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ../test.py \PYGZhy{}s \PYG{l+s+s1}{\PYGZsq{}ipv6*\PYGZsq{}}
\end{sphinxVerbatim}

Note the use of quotes. The result is similar to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: TestSuite ipv6\PYGZhy{}protocol
PASS: TestSuite ipv6\PYGZhy{}packet\PYGZhy{}info\PYGZhy{}tag
PASS: TestSuite ipv6\PYGZhy{}list\PYGZhy{}routing
PASS: TestSuite ipv6\PYGZhy{}extension\PYGZhy{}header
PASS: TestSuite ipv6\PYGZhy{}address\PYGZhy{}generator
PASS: TestSuite ipv6\PYGZhy{}raw
PASS: TestSuite ipv6\PYGZhy{}dual\PYGZhy{}stack
PASS: TestSuite ipv6\PYGZhy{}fragmentation
PASS: TestSuite ipv6\PYGZhy{}address\PYGZhy{}helper
PASS: TestSuite ipv6\PYGZhy{}address
PASS: TestSuite ipv6\PYGZhy{}forwarding
PASS: TestSuite ipv6\PYGZhy{}ripng
\end{sphinxVerbatim}

Similarly to test suites, one can run a single C++ example program
using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}example}} option.  Note that the relative path for the
example does not need to be included and that the executables built
for C++ examples do not have extensions.  Furthermore, the example
must be registered as an example to the test framework; it is not
sufficient to create an example and run it through test.py; it must
be added to the relevant \sphinxcode{\sphinxupquote{examples\sphinxhyphen{}to\sphinxhyphen{}run.py}} file, explained below.
Entering

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}example\PYG{o}{=}udp\PYGZhy{}echo
\end{sphinxVerbatim}

results in that single example being run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: Example examples/udp/udp\PYGZhy{}echo
\end{sphinxVerbatim}

You can specify the directory where \sphinxstyleemphasis{ns\sphinxhyphen{}3} was built using the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}buildpath}} option as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}buildpath\PYG{o}{=}/home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build/debug \PYGZhy{}\PYGZhy{}example\PYG{o}{=}wifi\PYGZhy{}simple\PYGZhy{}adhoc
\end{sphinxVerbatim}

One can run a single Python example program using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}pyexample}}
option.  Note that the relative path for the example must be included
and that Python examples do need their extensions.  Entering

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}pyexample\PYG{o}{=}examples/tutorial/first.py
\end{sphinxVerbatim}

results in that single example being run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: Example examples/tutorial/first.py
\end{sphinxVerbatim}

Because Python examples are not built, you do not need to specify the
directory where \sphinxstyleemphasis{ns\sphinxhyphen{}3} was built to run them.

Normally when example programs are executed, they write a large amount of trace
file data.  This is normally saved to the base directory of the distribution
(e.g., /home/user/ns\sphinxhyphen{}3\sphinxhyphen{}dev).  When \sphinxcode{\sphinxupquote{test.py}} runs an example, it really
is completely unconcerned with the trace files.  It just wants to to determine
if the example can be built and run without error.  Since this is the case, the
trace files are written into a \sphinxcode{\sphinxupquote{/tmp/unchecked\sphinxhyphen{}traces}} directory.  If you
run the above example, you should be able to find the associated
\sphinxcode{\sphinxupquote{udp\sphinxhyphen{}echo.tr}} and \sphinxcode{\sphinxupquote{udp\sphinxhyphen{}echo\sphinxhyphen{}n\sphinxhyphen{}1.pcap}} files there.

The list of available examples is defined by the contents of the ‘’examples’’
directory in the distribution.  If you select an example for execution using
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}example}} option, \sphinxcode{\sphinxupquote{test.py}} will not make any attempt to decide
if the example has been configured or not, it will just try to run it and
report the result of the attempt.

When \sphinxcode{\sphinxupquote{test.py}} runs, by default it will first ensure that the system has
been completely built.  This can be defeated by selecting the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}nowaf}}
option.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}list \PYGZhy{}\PYGZhy{}nowaf
\end{sphinxVerbatim}

will result in a list of the currently built test suites being displayed, similar to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
propagation\PYGZhy{}loss\PYGZhy{}model
ns3\PYGZhy{}tcp\PYGZhy{}cwnd
ns3\PYGZhy{}tcp\PYGZhy{}interoperability
pcap\PYGZhy{}file
object\PYGZhy{}name\PYGZhy{}service
random\PYGZhy{}variable\PYGZhy{}stream\PYGZhy{}generators
\end{sphinxVerbatim}

Note the absence of the \sphinxcode{\sphinxupquote{Waf}} build messages.

\sphinxcode{\sphinxupquote{test.py}} also supports running the test suites and examples under valgrind.
Valgrind is a flexible program for debugging and profiling Linux executables.  By
default, valgrind runs a tool called memcheck, which performs a range of memory\sphinxhyphen{}
checking functions, including detecting accesses to uninitialised memory, misuse
of allocated memory (double frees, access after free, etc.) and detecting memory
leaks.  This can be selected by using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}grind}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}grind
\end{sphinxVerbatim}

As it runs, \sphinxcode{\sphinxupquote{test.py}} and the programs that it runs indirectly, generate large
numbers of temporary files.  Usually, the content of these files is not interesting,
however in some cases it can be useful (for debugging purposes) to view these files.
\sphinxcode{\sphinxupquote{test.py}} provides a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}retain}} option which will cause these temporary
files to be kept after the run is completed.  The files are saved in a directory
named \sphinxcode{\sphinxupquote{testpy\sphinxhyphen{}output}} under a subdirectory named according to the current Coordinated
Universal Time (also known as Greenwich Mean Time).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}retain
\end{sphinxVerbatim}

Finally, \sphinxcode{\sphinxupquote{test.py}} provides a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}verbose}} option which will print
large amounts of information about its progress.  It is not expected that this
will be terribly useful unless there is an error.  In this case, you can get
access to the standard output and standard error reported by running test suites
and examples.  Select verbose in the following way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}verbose
\end{sphinxVerbatim}

All of these options can be mixed and matched.  For example, to run all of the
\sphinxstyleemphasis{ns\sphinxhyphen{}3} core test suites under valgrind, in verbose mode, while generating an HTML
output file, one would do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}\PYGZhy{}grind \PYGZhy{}\PYGZhy{}constrain\PYG{o}{=}core \PYGZhy{}\PYGZhy{}html\PYG{o}{=}results.html
\end{sphinxVerbatim}


\subsection{TestTaxonomy}
\label{\detokenize{test-framework:testtaxonomy}}
As mentioned above, tests are grouped into a number of broadly defined
classifications to allow users to selectively run tests to address the different
kinds of testing that need to be done.
\begin{itemize}
\item {} 
Build Verification Tests

\item {} 
Unit Tests

\item {} 
System Tests

\item {} 
Examples

\item {} 
Performance Tests

\end{itemize}

Moreover, each test is further classified according to the expected time needed to
run it. Tests are classified as:
\begin{itemize}
\item {} 
QUICK

\item {} 
EXTENSIVE

\item {} 
TAKES\_FOREVER

\end{itemize}

Note that specifying EXTENSIVE fullness will also run tests in QUICK category.
Specifying TAKES\_FOREVER will run tests in EXTENSIVE and QUICK categories.
By default, only QUICK tests are ran.

As a rule of thumb, tests that must be run to ensure \sphinxstyleemphasis{ns\sphinxhyphen{}3} coherence should be
QUICK (i.e., take a few seconds). Tests that could be skipped, but are nice to do
can be EXTENSIVE; these are tests that typically need minutes. TAKES\_FOREVER is
left for tests that take a really long time, in the order of several minutes.
The main classification goal is to be able to run the buildbots in a reasonable
time, and still be able to perform more extensive tests when needed.


\subsubsection{Unit Tests}
\label{\detokenize{test-framework:unit-tests}}
Unit tests are more involved tests that go into detail to make sure that a
piece of code works as advertised in isolation.  There is really no reason
for this kind of test to be built into an \sphinxstyleemphasis{ns\sphinxhyphen{}3} module.  It turns out, for
example, that the unit tests for the object name service are about the same
size as the object name service code itself.  Unit tests are tests that
check a single bit of functionality that are not built into the \sphinxstyleemphasis{ns\sphinxhyphen{}3} code,
but live in the same directory as the code it tests.  It is possible that
these tests check integration of multiple implementation files in a module
as well.  The file src/core/test/names\sphinxhyphen{}test\sphinxhyphen{}suite.cc is an example of this kind
of test.  The file src/network/test/pcap\sphinxhyphen{}file\sphinxhyphen{}test\sphinxhyphen{}suite.cc is another example
that uses a known good pcap file as a test vector file.  This file is stored
locally in the src/network directory.


\subsubsection{System Tests}
\label{\detokenize{test-framework:system-tests}}
System tests are those that involve more than one module in the system.  We
have lots of this kind of test running in our current regression framework,
but they are typically overloaded examples.  We provide a new place
for this kind of test in the directory \sphinxcode{\sphinxupquote{src/test}}.  The file
src/test/ns3tcp/ns3\sphinxhyphen{}interop\sphinxhyphen{}test\sphinxhyphen{}suite.cc is an example of this kind of
test.  It uses NSC TCP to test the \sphinxstyleemphasis{ns\sphinxhyphen{}3} TCP implementation.  Often there
will be test vectors required for this kind of test, and they are stored in
the directory where the test lives.  For example,
ns3tcp\sphinxhyphen{}interop\sphinxhyphen{}response\sphinxhyphen{}vectors.pcap is a file consisting of a number of TCP
headers that are used as the expected responses of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} TCP under test
to a stimulus generated by the NSC TCP which is used as a ‘’known good’’
implementation.


\subsubsection{Examples}
\label{\detokenize{test-framework:examples}}
The examples are tested by the framework to make sure they built and will
run.  Nothing is checked, and currently the pcap files are just written off
into /tmp to be discarded.  If the examples run (don’t crash) they pass this
smoke test.


\subsubsection{Performance Tests}
\label{\detokenize{test-framework:performance-tests}}
Performance tests are those which exercise a particular part of the system
and determine if the tests have executed to completion in a reasonable time.


\subsection{Running Tests}
\label{\detokenize{test-framework:running-tests}}
Tests are typically run using the high level \sphinxcode{\sphinxupquote{test.py}} program. To get a list of the available command\sphinxhyphen{}line options, run \sphinxcode{\sphinxupquote{test.py \sphinxhyphen{}\sphinxhyphen{}help}}

The test program \sphinxcode{\sphinxupquote{test.py}} will run both tests and those examples that
have been added to the list to check.  The difference between tests
and examples is as follows.  Tests generally check that specific simulation
output or events conforms to expected behavior.  In contrast, the output
of examples is not checked, and the test program merely checks the exit
status of the example program to make sure that it runs without error.

Briefly, to run all tests, first one must configure tests during configuration
stage, and also (optionally) examples if examples are to be checked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\end{sphinxVerbatim}

Then, build \sphinxstyleemphasis{ns\sphinxhyphen{}3}, and after it is built, just run \sphinxcode{\sphinxupquote{test.py}}.  \sphinxcode{\sphinxupquote{test.py \sphinxhyphen{}h}}
will show a number of configuration options that modify the behavior
of test.py.

The program \sphinxcode{\sphinxupquote{test.py}} invokes, for C++ tests and examples, a lower\sphinxhyphen{}level
C++ program called \sphinxcode{\sphinxupquote{test\sphinxhyphen{}runner}} to actually run the tests.  As discussed
below, this \sphinxcode{\sphinxupquote{test\sphinxhyphen{}runner}} can be a helpful way to debug tests.


\subsection{Debugging Tests}
\label{\detokenize{test-framework:debugging-tests}}
The debugging of the test programs is best performed running the low\sphinxhyphen{}level
test\sphinxhyphen{}runner program. The test\sphinxhyphen{}runner is the bridge from generic Python
code to \sphinxstyleemphasis{ns\sphinxhyphen{}3} code. It is written in C++ and uses the automatic test
discovery process in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} code to find and allow execution of all
of the various tests.

The main reason why \sphinxcode{\sphinxupquote{test.py}} is not suitable for debugging is that it is
not allowed for logging to be turned on using the \sphinxcode{\sphinxupquote{NS\_LOG}} environmental
variable when test.py runs.  This limitation does not apply to the test\sphinxhyphen{}runner
executable. Hence, if you want to see logging output from your tests, you
have to run them using the test\sphinxhyphen{}runner directly.

In order to execute the test\sphinxhyphen{}runner, you run it like any other \sphinxstyleemphasis{ns\sphinxhyphen{}3} executable
\textendash{} using \sphinxcode{\sphinxupquote{waf}}.  To get a list of available options, you can type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}help\PYGZdq{}}
\end{sphinxVerbatim}

You should see something like the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Usage: /home/craigdo/repos/ns\PYGZhy{}3\PYGZhy{}allinone\PYGZhy{}test/ns\PYGZhy{}3\PYGZhy{}dev/build/utils/ns3\PYGZhy{}dev\PYGZhy{}test\PYGZhy{}runner\PYGZhy{}debug [OPTIONS]

Options:
\PYGZhy{}\PYGZhy{}help                 : print these options
\PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}name\PYGZhy{}list : print the list of names of tests available
\PYGZhy{}\PYGZhy{}list                 : an alias for \PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}name\PYGZhy{}list
\PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}types     : print the type of tests along with their names
\PYGZhy{}\PYGZhy{}print\PYGZhy{}test\PYGZhy{}type\PYGZhy{}list : print the list of types of tests available
\PYGZhy{}\PYGZhy{}print\PYGZhy{}temp\PYGZhy{}dir       : print name of temporary directory before running
                         the tests
\PYGZhy{}\PYGZhy{}test\PYGZhy{}type=TYPE       : process only tests of type TYPE
\PYGZhy{}\PYGZhy{}test\PYGZhy{}name=NAME       : process only test whose name matches NAME
\PYGZhy{}\PYGZhy{}suite=NAME           : an alias (here for compatibility reasons only)
                         for \PYGZhy{}\PYGZhy{}test\PYGZhy{}name=NAME
\PYGZhy{}\PYGZhy{}assert\PYGZhy{}on\PYGZhy{}failure    : when a test fails, crash immediately (useful
                         when running under a debugger
\PYGZhy{}\PYGZhy{}stop\PYGZhy{}on\PYGZhy{}failure      : when a test fails, stop immediately
\PYGZhy{}\PYGZhy{}fullness=FULLNESS    : choose the duration of tests to run: QUICK,
                         EXTENSIVE, or TAKES\PYGZus{}FOREVER, where EXTENSIVE
                         includes QUICK and TAKES\PYGZus{}FOREVER includes
                         QUICK and EXTENSIVE (only QUICK tests are
                         run by default)
\PYGZhy{}\PYGZhy{}verbose              : print details of test execution
\PYGZhy{}\PYGZhy{}xml                  : format test run output as xml
\PYGZhy{}\PYGZhy{}tempdir=DIR          : set temp dir for tests to store output files
\PYGZhy{}\PYGZhy{}datadir=DIR          : set data dir for tests to read reference files
\PYGZhy{}\PYGZhy{}out=FILE             : send test result to FILE instead of standard output
\PYGZhy{}\PYGZhy{}append=FILE          : append test result to FILE instead of standard output
\end{sphinxVerbatim}

There are a number of things available to you which will be familiar to you if
you have looked at \sphinxcode{\sphinxupquote{test.py}}.  This should be expected since the test\sphinxhyphen{}
runner is just an interface between \sphinxcode{\sphinxupquote{test.py}} and \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  You
may notice that example\sphinxhyphen{}related commands are missing here.  That is because
the examples are really not \sphinxstyleemphasis{ns\sphinxhyphen{}3} tests.  \sphinxcode{\sphinxupquote{test.py}} runs them
as if they were to present a unified testing environment, but they are really
completely different and not to be found here.

The first new option that appears here, but not in test.py is the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}assert\sphinxhyphen{}on\sphinxhyphen{}failure}}
option.  This option is useful when debugging a test case when running under a
debugger like \sphinxcode{\sphinxupquote{gdb}}.  When selected, this option tells the underlying
test case to cause a segmentation violation if an error is detected.  This has
the nice side\sphinxhyphen{}effect of causing program execution to stop (break into the
debugger) when an error is detected.  If you are using gdb, you could use this
option something like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf shell
\PYGZdl{} \PYG{n+nb}{cd} build/utils
\PYGZdl{} gdb ns3\PYGZhy{}dev\PYGZhy{}test\PYGZhy{}runner\PYGZhy{}debug
\PYGZdl{} run \PYGZhy{}\PYGZhy{}suite\PYG{o}{=}global\PYGZhy{}value \PYGZhy{}\PYGZhy{}assert\PYGZhy{}on\PYGZhy{}failure
\end{sphinxVerbatim}

If an error is then found in the global\sphinxhyphen{}value test suite, a segfault would be
generated and the (source level) debugger would stop at the \sphinxcode{\sphinxupquote{NS\_TEST\_ASSERT\_MSG}}
that detected the error.

To run one of the tests directly from the test\sphinxhyphen{}runner
using \sphinxcode{\sphinxupquote{waf}}, you will need to specify the test suite to run.
So you could use the shell and do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}suite=pcap\PYGZhy{}file\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxstyleemphasis{ns\sphinxhyphen{}3} logging is available when you run it this way, such as:
\begin{quote}

\$ NS\_LOG=”Packet” ./waf \textendash{}run “test\sphinxhyphen{}runner \textendash{}suite=pcap\sphinxhyphen{}file”
\end{quote}


\subsubsection{Test output}
\label{\detokenize{test-framework:test-output}}
Many test suites need to write temporary files (such as pcap files)
in the process of running the tests.  The tests then need a temporary directory
to write to.  The Python test utility (test.py) will provide a temporary file
automatically, but if run stand\sphinxhyphen{}alone this temporary directory must be provided.
It can be annoying to continually have to provide
a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}tempdir}}, so the test runner will figure one out for you if you don’t
provide one.  It first looks for environment variables named \sphinxcode{\sphinxupquote{TMP}} and
\sphinxcode{\sphinxupquote{TEMP}} and uses those.  If neither \sphinxcode{\sphinxupquote{TMP}} nor \sphinxcode{\sphinxupquote{TEMP}} are defined
it picks \sphinxcode{\sphinxupquote{/tmp}}.  The code then tacks on an identifier indicating what
created the directory (ns\sphinxhyphen{}3) then the time (hh.mm.ss) followed by a large random
number.  The test runner creates a directory of that name to be used as the
temporary directory.  Temporary files then go into a directory that will be
named something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/tmp/ns\PYGZhy{}3.10.25.37.61537845
\end{sphinxVerbatim}

The time is provided as a hint so that you can relatively easily reconstruct
what directory was used if you need to go back and look at the files that were
placed in that directory.

Another class of output is test output like pcap traces that are generated
to compare to reference output.  The test program will typically delete
these after the test suites all run.  To disable the deletion of test
output, run \sphinxcode{\sphinxupquote{test.py}} with the “retain” option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}r
\end{sphinxVerbatim}

and test output can be found in the \sphinxcode{\sphinxupquote{testpy\sphinxhyphen{}output/}} directory.


\subsubsection{Reporting of test failures}
\label{\detokenize{test-framework:reporting-of-test-failures}}
When you run a test suite using the test\sphinxhyphen{}runner it will run the test
and report PASS or FAIL.
To run more quietly, you need to specify an output file to which the tests will write their status using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}out}} option.
Try,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner \PYGZhy{}\PYGZhy{}suite=pcap\PYGZhy{}file \PYGZhy{}\PYGZhy{}out=myfile.txt\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{Debugging test suite failures}
\label{\detokenize{test-framework:debugging-test-suite-failures}}
To debug test crashes, such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CRASH: TestSuite wifi\PYGZhy{}interference
\end{sphinxVerbatim}

You can access the underlying test\sphinxhyphen{}runner program via gdb as follows, and
then pass the “\textendash{}basedir=\textasciigrave{}pwd\textasciigrave{}” argument to run (you can also pass other
arguments as needed, but basedir is the minimum needed):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}gdb \PYGZpc{}s\PYGZdq{}} \PYGZhy{}\PYGZhy{}run \PYG{l+s+s2}{\PYGZdq{}test\PYGZhy{}runner\PYGZdq{}}
Waf: Entering directory \PYG{l+s+sb}{`}/home/tomh/hg/sep09/ns\PYGZhy{}3\PYGZhy{}allinone/ns\PYGZhy{}3\PYGZhy{}dev\PYGZhy{}678/build\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{Waf: Leaving directory `/home/tomh/hg/sep09/ns\PYGZhy{}3\PYGZhy{}allinone/ns\PYGZhy{}3\PYGZhy{}dev\PYGZhy{}678/build\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}build\PYGZsq{}} finished successfully \PYG{o}{(}\PYG{l+m}{0}.380s\PYG{o}{)}
GNU gdb \PYG{l+m}{6}.8\PYGZhy{}debian
Copyright \PYG{o}{(}C\PYG{o}{)} \PYG{l+m}{2008} Free Software Foundation, Inc.
L cense GPLv3+: GNU GPL version \PYG{l+m}{3} or later \PYGZlt{}http://gnu.org/licenses/gpl.html\PYGZgt{}
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type \PYG{l+s+s2}{\PYGZdq{}show copying\PYGZdq{}}
and \PYG{l+s+s2}{\PYGZdq{}show warranty\PYGZdq{}} \PYG{k}{for} details.
This GDB was configured as \PYG{l+s+s2}{\PYGZdq{}x86\PYGZus{}64\PYGZhy{}linux\PYGZhy{}gnu\PYGZdq{}}...
\PYG{o}{(}gdb\PYG{o}{)} r \PYGZhy{}\PYGZhy{}suite\PYG{o}{=}
Starting program: \PYGZlt{}..\PYGZgt{}/build/utils/ns3\PYGZhy{}dev\PYGZhy{}test\PYGZhy{}runner\PYGZhy{}debug \PYGZhy{}\PYGZhy{}suite\PYG{o}{=}wifi\PYGZhy{}interference
\PYG{o}{[}Thread debugging using libthread\PYGZus{}db enabled\PYG{o}{]}
assert failed. \PYG{n+nv}{file}\PYG{o}{=}../src/core/model/type\PYGZhy{}id.cc, \PYG{n+nv}{line}\PYG{o}{=}\PYG{l+m}{138}, \PYG{n+nv}{cond}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}uid \PYGZlt{}= m\PYGZus{}information.size () \PYGZam{}\PYGZam{} uid != 0\PYGZdq{}}
...
\end{sphinxVerbatim}

Here is another example of how to use valgrind to debug a memory problem
such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
VALGR: TestSuite devices\PYGZhy{}mesh\PYGZhy{}dot11s\PYGZhy{}regression

\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}valgrind \PYGZpc{}s \PYGZhy{}\PYGZhy{}suite=devices\PYGZhy{}mesh\PYGZhy{}dot11s\PYGZhy{}regression\PYGZdq{}} \PYGZhy{}\PYGZhy{}run test\PYGZhy{}runner
\end{sphinxVerbatim}


\subsection{Class TestRunner}
\label{\detokenize{test-framework:class-testrunner}}
The executables that run dedicated test programs use a TestRunner class.  This
class provides for automatic test registration and listing, as well as a way to
execute the individual tests.  Individual test suites use C++ global
constructors
to add themselves to a collection of test suites managed by the test runner.
The test runner is used to list all of the available tests and to select a test
to be run.  This is a quite simple class that provides three static methods to
provide or Adding and Getting test suites to a collection of tests.  See the
doxygen for class \sphinxcode{\sphinxupquote{ns3::TestRunner}} for details.


\subsection{Test Suite}
\label{\detokenize{test-framework:test-suite}}
All \sphinxstyleemphasis{ns\sphinxhyphen{}3} tests are classified into Test Suites and Test Cases.  A
test suite is a collection of test cases that completely exercise a given kind
of functionality.  As described above, test suites can be classified as,
\begin{itemize}
\item {} 
Build Verification Tests

\item {} 
Unit Tests

\item {} 
System Tests

\item {} 
Examples

\item {} 
Performance Tests

\end{itemize}

This classification is exported from the TestSuite class.  This class is quite
simple, existing only as a place to export this type and to accumulate test
cases.  From a user perspective, in order to create a new TestSuite in the
system one only has to define a new class that inherits from class \sphinxcode{\sphinxupquote{TestSuite}}
and perform these two duties.

The following code will define a new class that can be run by \sphinxcode{\sphinxupquote{test.py}}
as a ‘’unit’’ test with the display name, \sphinxcode{\sphinxupquote{my\sphinxhyphen{}test\sphinxhyphen{}suite\sphinxhyphen{}name}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MySuite} \PYG{o}{:} \PYG{k}{public} \PYG{n}{TestSuite}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{MyTestSuite} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{MyTestSuite}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyTestSuite} \PYG{p}{(}\PYG{p}{)}
  \PYG{o}{:} \PYG{n}{TestSuite} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZhy{}test\PYGZhy{}suite\PYGZhy{}name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{UNIT}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{AddTestCase} \PYG{p}{(}\PYG{k}{new} \PYG{n}{MyTestCase}\PYG{p}{,} \PYG{n}{TestCase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{QUICK}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static} \PYG{n}{MyTestSuite} \PYG{n}{myTestSuite}\PYG{p}{;}
\end{sphinxVerbatim}

The base class takes care of all of the registration and reporting required to
be a good citizen in the test framework.

Avoid putting initialization logic into the test suite or test case
constructors.  This is
because an instance of the test suite is created at run time
(due to the static variable above) regardless of whether the test is being
run or not.  Instead, the TestCase provides a virtual \sphinxcode{\sphinxupquote{DoSetup}} method
that can be specialized to perform setup before \sphinxcode{\sphinxupquote{DoRun}} is called.


\subsection{Test Case}
\label{\detokenize{test-framework:test-case}}
Individual tests are created using a TestCase class.  Common models for the use
of a test case include “one test case per feature”, and “one test case per method.”
Mixtures of these models may be used.

In order to create a new test case in the system, all one has to do is to inherit
from the  \sphinxcode{\sphinxupquote{TestCase}} base class, override the constructor to give the test
case a name and override the \sphinxcode{\sphinxupquote{DoRun}} method to run the test.  Optionally,
override also the \sphinxcode{\sphinxupquote{DoSetup}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyTestCase} \PYG{o}{:} \PYG{k}{public} \PYG{n}{TestCase}
\PYG{p}{\PYGZob{}}
  \PYG{n}{MyTestCase} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{DoSetup} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{DoRun} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{MyTestCase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyTestCase} \PYG{p}{(}\PYG{p}{)}
  \PYG{o}{:} \PYG{n}{TestCase} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Check some bit of functionality}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}
\PYG{n}{MyTestCase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DoRun} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}EQ} \PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Some failure message}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Utilities}
\label{\detokenize{test-framework:utilities}}
There are a number of utilities of various kinds that are also part of the
testing framework.  Examples include a generalized pcap file useful for
storing test vectors; a generic container useful for transient storage of
test vectors during test execution; and tools for generating presentations
based on validation and verification testing results.

These utilities are not documented here, but for example, please see
how the TCP tests found in \sphinxcode{\sphinxupquote{src/test/ns3tcp/}} use pcap files and reference
output.


\section{How to write tests}
\label{\detokenize{how-to-write-tests:how-to-write-tests}}\label{\detokenize{how-to-write-tests::doc}}
A primary goal of the ns\sphinxhyphen{}3 project is to help users to improve the
validity and credibility of their results.  There are many elements
to obtaining valid models and simulations, and testing is a major
component.  If you contribute models or examples to ns\sphinxhyphen{}3, you may
be asked to contribute test code.  Models that you contribute will be
used for many years by other people, who probably have no idea upon
first glance whether the model is correct.  The test code that you
write for your model will help to avoid future regressions in
the output and will aid future users in understanding the verification
and bounds of applicability of your models.

There are many ways to verify the correctness of a model’s implementation.
In this section,
we hope to cover some common cases that can be used as a guide to
writing new tests.


\subsection{Sample TestSuite skeleton}
\label{\detokenize{how-to-write-tests:sample-testsuite-skeleton}}
When starting from scratch (i.e. not adding a TestCase to an existing
TestSuite), these things need to be decided up front:
\begin{itemize}
\item {} 
What the test suite will be called

\item {} 
What type of test it will be (Build Verification Test, Unit Test,
System Test, or Performance Test)

\item {} 
Where the test code will live (either in an existing ns\sphinxhyphen{}3 module or
separately in src/test/ directory).  You will have to edit the wscript
file in that directory to compile your new code, if it is a new file.

\end{itemize}

A program called \sphinxcode{\sphinxupquote{src/create\sphinxhyphen{}module.py}} is a good starting point.
This program can be invoked such as \sphinxcode{\sphinxupquote{create\sphinxhyphen{}module.py router}} for
a hypothetical new module called \sphinxcode{\sphinxupquote{router}}.  Once you do this, you
will see a \sphinxcode{\sphinxupquote{router}} directory, and a \sphinxcode{\sphinxupquote{test/router\sphinxhyphen{}test\sphinxhyphen{}suite.cc}}
test suite.  This file can be a starting point for your initial test.
This is a working test suite, although the actual tests performed are
trivial.  Copy it over to your module’s test directory, and do a global
substitution of “Router” in that file for something pertaining to
the model that you want to test.  You can also edit things such as a
more descriptive test case name.

You also need to add a block into your wscript to get this test to
compile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module\PYGZus{}test}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/router\PYGZhy{}test\PYGZhy{}suite.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{]}
\end{sphinxVerbatim}

Before you actually start making this do useful things, it may help
to try to run the skeleton.  Make sure that ns\sphinxhyphen{}3 has been configured with
the “\textendash{}enable\sphinxhyphen{}tests” option.  Let’s assume that your new test suite
is called “router” such as here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RouterTestSuite}\PYG{o}{:}\PYG{o}{:}\PYG{n}{RouterTestSuite} \PYG{p}{(}\PYG{p}{)}
  \PYG{o}{:} \PYG{n}{TestSuite} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{router}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{UNIT}\PYG{p}{)}
\end{sphinxVerbatim}

Try this command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test.py \PYGZhy{}s router
\end{sphinxVerbatim}

Output such as below should be produced:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PASS: TestSuite router
1 of 1 tests passed (1 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

See src/lte/test/test\sphinxhyphen{}lte\sphinxhyphen{}antenna.cc for a worked example.


\subsection{Test macros}
\label{\detokenize{how-to-write-tests:test-macros}}
There are a number of macros available for checking test program
output with expected output.  These macros are defined in
\sphinxcode{\sphinxupquote{src/core/model/test.h}}.

The main set of macros that are used include the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}EQ}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}NE}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}LT}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}GT}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}
\PYG{n}{NS\PYGZus{}TEST\PYGZus{}ASSERT\PYGZus{}MSG\PYGZus{}EQ\PYGZus{}TOL}\PYG{p}{(}\PYG{n}{actual}\PYG{p}{,} \PYG{n}{limit}\PYG{p}{,} \PYG{n}{tol}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}
\end{sphinxVerbatim}

The first argument \sphinxcode{\sphinxupquote{actual}} is the value under test, the second value
\sphinxcode{\sphinxupquote{limit}} is the expected value (or the value to test against), and the
last argument \sphinxcode{\sphinxupquote{msg}} is the error message to print out if the test fails.

The first four macros above test for equality, inequality, less than, or
greater than, respectively.  The fifth macro above tests for equality,
but within a certain tolerance.  This variant is useful when testing
floating point numbers for equality against a limit, where you want to
avoid a test failure due to rounding errors.

Finally, there are variants of the above where the keyword \sphinxcode{\sphinxupquote{ASSERT}}
is replaced by \sphinxcode{\sphinxupquote{EXPECT}}.  These variants are designed specially for
use in methods (especially callbacks) returning void.  Reserve their
use for callbacks that you use in your test programs; otherwise,
use the \sphinxcode{\sphinxupquote{ASSERT}} variants.


\subsection{How to add an example program to the test suite}
\label{\detokenize{how-to-write-tests:how-to-add-an-example-program-to-the-test-suite}}
One can “smoke test” that examples compile and run successfully
to completion (without memory leaks) using the \sphinxcode{\sphinxupquote{examples\sphinxhyphen{}to\sphinxhyphen{}run.py}}
script located in your module’s test directory.  Briefly, by including
an instance of this file in your test directory, you can cause the
test runner to execute the examples listed.  It is usually best to make
sure that you select examples that have reasonably short run times so as
to not bog down the tests.  See the example in \sphinxcode{\sphinxupquote{src/lte/test/}}
directory.


\subsection{Testing for boolean outcomes}
\label{\detokenize{how-to-write-tests:testing-for-boolean-outcomes}}

\subsection{Testing outcomes when randomness is involved}
\label{\detokenize{how-to-write-tests:testing-outcomes-when-randomness-is-involved}}

\subsection{Testing output data against a known distribution}
\label{\detokenize{how-to-write-tests:testing-output-data-against-a-known-distribution}}

\subsection{Providing non\sphinxhyphen{}trivial input vectors of data}
\label{\detokenize{how-to-write-tests:providing-non-trivial-input-vectors-of-data}}

\subsection{Storing and referencing non\sphinxhyphen{}trivial output data}
\label{\detokenize{how-to-write-tests:storing-and-referencing-non-trivial-output-data}}

\subsection{Presenting your output test data}
\label{\detokenize{how-to-write-tests:presenting-your-output-test-data}}

\chapter{Support}
\label{\detokenize{support:support}}\label{\detokenize{support::doc}}

\section{Creating a new \sphinxstyleemphasis{ns\sphinxhyphen{}3} model}
\label{\detokenize{new-models:creating-a-new-ns3-model}}\label{\detokenize{new-models::doc}}
This chapter walks through the design process of an \sphinxstyleemphasis{ns\sphinxhyphen{}3} model.  In many
research cases, users will not be satisfied to merely adapt existing models, but
may want to extend the core of the simulator in a novel way. We will use the
example of adding an ErrorModel to a simple \sphinxstyleemphasis{ns\sphinxhyphen{}3} link as a motivating example
of how one might approach this problem and proceed through a design and
implementation.

\begin{sphinxadmonition}{note}{Note:}
Documentation

Here we focus on the process of creating new models
and new modules, and some of the design choices involved.
For the sake of clarity, we defer discussion of the
\sphinxstyleemphasis{mechanics} of documenting models and source code to the
{\hyperref[\detokenize{documentation::doc}]{\sphinxcrossref{\DUrole{doc}{Documentation}}}} chapter.
\end{sphinxadmonition}


\subsection{Design Approach}
\label{\detokenize{new-models:design-approach}}
Consider how you want it to work; what should it do. Think about these things:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{functionality:}  What functionality should it have?  What attributes or
configuration is exposed to the user?

\item {} 
\sphinxstyleemphasis{reusability:}  How much should others be able to reuse my design?  Can I
reuse code from \sphinxstyleemphasis{ns\sphinxhyphen{}2} to get started?  How does a user integrate the model
with the rest of another simulation?

\item {} 
\sphinxstyleemphasis{dependencies:}  How can I reduce the introduction of outside dependencies on
my new code as much as possible (to make it more modular)?  For instance,
should I avoid any dependence on IPv4 if I want it to also be used by IPv6?
Should I avoid any dependency on IP at all?

\end{itemize}

Do not be hesitant to contact the \sphinxtitleref{ns\sphinxhyphen{}3\sphinxhyphen{}users} or \sphinxtitleref{ns\sphinxhyphen{}developers} list if you have
questions. In particular, it is important to think about the public API of your
new model and ask for feedback. It also helps to let others know of your work in
case you are interested in collaborators.


\subsubsection{Example: \sphinxtitleref{ErrorModel}}
\label{\detokenize{new-models:example-errormodel}}
An error model exists in \sphinxstyleemphasis{ns\sphinxhyphen{}2}. It allows packets to be passed to a stateful
object that determines, based on a random variable, whether the packet is
corrupted.  The caller can then decide what to do with the packet (drop it,
etc.).

The main API of the error model is a function to pass a packet to, and the
return value of this function is a boolean that tells the caller whether any
corruption occurred.  Note that depending on the error model, the packet data
buffer may or may not be corrupted.  Let’s call this function “IsCorrupt()”.

So far, in our design, we have:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
 \PYG{c+cm}{/**}
\PYG{c+cm}{  * \PYGZbs{}returns true if the Packet is to be considered as errored/corrupted}
\PYG{c+cm}{  * \PYGZbs{}param pkt Packet to apply error model to}
\PYG{c+cm}{  */}
  \PYG{k+kt}{bool} \PYG{n}{IsCorrupt} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Note that we do not pass a const pointer, thereby allowing the function to
modify the packet if IsCorrupt() returns true. Not all error models will
actually modify the packet; whether or not the packet data buffer is corrupted
should be documented.

We may also want specialized versions of this, such as in \sphinxstyleemphasis{ns\sphinxhyphen{}2}, so although it
is not the only design choice for polymorphism, we assume that we will subclass
a base class ErrorModel for specialized classes, such as RateErrorModel,
ListErrorModel, etc, such as is done in \sphinxstyleemphasis{ns\sphinxhyphen{}2}.

You may be thinking at this point, “Why not make IsCorrupt() a virtual method?”.
That is one approach; the other is to make the public non\sphinxhyphen{}virtual function
indirect through a private virtual function (this in C++ is known as the non
virtual interface idiom and is adopted in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} ErrorModel class).

Next, should this device have any dependencies on IP or other protocols?  We do
not want to create dependencies on Internet protocols (the error model should be
applicable to non\sphinxhyphen{}Internet protocols too), so we’ll keep that in mind later.

Another consideration is how objects will include this error model.  We envision
putting an explicit setter in certain NetDevice implementations, for example.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * Attach a receive ErrorModel to the PointToPointNetDevice.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The PointToPointNetDevice may optionally include an ErrorModel in}
\PYG{c+cm}{ * the packet receive chain.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @see ErrorModel}
\PYG{c+cm}{ * @param em Ptr to the ErrorModel.}
\PYG{c+cm}{ */}
\PYG{k+kt}{void} \PYG{n}{PointToPointNetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetReceiveErrorModel}\PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{n}{em}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Again, this is not the only choice we have (error models could be aggregated to
lots of other objects), but it satisfies our primary use case, which is to allow
a user to force errors on otherwise successful packet transmissions, at the
NetDevice level.

After some thinking and looking at existing \sphinxstyleemphasis{ns\sphinxhyphen{}2} code, here is a sample API of
a base class and first subclass that could be posted for initial review:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{ErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{ErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{bool} \PYG{n+nf}{IsCorrupt} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{Reset} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{Enable} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{Disable} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{bool} \PYG{n+nf}{IsEnabled} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n}{DoCorrupt} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{pkt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{DoReset} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{enum} \PYG{n}{ErrorUnit}
  \PYG{p}{\PYGZob{}}
    \PYG{n}{EU\PYGZus{}BIT}\PYG{p}{,}
    \PYG{n}{EU\PYGZus{}BYTE}\PYG{p}{,}
    \PYG{n}{EU\PYGZus{}PKT}
  \PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Determine which packets are errored corresponding to an underlying}
\PYG{c+c1}{// random variable distribution, an error rate, and unit for the rate.}
\PYG{k}{class} \PYG{n+nc}{RateErrorModel} \PYG{o}{:} \PYG{k}{public} \PYG{n}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{n}{RateErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{RateErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{enum} \PYG{n}{ErrorUnit} \PYG{n+nf}{GetUnit} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{SetUnit} \PYG{p}{(}\PYG{k}{enum} \PYG{n}{ErrorUnit} \PYG{n}{error\PYGZus{}unit}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n+nf}{GetRate} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{SetRate} \PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{rate}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{n+nf}{SetRandomVariable} \PYG{p}{(}\PYG{k}{const} \PYG{n}{RandomVariable} \PYG{o}{\PYGZam{}}\PYG{n}{ranvar}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{private}\PYG{o}{:}
  \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n}{DoCorrupt} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{pkt}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{DoReset} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Scaffolding}
\label{\detokenize{new-models:scaffolding}}
Let’s say that you are ready to start implementing; you have a fairly clear
picture of what you want to build, and you may have solicited some initial
review or suggestions from the list.  One way to approach the next step
(implementation) is to create scaffolding and fill in the details as the design
matures.

This section walks through many of the steps you should consider to define
scaffolding, or a non\sphinxhyphen{}functional skeleton of what your model will eventually
implement. It is usually good practice to not wait to get these details
integrated at the end, but instead to plumb a skeleton of your model into the
system early and then add functions later once the API and integration seems
about right.

Note that you will want to modify a few things in the below presentation for
your model since if you follow the error model verbatim, the code you produce
will collide with the existing error model. The below is just an outline of how
ErrorModel was built that you can adapt to other models.


\subsubsection{Review the \sphinxstyleemphasis{ns\sphinxhyphen{}3} Coding Style Document}
\label{\detokenize{new-models:review-the-ns3-coding-style-document}}
At this point, you may want to pause and read the \sphinxstyleemphasis{ns\sphinxhyphen{}3} coding style document,
especially if you are considering to contribute your code back to the project.
The coding style document is linked off the main project page: \sphinxhref{http://www.nsnam.org/developers/contributing-code/coding-style/}{ns\sphinxhyphen{}3 coding
style}.


\subsubsection{Decide Where in the Source Tree the Model Should Reside}
\label{\detokenize{new-models:decide-where-in-the-source-tree-the-model-should-reside}}
All of the \sphinxstyleemphasis{ns\sphinxhyphen{}3} model source code is in the directory \sphinxcode{\sphinxupquote{src/}}.  You will need
to choose which subdirectory it resides in. If it is new model code of some
sort, it makes sense to put it into the \sphinxcode{\sphinxupquote{src/}} directory somewhere,
particularly for ease of integrating with the build system.

In the case of the error model, it is very related to the packet class, so it
makes sense to implement this in the \sphinxcode{\sphinxupquote{src/network/}} module where \sphinxstyleemphasis{ns\sphinxhyphen{}3}
packets are implemented.


\subsubsection{\sphinxtitleref{waf} and \sphinxtitleref{wscript}}
\label{\detokenize{new-models:waf-and-wscript}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the \sphinxhref{http://www.freehackers.org/~tnagy/waf.html}{Waf} build system.
You will want to integrate your new \sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the Waf build system. You will
want to integrate your new source files into this system. This requires that you
add your files to the \sphinxcode{\sphinxupquote{wscript}} file found in each directory.

Let’s start with empty files error\sphinxhyphen{}model.h and error\sphinxhyphen{}model.cc, and add this to
\sphinxcode{\sphinxupquote{src/network/wscript}}. It is really just a matter of adding the .cc file to the
rest of the source files, and the .h file to the list of the header files.

Now, pop up to the top level directory and type “./test.py”.  You
shouldn’t have broken anything by this operation.


\subsubsection{Include Guards}
\label{\detokenize{new-models:include-guards}}
Next, let’s add some \sphinxhref{http://en.wikipedia.org/wiki/Include\_guard}{include guards} in our header file.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsubsection{\sphinxtitleref{namespace ns3}}
\label{\detokenize{new-models:namespace-ns3}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} uses the \sphinxstyleemphasis{ns\sphinxhyphen{}3} \sphinxhref{http://en.wikipedia.org/wiki/Namespace\_(computer\_science)\#Use\_in\_common\_languages}{namespace}
to isolate its symbols from other namespaces. Typically, a user will next put
an \sphinxstyleemphasis{ns\sphinxhyphen{}3} namespace block in both the cc and h file.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

At this point, we have some skeletal files in which we can start defining
our new classes. The header file looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ERROR\PYGZus{}MODEL\PYGZus{}H}

\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// namespace ns3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

while the \sphinxcode{\sphinxupquote{error\sphinxhyphen{}model.cc}} file simply looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}error\PYGZhy{}model.h\PYGZdq{}}

\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// namespace ns3}
\end{sphinxVerbatim}

These files should compile since they don’t really have any contents.  We’re now
ready to start adding classes.


\subsection{Initial Implementation}
\label{\detokenize{new-models:initial-implementation}}
At this point, we’re still working on some scaffolding, but we can begin to
define our classes, with the functionality to be added later.


\subsubsection{Inherit from the \sphinxtitleref{Object} Class?}
\label{\detokenize{new-models:inherit-from-the-object-class}}
This is an important design step; whether to use class \sphinxcode{\sphinxupquote{Object}} as a
base class for your new classes.

As described in the chapter on the \sphinxstyleemphasis{ns\sphinxhyphen{}3} {\hyperref[\detokenize{object-model:object-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Object model}}}}, classes that
inherit from class \sphinxcode{\sphinxupquote{Object}} get special properties:
\begin{itemize}
\item {} 
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} type and attribute system (see {\hyperref[\detokenize{attributes:attributes}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration and Attributes}}}})

\item {} 
an object aggregation system

\item {} 
a smart\sphinxhyphen{}pointer reference counting system (class Ptr)

\end{itemize}

Classes that derive from class \sphinxcode{\sphinxupquote{ObjectBase}}\} get the first two
properties above, but do not get smart pointers. Classes that derive from class
\sphinxcode{\sphinxupquote{RefCountBase}} get only the smart\sphinxhyphen{}pointer reference counting system.

In practice, class \sphinxcode{\sphinxupquote{Object}} is the variant of the three above that
the \sphinxstyleemphasis{ns\sphinxhyphen{}3} developer will most commonly encounter.

In our case, we want to make use of the attribute system, and we will be passing
instances of this object across the \sphinxstyleemphasis{ns\sphinxhyphen{}3} public API, so class
\sphinxcode{\sphinxupquote{Object}} is appropriate for us.


\subsubsection{Initial Classes}
\label{\detokenize{new-models:initial-classes}}
One way to proceed is to start by defining the bare minimum functions and see if
they will compile. Let’s review what all is needed to implement when we derive
from class Object.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ERROR\PYGZus{}MODEL\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ERROR\PYGZus{}MODEL\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/object.h\PYGZdq{}}

\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}

\PYG{k}{class} \PYG{n+nc}{ErrorModel} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Object}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{ErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{ErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{RateErrorModel} \PYG{o}{:} \PYG{k}{public} \PYG{n}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{RateErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{RateErrorModel} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

A few things to note here. We need to include \sphinxcode{\sphinxupquote{object.h}}. The convention in
\sphinxstyleemphasis{ns\sphinxhyphen{}3} is that if the header file is co\sphinxhyphen{}located in the same directory, it may be
included without any path prefix. Therefore, if we were implementing ErrorModel
in \sphinxcode{\sphinxupquote{src/core/model}} directory, we could have just said “\sphinxcode{\sphinxupquote{\#include "object.h"}}”.
But we are in \sphinxcode{\sphinxupquote{src/network/model}}, so we must include it as “\sphinxcode{\sphinxupquote{\#include
"ns3/object.h"}}”. Note also that this goes outside the namespace declaration.

Second, each class must implement a static public member function called
\sphinxcode{\sphinxupquote{GetTypeId (void)}}.

Third, it is a good idea to implement constructors and destructors rather than
to let the compiler generate them, and to make the destructor virtual. In C++,
note also that copy assignment operator and copy constructors are auto\sphinxhyphen{}generated
if they are not defined, so if you do not want those, you should implement those
as private members. This aspect of C++ is discussed in Scott Meyers’ Effective
C++ book. item 45.

Let’s now look at some corresponding skeletal implementation code in the .cc
file.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}error\PYGZhy{}model.h\PYGZdq{}}

\PYG{k}{namespace} \PYG{n}{ns3} \PYG{p}{\PYGZob{}}

\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED} \PYG{p}{(}\PYG{n}{ErrorModel}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId} \PYG{n}{ErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::ErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{;}
  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ErrorModel} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{ErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{ErrorModel} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{NS\PYGZus{}OBJECT\PYGZus{}ENSURE\PYGZus{}REGISTERED} \PYG{p}{(}\PYG{n}{RateErrorModel}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{TypeId} \PYG{n}{RateErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RateErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{RateErrorModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{;}
  \PYG{k}{return} \PYG{n}{tid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{RateErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{RateErrorModel} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{RateErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{RateErrorModel} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

What is the \sphinxcode{\sphinxupquote{GetTypeId (void)}} function? This function does a few things.  It
registers a unique string into the TypeId system. It establishes  the hierarchy
of objects in the attribute system (via \sphinxcode{\sphinxupquote{SetParent}}). It also declares that
certain objects can be created via the object creation framework
(\sphinxcode{\sphinxupquote{AddConstructor}}).

The macro \sphinxcode{\sphinxupquote{NS\_OBJECT\_ENSURE\_REGISTERED (classname)}} is needed also once for
every class that defines a new GetTypeId method, and it does the actual
registration of the class into the system.  The {\hyperref[\detokenize{object-model:object-model}]{\sphinxcrossref{\DUrole{std,std-ref}{Object model}}}} chapter
discusses this in more detail.


\subsubsection{Including External Files}
\label{\detokenize{new-models:including-external-files}}

\subsubsection{Logging Support}
\label{\detokenize{new-models:logging-support}}
\sphinxstyleemphasis{Here, write a bit about adding |ns3| logging macros. Note that
LOG\_COMPONENT\_DEFINE is done outside the namespace ns3}


\subsubsection{Constructor, Empty Function Prototypes}
\label{\detokenize{new-models:constructor-empty-function-prototypes}}

\subsubsection{Key Variables (Default Values, Attributes)}
\label{\detokenize{new-models:key-variables-default-values-attributes}}

\subsubsection{Test Program 1}
\label{\detokenize{new-models:test-program-1}}

\subsubsection{Object Framework}
\label{\detokenize{new-models:object-framework}}

\subsection{Adding a Sample Script}
\label{\detokenize{new-models:adding-a-sample-script}}
At this point, one may want to try to take the basic scaffolding defined above
and add it into the system. Performing this step now allows one to use a simpler
model when plumbing into the system and may also reveal whether any design or
API modifications need to be made. Once this is done, we will return to building
out the functionality of the ErrorModels themselves.


\subsubsection{Add Basic Support in the Class}
\label{\detokenize{new-models:add-basic-support-in-the-class}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* point\PYGZhy{}to\PYGZhy{}point\PYGZhy{}net\PYGZhy{}device.h */}
  \PYG{k}{class} \PYG{n+nc}{ErrorModel}\PYG{p}{;}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * Error model for receive packet events}
\PYG{c+cm}{   */}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Add Accessor}
\label{\detokenize{new-models:add-accessor}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n}{PointToPointNetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetReceiveErrorModel} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{n}{em}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION} \PYG{p}{(}\PYG{k}{this} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{em}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{m\PYGZus{}receiveErrorModel} \PYG{o}{=} \PYG{n}{em}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

   \PYG{p}{.}\PYG{n}{AddAttribute} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ReceiveErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The receiver error model used to simulate packet loss}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{n}{PointerValue} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakePointerAccessor} \PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{MakePointerChecker}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Plumb Into the System}
\label{\detokenize{new-models:plumb-into-the-system}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{PointToPointNetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Receive} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{packet}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION} \PYG{p}{(}\PYG{k}{this} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{packet}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{uint16\PYGZus{}t} \PYG{n}{protocol} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

  \PYG{k}{if} \PYG{p}{(}\PYG{n}{m\PYGZus{}receiveErrorModel} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{m\PYGZus{}receiveErrorModel}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{IsCorrupt} \PYG{p}{(}\PYG{n}{packet}\PYG{p}{)} \PYG{p}{)}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//}
\PYG{c+c1}{// If we have an error model and it indicates that it is time to lose a}
\PYG{c+c1}{// corrupted packet, don\PYGZsq{}t forward this packet up, let it go.}
\PYG{c+c1}{//}
      \PYG{n}{m\PYGZus{}dropTrace} \PYG{p}{(}\PYG{n}{packet}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//}
\PYG{c+c1}{// Hit the receive trace hook, strip off the point\PYGZhy{}to\PYGZhy{}point protocol header}
\PYG{c+c1}{// and forward this packet up the protocol stack.}
\PYG{c+c1}{//}
      \PYG{n}{m\PYGZus{}rxTrace} \PYG{p}{(}\PYG{n}{packet}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ProcessHeader}\PYG{p}{(}\PYG{n}{packet}\PYG{p}{,} \PYG{n}{protocol}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}rxCallback} \PYG{p}{(}\PYG{k}{this}\PYG{p}{,} \PYG{n}{packet}\PYG{p}{,} \PYG{n}{protocol}\PYG{p}{,} \PYG{n}{GetRemote} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{m\PYGZus{}promiscCallback}\PYG{p}{.}\PYG{n}{IsNull} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}           \PYG{n}{m\PYGZus{}promiscCallback} \PYG{p}{(}\PYG{k}{this}\PYG{p}{,} \PYG{n}{packet}\PYG{p}{,} \PYG{n}{protocol}\PYG{p}{,} \PYG{n}{GetRemote} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                      \PYG{n}{GetAddress} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{NetDevice}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PACKET\PYGZus{}HOST}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Create Null Functional Script}
\label{\detokenize{new-models:create-null-functional-script}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* simple\PYGZhy{}error\PYGZhy{}model.cc */}

  \PYG{c+c1}{// Error model}
  \PYG{c+c1}{// We want to add an error model to node 3\PYGZsq{}s NetDevice}
  \PYG{c+c1}{// We can obtain a handle to the NetDevice via the channel and node}
  \PYG{c+c1}{// pointers}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{PointToPointNetDevice}\PYG{o}{\PYGZgt{}} \PYG{n}{nd3} \PYG{o}{=} \PYG{n}{PointToPointTopology}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetNetDevice}
    \PYG{p}{(}\PYG{n}{n3}\PYG{p}{,} \PYG{n}{channel2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{n}{em} \PYG{o}{=} \PYG{n}{Create}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{nd3}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{SetReceiveErrorModel} \PYG{p}{(}\PYG{n}{em}\PYG{p}{)}\PYG{p}{;}


\PYG{k+kt}{bool}
\PYG{n}{ErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DoCorrupt} \PYG{p}{(}\PYG{n}{Packet}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}FUNCTION}\PYG{p}{;}
  \PYG{n}{NS\PYGZus{}LOG\PYGZus{}UNCOND}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Corrupt!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

At this point, we can run the program with our trivial ErrorModel plumbed into
the receive path of the PointToPointNetDevice. It prints out the string
“Corrupt!” for each packet received at node n3. Next, we return to the error
model to add in a subclass that performs more interesting error modeling.


\subsection{Add a Subclass}
\label{\detokenize{new-models:add-a-subclass}}
The trivial base class ErrorModel does not do anything interesting, but it
provides a useful base class interface (Corrupt () and Reset ()), forwarded to
virtual functions that can be subclassed. Let’s next consider what we call a
BasicErrorModel which is based on the \sphinxstyleemphasis{ns\sphinxhyphen{}2} ErrorModel class (in
\sphinxcode{\sphinxupquote{ns\sphinxhyphen{}2/queue/errmodel.\{cc,h\}}}).

What properties do we want this to have, from a user interface perspective? We
would like for the user to be able to trivially swap out the type of ErrorModel
used in the NetDevice. We would also like the capability to set configurable
parameters.

Here are a few simple requirements we will consider:
\begin{itemize}
\item {} 
Ability to set the random variable that governs the losses (default is
UniformVariable)

\item {} 
Ability to set the unit (bit, byte, packet, time) of granularity over which
errors are applied.

\item {} 
Ability to set the rate of errors (e.g. 10\textasciicircum{}\sphinxhyphen{}3) corresponding to the above unit
of granularity.

\item {} 
Ability to enable/disable (default is enabled)

\end{itemize}


\subsubsection{How to Subclass}
\label{\detokenize{new-models:how-to-subclass}}
We declare BasicErrorModel to be a subclass of ErrorModel as follows,:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{BasicErrorModel} \PYG{o}{:} \PYG{k}{public} \PYG{n}{ErrorModel}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{private}\PYG{o}{:}
  \PYG{c+c1}{// Implement base class pure virtual functions}
  \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n}{DoCorrupt} \PYG{p}{(}\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Packet}\PYG{o}{\PYGZgt{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{DoReset} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

and configure the subclass GetTypeId function by setting a unique TypeId string
and setting the Parent to ErrorModel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TypeId} \PYG{n}{RateErrorModel}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{static} \PYG{n}{TypeId} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{TypeId} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ns3::RateErrorModel}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetParent}\PYG{o}{\PYGZlt{}}\PYG{n}{ErrorModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{SetGroupName} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Network}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{.}\PYG{n}{AddConstructor}\PYG{o}{\PYGZlt{}}\PYG{n}{RateErrorModel}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{p}{)}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}


\subsection{Build Core Functions and Unit Tests}
\label{\detokenize{new-models:build-core-functions-and-unit-tests}}

\subsubsection{Assert Macros}
\label{\detokenize{new-models:assert-macros}}

\subsubsection{Writing Unit Tests}
\label{\detokenize{new-models:writing-unit-tests}}

\section{Adding a New Module to \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{new-modules:adding-a-new-module-to-ns3}}\label{\detokenize{new-modules::doc}}
When you have created a group of related classes, examples, and tests,
they can be combined together into an \sphinxstyleemphasis{ns\sphinxhyphen{}3} module so that they can be
used with existing \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules and by other researchers.

This chapter walks you through the steps necessary to add a new module
to \sphinxstyleemphasis{ns\sphinxhyphen{}3}.


\subsection{Step 0 \sphinxhyphen{} Module Layout}
\label{\detokenize{new-modules:step-0-module-layout}}\label{\detokenize{new-modules:step-0}}
All modules can be found in the \sphinxcode{\sphinxupquote{src}} directory.  Each module can be
found in a directory that has the same name as the module.  For
example, the \sphinxcode{\sphinxupquote{spectrum}} module can be found here: \sphinxcode{\sphinxupquote{src/spectrum}}.
We’ll be quoting from the \sphinxcode{\sphinxupquote{spectrum}} module for illustration.

A prototypical module has the following directory structure and
required files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src/
  module\PYGZhy{}name/
    bindings/
    doc/
    examples/
      wscript
    helper/
    model/
    test/
      examples\PYGZhy{}to\PYGZhy{}run.py
    wscript
\end{sphinxVerbatim}

Not all directories will be present in each module.


\subsection{Step 1 \sphinxhyphen{} Create a Module Skeleton}
\label{\detokenize{new-modules:step-1-create-a-module-skeleton}}
A python program is provided in the source directory that
will create a skeleton for a new module.  For the purposes
of this discussion we will assume that your new module
is called \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}}.  From the \sphinxcode{\sphinxupquote{src}} directory, do the following
to create the new module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./create\PYGZhy{}module.py new\PYGZhy{}module
\end{sphinxVerbatim}

Next, \sphinxcode{\sphinxupquote{cd}} into \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}}; you will find this directory layout:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd new\PYGZhy{}module
\PYGZdl{} ls
doc examples  helper  model  test  wscript
\end{sphinxVerbatim}

In more detail, the \sphinxcode{\sphinxupquote{create\sphinxhyphen{}module.py}} script will create the
directories as well as initial skeleton \sphinxcode{\sphinxupquote{wscript}}, \sphinxcode{\sphinxupquote{.h}}, \sphinxcode{\sphinxupquote{.cc}}
and \sphinxcode{\sphinxupquote{.rst}} files.  The complete module with skeleton files looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
src/
  new\PYGZhy{}module/
    doc/
      new\PYGZhy{}module.rst
    examples/
      new\PYGZhy{}module\PYGZhy{}example.cc
      wscript
    helper/
      new\PYGZhy{}module\PYGZhy{}helper.cc
      new\PYGZhy{}module\PYGZhy{}helper.h
    model/
      new\PYGZhy{}module.cc
      new\PYGZhy{}module.h
    test/
      new\PYGZhy{}module\PYGZhy{}test\PYGZhy{}suite.cc
    wscript
\end{sphinxVerbatim}

(If required the \sphinxcode{\sphinxupquote{bindings/}} directory listed in
{\hyperref[\detokenize{new-modules:step-0}]{\sphinxcrossref{\DUrole{std,std-ref}{Step\sphinxhyphen{}0}}}} will be created automatically during
the build.)

We next walk through how to customize this module.  Informing \sphinxcode{\sphinxupquote{waf}}
about the files which make up your module is done by editing the two
\sphinxcode{\sphinxupquote{wscript}} files.  We will walk through the main steps in this chapter.

All \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules depend on the \sphinxcode{\sphinxupquote{core}} module and usually on
other modules.  This dependency is specified in the \sphinxcode{\sphinxupquote{wscript}} file
(at the top level of the module, not the separate \sphinxcode{\sphinxupquote{wscript}} file
in the \sphinxcode{\sphinxupquote{examples}} directory!).  In the skeleton \sphinxcode{\sphinxupquote{wscript}}
the call that will declare your new module to \sphinxcode{\sphinxupquote{waf}} will look
like this (before editing):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{build}\PYG{p}{(}\PYG{n}{bld}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{core}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Let’s assume that \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}} depends on the \sphinxcode{\sphinxupquote{internet}},
\sphinxcode{\sphinxupquote{mobility}}, and \sphinxcode{\sphinxupquote{aodv}} modules.  After editing it the \sphinxcode{\sphinxupquote{wscript}} file
should look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{build}\PYG{p}{(}\PYG{n}{bld}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{internet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mobility}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aodv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Note that only first level module dependencies should be listed, which
is why we removed \sphinxcode{\sphinxupquote{core}}; the \sphinxcode{\sphinxupquote{internet}} module in turn depends on
\sphinxcode{\sphinxupquote{core}}.

Your module will most likely have model source files.  Initial skeletons
(which will compile successfully) are created in \sphinxcode{\sphinxupquote{model/new\sphinxhyphen{}module.cc}}
and \sphinxcode{\sphinxupquote{model/new\sphinxhyphen{}module.h}}.

If your module will have helper source files, then they will go into
the \sphinxcode{\sphinxupquote{helper/}} directory; again, initial skeletons are created
in that directory.

Finally, it is good practice to write tests and examples.  These will
almost certainly be required for new modules to be accepted into
the official \sphinxstyleemphasis{ns\sphinxhyphen{}3} source tree.  A skeleton
test suite and test case is created in the \sphinxcode{\sphinxupquote{test/}} directory.
The skeleton test suite will contain the below constructor,
which declares a new unit test named \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}},
with a single test case consisting of the class \sphinxcode{\sphinxupquote{NewModuleTestCase1}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NewModuleTestSuite}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NewModuleTestSuite} \PYG{p}{(}\PYG{p}{)}
  \PYG{o}{:} \PYG{n}{TestSuite} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{new\PYGZhy{}module}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{UNIT}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{AddTestCase} \PYG{p}{(}\PYG{k}{new} \PYG{n}{NewModuleTestCase1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Step 3 \sphinxhyphen{} Declare Source Files}
\label{\detokenize{new-modules:step-3-declare-source-files}}
The public header and source code files for your new module
should be specified in the \sphinxcode{\sphinxupquote{wscript}} file by modifying it with
your text editor.

As an example, after declaring the \sphinxcode{\sphinxupquote{spectrum}} module,
the \sphinxcode{\sphinxupquote{src/spectrum/wscript}} specifies the source code files
with the following list:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{build}\PYG{p}{(}\PYG{n}{bld}\PYG{p}{)}\PYG{p}{:}

  \PYG{n}{module} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}module}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spectrum}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{internet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{propagation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{antenna}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{applications}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

  \PYG{n}{module}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/spectrum\PYGZhy{}model.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/spectrum\PYGZhy{}value.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{o}{.}
            \PYG{o}{.}
            \PYG{o}{.}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/microwave\PYGZhy{}oven\PYGZhy{}spectrum\PYGZhy{}value\PYGZhy{}helper.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/spectrum\PYGZhy{}helper.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/adhoc\PYGZhy{}aloha\PYGZhy{}noack\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}helper.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/waveform\PYGZhy{}generator\PYGZhy{}helper.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/spectrum\PYGZhy{}analyzer\PYGZhy{}helper.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
      \PYG{p}{]}
\end{sphinxVerbatim}

The objects resulting from compiling these sources will be assembled
into a link library, which will be linked to any programs relying on this
module.

But how do such programs learn the public API of our new module?  Read on!


\subsection{Step 4 \sphinxhyphen{} Declare Public Header Files}
\label{\detokenize{new-modules:step-4-declare-public-header-files}}
The header files defining the public API of your model and helpers
also should be specified in the \sphinxcode{\sphinxupquote{wscript}} file.

Continuing with the \sphinxcode{\sphinxupquote{spectrum}} model illustration,
the public header files are specified with the following stanza.
(Note that the argument to the \sphinxcode{\sphinxupquote{bld}} function tells
\sphinxcode{\sphinxupquote{waf}} to install this module’s headers with the other \sphinxstyleemphasis{ns\sphinxhyphen{}3} headers):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{headers} \PYG{o}{=} \PYG{n}{bld}\PYG{p}{(}\PYG{n}{features}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ns3header}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{headers}\PYG{o}{.}\PYG{n}{module} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spectrum}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{headers}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/spectrum\PYGZhy{}model.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/spectrum\PYGZhy{}value.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
           \PYG{o}{.}
           \PYG{o}{.}
           \PYG{o}{.}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model/microwave\PYGZhy{}oven\PYGZhy{}spectrum\PYGZhy{}value\PYGZhy{}helper.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/spectrum\PYGZhy{}helper.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/adhoc\PYGZhy{}aloha\PYGZhy{}noack\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}helper.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/waveform\PYGZhy{}generator\PYGZhy{}helper.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helper/spectrum\PYGZhy{}analyzer\PYGZhy{}helper.h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{]}
\end{sphinxVerbatim}

Headers made public in this way will be accessible to users of your model
with include statements like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}ns3/spectrum\PYGZhy{}model.h\PYGZdq{}}
\end{sphinxVerbatim}

Headers used strictly internally in your implementation should not
be included here.  They are still accessible to your implementation by
include statements like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}my\PYGZhy{}module\PYGZhy{}implementation.h\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Step 5 \sphinxhyphen{} Declare Tests}
\label{\detokenize{new-modules:step-5-declare-tests}}
If your new module has tests, then they must be specified in your
\sphinxcode{\sphinxupquote{wscript}} file by modifying it with your text editor.

The \sphinxcode{\sphinxupquote{spectrum}} model tests are specified with the following stanza:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module\PYGZus{}test} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}module\PYGZus{}test\PYGZus{}library}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spectrum}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{module\PYGZus{}test}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/spectrum\PYGZhy{}interference\PYGZhy{}test.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/spectrum\PYGZhy{}value\PYGZhy{}test.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{p}{]}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{tests::doc}]{\sphinxcrossref{\DUrole{doc}{Tests}}}} for more information on how to write test cases.


\subsection{Step 6 \sphinxhyphen{} Declare Examples}
\label{\detokenize{new-modules:step-6-declare-examples}}
If your new module has examples, then they must be specified in your
\sphinxcode{\sphinxupquote{examples/wscript}} file.  (The skeleton top\sphinxhyphen{}level \sphinxcode{\sphinxupquote{wscript}} will
recursively include \sphinxcode{\sphinxupquote{examples/wscript}} only if the examples were
enabled at configure time.)

The \sphinxcode{\sphinxupquote{spectrum}} model defines it’s first example in
\sphinxcode{\sphinxupquote{src/spectrum/examples/wscript}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{build}\PYG{p}{(}\PYG{n}{bld}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{obj} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}program}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                               \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spectrum}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mobility}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
  \PYG{n}{obj}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy.cc}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

Note that the second argument to the function \sphinxcode{\sphinxupquote{create\_ns3\_program()}}
is the list of modules that the program being created depends on; again,
don’t forget to include \sphinxcode{\sphinxupquote{new\sphinxhyphen{}module}} in the list.  It’s best practice
to list only the direct module dependencies, and let \sphinxcode{\sphinxupquote{waf}} deduce
the full dependency tree.

Occasionally, for clarity, you may want to split the implementation
for your example among several source files.  In this case, just
include those files as additional explicit sources of the example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{obj} \PYG{o}{=} \PYG{n}{bld}\PYG{o}{.}\PYG{n}{create\PYGZus{}ns3\PYGZus{}program}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module\PYGZhy{}example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n}{new}\PYG{o}{\PYGZhy{}}\PYG{n}{module}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{obj}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module\PYGZhy{}example.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module\PYGZhy{}example\PYGZhy{}part.cc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

Python examples are specified using the following
function call.  Note that the second argument for the function
\sphinxcode{\sphinxupquote{register\_ns3\_script()}} is the list of modules that the Python example
depends on:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bld}\PYG{o}{.}\PYG{n}{register\PYGZus{}ns3\PYGZus{}script}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module\PYGZhy{}example.py}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZhy{}module}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Step 7 \sphinxhyphen{} Examples Run as Tests}
\label{\detokenize{new-modules:step-7-examples-run-as-tests}}
In addition to running explicit test code, the test framework
can also be instrumented to run full example programs to
try to catch regressions in the examples.  However, not all examples
are suitable for regression tests.  The file \sphinxcode{\sphinxupquote{test/examples\sphinxhyphen{}to\sphinxhyphen{}run.py}}
controls the invocation of the examples when the test framework runs.

The \sphinxcode{\sphinxupquote{spectrum}} model examples run by \sphinxcode{\sphinxupquote{test.py}} are specified in
\sphinxcode{\sphinxupquote{src/spectrum/test/examples\sphinxhyphen{}to\sphinxhyphen{}run.py}} using the following
two lists of C++ and Python examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} A list of C++ examples to run in order to ensure that they remain}
\PYG{c+c1}{\PYGZsh{} buildable and runnable over time.  Each tuple in the list contains}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}     (example\PYGZus{}name, do\PYGZus{}run, do\PYGZus{}valgrind\PYGZus{}run).}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} See test.py for more information.}
\PYG{n}{cpp\PYGZus{}examples} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}with\PYGZhy{}microwave\PYGZhy{}oven}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{adhoc\PYGZhy{}aloha\PYGZhy{}ideal\PYGZhy{}phy\PYGZhy{}matrix\PYGZhy{}propagation\PYGZhy{}loss\PYGZhy{}model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} A list of Python examples to run in order to ensure that they remain}
\PYG{c+c1}{\PYGZsh{} runnable over time.  Each tuple in the list contains}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}     (example\PYGZus{}name, do\PYGZus{}run).}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} See test.py for more information.}
\PYG{n}{python\PYGZus{}examples} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sample\PYGZhy{}simulator.py}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}
\end{sphinxVerbatim}

As indicated in the comment, each entry in the C++ list of examples to run
contains the tuple \sphinxcode{\sphinxupquote{(example\_name, do\_run, do\_valgrind\_run)}}, where
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{example\_name}} is the executable to be run,

\item {} 
\sphinxcode{\sphinxupquote{do\_run}} is a condition under which to run the example, and

\item {} 
\sphinxcode{\sphinxupquote{do\_valgrind\_run}} is a condition under which to run the example
under valgrind.  (This is needed because NSC causes illegal instruction
crashes with some tests when they are run under valgrind.)

\end{itemize}

Note that the two conditions are Python statements that
can depend on \sphinxcode{\sphinxupquote{waf}} configuration variables.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tcp\PYGZhy{}nsc\PYGZhy{}lfn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NSC\PYGZus{}ENABLED == True}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NSC\PYGZus{}ENABLED == False}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}

Each entry in the Python list of examples to run contains the tuple
\sphinxcode{\sphinxupquote{(example\_name, do\_run)}}, where, as for the C++ examples,
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{example\_name}} is the Python script to be run, and

\item {} 
\sphinxcode{\sphinxupquote{do\_run}} is a condition under which to run the example.

\end{itemize}

Again, the condition is a Python statement that can
depend on \sphinxcode{\sphinxupquote{waf}} configuration variables.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{realtime\PYGZhy{}udp\PYGZhy{}echo.py}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ENABLE\PYGZus{}REAL\PYGZus{}TIME == False}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}


\subsection{Step 8 \sphinxhyphen{} Configure and Build}
\label{\detokenize{new-modules:step-8-configure-and-build}}
You can now configure, build and test your module as normal.
You must reconfigure the project as a first step so that \sphinxcode{\sphinxupquote{waf}}
caches the new information in your \sphinxcode{\sphinxupquote{wscript}} files,
or else your new module will not be included in the build.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{} ./waf build
\PYGZdl{} ./test.py
\end{sphinxVerbatim}

Look for your new module’s test suite (and example programs,
if your module has any enabled) in the test output.


\subsection{Step 9 \sphinxhyphen{} Python Bindings}
\label{\detokenize{new-modules:step-9-python-bindings}}
Adding Python bindings to your module is optional, and the step is
commented out by default in the \sphinxcode{\sphinxupquote{create\sphinxhyphen{}module.py}} script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} bld.ns3\PYGZus{}python\PYGZus{}bindings()}
\end{sphinxVerbatim}

If you want to include Python bindings (needed only if you want
to write Python ns\sphinxhyphen{}3 programs instead of C++ ns\sphinxhyphen{}3 programs), you
should uncomment the above and install the Python API scanning
system (covered elsewhere in this manual) and scan your module to
generate new bindings.


\section{Creating Documentation}
\label{\detokenize{documentation:creating-documentation}}\label{\detokenize{documentation::doc}}
\sphinxstyleemphasis{ns\sphinxhyphen{}3} supplies two kinds of documentation:  expository “user\sphinxhyphen{}guide”\sphinxhyphen{}style
chapters, and source code API documentation.

The “user\sphinxhyphen{}guide” chapters are written by hand in \sphinxhref{http://sphinx-doc.org/rest.html}{reStructuredText}
format (\sphinxcode{\sphinxupquote{.rst}}), which is processed by the Python documentation
system \sphinxhref{http://sphinx-doc.org/}{Sphinx} to generate web pages and pdf files.
The API documentation is generated from the source code itself,
using \sphinxhref{http://www.doxygen.org/}{Doxygen}, to generate cross\sphinxhyphen{}linked web pages.
Both of these are important:  the Sphinx chapters explain the \sphinxstyleemphasis{why}
and overview of using a model; the API documentation explains the
\sphinxstyleemphasis{how} details.

This chapter gives a quick overview of these
tools, emphasizing preferred usage and customizations for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

To build all the standard documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf docs
\end{sphinxVerbatim}

For more specialized options, read on.


\subsection{Documenting with Sphinx}
\label{\detokenize{documentation:documenting-with-sphinx}}
We use \sphinxhref{http://sphinx-doc.org/}{Sphinx} to generate expository chapters describing
the design and usage of each module.  Right now you are reading the
{\hyperref[\detokenize{documentation::doc}]{\sphinxcrossref{\DUrole{doc}{Documentation}}}} Chapter.
If you are reading the html version, the
\sphinxhref{\_sources/documentation.txt}{Show Source} link in the sidebar
will show you the reStructuredText source for this chapter.


\subsubsection{Adding New Chapters}
\label{\detokenize{documentation:adding-new-chapters}}
Adding a new chapter takes three steps (described in more detail below):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Choose {\hyperref[\detokenize{documentation:where}]{\sphinxcrossref{Where?}}} the documentation file(s) will live.

\item {} 
{\hyperref[\detokenize{documentation:link}]{\sphinxcrossref{Link}}} from an existing page to the new documentation.

\item {} 
Add the new file to the {\hyperref[\detokenize{documentation:makefile}]{\sphinxcrossref{Makefile}}}.

\end{enumerate}


\paragraph{Where?}
\label{\detokenize{documentation:where}}
Documentation for a specific module, \sphinxcode{\sphinxupquote{foo}}, should normally go in
\sphinxcode{\sphinxupquote{src/foo/doc/}}.  For example \sphinxcode{\sphinxupquote{src/foo/doc/foo.rst}} would be the
top\sphinxhyphen{}level document for the module.  The \sphinxcode{\sphinxupquote{src/create\sphinxhyphen{}module.py}} script
will create this file for you.

Some models require several \sphinxcode{\sphinxupquote{.rst}} files, and figures; these should
all go in the \sphinxcode{\sphinxupquote{src/foo/doc/}} directory.  The docs are actually built
by a Sphinx Makefile.  For especially involved
documentation, it may be helpful to have a local \sphinxcode{\sphinxupquote{Makefile}}
in the \sphinxcode{\sphinxupquote{src/foo/doc/}} directory to
simplify building the documentation for this module
(\sphinxhref{http://www.nsnam.org/docs/models/html/antenna.html}{Antenna} is an example).  Setting this up
is not particularly hard, but is beyond the scope of this chapter.

In some cases, documentation spans multiple models; the
\sphinxhref{http://www.nsnam.org/docs/models/html/network.html}{Network} chapter is an example.  In these cases
adding the \sphinxcode{\sphinxupquote{.rst}} files directly to \sphinxcode{\sphinxupquote{doc/models/source/}} might
be appropriate.


\paragraph{Link}
\label{\detokenize{documentation:link}}
Sphinx has to know \sphinxstyleemphasis{where} your new chapter should appear.  In most
cases, a new model chapter should appear the in \sphinxtitleref{Models} book.
To add your chapter there, edit \sphinxcode{\sphinxupquote{doc/models/source/index.rst}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{toctree}\PYG{p}{::}
   \PYG{n+nc}{:maxdepth:} 1

  organization
  animation
  antenna
  aodv
  applications
\PYG{c+cp}{  ...}
\end{sphinxVerbatim}

Add the name of your document (without the \sphinxcode{\sphinxupquote{.rst}} extension) to
this list.  Please keep the Model chapters in alphabetical order,
to ease visual scanning for specific chapters.


\paragraph{Makefile}
\label{\detokenize{documentation:makefile}}
You also have to add your document to the appropriate \sphinxcode{\sphinxupquote{Makefile}},
so \sphinxcode{\sphinxupquote{make}} knows to check it for updates.  The Models book Makefile
is \sphinxcode{\sphinxupquote{doc/models/Makefile}}, the Manual book Makefile is
\sphinxcode{\sphinxupquote{doc/manual/Makefile}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} list all model library .rst files that need to be copied to \PYGZdl{}SOURCETEMP}
\PYG{n+nv}{SOURCES} \PYG{o}{=} \PYG{l+s+se}{\PYGZbs{}}
        source/conf.py \PYG{l+s+se}{\PYGZbs{}}
        source/\PYGZus{}static \PYG{l+s+se}{\PYGZbs{}}
        source/index.rst \PYG{l+s+se}{\PYGZbs{}}
        source/replace.txt \PYG{l+s+se}{\PYGZbs{}}
        source/organization.rst \PYG{l+s+se}{\PYGZbs{}}
        ...
        \PYG{k}{\PYGZdl{}(}SRC\PYG{k}{)}/antenna/doc/source/antenna.rst \PYG{l+s+se}{\PYGZbs{}}
        ...
\end{sphinxVerbatim}

You add your \sphinxcode{\sphinxupquote{.rst}} files to the \sphinxcode{\sphinxupquote{SOURCES}} variable.  To add figures,
read the comments in the \sphinxcode{\sphinxupquote{Makefile}} to see which variable should contain
your image files.  Again, please keep these in alphabetical order.


\subsubsection{Building Sphinx Docs}
\label{\detokenize{documentation:building-sphinx-docs}}
Building the Sphinx documentation is pretty simple.
To build all the Sphinx documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf sphinx
\end{sphinxVerbatim}

To build just the Models documentation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C doc/models html
\end{sphinxVerbatim}

To see the generated documentation point your browser at
\sphinxcode{\sphinxupquote{doc/models/build/html}}.

As you can see, Sphinx uses Make to guide the process.
The default target builds all enabled output forms, which in
\sphinxstyleemphasis{ns\sphinxhyphen{}3} are the multi\sphinxhyphen{}page \sphinxcode{\sphinxupquote{html}}, single\sphinxhyphen{}page \sphinxcode{\sphinxupquote{singlehtml}}, and pdf
(\sphinxcode{\sphinxupquote{latex}}).  To build just the multi\sphinxhyphen{}page html, you add the \sphinxcode{\sphinxupquote{html}} target:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C doc/models html
\end{sphinxVerbatim}

This can be helpful to reduce the build time (and the size of the
build chatter) as you are writing your chapter.

Before committing your documentation to the repo, please check
that it builds without errors or warnings.  The build process
generates lots of output (mostly normal chatter from LaTeX),
which can make it difficult to see if there are any Sphinx
warnings or errors.  To find important warnings and errors
build just the \sphinxcode{\sphinxupquote{html}} version, then search the build log
for \sphinxcode{\sphinxupquote{warning}} or \sphinxcode{\sphinxupquote{error}}.


\subsubsection{\sphinxstyleemphasis{ns\sphinxhyphen{}3} Specifics}
\label{\detokenize{documentation:ns3-specifics}}
The Sphinx \sphinxhref{http://sphinx-doc.org/contents.html}{documentation} and \sphinxhref{http://sphinx-doc.org/tutorial.html}{tutorial} are pretty good.  We won’t duplicate
the basics here, instead focusing on preferred usage for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
\begin{itemize}
\item {} 
Start documents with these two lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{include}\PYG{p}{::} replace.txt
\PYG{p}{..} \PYG{o+ow}{highlight}\PYG{p}{::} cpp
\end{sphinxVerbatim}

The first line enables some simple replacements.  For example,
typing \sphinxcode{\sphinxupquote{|ns3|}} renders as \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
The second sets the default source code highlighting language explicitly
for the file, since the parser guess isn’t always accurate.
(It’s also possible to set the language explicitly for a single code block,
see below.)

\item {} 
Sections:

Sphinx is pretty liberal about marking section headings.  By convention,
we prefer this hierarchy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{.. heading hierarchy:}
\PYG{c+cp}{   \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Chapter}
\PYG{c+cp}{   ************* Section (\PYGZsh{}.\PYGZsh{})}
\PYG{c+cp}{   ============= Subsection (\PYGZsh{}.\PYGZsh{}.\PYGZsh{})}
\PYG{c+cp}{   \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Sub\PYGZhy{}subsection}
\end{sphinxVerbatim}

\item {} 
Syntax Highlighting:

To use the default syntax highlighter, simply start a sourcecode block:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Sphinx Source
&\sphinxstyletheadfamily 
Rendered Output
\\
\hline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
The \PYG{l+s}{``}\PYG{l+s}{Frobnitz}\PYG{l+s}{``} is accessed by\PYG{l+s+se}{::}

\PYG{l+s}{  }\PYG{l+s}{Foo::Frobnitz frob;}
\PYG{l+s}{  frob.Set (...);}
\end{sphinxVerbatimintable}
&
The \sphinxcode{\sphinxupquote{Frobnitz}} is accessed by:

\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYG{n}{Foo}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Frobnitz} \PYG{n}{frob}\PYG{p}{;}
\PYG{n}{frob}\PYG{p}{.}\PYG{n}{Set} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatimintable}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

To use a specific syntax highlighter, for example, \sphinxcode{\sphinxupquote{bash}} shell commands:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Sphinx Source
&\sphinxstyletheadfamily 
Rendered Output
\\
\hline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYG{p}{..} \PYG{o+ow}{sourcecode}\PYG{p}{::} bash

   \PYGZdl{} ls
\end{sphinxVerbatimintable}
&
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYGZdl{} ls
\end{sphinxVerbatimintable}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\item {} 
Shorthand Notations:

These shorthands are defined:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Sphinx Source
&\sphinxstyletheadfamily 
Rendered Output
\\
\hline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
|ns3|
\end{sphinxVerbatimintable}
&
\sphinxstyleemphasis{ns\sphinxhyphen{}3}
\\
\hline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
|ns2|
\end{sphinxVerbatimintable}
&
\sphinxstyleemphasis{ns\sphinxhyphen{}2}
\\
\hline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
|check|
\end{sphinxVerbatimintable}
&
\(\checkmark\)
\\
\hline
\begin{sphinxVerbatimintable}[commandchars=\\\{\}]
\PYG{n+na}{:rfc:}\PYG{n+nv}{`6282`}
\end{sphinxVerbatimintable}
&
\index{RFC@\spxentry{RFC}!RFC 6282@\spxentry{RFC 6282}}\sphinxhref{https://tools.ietf.org/html/rfc6282.html}{\sphinxstylestrong{RFC 6282}}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\end{itemize}


\subsection{Documenting with Doxygen}
\label{\detokenize{documentation:documenting-with-doxygen}}
We use \sphinxhref{http://www.doxygen.org/}{Doxygen} to generate \sphinxhref{https://www.nsnam.org/docs/doxygen}{browsable} API documentation.  Doxygen
provides a number of useful features:
\begin{itemize}
\item {} 
Summary table of all class members.

\item {} 
Graphs of inheritance and collaboration for all classes.

\item {} 
Links to the source code implementing each function.

\item {} 
Links to every place a member is used.

\item {} 
Links to every object used in implementing a function.

\item {} 
Grouping of related classes, such as all the classes related to
a specific protocol.

\end{itemize}

In addition, we use the \sphinxcode{\sphinxupquote{TypeId}} system to add to the documentation
for every class
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{Config}} paths by which such objects can be reached.

\item {} 
Documentation for any \sphinxcode{\sphinxupquote{Attributes}}, including \sphinxcode{\sphinxupquote{Attributes}}
defined in parent classes.

\item {} 
Documentation for any \sphinxcode{\sphinxupquote{Trace}} sources defined by the class.

\item {} 
The memory footprint for each class.

\end{itemize}

Doxygen operates by scanning the source code, looking for
specially marked comments.  It also creates a cross reference,
indicating \sphinxstyleemphasis{where} each file, class, method, and variable is used.


\subsubsection{Preferred Style}
\label{\detokenize{documentation:preferred-style}}
The preferred style for Doxygen comments is the JavaDoc style:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  Brief description of this class or method.}
\PYG{c+cm}{ *  Adjacent lines become a single paragraph.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  Longer description, with lots of details.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  Blank lines separate paragraphs.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  Explain what the class or method does, using what algorithm.}
\PYG{c+cm}{ *  Explain the units of arguments and return values.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  \PYGZbs{}note Note any limitations or gotchas.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  (For functions with arguments or return valued:)}
\PYG{c+cm}{ *  \PYGZbs{}param [in] foo Brief noun phrase describing this argument. Note}
\PYG{c+cm}{ *                  that we indicate if the argument is input,}
\PYG{c+cm}{ *                  output, or both.}
\PYG{c+cm}{ *  \PYGZbs{}param [in,out] bar Note Sentence case, and terminating period.}
\PYG{c+cm}{ *  \PYGZbs{}param [in] baz Indicate boolean values with \PYGZbs{}c true or \PYGZbs{}c false.}
\PYG{c+cm}{ *  \PYGZbs{}return Brief noun phrase describing the value.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  \PYGZbs{}internal}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  You can also discuss internal implementation details.}
\PYG{c+cm}{ *  Understanding this material shouldn\PYGZsq{}t be necessary to using}
\PYG{c+cm}{ *  the class or method.}
\PYG{c+cm}{ */}
 \PYG{k+kt}{void} \PYG{n+nf}{ExampleFunction} \PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{foo}\PYG{p}{,} \PYG{k+kt}{double} \PYG{o}{\PYGZam{}} \PYG{n}{bar}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{baz}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In this style the Doxygen comment block begins with two \textasciigrave{}*’ characters:
\sphinxcode{\sphinxupquote{/**}}, and precedes the item being documented.

For items needing only a brief description, either of these short forms
is appropriate:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Destructor implementation. */}
\PYG{k+kt}{void} \PYG{n+nf}{DoDispose} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{m\PYGZus{}count}\PYG{p}{;}  \PYG{c+c1}{//!\PYGZlt{} Count of ...}
\end{sphinxVerbatim}

Note the special form of the end of line comment, \sphinxcode{\sphinxupquote{//!\textless{}}}, indicating
that it refers to the \sphinxstyleemphasis{preceding} item.

Some items to note:
\begin{itemize}
\item {} 
Use sentence case, including the initial capital.

\item {} 
Use punctuation, especially \textasciigrave{}.’s at the end of sentences or phrases.

\item {} \begin{description}
\item[{The \sphinxcode{\sphinxupquote{\textbackslash{}brief}} tag is not needed; the first sentence will be}] \leavevmode
used as the brief description.

\end{description}

\end{itemize}

Every class, method, typedef, member variable, function argument
and return value should be documented in all source code files
which form the formal API and implementation for \sphinxstyleemphasis{ns\sphinxhyphen{}3}, such as
\sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/model/*}}, \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/helper/*}} and
\sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/utils/*}}.  Documentation for items in \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/test/*}}
and \sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/examples/*}} is preferred, but not required.


\subsubsection{Useful Features}
\label{\detokenize{documentation:useful-features}}\begin{itemize}
\item {} 
Inherited members will automatically inherit docs from the parent,
(but can be replaced by local documentation).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Document the base class.

\item {} 
In the sub class mark inherited functions with an ordinary comment:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Inherited methods}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{FooBar} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{int} \PYG{n+nf}{BarFoo} \PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{baz}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that the signatures have to match exactly, so include the formal
argument \sphinxcode{\sphinxupquote{(void)}}

This doesn’t work for static functions; see \sphinxcode{\sphinxupquote{GetTypeId}}, below, for an
example.

\end{enumerate}

\end{itemize}


\subsubsection{Building Doxygen Docs}
\label{\detokenize{documentation:building-doxygen-docs}}
Building the Doxygen documentation is pretty simple:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf doxygen
\end{sphinxVerbatim}

This builds using the default configuration, which generates
documentation sections for \sphinxstyleemphasis{all} items, even if they do not have
explicit comment documentation blocks.  This has the effect of
suppressing warnings for undocumented items, but makes sure everything
appears in the generated output, which is usually what you want for
general use.  Note that we generate documentation even for modules
which are disabled, to make it easier to see all the features
available in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

When writing documentation, it’s often more useful to see which items
are generating warnings, typically about missing documentation.  To
see the full warnings list, use the \sphinxcode{\sphinxupquote{doc/doxygen.warnings.report.sh}}
script:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} doc/doxygen.warnings.report.sh

doxygen.warnings.report.sh:
Building and running print\PYGZhy{}introspected\PYGZhy{}doxygen...done.
Rebuilding doxygen \PYG{o}{(}v1.8.10\PYG{o}{)} docs with full errors...done.


Report of Doxygen warnings
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

\PYG{o}{(}All counts are lower bounds.\PYG{o}{)}

Warnings by module/directory:

Count Directory
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYG{l+m}{3414} src/lte/model
\PYG{l+m}{1532} src/wimax/model
 \PYG{l+m}{825} src/lte/test
....
   \PYG{l+m}{1} src/applications/test
 \PYG{l+m}{97} additional undocumented parameters.
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 \PYG{l+m}{12460} total warnings
   \PYG{l+m}{100} directories with warnings


Warnings by file \PYG{o}{(}alphabetical\PYG{o}{)}

Count File
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  \PYG{l+m}{15} examples/routing/manet\PYGZhy{}routing\PYGZhy{}compare.cc
  \PYG{l+m}{26} examples/stats/wifi\PYGZhy{}example\PYGZhy{}apps.h
  \PYG{l+m}{12} examples/tutorial/fifth.cc
....
  \PYG{l+m}{17} utils/python\PYGZhy{}unit\PYGZhy{}tests.py
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
   \PYG{l+m}{771} files with warnings


Warnings by file \PYG{o}{(}numerical\PYG{o}{)}

Count File
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 \PYG{l+m}{273} src/lte/model/lte\PYGZhy{}rrc\PYGZhy{}sap.h
 \PYG{l+m}{272} src/core/model/simulator.h
 \PYG{l+m}{221} src/netanim/model/animation\PYGZhy{}interface.h
....
   \PYG{l+m}{1} src/wimax/model/ul\PYGZhy{}job.cc
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
   \PYG{l+m}{771} files with warnings


Doxygen Warnings Summary
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
   \PYG{l+m}{100} directories
   \PYG{l+m}{771} files
 \PYG{l+m}{12460} warnings
\end{sphinxVerbatim}

(This snippet has \sphinxstyleemphasis{a lot} of lines suppressed!)

The script modifies the configuration to show all warnings, and to
shorten the run time.  (It shortens the run time primarily by
disabling creation of diagrams, such as call trees, and doesn’t
generate documentation for undocumented items, in order to trigger the
warnings.)  As you can see, at this writing we have \sphinxstyleemphasis{a lot} of
undocumented items.  The report summarizes warnings by module
\sphinxcode{\sphinxupquote{src/*/*}}, and by file, in alphabetically and numerical order.

The script has a few options to pare things down and make the output more
manageable.  For help, use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}h}} option.  Having run it once
to do the Doxygen build and generate the full warnings log,
you can reprocess the log file with various “filters,”
without having to do the full Doxygen build again by
using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}s}} option.  You can exclude warnings
from \sphinxcode{\sphinxupquote{*/examples/*}} files (\sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} option), and/or \sphinxcode{\sphinxupquote{*/test/*}} files
(\sphinxcode{\sphinxupquote{\sphinxhyphen{}t}}).  Just to be clear, all of the filter options do the complete
fast doxygen build; they just filter doxygen log and warnings output.

Perhaps the most useful option when writing documentation comments
is \sphinxcode{\sphinxupquote{\sphinxhyphen{}m \textless{}module\textgreater{}}}, which will limit the report to just files matching
\sphinxcode{\sphinxupquote{src/\textless{}module\textgreater{}/*}}, and follow the report with the actual warning lines.
Combine with \sphinxcode{\sphinxupquote{\sphinxhyphen{}et}} and you can focus on the warnings that are most
urgent in a single module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} doc/doxygen.warnings.report.sh \PYGZhy{}m mesh/helper
...
Doxygen Warnings Summary
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  \PYG{l+m}{1} directories
  \PYG{l+m}{3} files
\PYG{l+m}{149} warnings


Filtered \PYG{n+nv}{Warnings}
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
src/mesh/helper/dot11s/dot11s\PYGZhy{}installer.h:72: warning: Member m\PYGZus{}root \PYG{o}{(}variable\PYG{o}{)} of class ns3::Dot11sStack is not documented.
src/mesh/helper/dot11s/dot11s\PYGZhy{}installer.h:35: warning: \PYG{k}{return} \PYG{n+nb}{type} of member ns3::Dot11sStack::GetTypeId is not documented
src/mesh/helper/dot11s/dot11s\PYGZhy{}installer.h:56: warning: \PYG{k}{return} \PYG{n+nb}{type} of member ns3::Dot11sStack::InstallStack is not documented
src/mesh/helper/flame/lfame\PYGZhy{}installer.h:40: warning: Member GetTypeId\PYG{o}{(}\PYG{o}{)} \PYG{o}{(}\PYG{k}{function}\PYG{o}{)} of class ns3::FlameStack is not documented.
src/mesh/helper/flame/flame\PYGZhy{}installer.h:60: warning: \PYG{k}{return} \PYG{n+nb}{type} of member ns3::FlameStack::InstallStack is not documented
src/mesh/helper/mesh\PYGZhy{}helper.h:213: warning: Member m\PYGZus{}nInterfaces \PYG{o}{(}variable\PYG{o}{)} of class ns3::MeshHelper is not documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:214: warning: Member m\PYGZus{}spreadChannelPolicy \PYG{o}{(}variable\PYG{o}{)} of class ns3::MeshHelper is not documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:215: warning: Member m\PYGZus{}stack \PYG{o}{(}variable\PYG{o}{)} of class ns3::MeshHelper is not documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:216: warning: Member m\PYGZus{}stackFactory \PYG{o}{(}variable\PYG{o}{)} of class ns3::MeshHelper is not documented.
src/mesh/helper/mesh\PYGZhy{}helper.h:209: warning: parameters of member ns3::MeshHelper::CreateInterface are not \PYG{o}{(}all\PYG{o}{)} documented
src/mesh/helper/mesh\PYGZhy{}helper.h:119: warning: parameters of member ns3::MeshHelper::SetStandard are not \PYG{o}{(}all\PYG{o}{)} documented
\end{sphinxVerbatim}

Finally, note that undocumented items (classes, methods, functions,
typedefs, \sphinxstyleemphasis{etc.} won’t produce documentation when you build with
\sphinxcode{\sphinxupquote{doxygen.warnings.report.sh}}, and only the outermost item
will produce a warning.  As a result, if you don’t see documentation
for a class method in the generated documentation, the class itself
probably needs documentation.

Now it’s just a matter of understanding the code, and writing some
docs!


\subsubsection{\sphinxstyleemphasis{ns\sphinxhyphen{}3} Specifics}
\label{\detokenize{documentation:id1}}
As for Sphinx, the Doxygen \sphinxhref{http://www.stack.nl/~dimitri/doxygen/index.html}{docs} and \sphinxhref{http://www.stack.nl/~dimitri/doxygen/manual/commands.html}{reference} are pretty good.
We won’t duplicate the basics here, instead focusing on preferred
usage for \sphinxstyleemphasis{ns\sphinxhyphen{}3}.
\begin{itemize}
\item {} 
Use Doxygen \sphinxcode{\sphinxupquote{Modules}} to group related items.

In the main header for a module, create a Doxgyen group:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}defgroup foo Foo protocol.}
\PYG{c+cm}{ *  Implementation of the Foo protocol.}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}

The symbol \sphinxcode{\sphinxupquote{foo}} is how other items can add themselves to this group.
The string following that will be the title for the group.  Any further
text will be the detailed description for the group page.

\item {} 
Document each file, assigning it to the relevant group.  In a header file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}file}
\PYG{c+cm}{ *  \PYGZbs{}ingroup foo}
\PYG{c+cm}{ *  Class Foo declaration.}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}

or in the corresponding \sphinxcode{\sphinxupquote{.cc}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}file}
\PYG{c+cm}{ *  \PYGZbs{}ingroup foo}
\PYG{c+cm}{ *  Class FooBar implementation.}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}

\item {} 
Mark each associated class as belonging to the group:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  \PYGZbs{}ingroup foo}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  FooBar packet type.}
\PYG{c+cm}{*/}
\PYG{k}{class} \PYG{n+nc}{FooBar}
\end{sphinxVerbatim}

\item {} 
Did you know \sphinxcode{\sphinxupquote{typedefs}} can have formal arguments?  This enables
documentation of function pointer signatures:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  Bar callback function signature.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  \PYGZbs{}param ale The size of a pint of ale, in Imperial ounces.}
\PYG{c+cm}{ */}
\PYG{k}{typedef} \PYG{n+nf}{void} \PYG{p}{(}\PYG{o}{*} \PYG{n}{BarCallback}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{ale}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Copy the \sphinxcode{\sphinxupquote{Attribute}} help strings from the \sphinxcode{\sphinxupquote{GetTypeId}} method to use
as the brief descriptions of associated members.

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}bugid\{298\}}} will create a link to bug 298 in our Bugzilla.

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}p foo}} in a description will format \sphinxcode{\sphinxupquote{foo}}
the same as the \sphinxcode{\sphinxupquote{\textbackslash{}param foo}} parameter, making it clear that you
are referring to an actual argument.

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}RFC\{301\}}} will create a link to RFC 301.

\item {} 
Document the direction of function arguments with \sphinxcode{\sphinxupquote{\textbackslash{}param {[}in{]}}}, \sphinxstyleemphasis{etc}.
The allowed values of the direction token are \sphinxcode{\sphinxupquote{{[}in{]}}}, \sphinxcode{\sphinxupquote{{[}out{]}}}, and
\sphinxcode{\sphinxupquote{{[}in,out{]}}} (note the explicit square brackets), as discussed in the
Doxygen docs for \sphinxcode{\sphinxupquote{\textbackslash{}param}}.

\item {} 
Document template arguments with \sphinxcode{\sphinxupquote{\textbackslash{}tparam}}, just as you use \sphinxcode{\sphinxupquote{\textbackslash{}param}}
for function arguments.

\item {} 
For template arguments, indicate if they will be deduced or must be given
explicitly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * A templated function.}
\PYG{c+cm}{ * \PYGZbs{}tparam T \PYGZbs{}explicit The return type.}
\PYG{c+cm}{ * \PYGZbs{}tparam U \PYGZbs{}deduced The argument type.}
\PYG{c+cm}{ * \PYGZbs{}param [in] a The argument.}
\PYG{c+cm}{ */}
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{p}{,} \PYG{k}{typename} \PYG{n}{U}\PYG{o}{\PYGZgt{}} \PYG{n}{T} \PYG{n}{Function} \PYG{p}{(}\PYG{n}{U} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use \sphinxcode{\sphinxupquote{\textbackslash{}tparam U \textbackslash{}deduced}} because the type \sphinxcode{\sphinxupquote{U}} can be deduced at
the site where the template is invoked.  Basically deduction can only
be done for function arguments.

\item {} 
Use \sphinxcode{\sphinxupquote{\textbackslash{}tparam T \textbackslash{}explicit}} because the type \sphinxcode{\sphinxupquote{T}} can’t be deduced;
it must be given explicitly at the invocation site, as in
\sphinxcode{\sphinxupquote{Create\textless{}MyObject\textgreater{} (...)}}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}internal}} should be used only to set off a discussion of implementation
details, not to mark \sphinxcode{\sphinxupquote{private}} functions (they are already marked,
as \sphinxcode{\sphinxupquote{private}}!)

\item {} 
Don’t create classes with trivial names, such as \sphinxcode{\sphinxupquote{class A}},
even in test suites.  These cause all instances of the class name
literal \textasciigrave{}A’ to be rendered as links.

\end{itemize}

As noted above, static functions don’t inherit the documentation
of the same functions in the parent class.  \sphinxstyleemphasis{ns\sphinxhyphen{}3} uses a few static
functions ubiquitously; the suggested documentation block for these
cases is:
\begin{itemize}
\item {} 
Default constructor/destructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MyClass} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{//!\PYGZlt{} Default constructor}
\PYG{o}{\PYGZti{}}\PYG{n}{MyClass} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//!\PYGZlt{} Destructor}
\end{sphinxVerbatim}

\item {} 
Dummy destructor and DoDispose:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Dummy destructor, see DoDispose. */}
\PYG{o}{\PYGZti{}}\PYG{n}{MyClass} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/** Destructor implementation */}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{DoDispose} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
GetTypeId:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ *  Register this type.}
\PYG{c+cm}{ *  \PYGZbs{}return The object TypeId.}
\PYG{c+cm}{ */}
\PYG{k}{static} \PYG{n}{TypeId} \PYG{n+nf}{GetTypeId} \PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\section{Enabling Subsets of \sphinxstyleemphasis{ns\sphinxhyphen{}3} Modules}
\label{\detokenize{enable-modules:enabling-subsets-of-ns3-modules}}\label{\detokenize{enable-modules::doc}}
As with most software projects, \sphinxstyleemphasis{ns\sphinxhyphen{}3} is ever growing larger in terms of number of modules, lines of code, and memory footprint.  Users, however, may only use a few of those modules at a time.  For this reason, users may want to explicitly enable only the subset of the possible \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules that they actually need for their research.

This chapter discusses how to enable only the \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules that you are interested in using.


\subsection{How to enable a subset of \sphinxstyleemphasis{ns\sphinxhyphen{}3}’s modules}
\label{\detokenize{enable-modules:how-to-enable-a-subset-of-ns3-s-modules}}
If shared libraries are being built, then enabling a module will cause at least one library to be built:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}modulename.so
\end{sphinxVerbatim}

If the module has a test library and test libraries are being built, then

\begin{sphinxVerbatim}[commandchars=\\\{\}]
libns3\PYGZhy{}modulename\PYGZhy{}test.so
\end{sphinxVerbatim}

will be built, too.  Other modules that the module depends on and their test libraries will also be built.

By default, all modules are built in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.  There are two ways to enable a subset of these modules:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Using waf’s \textendash{}enable\sphinxhyphen{}modules option

\item {} 
Using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file

\end{enumerate}


\subsubsection{Enable modules using waf’s \textendash{}enable\sphinxhyphen{}modules option}
\label{\detokenize{enable-modules:enable-modules-using-waf-s-enable-modules-option}}
To enable only the core module with example and tests, for example,
try these commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf clean
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests \PYGZhy{}\PYGZhy{}enable\PYGZhy{}modules\PYG{o}{=}core
\PYGZdl{} ./waf build
\PYGZdl{} \PYG{n+nb}{cd} build/debug/
\PYGZdl{} ls
\end{sphinxVerbatim}

and the following libraries should be present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bindings  libns3\PYGZhy{}core.so       ns3      scratch  utils
examples  libns3\PYGZhy{}core\PYGZhy{}test.so  samples  src
\end{sphinxVerbatim}

Note the \sphinxcode{\sphinxupquote{./waf clean}} step is done here only to make it more obvious which module libraries were built.  You don’t have to do \sphinxcode{\sphinxupquote{./waf clean}} in order to enable subsets of modules.

Running test.py will cause only those tests that depend on module core to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
24 of 24 tests passed (24 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

Repeat the above steps for the “network” module instead of the “core” module, and the following will be built, since network depends on core:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bindings  libns3\PYGZhy{}core.so       libns3\PYGZhy{}network.so       ns3      scratch  utils
examples  libns3\PYGZhy{}core\PYGZhy{}test.so  libns3\PYGZhy{}network\PYGZhy{}test.so  samples  src
\end{sphinxVerbatim}

Running test.py will cause those tests that depend on only the core and network modules to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
31 of 31 tests passed (31 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable modules using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file}
\label{\detokenize{enable-modules:enable-modules-using-the-ns3-configuration-file}}
A configuration file, .ns3rc, has been added to \sphinxstyleemphasis{ns\sphinxhyphen{}3} that allows users to specify which modules are to be included in the build.

When enabling a subset of \sphinxstyleemphasis{ns\sphinxhyphen{}3} modules, the precedence rules are as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
the \textendash{}enable\sphinxhyphen{}modules configure string overrides any .ns3rc file

\item {} 
the .ns3rc file in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory is next consulted, if present

\item {} 
the system searches for \textasciitilde{}/.ns3rc if the above two are unspecified

\end{enumerate}

If none of the above limits the modules to be built, all modules that waf knows about will be built.

The maintained version of the .ns3rc file in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} source code repository resides in the \sphinxcode{\sphinxupquote{utils}} directory.  The reason for this is if it were in the top\sphinxhyphen{}level directory of the repository, it would be prone to accidental checkins from maintainers that enable the modules they want to use.  Therefore, users need to manually copy the .ns3rc from the \sphinxcode{\sphinxupquote{utils}} directory to their preferred place (top level directory or their home directory) to enable persistent modular build configuration.

Assuming that you are in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can get a copy of the .ns3rc file that is in the \sphinxcode{\sphinxupquote{utils}} directory as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cp utils/.ns3rc .
\end{sphinxVerbatim}

The .ns3rc file should now be in your top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, and it contains the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python}

\PYG{c+c1}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c+c1}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} All modules can be enabled by choosing \PYGZsq{}all\PYGZus{}modules\PYGZsq{}.}
\PYG{n}{modules\PYGZus{}enabled} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all\PYGZus{}modules}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want examples to be run.}
\PYG{n}{examples\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{False}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want tests to be run.}
\PYG{n}{tests\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{False}
\end{sphinxVerbatim}

Use your favorite editor to modify the .ns3rc file to only enable the core module with examples and tests like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python}

\PYG{c+c1}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c+c1}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} All modules can be enabled by choosing \PYGZsq{}all\PYGZus{}modules\PYGZsq{}.}
\PYG{n}{modules\PYGZus{}enabled} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{core}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want examples to be run.}
\PYG{n}{examples\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{True}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want tests to be run.}
\PYG{n}{tests\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

Only the core module will be enabled now if you try these commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf clean
\PYGZdl{} ./waf configure
\PYGZdl{} ./waf build
\PYGZdl{} \PYG{n+nb}{cd} build/debug/
\PYGZdl{} ls
\end{sphinxVerbatim}

and the following libraries should be present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bindings  libns3\PYGZhy{}core.so       ns3      scratch  utils
examples  libns3\PYGZhy{}core\PYGZhy{}test.so  samples  src
\end{sphinxVerbatim}

Note the \sphinxcode{\sphinxupquote{./waf clean}} step is done here only to make it more obvious which module libraries were built.  You don’t have to do \sphinxcode{\sphinxupquote{./waf clean}} in order to enable subsets of modules.

Running test.py will cause only those tests that depend on module core to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
24 of 24 tests passed (24 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

Repeat the above steps for the “network” module instead of the “core” module, and the following will be built, since network depends on core:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bindings  libns3\PYGZhy{}core.so       libns3\PYGZhy{}network.so       ns3      scratch  utils
examples  libns3\PYGZhy{}core\PYGZhy{}test.so  libns3\PYGZhy{}network\PYGZhy{}test.so  samples  src
\end{sphinxVerbatim}

Running test.py will cause those tests that depend on only the core and network modules to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
31 of 31 tests passed (31 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\section{Enabling/disabling \sphinxstyleemphasis{ns\sphinxhyphen{}3} Tests and Examples}
\label{\detokenize{enable-tests:enabling-disabling-ns3-tests-and-examples}}\label{\detokenize{enable-tests::doc}}
The \sphinxstyleemphasis{ns\sphinxhyphen{}3} distribution includes many examples and tests that are used to validate the \sphinxstyleemphasis{ns\sphinxhyphen{}3} system.  Users, however, may not always want these examples and tests to be run for their installation of \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

This chapter discusses how to build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with or without its examples and tests.


\subsection{How to enable/disable examples and tests in \sphinxstyleemphasis{ns\sphinxhyphen{}3}}
\label{\detokenize{enable-tests:how-to-enable-disable-examples-and-tests-in-ns3}}
There are 3 ways to enable/disable examples and tests in \sphinxstyleemphasis{ns\sphinxhyphen{}3}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Using build.py when \sphinxstyleemphasis{ns\sphinxhyphen{}3} is built for the first time

\item {} 
Using waf once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built

\item {} 
Using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built

\end{enumerate}


\subsubsection{Enable/disable examples and tests using build.py}
\label{\detokenize{enable-tests:enable-disable-examples-and-tests-using-build-py}}
You can use build.py to enable/disable examples and tests when \sphinxstyleemphasis{ns\sphinxhyphen{}3} is built for the first time.

By default, examples and tests are not built in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

From the ns\sphinxhyphen{}3\sphinxhyphen{}allinone directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} without any
examples or tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./build.py
\end{sphinxVerbatim}

Running test.py in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory now will cause no examples or tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

If you would like build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples and tests, then do the following from the ns\sphinxhyphen{}3\sphinxhyphen{}allinone directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./build.py \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\end{sphinxVerbatim}

Running test.py in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory will cause all of the examples and tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable/disable examples and tests using waf}
\label{\detokenize{enable-tests:enable-disable-examples-and-tests-using-waf}}
You can use waf to enable/disable examples and tests once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built.

By default, examples and tests are not built in \sphinxstyleemphasis{ns\sphinxhyphen{}3}.

From the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} without any
examples or tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure
\PYGZdl{} ./waf build
\end{sphinxVerbatim}

Running test.py now will cause no examples or tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

If you would like build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples and tests, then do the following from the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}examples \PYGZhy{}\PYGZhy{}enable\PYGZhy{}tests
\PYGZdl{} ./waf build
\end{sphinxVerbatim}

Running test.py will cause all of the examples and tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\subsubsection{Enable/disable examples and tests using the \sphinxstyleemphasis{ns\sphinxhyphen{}3} configuration file}
\label{\detokenize{enable-tests:enable-disable-examples-and-tests-using-the-ns3-configuration-file}}
A configuration file, .ns3rc, has been added to \sphinxstyleemphasis{ns\sphinxhyphen{}3} that allows users to specify whether examples and tests should be built or not.  You can use this file to enable/disable examples and tests once \sphinxstyleemphasis{ns\sphinxhyphen{}3} has been built.

When enabling disabling examples and tests, the precedence rules are as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
the \textendash{}enable\sphinxhyphen{}examples/\textendash{}disable\sphinxhyphen{}examples configure strings override any .ns3rc file

\item {} 
the \textendash{}enable\sphinxhyphen{}tests/\textendash{}disable\sphinxhyphen{}tests configure strings override any .ns3rc file

\item {} 
the .ns3rc file in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory is next consulted, if present

\item {} 
the system searches for \textasciitilde{}/.ns3rc if the .ns3rc file was not found in the previous step

\end{enumerate}

If none of the above exists, then examples and tests will not be built.

The maintained version of the .ns3rc file in the \sphinxstyleemphasis{ns\sphinxhyphen{}3} source code repository resides in the \sphinxcode{\sphinxupquote{utils}} directory.  The reason for this is if it were in the top\sphinxhyphen{}level directory of the repository, it would be prone to accidental checkins from maintainers that enable the modules they want to use.  Therefore, users need to manually copy the .ns3rc from the \sphinxcode{\sphinxupquote{utils}} directory to their preferred place (top level directory or their home directory) to enable persistent enabling of examples and tests.

Assuming that you are in the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can get a copy of the .ns3rc file that is in the \sphinxcode{\sphinxupquote{utils}} directory as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cp utils/.ns3rc .
\end{sphinxVerbatim}

The .ns3rc file should now be in your top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, and it contains the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python}

\PYG{c+c1}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c+c1}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} All modules can be enabled by choosing \PYGZsq{}all\PYGZus{}modules\PYGZsq{}.}
\PYG{n}{modules\PYGZus{}enabled} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all\PYGZus{}modules}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want examples to be run.}
\PYG{n}{examples\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{False}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want tests to be run.}
\PYG{n}{tests\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{False}
\end{sphinxVerbatim}

From the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} without any
examples or tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure
\PYGZdl{} ./waf build
\end{sphinxVerbatim}

Running test.py now will cause no examples or tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}

If you would like build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples and tests, use your
favorite editor to change the values in the .ns3rc file for
examples\_enabled and tests\_enabled file to be True:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}! /usr/bin/env python}

\PYG{c+c1}{\PYGZsh{} A list of the modules that will be enabled when ns\PYGZhy{}3 is run.}
\PYG{c+c1}{\PYGZsh{} Modules that depend on the listed modules will be enabled also.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} All modules can be enabled by choosing \PYGZsq{}all\PYGZus{}modules\PYGZsq{}.}
\PYG{n}{modules\PYGZus{}enabled} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all\PYGZus{}modules}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want examples to be run.}
\PYG{n}{examples\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{True}

\PYG{c+c1}{\PYGZsh{} Set this equal to true if you want tests to be run.}
\PYG{n}{tests\PYGZus{}enabled} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

From the top level \sphinxstyleemphasis{ns\sphinxhyphen{}3} directory, you can build \sphinxstyleemphasis{ns\sphinxhyphen{}3} with examples
and tests simply by doing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf configure
\PYGZdl{} ./waf build
\end{sphinxVerbatim}

Running test.py will cause all of the examples and tests to be run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
\end{sphinxVerbatim}


\section{Troubleshooting}
\label{\detokenize{troubleshoot:troubleshooting}}\label{\detokenize{troubleshoot::doc}}
This chapter posts some information about possibly common errors in building
or running \sphinxstyleemphasis{ns\sphinxhyphen{}3} programs.

Please note that the wiki
(\sphinxurl{http://www.nsnam.org/wiki/Troubleshooting}) may have contributed
items.


\subsection{Build errors}
\label{\detokenize{troubleshoot:build-errors}}

\subsection{Run\sphinxhyphen{}time errors}
\label{\detokenize{troubleshoot:run-time-errors}}
Sometimes, errors can occur with a program after a successful build. These are
run\sphinxhyphen{}time errors, and can commonly occur when memory is corrupted or pointer
values are unexpectedly null.

Here is an example of what might occur:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point
Entering directory \PYG{l+s+s1}{\PYGZsq{}/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build\PYGZsq{}}
Compilation finished successfully
Command \PYG{o}{[}\PYG{l+s+s1}{\PYGZsq{}/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build/debug/examples/tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point\PYGZsq{}}\PYG{o}{]} exited with code \PYGZhy{}11
\end{sphinxVerbatim}

The error message says that the program terminated unsuccessfully, but it is
not clear from this information what might be wrong. To examine more
closely, try running it under the \sphinxhref{http://sources.redhat.com/gdb/}{gdb debugger}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point \PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}gdb \PYGZpc{}s\PYGZdq{}}
Entering directory \PYG{l+s+s1}{\PYGZsq{}/home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build\PYGZsq{}}
Compilation finished successfully
GNU gdb Red Hat Linux \PYG{o}{(}\PYG{l+m}{6}.3.0.0\PYGZhy{}1.134.fc5rh\PYG{o}{)}
Copyright \PYG{l+m}{2004} Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type \PYG{l+s+s2}{\PYGZdq{}show copying\PYGZdq{}} to see the conditions.
There is absolutely no warranty \PYG{k}{for} GDB.  Type \PYG{l+s+s2}{\PYGZdq{}show warranty\PYGZdq{}} \PYG{k}{for} details.
This GDB was configured as \PYG{l+s+s2}{\PYGZdq{}i386\PYGZhy{}redhat\PYGZhy{}linux\PYGZhy{}gnu\PYGZdq{}}...Using host libthread\PYGZus{}db
library \PYG{l+s+s2}{\PYGZdq{}/lib/libthread\PYGZus{}db.so.1\PYGZdq{}}.

\PYG{o}{(}gdb\PYG{o}{)} run
Starting program: /home/tomh/ns\PYGZhy{}3\PYGZhy{}nsc/build/debug/examples/tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point
Reading symbols from shared object \PYG{n+nb}{read} from target memory...done.
Loaded system supplied DSO at 0xf5c000

Program received signal SIGSEGV, Segmentation fault.
0x0804aa12 in main \PYG{o}{(}\PYG{n+nv}{argc}\PYG{o}{=}\PYG{l+m}{1}, \PYG{n+nv}{argv}\PYG{o}{=}0xbfdfefa4\PYG{o}{)}
    at ../examples/tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point.cc:136
\PYG{l+m}{136}       Ptr\PYGZlt{}Socket\PYGZgt{} \PYG{n+nv}{localSocket} \PYG{o}{=} socketFactory\PYGZhy{}\PYGZgt{}CreateSocket \PYG{o}{(}\PYG{o}{)}\PYG{p}{;}
\PYG{o}{(}gdb\PYG{o}{)} p localSocket
\PYG{n+nv}{\PYGZdl{}1} \PYG{o}{=} \PYG{o}{\PYGZob{}}\PYG{n+nv}{m\PYGZus{}ptr} \PYG{o}{=} 0x3c5d65\PYG{o}{\PYGZcb{}}
\PYG{o}{(}gdb\PYG{o}{)} p socketFactory
\PYG{n+nv}{\PYGZdl{}2} \PYG{o}{=} \PYG{o}{\PYGZob{}}\PYG{n+nv}{m\PYGZus{}ptr} \PYG{o}{=} 0x0\PYG{o}{\PYGZcb{}}
\PYG{o}{(}gdb\PYG{o}{)} quit
The program is running.  Exit anyway? \PYG{o}{(}y or n\PYG{o}{)} y
\end{sphinxVerbatim}

Note first the way the program was invoked\textendash{} pass the command to run as an
argument to the command template “gdb \%s”.

This tells us that there was an attempt to dereference a null pointer
socketFactory.

Let’s look around line 136 of tcp\sphinxhyphen{}point\sphinxhyphen{}to\sphinxhyphen{}point, as gdb suggests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{SocketFactory}\PYG{o}{\PYGZgt{}} \PYG{n}{socketFactory} \PYG{o}{=} \PYG{n}{n2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GetObject}\PYG{o}{\PYGZlt{}}\PYG{n}{SocketFactory}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{Tcp}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iid}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{Socket}\PYG{o}{\PYGZgt{}} \PYG{n}{localSocket} \PYG{o}{=} \PYG{n}{socketFactory}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CreateSocket} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{localSocket}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Bind} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The culprit here is that the return value of GetObject is not being checked and
may be null.

Sometimes you may need to use the \sphinxhref{http://valgrind.org}{valgrind memory checker} for more subtle errors. Again, you invoke the use of
valgrind similarly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./waf \PYGZhy{}\PYGZhy{}run tcp\PYGZhy{}point\PYGZhy{}to\PYGZhy{}point \PYGZhy{}\PYGZhy{}command\PYGZhy{}template\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}valgrind \PYGZpc{}s\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{Cic06}
\bibitem[Cic06]{probe:cic06}
Claudio Cicconetti, Enzo Mingozzi, Giovanni Stea, “An Integrated
Framework for Enabling Effective Data Collection and Statistical
Analysis with ns2, Workshop on ns\sphinxhyphen{}2 (WNS2), Pisa, Italy, October 2006.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}