

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Design Documentation &#8212; Model Library</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User Documentation" href="lte-user.html" />
    <link rel="prev" title="LTE Module" href="lte.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico" 
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>
      

  </head><body>
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0" width="100%">
      <tbody>
	<tr style="height: 56px;">
	  <td id="projectlogo">
	    <a id="ns3_home1"
	       href="http://www.nsnam.org/">
	       <img alt="ns-3 Logo"
		    src="_static/ns-3-inverted-notext-small.png"/>
	    </a>
	  </td>
	  <td id="projecttext">
	    <div id="projectbrief">A Discrete-Event Network Simulator</div>
	      <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
	  </td>
	      
	  <td id="ns3-menu">
	    <div class="menu">
	      <ul >
	        <li><a id="ns3_home2"
		       href="http://www.nsnam.org/"
		       >&nbsp;&nbsp;Home</a>
	        </li>
	        <li><span
		      onmouseover="mopen('mTuts')" 
		      onmouseout="mclosetime()"
			>Tutorials &nbsp;&#x25BC;</span>
		    <div id="mTuts" 
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_tut"
			 href="/docs/tutorial/html/index.html"
			  >English</a><br/>
	        </li>
	        <li><span
		      onmouseover="mopen('mDocs')" 
		      onmouseout="mclosetime()"
			>Docs &nbsp;&nbsp;&nbsp;&#x25BC;</span>
		    <div id="mDocs"
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_wiki"
			 href="http://www.nsnam.org/wiki"
			 >Wiki</a><br/>
		      <a id="ns3_man"
			 href="/docs/manual/html/index.html"
			 >Manual</a><br/>
		      <a id="ns3_mod"
			 href="/docs/models/html/index.html"
			 >Models</a><br/>
	        </li>
	        <li><span
		      onmouseover="mopen('mDev')" 
		      onmouseout="mclosetime()"
			>Develop &#x25BC;</span>
		    <div id="mDev"
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_api"
			 href="/docs/doxygen/html/index.html"
			 >API</a><br/>
		      <a id="ns3_bugs"
		       href="http://www.nsnam.org/bugzilla/">Bugs</a>
	        </li>
	      </ul>
	    </div>
	  </td>
	  <td id="projectsection">
	    <span style="margin-right:10px">Models</span>
	  </td>
	</tr>
      </tbody>
    </table>
    <script  type="text/javascript">ns3_write_links()</script>
  </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="lte-user.html" title="User Documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lte.html" title="LTE Module"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="lte.html" accesskey="U">LTE Module</a><span class="navelem">&nbsp;</span></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="design-documentation">
<h1>Design Documentation<a class="headerlink" href="#design-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>An overview of the  LTE-EPC simulation model is depicted in
the figure <a class="reference internal" href="#fig-epc-topology"><span class="std std-ref">Overview of the LTE-EPC simulation model</span></a>. There are two main components:</p>
<blockquote>
<div><ul class="simple">
<li><p>the LTE Model. This model includes the LTE Radio Protocol
stack (RRC, PDCP, RLC, MAC, PHY). These entities reside entirely within the
UE and the eNB nodes.</p></li>
<li><p>the EPC Model. This model includes core network
interfaces, protocols and entities. These entities and protocols
reside within the SGW, PGW and MME nodes, and partially within the
eNB nodes.</p></li>
</ul>
</div></blockquote>
<div class="figure align-center" id="id143">
<span id="fig-epc-topology"></span><img alt="_images/epc-topology-with-split.png" src="_images/epc-topology-with-split.png" />
<p class="caption"><span class="caption-text">Overview of the LTE-EPC simulation model</span><a class="headerlink" href="#id143" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="design-criteria">
<span id="sec-design-criteria"></span><h2>Design Criteria<a class="headerlink" href="#design-criteria" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lte-model">
<h3>LTE Model<a class="headerlink" href="#lte-model" title="Permalink to this headline">¶</a></h3>
<p>The LTE model has been designed to support the evaluation of the following aspects of LTE systems:</p>
<blockquote>
<div><ul class="simple">
<li><p>Radio Resource Management</p></li>
<li><p>QoS-aware Packet Scheduling</p></li>
<li><p>Inter-cell Interference Coordination</p></li>
<li><p>Dynamic Spectrum Access</p></li>
</ul>
</div></blockquote>
<p>In order to model LTE systems to a level of detail that is sufficient to allow a
correct evaluation of the above mentioned aspects, the following requirements
have been considered:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>At the radio level, the granularity of the model should be at least that
of the Resource Block (RB). In fact, this is the fundamental unit being used for
resource allocation. Without this minimum level of granularity, it is not
possible to model accurately packet scheduling and
inter-cell-interference.
The reason is that, since packet scheduling is done on
a per-RB basis, an eNB might transmit on a subset only of all the available
RBs, hence interfering with other eNBs only on those RBs where it is
transmitting.
Note that this requirement rules out the adoption of a system level simulation
approach, which evaluates resource allocation only at the granularity of
call/bearer establishment.</p></li>
<li><p>The simulator should scale up to tens of eNBs and hundreds of User
Equipment (UEs). This
rules out the use of a link level simulator, i.e., a simulator whose radio
interface is modeled with a granularity up to the symbol level. This is because
to have a symbol level model it is necessary to implement all the PHY
layer signal processing, whose huge computational complexity severely limits
simulation. In fact, link-level simulators are normally limited to a single eNB
and one or a few UEs.</p></li>
<li><p>It should be possible within the simulation to configure different cells
so that they use different carrier frequencies and system bandwidths. The
bandwidth used by different cells should be allowed to overlap, in order to
support dynamic spectrum licensing solutions such as those described
in <a class="reference internal" href="lte-references.html#ofcom2600mhz" id="id1"><span>[Ofcom2600MHz]</span></a> and <a class="reference internal" href="lte-references.html#realwireless" id="id2"><span>[RealWireless]</span></a>. The calculation of interference should
handle appropriately this case.</p></li>
<li><p>To be more representative of the LTE standard, as well as to be as
close as possible to real-world implementations, the simulator
should support the MAC Scheduler API published by the FemtoForum
<a class="reference internal" href="lte-references.html#ffapi" id="id3"><span>[FFAPI]</span></a>. This interface is expected to be used by femtocell manufacturers
for the implementation of scheduling and Radio Resource Management
(RRM) algorithms. By introducing support for this interface in the
simulator, we make it possible for LTE equipment vendors and
operators to test in a simulative environment exactly the same
algorithms that would be deployed in a real system.</p></li>
<li><p>The LTE simulation model should contain its own implementation of
the API defined in <a class="reference internal" href="lte-references.html#ffapi" id="id4"><span>[FFAPI]</span></a>. Neither
binary nor data structure compatibility with vendor-specific implementations
of the same interface are expected; hence, a compatibility layer should be
interposed whenever a vendor-specific MAC scheduler is to be used
with the simulator. This requirement is necessary to allow the
simulator to be independent from vendor-specific implementations of this
interface specification. We note that <a class="reference internal" href="lte-references.html#ffapi" id="id5"><span>[FFAPI]</span></a> is a logical
specification only, and its implementation (e.g., translation to some specific
programming language) is left to the vendors.</p></li>
<li><p>The model is to be used to simulate the transmission of IP packets
by the upper layers. With this respect, it shall be considered
that in LTE the Scheduling and Radio Resource Management do not
work with IP packets directly, but rather with RLC PDUs, which are
obtained by segmentation and concatenation of IP packets done by
the RLC entities. Hence, these functionalities of the RLC layer
should be modeled accurately.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="epc-model">
<h3>EPC Model<a class="headerlink" href="#epc-model" title="Permalink to this headline">¶</a></h3>
<p>The main objective of the EPC model is to provides means for the
simulation of end-to-end IP connectivity over the LTE model.
To this aim, it supports for the
interconnection of multiple UEs to the Internet, via a radio access
network of multiple eNBs connected to the core network, as shown
in Figure <a class="reference internal" href="#fig-epc-topology"><span class="std std-ref">Overview of the LTE-EPC simulation model</span></a>.</p>
<p>The following design choices have been made for the EPC model:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The Packet Data Network (PDN) type supported is both IPv4 and IPv6.
In other words, the end-to-end connections between the UEs and the remote
hosts can be IPv4 and IPv6. However, the networks between the core network
elements (MME, SGWs and PGWs) are IPv4-only.</p></li>
<li><p>The SGW and PGW functional entities are implemented in different
nodes, which are hence referred to as the SGW node and PGW node,
respectively.</p></li>
<li><p>The MME functional entities is implemented as a network node,
which is hence referred to as the MME node.</p></li>
<li><p>The scenarios with inter-SGW mobility are not of interest. But
several SGW nodes may be present in simulations scenarios.</p></li>
<li><p>A requirement for the EPC model is that it can be used to simulate the
end-to-end performance of realistic applications. Hence, it should
be possible to use with the EPC model any regular ns-3 application
working on top of TCP or UDP.</p></li>
<li><p>Another requirement is the possibility of simulating network topologies
with the presence of multiple eNBs, some of which might be
equipped with a backhaul connection with limited capabilities. In
order to simulate such scenarios, the user data plane
protocols being used between the eNBs and the SGW should be
modeled accurately.</p></li>
<li><p>It should be possible for a single UE to use different applications
with different QoS profiles. Hence, multiple EPS bearers should be
supported for each UE. This includes the necessary classification
of TCP/UDP traffic over IP done at the UE in the uplink and at the
PGW in the downlink.</p></li>
<li><p>The initial focus of the EPC model is mainly on the EPC data plane.
The accurate modeling of the EPC control plane is,
for the time being, not a requirement; however, the necessary control
plane interactions among the different network nodes of the core network
are realized by implementing control protocols/messages among them.
Direct interaction among the different simulation objects via the
provided helper objects should be avoided as much as possible.</p></li>
<li><p>The focus of the EPC model is on simulations of active users in ECM
connected mode. Hence, all the functionality that is only relevant
for ECM idle mode (in particular, tracking area update and paging)
are not modeled at all.</p></li>
<li><p>The model should allow the possibility to perform an X2-based
handover between two eNBs.</p></li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="architecture">
<span id="sec-overall-architecture"></span><h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id6">
<h3>LTE Model<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ue-architecture">
<h4>UE architecture<a class="headerlink" href="#ue-architecture" title="Permalink to this headline">¶</a></h4>
<p>The architecture of the LTE radio protocol stack model of the UE is
represented in the figures <a class="reference internal" href="#fig-lte-arch-ue-data"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the data plane</span></a> and
<a class="reference internal" href="#fig-lte-arch-ue-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the control plane</span></a> which highlight respectively the data
plane and the control plane.</p>
<div class="figure align-center" id="id144">
<span id="fig-lte-arch-ue-data"></span><img alt="_images/lte-arch-ue-data.png" src="_images/lte-arch-ue-data.png" />
<p class="caption"><span class="caption-text">LTE radio protocol stack architecture for the UE on the data plane</span><a class="headerlink" href="#id144" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id145">
<span id="fig-lte-arch-ue-ctrl"></span><img alt="_images/lte-arch-ue-ctrl.png" src="_images/lte-arch-ue-ctrl.png" />
<p class="caption"><span class="caption-text">LTE radio protocol stack architecture for the UE on the control plane</span><a class="headerlink" href="#id145" title="Permalink to this image">¶</a></p>
</div>
<p>The architecture of the PHY/channel model of the UE is represented in figure <a class="reference internal" href="#fig-lte-ue-phy"><span class="std std-ref">PHY and channel model architecture for the UE</span></a>.</p>
<div class="figure align-center" id="id146">
<span id="fig-lte-ue-phy"></span><img alt="_images/lte-ue-phy.png" src="_images/lte-ue-phy.png" />
<p class="caption"><span class="caption-text">PHY and channel model architecture for the UE</span><a class="headerlink" href="#id146" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="enb-architecture">
<h4>eNB architecture<a class="headerlink" href="#enb-architecture" title="Permalink to this headline">¶</a></h4>
<p>The architecture of the LTE radio protocol stack model of the eNB is
represented in the figures <a class="reference internal" href="#fig-lte-arch-enb-data"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the data plane</span></a> and
<a class="reference internal" href="#fig-lte-arch-enb-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the control plane</span></a> which highlight respectively the data plane
and the control plane.</p>
<div class="figure align-center" id="id147">
<span id="fig-lte-arch-enb-data"></span><img alt="_images/lte-arch-enb-data.png" src="_images/lte-arch-enb-data.png" />
<p class="caption"><span class="caption-text">LTE radio protocol stack architecture for the eNB on the data plane</span><a class="headerlink" href="#id147" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id148">
<span id="fig-lte-arch-enb-ctrl"></span><img alt="_images/lte-arch-enb-ctrl.png" src="_images/lte-arch-enb-ctrl.png" />
<p class="caption"><span class="caption-text">LTE radio protocol stack architecture for the eNB on the control plane</span><a class="headerlink" href="#id148" title="Permalink to this image">¶</a></p>
</div>
<p>The architecture of the PHY/channel model of the eNB is represented in figure <a class="reference internal" href="#fig-lte-enb-phy"><span class="std std-ref">PHY and channel model architecture for the eNB</span></a>.</p>
<div class="figure align-center" id="id149">
<span id="fig-lte-enb-phy"></span><img alt="_images/lte-enb-phy.png" src="_images/lte-enb-phy.png" />
<p class="caption"><span class="caption-text">PHY and channel model architecture for the eNB</span><a class="headerlink" href="#id149" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="id7">
<h3>EPC Model<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="section" id="epc-data-plane">
<h4>EPC data plane<a class="headerlink" href="#epc-data-plane" title="Permalink to this headline">¶</a></h4>
<p>In Figure <a class="reference internal" href="#fig-lte-epc-e2e-data-protocol-stack-with-split"><span class="std std-ref">LTE-EPC data plane protocol stack</span></a>, we represent the
end-to-end LTE-EPC data plane protocol stack as it is modeled in the
simulator. The figure shows all nodes in the data path, i.e. UE, eNB,
SGW, PGW and a remote host in the Internet. All protocol stacks
(S5 protocol stack, S1-U protocol stack and the LTE radio protocol stack)
specified by 3GPP are present.</p>
<div class="figure align-center" id="id150">
<span id="fig-lte-epc-e2e-data-protocol-stack-with-split"></span><img alt="_images/lte-epc-e2e-data-protocol-stack-with-split.png" src="_images/lte-epc-e2e-data-protocol-stack-with-split.png" />
<p class="caption"><span class="caption-text">LTE-EPC data plane protocol stack</span><a class="headerlink" href="#id150" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="epc-control-plane">
<h4>EPC control plane<a class="headerlink" href="#epc-control-plane" title="Permalink to this headline">¶</a></h4>
<p>The architecture of the implementation of the control plane model is
shown in figure <a class="reference internal" href="#fig-lte-epc-e2e-control-protocol-stack-with-split"><span class="std std-ref">LTE-EPC control plane protocol stack</span></a>.
The control interfaces that are modeled explicitly are the S1-MME, the S11, and the S5
interfaces. The X2 interface is also modeled explicitly and it is described in more
detail in section <a class="reference internal" href="#sec-x2"><span class="std std-ref">X2</span></a></p>
<p>The S1-MME, the S11 and the S5 interfaces are modeled using procotol data units sent
over its respective links. These interfaces use the SCTP protocol as transport protocol
but currently, the SCTP protocol is not modeled in the ns-3 simulator, so the
UDP protocol is used instead of the SCTP protocol.</p>
<div class="figure align-center" id="id151">
<span id="fig-lte-epc-e2e-control-protocol-stack-with-split"></span><img alt="_images/lte-epc-e2e-control-protocol-stack-with-split.png" src="_images/lte-epc-e2e-control-protocol-stack-with-split.png" />
<p class="caption"><span class="caption-text">LTE-EPC control plane protocol stack</span><a class="headerlink" href="#id151" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
</div>
<div class="section" id="channel-and-propagation">
<h2>Channel and Propagation<a class="headerlink" href="#channel-and-propagation" title="Permalink to this headline">¶</a></h2>
<p>For channel modeling purposes, the LTE module uses the <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code>
interface provided by the spectrum module. At the time of this
writing, two implementations of such interface are available:
<code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code>, and the
LTE module requires the use of the <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> in
order to work properly. This is because of the need to support
different frequency and bandwidth configurations. All the
propagation models supported by <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> can be
used within the LTE module.</p>
<div class="section" id="use-of-the-buildings-model-with-lte">
<h3>Use of the Buildings model with LTE<a class="headerlink" href="#use-of-the-buildings-model-with-lte" title="Permalink to this headline">¶</a></h3>
<p>The recommended propagation model to be used with the LTE
module is the one provided by the Buildings module, which was in fact
designed specifically with LTE (though it can be used with other
wireless technologies as well). Please refer to the documentation of
the Buildings module for generic information on the propagation model
it provides.</p>
<p>In this section we will highlight some considerations that
specifically apply when the Buildings module is used together with the
LTE module.</p>
<p>The naming convention used in the following will be:</p>
<blockquote>
<div><ul class="simple">
<li><p>User equipment:  UE</p></li>
<li><p>Macro Base Station: MBS</p></li>
<li><p>Small cell Base Station (e.g., pico/femtocell): SC</p></li>
</ul>
</div></blockquote>
<p>The LTE module considers FDD only, and implements downlink and uplink propagation separately. As a consequence, the following pathloss computations are performed</p>
<blockquote>
<div><ul class="simple">
<li><p>MBS &lt;-&gt; UE (indoor and outdoor)</p></li>
<li><p>SC (indoor and outdoor) &lt;-&gt; UE (indoor and outdoor)</p></li>
</ul>
</div></blockquote>
<p>The LTE model does not provide the following pathloss computations:</p>
<blockquote>
<div><ul class="simple">
<li><p>UE &lt;-&gt; UE</p></li>
<li><p>MBS &lt;-&gt; MBS</p></li>
<li><p>MBS &lt;-&gt; SC</p></li>
<li><p>SC &lt;-&gt; SC</p></li>
</ul>
</div></blockquote>
<p>The Buildings model does not know the actual type of the node; i.e.,
it is not aware of whether a transmitter node is a UE, a MBS, or a
SC. Rather, the Buildings model only cares about the position of the
node: whether it is indoor and outdoor, and what is its z-axis respect
to the rooftop level. As a consequence, for an eNB node that is placed
outdoor and at a z-coordinate above the rooftop level, the propagation
models typical of MBS will be used by the Buildings
module. Conversely, for an eNB that is placed outdoor but below the
rooftop,  or indoor, the propagation models typical of pico and
femtocells will be used.</p>
<p>For communications involving at least one indoor node, the
corresponding wall penetration losses will be calculated by the
Buildings model. This covers the following use cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>MBS &lt;-&gt; indoor UE</p></li>
<li><p>outdoor SC &lt;-&gt; indoor UE</p></li>
<li><p>indoor SC &lt;-&gt; indoor UE</p></li>
<li><p>indoor SC &lt;-&gt; outdoor UE</p></li>
</ul>
</div></blockquote>
<p>Please refer to the documentation of the Buildings module for details
on the actual models used in each case.</p>
</div>
<div class="section" id="fading-model">
<span id="sec-fading-model"></span><h3>Fading Model<a class="headerlink" href="#fading-model" title="Permalink to this headline">¶</a></h3>
<p>The LTE module includes a trace-based fading model derived from the one developed during the GSoC 2010 <a class="reference internal" href="lte-references.html#piro2011" id="id8"><span>[Piro2011]</span></a>. The main characteristic of this model is the fact that the fading evaluation during simulation run-time is based on per-calculated traces. This is done to limit the computational complexity of the simulator. On the other hand, it needs huge structures for storing the traces; therefore, a trade-off between the number of possible parameters and the memory occupancy has to be found. The most important ones are:</p>
<blockquote>
<div><ul class="simple">
<li><p>users’ speed: relative speed between users (affects the Doppler frequency, which in turns affects the time-variance property of the fading)</p></li>
<li><p>number of taps (and relative power): number of multiple paths considered, which affects the frequency property of the fading.</p></li>
<li><p>time granularity of the trace: sampling time of the trace.</p></li>
<li><p>frequency granularity of the trace: number of values in frequency to be evaluated.</p></li>
<li><p>length of trace: ideally large as the simulation time, might be reduced by windowing mechanism.</p></li>
<li><p>number of users: number of independent traces to be used (ideally one trace per user).</p></li>
</ul>
</div></blockquote>
<p>With respect to the mathematical channel propagation model, we suggest the one provided by the <code class="docutils literal notranslate"><span class="pre">rayleighchan</span></code> function of Matlab, since it provides a well accepted channel modelization both in time and frequency domain. For more information, the reader is referred to  <a class="reference internal" href="lte-references.html#mathworks" id="id9"><span>[mathworks]</span></a>.</p>
<p>The simulator provides a matlab script (<code class="docutils literal notranslate"><span class="pre">src/lte/model/fading-traces/fading-trace-generator.m</span></code>) for generating traces based on the format used by the simulator.
In detail, the channel object created with the rayleighchan function is used for filtering a discrete-time impulse signal in order to obtain the channel impulse response. The filtering is repeated for different TTI, thus yielding subsequent time-correlated channel responses (one per TTI). The channel response is then processed with the <code class="docutils literal notranslate"><span class="pre">pwelch</span></code> function for obtaining its power spectral density values, which are then saved in a file with the proper format compatible with the simulator model.</p>
<p>Since the number of variable it is pretty high, generate traces considering all of them might produce a high number of traces of huge size. On this matter, we considered the following assumptions of the parameters based on the 3GPP fading propagation conditions (see Annex B.2 of <a class="reference internal" href="lte-references.html#ts36104" id="id10"><span>[TS36104]</span></a>):</p>
<blockquote>
<div><ul class="simple">
<li><p>users’ speed: typically only a few discrete values are considered, i.e.:</p>
<ul>
<li><p>0 and 3 kmph for pedestrian scenarios</p></li>
<li><p>30 and 60 kmph for vehicular scenarios</p></li>
<li><p>0, 3, 30 and 60 for urban scenarios</p></li>
</ul>
</li>
<li><p>channel taps: only a limited number of sets of channel taps are normally considered, for example three models are mentioned in Annex B.2 of <a class="reference internal" href="lte-references.html#ts36104" id="id11"><span>[TS36104]</span></a>.</p></li>
<li><p>time granularity: we need one fading value per TTI, i.e., every 1 ms (as this is the granularity in time of the ns-3 LTE PHY model).</p></li>
<li><p>frequency granularity: we need one fading value per RB (which is the frequency granularity of the spectrum model used by the ns-3 LTE model).</p></li>
<li><p>length of the trace: the simulator includes the windowing mechanism implemented during the GSoC 2011, which consists of picking up a window of the trace each window length in a random fashion.</p></li>
<li><p>per-user fading process: users share the same fading trace, but for each user a different starting point in the trace is randomly picked up. This choice was made to avoid the need to provide one fading trace per user.</p></li>
</ul>
</div></blockquote>
<p>According to the parameters we considered, the following formula express in detail the total size <img class="math" src="_images/math/7e8fc2514e47c89474c09f0e60bc4347ff27a86f.png" alt="S_{traces}"/> of the fading traces:</p>
<div class="math">
<p><img src="_images/math/e2b5a5ab300c497a9a0fd80fff9f1a4efe80e388.png" alt="S_{traces} = S_{sample} \times N_{RB} \times \frac{T_{trace}}{T_{sample}} \times N_{scenarios} \mbox{ [bytes]}"/></p>
</div><p>where <img class="math" src="_images/math/792331b81b1f05472af9f2609963de330f87f6ce.png" alt="S_{sample}"/> is the size in bytes of the sample (e.g., 8 in case of double precision, 4 in case of float precision), <img class="math" src="_images/math/049f11949db10818eace89509bc5e593b87cb37a.png" alt="N_{RB}"/> is the number of RB or set of RBs to be considered, <img class="math" src="_images/math/6951ccb723a9067235d9624fdb210b33c55ded54.png" alt="T_{trace}"/> is the total length of the trace, <img class="math" src="_images/math/b0aefca274fa376e150a65fa40a36f1d2f50dd3e.png" alt="T_{sample}"/> is the time resolution of the trace (1 ms), and <img class="math" src="_images/math/2ef05794582db9d0f9d63b2f18c9364084c98313.png" alt="N_{scenarios}"/> is the number of fading scenarios that are desired (i.e., combinations of different sets of channel taps and user speed values). We provide traces for 3 different scenarios one for each taps configuration defined in Annex B.2 of <a class="reference internal" href="lte-references.html#ts36104" id="id12"><span>[TS36104]</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Pedestrian: with nodes’ speed of 3 kmph.</p></li>
<li><p>Vehicular: with nodes’ speed of 60 kmph.</p></li>
<li><p>Urban: with nodes’ speed of 3 kmph.</p></li>
</ul>
</div></blockquote>
<p>hence <img class="math" src="_images/math/527d42178112aecc8f53d09e873d34644e199c9d.png" alt="N_{scenarios} = 3"/>. All traces have <img class="math" src="_images/math/726fc6789f8ccce116bb761beaf87942248b063a.png" alt="T_{trace} = 10"/> s and <img class="math" src="_images/math/61624b56a435c045834ad77eef63bd8cbfe764be.png" alt="RB_{NUM} = 100"/>. This results in a total 24 MB bytes of traces.</p>
</div>
<div class="section" id="antennas">
<h3>Antennas<a class="headerlink" href="#antennas" title="Permalink to this headline">¶</a></h3>
<p>Being based on the <code class="docutils literal notranslate"><span class="pre">SpectrumPhy</span></code>, the LTE PHY model supports antenna
modeling via the ns-3 <code class="docutils literal notranslate"><span class="pre">AntennaModel</span></code> class. Hence, any model based on
this class can be associated with any eNB or UE instance. For
instance, the use of the <code class="docutils literal notranslate"><span class="pre">CosineAntennaModel</span></code> associated with an eNB
device allows to model one sector of a macro base station. By default,
the <code class="docutils literal notranslate"><span class="pre">IsotropicAntennaModel</span></code> is used for both eNBs and UEs.</p>
</div>
</div>
<div class="section" id="phy">
<h2>PHY<a class="headerlink" href="#phy" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3>Overview<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>The physical layer model provided in this LTE simulator is based on
the one described in <a class="reference internal" href="lte-references.html#piro2011" id="id14"><span>[Piro2011]</span></a>, with the following modifications.  The model now includes the
inter cell interference calculation and the simulation of uplink traffic, including both packet transmission and CQI generation.</p>
</div>
<div class="section" id="subframe-structure">
<h3>Subframe Structure<a class="headerlink" href="#subframe-structure" title="Permalink to this headline">¶</a></h3>
<p>The subframe is divided into control and data part as described in Figure <a class="reference internal" href="#fig-lte-subframe-structure"><span class="std std-ref">LTE subframe division.</span></a>.</p>
<div class="figure align-center" id="id152">
<span id="fig-lte-subframe-structure"></span><a class="reference internal image-reference" href="_images/lte-subframe-structure.png"><img alt="_images/lte-subframe-structure.png" src="_images/lte-subframe-structure.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-text">LTE subframe division.</span><a class="headerlink" href="#id152" title="Permalink to this image">¶</a></p>
</div>
<p>Considering the granularity of the simulator based on RB, the control and the reference signaling have to be consequently modeled considering this constraint.  According to the standard <a class="reference internal" href="lte-references.html#ts36211" id="id15"><span>[TS36211]</span></a>, the downlink control frame starts at the beginning of each subframe and lasts up to three symbols across the whole system bandwidth, where the actual duration is provided by the Physical Control Format Indicator Channel (PCFICH). The information on the allocation are then mapped in the remaining resource up to the duration defined by the PCFICH, in the so called Physical Downlink Control Channel (PDCCH). A PDCCH transports a single message called Downlink Control Information (DCI) coming from the MAC layer, where the scheduler indicates the resource allocation for a specific user.
The PCFICH and PDCCH are modeled with the transmission of the control frame of a fixed duration of 3/14 of milliseconds spanning in the whole available bandwidth, since the scheduler does not estimate the size of the control region. This implies that a single transmission block models the entire control frame with a fixed power (i.e., the one used for the PDSCH) across all the available RBs. According to this feature, this transmission represents also a valuable support for the Reference Signal (RS). This allows of having every TTI an evaluation of the interference scenario since all the eNB are transmitting (simultaneously) the control frame over the respective available bandwidths. We note that, the model does not include the power boosting since it does not reflect any improvement in the implemented model of the channel estimation.</p>
<p>The Sounding Reference Signal (SRS) is modeled similar to the downlink control frame. The SRS is periodically placed in the last symbol of the subframe in the whole system bandwidth. The RRC module already includes an algorithm for dynamically assigning the periodicity as function of the actual number of UEs attached to a eNB according to the UE-specific procedure (see Section 8.2 of <a class="reference internal" href="lte-references.html#ts36213" id="id16"><span>[TS36213]</span></a>).</p>
</div>
<div class="section" id="mac-to-channel-delay">
<h3>MAC to Channel delay<a class="headerlink" href="#mac-to-channel-delay" title="Permalink to this headline">¶</a></h3>
<p>To model the latency of real MAC and PHY implementations, the PHY model simulates a MAC-to-channel delay in multiples of TTIs (1ms). The transmission of both data and control packets are delayed by this amount.</p>
</div>
<div class="section" id="cqi-feedback">
<span id="sec-cqi-feedback"></span><h3>CQI feedback<a class="headerlink" href="#cqi-feedback" title="Permalink to this headline">¶</a></h3>
<p>The generation of CQI feedback is done accordingly to what specified in <a class="reference internal" href="lte-references.html#ffapi" id="id17"><span>[FFAPI]</span></a>. In detail, we considered the generation
of periodic wideband CQI (i.e., a single value of channel state that is deemed representative of all RBs
in use) and inband CQIs (i.e., a set of value representing the channel state for each RB).</p>
<p>The CQI index to be reported is obtained by first obtaining a SINR measurement and then passing this SINR measurement to the <a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a> module which will map it to the CQI index.</p>
<p>In downlink, the SINR used to generate CQI feedback can be calculated in two different ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><em>Ctrl</em> method: SINR is calculated combining the signal power from the reference signals (which in the simulation is equivalent to the PDCCH) and the interference power from the PDCCH. This approach results in considering any neighboring eNB as an interferer, regardless of whether this eNB is actually performing any PDSCH transmission, and regardless of the power and RBs used for eventual interfering PDSCH transmissions.</p></li>
<li><p><em>Mixed</em> method: SINR is calculated combining the signal power from the reference signals (which in the simulation is equivalent to the PDCCH) and the interference power from the PDSCH. This approach results in considering as interferers only those neighboring eNBs that are actively transmitting data on the PDSCH, and allows to generate inband CQIs that account for different amounts of interference on different RBs according to the actual interference level. In the case that no PDSCH transmission is performed by any eNB, this method consider that interference is zero, i.e., the SINR will be calculated as the ratio of signal to noise only.</p></li>
</ol>
</div></blockquote>
<p>To switch between this two CQI generation approaches, <code class="docutils literal notranslate"><span class="pre">LteHelper::UsePdschForCqiGeneration</span></code> needs to be configured: false for first approach and true for second approach (true is default value):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteHelper::UsePdschForCqiGeneration&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>In uplink, two types of CQIs are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p>SRS based, periodically sent by the UEs.</p></li>
<li><p>PUSCH based, calculated from the actual transmitted data.</p></li>
</ul>
</div></blockquote>
<p>The scheduler interface include an attribute system called <code class="docutils literal notranslate"><span class="pre">UlCqiFilter</span></code> for managing the filtering of the CQIs according to their nature, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SRS_UL_CQI</span></code> for storing only SRS based CQIs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PUSCH_UL_CQI</span></code> for storing only PUSCH based CQIs.</p></li>
</ul>
</div></blockquote>
<p>It has to be noted that, the <code class="docutils literal notranslate"><span class="pre">FfMacScheduler</span></code> provides only the interface and it is matter of the actual scheduler implementation to include the code for managing these attributes (see scheduler related section for more information on this matter).</p>
</div>
<div class="section" id="interference-model">
<h3>Interference Model<a class="headerlink" href="#interference-model" title="Permalink to this headline">¶</a></h3>
<p>The PHY model is based on the well-known Gaussian interference models, according to which the powers of interfering signals (in linear units) are summed up together to determine the overall interference power.</p>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-phy-interference"><span class="std std-ref">Sequence diagram of the PHY interference calculation procedure</span></a> shows how interfering signals are processed to calculate the SINR, and how SINR is then used for the generation of CQI feedback.</p>
<div class="figure align-center" id="id153">
<span id="fig-lte-phy-interference"></span><img alt="_images/lte-phy-interference.png" src="_images/lte-phy-interference.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the PHY interference calculation procedure</span><a class="headerlink" href="#id153" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="lte-spectrum-model">
<h3>LTE Spectrum Model<a class="headerlink" href="#lte-spectrum-model" title="Permalink to this headline">¶</a></h3>
<p>The usage of the radio spectrum by eNBs and UEs in LTE is described in
<a class="reference internal" href="lte-references.html#ts36101" id="id18"><span>[TS36101]</span></a>. In the simulator, radio spectrum usage is modeled as follows.
Let <img class="math" src="_images/math/f3c754ede5a325f045a10fe57b2f387ad53341c4.png" alt="f_c"/> denote the  LTE Absolute Radio Frequency Channel Number, which
identifies the carrier frequency on a 100 kHz raster; furthermore, let <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> be
the Transmission Bandwidth Configuration in number of Resource Blocks. For every
pair <img class="math" src="_images/math/9d866536d78f493deb5e76b2a90cb76e6f034bff.png" alt="(f_c,B)"/> used in the simulation we define a corresponding SpectrumModel using
the functionality provided by the <a class="reference internal" href="spectrum.html#sec-spectrum-module"><span class="std std-ref">Spectrum Module</span></a> .
model using the Spectrum framework described
in <a class="reference internal" href="lte-references.html#baldo2009" id="id19"><span>[Baldo2009]</span></a>.  <img class="math" src="_images/math/f3c754ede5a325f045a10fe57b2f387ad53341c4.png" alt="f_c"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> can be configured for every eNB instantiated
in the simulation; hence, each eNB can use a different spectrum model. Every UE
will automatically use the spectrum model of the eNB it is attached to. Using
the MultiModelSpectrumChannel described in <a class="reference internal" href="lte-references.html#baldo2009" id="id20"><span>[Baldo2009]</span></a>, the interference
among eNBs that use different spectrum models is properly accounted for.
This allows to simulate dynamic spectrum access policies, such as for
example the spectrum licensing policies that are
discussed in <a class="reference internal" href="lte-references.html#ofcom2600mhz" id="id21"><span>[Ofcom2600MHz]</span></a>.</p>
</div>
<div class="section" id="data-phy-error-model">
<h3>Data PHY Error Model<a class="headerlink" href="#data-phy-error-model" title="Permalink to this headline">¶</a></h3>
<p>The simulator includes an error model of the data plane (i.e., PDSCH and PUSCH) according to the standard link-to-system mapping (LSM) techniques. The choice is aligned with the standard system simulation methodology of OFDMA  radio transmission technology. Thanks to LSM we are able to maintain a good level of accuracy and at the same time limiting the computational complexity increase. It is based on the mapping of single link layer performance obtained by means of link level simulators to system (in our case network) simulators. In particular link the layer simulator is used for generating the performance of a single link from a PHY layer perspective, usually in terms of code block error rate (BLER), under specific static conditions. LSM allows the usage of these parameters in more complex scenarios, typical of system/network simulators, where we have more links, interference and “colored” channel propagation phenomena (e.g., frequency selective fading).</p>
<p>To do this the Vienna LTE Simulator <a class="reference internal" href="lte-references.html#viennaltesim" id="id22"><span>[ViennaLteSim]</span></a> has been used for what concerns the extraction of link layer performance and the Mutual Information Based Effective SINR (MIESM) as LSM mapping function using part of the work recently published by the Signet Group of University of Padua <a class="reference internal" href="lte-references.html#paduapem" id="id23"><span>[PaduaPEM]</span></a>.</p>
<div class="section" id="miesm">
<h4>MIESM<a class="headerlink" href="#miesm" title="Permalink to this headline">¶</a></h4>
<p>The specific LSM method adopted is the one based on the usage of a mutual information metric, commonly referred to as the mutual information per per coded bit (MIB or MMIB when a mean of multiples MIBs is involved). Another option would be represented by the Exponential ESM (EESM); however, recent studies demonstrate that MIESM outperforms EESM in terms of accuracy <a class="reference internal" href="lte-references.html#lozanocost" id="id24"><span>[LozanoCost]</span></a>.</p>
<div class="figure align-center" id="id154">
<span id="fig-miesm-architecture"></span><img alt="_images/miesm_scheme.png" src="_images/miesm_scheme.png" />
<p class="caption"><span class="caption-text">MIESM computational procedure diagram</span><a class="headerlink" href="#id154" title="Permalink to this image">¶</a></p>
</div>
<p>The mutual information (MI) is dependent on the constellation mapping and can be calculated per transport block (TB) basis, by evaluating the MI over the symbols and the subcarrier. However, this would be too complex for a network simulator. Hence, in our implementation a flat channel response within the RB has been considered; therefore the overall MI of a TB is calculated averaging the MI evaluated per each RB used in the TB. In detail, the implemented scheme is depicted in Figure <a class="reference internal" href="#fig-miesm-architecture"><span class="std std-ref">MIESM computational procedure diagram</span></a>, where we see that the model starts by evaluating the MI value for each RB, represented in the figure by the SINR samples. Then the equivalent MI is evaluated per TB basis by averaging the MI values. Finally, a further step has to be done since the link level simulator returns the performance of the link in terms of block error rate (BLER) in a addive white gaussian noise  (AWGN) channel, where the blocks are the code blocks (CBs) independently encoded/decoded by the turbo encoder. On this matter the
standard 3GPP segmentation scheme has been used for estimating the actual CB size (described in section 5.1.2 of <a class="reference internal" href="lte-references.html#ts36212" id="id25"><span>[TS36212]</span></a>). This scheme divides the TB in <img class="math" src="_images/math/91a52beabdbbbb318c05716194b3b6f6581ce5e7.png" alt="N_{K_-}"/> blocks of size <img class="math" src="_images/math/a4d98c7cad89d97267f3ec34aaf27a35e0f8a032.png" alt="K_-"/> and <img class="math" src="_images/math/26d4e2b3ccb1618508c6f10a00b0cf5c7889184e.png" alt="N_{K+}"/> blocks of size <img class="math" src="_images/math/8a4e09d5c1186bc46049ce9a6d8ec5d7696f8fe9.png" alt="K_+"/>. Therefore the overall TB BLER (TBLER) can be expressed as</p>
<div class="math">
<p><img src="_images/math/fe7293472e5205c1b13e543d1006cb7dd197a548.png" alt="TBLER = 1- \prod\limits_{i=1}^{C}(1-CBLER_i)"/></p>
</div><p>where the <img class="math" src="_images/math/4cbd4f61ccd1be0720110cc6007829810d0bdf9b.png" alt="CBLER_i"/> is the BLER of the CB <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> obtained according to the link level simulator CB BLER curves.
For estimating the <img class="math" src="_images/math/4cbd4f61ccd1be0720110cc6007829810d0bdf9b.png" alt="CBLER_i"/>, the MI evaluation has been implemented according to its numerical approximation defined in <a class="reference internal" href="lte-references.html#wimaxemd" id="id26"><span>[wimaxEmd]</span></a>. Moreover, for reducing the complexity of the computation, the approximation has been converted into lookup tables. In detail, Gaussian cumulative model has been used for approximating the AWGN BLER curves with three parameters which provides a close fit to the standard AWGN performances, in formula:</p>
<div class="math">
<p><img src="_images/math/5034a67ad4e058559b1cda84ee267f88424357b7.png" alt="CBLER_i = \frac{1}{2}\left[1-erf\left(\frac{x-b_{ECR}}{\sqrt{2}c_{ECR}} \right) \right]"/></p>
</div><p>where <img class="math" src="_images/math/888f7c323ac0341871e867220ae2d76467d74d6e.png" alt="x"/> is the MI of the TB, <img class="math" src="_images/math/732a9df735b4b869d7460fd53b1947bad95eeab0.png" alt="b_{ECR}"/> represents the “transition center” and <img class="math" src="_images/math/9f8e2bfac108f33753d7f02507b123124d517e1a.png" alt="c_{ECR}"/> is related to the “transition width” of the Gaussian cumulative distribution for each Effective Code Rate (ECR) which is the actual transmission rate according to the channel coding and MCS. For limiting the computational complexity of the model we considered only a subset of the possible ECRs in fact we would have potentially 5076 possible ECRs (i.e., 27 MCSs and 188 CB sizes). On this respect, we will limit the CB sizes to some representative values (i.e., 40, 140, 160, 256, 512, 1024, 2048, 4032, 6144), while for the others the worst one approximating the real one will be used (i.e., the smaller CB size value available respect to the real one). This choice is aligned to the typical performance of turbo codes, where the CB size is not strongly impacting on the BLER. However, it is to be notes that for CB sizes lower than 1000 bits the effect might be relevant (i.e., till 2 dB); therefore, we adopt
this unbalanced sampling interval for having more precision where it is necessary. This behaviour is confirmed by the figures presented in the Annes Section.</p>
</div>
<div class="section" id="bler-curves">
<h4>BLER Curves<a class="headerlink" href="#bler-curves" title="Permalink to this headline">¶</a></h4>
<p>On this respect, we reused part of the curves obtained within <a class="reference internal" href="lte-references.html#paduapem" id="id27"><span>[PaduaPEM]</span></a>. In detail, we introduced the CB size dependency to the CB BLER curves with the support of the developers of <a class="reference internal" href="lte-references.html#paduapem" id="id28"><span>[PaduaPEM]</span></a> and of the LTE Vienna Simulator. In fact, the module released provides the link layer performance only for what concerns the MCSs (i.e, with a given fixed ECR). In detail the new error rate curves for each has been evaluated with a simulation campaign with the link layer simulator for a single link with AWGN noise and for CB size of 104, 140, 256, 512, 1024, 2048, 4032 and 6144. These curves has been mapped with the Gaussian cumulative model formula presented above for obtaining the correspondents <img class="math" src="_images/math/732a9df735b4b869d7460fd53b1947bad95eeab0.png" alt="b_{ECR}"/> and <img class="math" src="_images/math/9f8e2bfac108f33753d7f02507b123124d517e1a.png" alt="c_{ECR}"/> parameters.</p>
<p>The BLER performance of all MCS obtained with the link level simulator are plotted in the following figures (blue lines) together with their correspondent mapping to the Gaussian cumulative distribution (red dashed lines).</p>
<div class="figure align-center" id="id155">
<span id="fig-mcs-1-4-ber"></span><img alt="_images/MCS_1_4.png" src="_images/MCS_1_4.png" />
<p class="caption"><span class="caption-text">BLER for MCS 1, 2, 3 and 4.</span><a class="headerlink" href="#id155" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id156">
<span id="fig-mcs-5-8-ber"></span><img alt="_images/MCS_5_8.png" src="_images/MCS_5_8.png" />
<p class="caption"><span class="caption-text">BLER for MCS 5, 6, 7 and 8.</span><a class="headerlink" href="#id156" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id157">
<span id="fig-mcs-9-12-ber"></span><img alt="_images/MCS_9_12.png" src="_images/MCS_9_12.png" />
<p class="caption"><span class="caption-text">BLER for MCS 9, 10, 11 and 12.</span><a class="headerlink" href="#id157" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id158">
<span id="fig-mcs-13-16-ber"></span><img alt="_images/MCS_13_16.png" src="_images/MCS_13_16.png" />
<p class="caption"><span class="caption-text">BLER for MCS 13, 14, 15 and 16.</span><a class="headerlink" href="#id158" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id159">
<span id="fig-mcs-17-20-ber"></span><img alt="_images/MCS_17_20.png" src="_images/MCS_17_20.png" />
<p class="caption"><span class="caption-text">BLER for MCS 17, 17, 19 and 20.</span><a class="headerlink" href="#id159" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id160">
<span id="fig-mcs-21-24-ber"></span><img alt="_images/MCS_21_24.png" src="_images/MCS_21_24.png" />
<p class="caption"><span class="caption-text">BLER for MCS 21, 22, 23 and 24.</span><a class="headerlink" href="#id160" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id161">
<span id="fig-mcs-25-28-ber"></span><img alt="_images/MCS_25_28.png" src="_images/MCS_25_28.png" />
<p class="caption"><span class="caption-text">BLER for MCS 25, 26, 27 and 28.</span><a class="headerlink" href="#id161" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id162">
<span id="fig-mcs-29-29-ber"></span><img alt="_images/MCS_29_29.png" src="_images/MCS_29_29.png" />
<p class="caption"><span class="caption-text">BLER for MCS 29.</span><a class="headerlink" href="#id162" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="integration-of-the-bler-curves-in-the-ns-3-lte-module">
<h4>Integration of the BLER curves in the ns-3 LTE module<a class="headerlink" href="#integration-of-the-bler-curves-in-the-ns-3-lte-module" title="Permalink to this headline">¶</a></h4>
<p>The model implemented uses the curves for the LSM of the recently LTE PHY Error Model released in the ns3 community by the Signet Group <a class="reference internal" href="lte-references.html#paduapem" id="id29"><span>[PaduaPEM]</span></a> and the new ones generated for different CB sizes. The <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> class is in charge of evaluating the TB BLER thanks to the methods provided by the <code class="docutils literal notranslate"><span class="pre">LteMiErrorModel</span></code> class, which is in charge of evaluating the TB BLER according to the vector of the perceived SINR per RB, the MCS and the size in order to proper model the segmentation of the TB in CBs. In order to obtain the vector of the perceived SINR two instances of <code class="docutils literal notranslate"><span class="pre">LtePemSinrChunkProcessor</span></code> (child of <code class="docutils literal notranslate"><span class="pre">LteChunkProcessor</span></code> dedicated to evaluate the SINR for obtaining physical error performance) have been attached to UE downlink and eNB uplink <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> modules for evaluating the error model distribution respectively of PDSCH (UE side) and ULSCH (eNB side).</p>
<p>The model can be disabled for working with a zero-losses channel by setting the <code class="docutils literal notranslate"><span class="pre">PemEnabled</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> class (by default is active). This can be done according to the standard ns3 attribute system procedure, that is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteSpectrumPhy::DataErrorModelEnabled&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="control-channels-phy-error-model">
<span id="sec-control-channles-phy-error-model"></span><h3>Control Channels PHY Error Model<a class="headerlink" href="#control-channels-phy-error-model" title="Permalink to this headline">¶</a></h3>
<p>The simulator includes the error model for downlink control channels (PCFICH and PDCCH), while in uplink it is assumed and ideal error-free channel. The model is based on the MIESM approach presented before for considering the effects of the frequency selective channel since most of the control channels span the whole available bandwidth.</p>
<div class="section" id="pcfich-pdcch-error-model">
<h4>PCFICH + PDCCH Error Model<a class="headerlink" href="#pcfich-pdcch-error-model" title="Permalink to this headline">¶</a></h4>
<p>The model adopted for the error distribution of these channels is based on an evaluation study carried out in the RAN4 of 3GPP, where different vendors investigated the demodulation performance of the PCFICH jointly with PDCCH. This is due to the fact that the PCFICH is the channel in charge of communicating to the UEs the actual dimension of the PDCCH (which spans between 1 and 3 symbols); therefore the correct decodification of the DCIs  depends on the correct interpretation of both ones. In 3GPP this problem have been evaluated for improving the cell-edge performance <a class="reference internal" href="lte-references.html#fujitsuwhitepaper" id="id30"><span>[FujitsuWhitePaper]</span></a>, where the interference among neighboring cells can be relatively high due to signal degradation. A similar problem has been notices in femto-cell scenario and, more in general, in HetNet scenarios the bottleneck has been detected mainly as the PCFICH channel <a class="reference internal" href="lte-references.html#bharucha2011" id="id31"><span>[Bharucha2011]</span></a>, where in case of many eNBs are deployed in the same service area, this channel may collide in frequency, making impossible the correct detection of
the PDCCH channel, too.</p>
<p>In the simulator, the SINR perceived during the reception has been estimated according to the MIESM model presented above in order to evaluate the error distribution of PCFICH and PDCCH. In detail, the SINR samples of all the RBs are included in the evaluation of the MI associated to the control frame and, according to this values, the effective SINR (eSINR) is obtained by inverting the MI evaluation process. It has to be noted that, in case of MIMO transmission, both PCFICH and the PDCCH use always the transmit diversity mode as defined by the standard. According to the eSINR perceived the decodification error probability can be estimated as function of the results presented in <a class="reference internal" href="lte-references.html#r4-081920" id="id32"><span>[R4-081920]</span></a>. In case an error occur, the DCIs discarded and therefore the UE will be not able to receive the correspondent Tbs, therefore resulting lost.</p>
</div>
</div>
<div class="section" id="mimo-model">
<h3>MIMO Model<a class="headerlink" href="#mimo-model" title="Permalink to this headline">¶</a></h3>
<p>The use of multiple antennas both at transmitter and receiver side, known as multiple-input and multiple-output (MIMO), is a problem well studied in literature during the past years. Most of the work concentrate on evaluating analytically the gain that the different MIMO schemes might have in term of capacity; however someones provide also information of the gain in terms of received power <a class="reference internal" href="lte-references.html#catreuxmimo" id="id33"><span>[CatreuxMIMO]</span></a>.</p>
<p>According to the considerations above, a model more flexible can be obtained considering the gain that MIMO schemes bring in the system from a statistical point of view. As highlighted before, <a class="reference internal" href="lte-references.html#catreuxmimo" id="id34"><span>[CatreuxMIMO]</span></a> presents the statistical gain of several MIMO solutions respect to the SISO one in case of no correlation between the antennas. In the work the gain is presented as the cumulative distribution function (CDF) of the output SINR for what concern SISO, MIMO-Alamouti, MIMO-MMSE, MIMO-OSIC-MMSE and MIMO-ZF schemes. Elaborating the results, the output SINR distribution can be approximated with a log-normal one with different mean and variance as function of the scheme considered. However, the variances are not so different and they are approximatively equal to the one of the SISO mode already included in the shadowing component of the <code class="docutils literal notranslate"><span class="pre">BuildingsPropagationLossModel</span></code>, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p>SISO: <img class="math" src="_images/math/438b4c7487e88fedc8ad2f9727e252f099dc4cf9.png" alt="\mu = 13.5"/> and <img class="math" src="_images/math/79e07f025929a14eec7bb2ddfc761665e165699f.png" alt="\sigma = 20"/> [dB].</p></li>
<li><p>MIMO-Alamouti: <img class="math" src="_images/math/280aeca1cf310bbaba6efdab9f59dd9ea6086091.png" alt="\mu = 17.7"/> and <img class="math" src="_images/math/a31fb712d3c1c1a9a30143b90cee8fd93bb082f3.png" alt="\sigma = 11.1"/> [dB].</p></li>
<li><p>MIMO-MMSE: <img class="math" src="_images/math/aca71798f302343aaaa038942afe6f32230eb6ea.png" alt="\mu = 10.7"/> and <img class="math" src="_images/math/062d4950a41ff8323aeb7db28e87e5e388e9bf54.png" alt="\sigma = 16.6"/> [dB].</p></li>
<li><p>MIMO-OSIC-MMSE: <img class="math" src="_images/math/7d62ee9cd1ec616b6e42912cb5ee41810b66dac5.png" alt="\mu = 12.6"/> and <img class="math" src="_images/math/505213c79a60fc0f9b5e11ae021ae9548a2f44b2.png" alt="\sigma = 15.5"/> [dB].</p></li>
<li><p>MIMO-ZF: <img class="math" src="_images/math/5a257340e112ef3c73eaeaa810938bde195940d5.png" alt="\mu = 10.3"/> and <img class="math" src="_images/math/af37942808cd165511f8e57a3f03eed1b6ce394c.png" alt="\sigma = 12.6"/> [dB].</p></li>
</ul>
</div></blockquote>
<p>Therefore the PHY layer implements the MIMO model as the gain perceived by the receiver when using a MIMO scheme respect to the one obtained using SISO one. We note that, these gains referred to a case where there is no correlation between the antennas in MIMO scheme; therefore do not model degradation due to paths correlation.</p>
</div>
<div class="section" id="ue-phy-measurements-model">
<span id="sec-phy-ue-measurements"></span><h3>UE PHY Measurements Model<a class="headerlink" href="#ue-phy-measurements-model" title="Permalink to this headline">¶</a></h3>
<p>According to <a class="reference internal" href="lte-references.html#ts36214" id="id35"><span>[TS36214]</span></a>, the UE has to report a set of measurements of the eNBs that the device is able to perceive: the reference signal received power (RSRP) and the reference signal received quality (RSRQ). The former is a measure of the received power of a specific eNB, while the latter includes also channel interference and thermal noise.
The UE has to report the measurements jointly with the physical cell identity (PCI) of the cell. Both the RSRP and RSRQ measurements are performed during the reception of the RS, while the PCI is obtained with the Primary Synchronization Signal (PSS). The PSS is sent by the eNB each 5 subframes and in detail in the subframes 1 and 6. In real systems, only 504 distinct PCIs are available, and hence it could occur that two nearby eNBs use the same PCI; however, in the simulator we model PCIs using simulation metadata, and we allow up to 65535 distinct PCIs, thereby avoiding PCI collisions provided that less that 65535 eNBs are simulated in the same scenario.</p>
<p>According to <a class="reference internal" href="lte-references.html#ts36133" id="id36"><span>[TS36133]</span></a> sections 9.1.4 and 9.1.7, RSRP is reported by PHY layer in dBm while RSRQ in dB. The values of RSRP and RSRQ are provided to higher layers through the C-PHY SAP (by means of <code class="docutils literal notranslate"><span class="pre">UeMeasurementsParameters</span></code> struct) every 200 ms as defined in <a class="reference internal" href="lte-references.html#ts36331" id="id37"><span>[TS36331]</span></a>. Layer 1 filtering is performed by averaging the all the measurements collected during the last window slot. The periodicity of reporting can be adjusted for research purposes by means of the <code class="docutils literal notranslate"><span class="pre">LteUePhy::UeMeasurementsFilterPeriod</span></code> attribute.</p>
<p>The formulas of the RSRP and RSRQ can be simplified considering the assumption of the PHY layer that the channel is flat within the RB, the finest level of accuracy. In fact, this implies that all the REs within a RB have the same power, therefore:</p>
<div class="math">
<p><img src="_images/math/29197196e4466e201741558622769695435e5aee.png" alt="RSRP = \frac{\sum_{k=0}^{K-1}\frac{\sum_{m=0}^{M-1}(P(k,m))}{M}}{K}
     = \frac{\sum_{k=0}^{K-1}\frac{(M \times P(k))}{M}}{K}
     = \frac{\sum_{k=0}^{K-1}(P(k))}{K}"/></p>
</div><p>where <img class="math" src="_images/math/c4de3b06a294154e6505ff9e622a73b127bd8b52.png" alt="P(k,m)"/> represents the signal power of the RE <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> within the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, which, as observed before, is constant within the same RB and equal to <img class="math" src="_images/math/24a70eb4b8eb2a2d8b616964a01e42f3e5e47476.png" alt="P(k)"/>, <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> is the number of REs carrying the RS in a RB and <img class="math" src="_images/math/52ddc0cde6d632f631533173562fe3ca375b1f32.png" alt="K"/> is the number of RBs. It is to be noted that <img class="math" src="_images/math/24a70eb4b8eb2a2d8b616964a01e42f3e5e47476.png" alt="P(k)"/>, and in general all the powers defined in this section, is obtained in the simulator from the PSD of the RB (which is provided by  the <code class="docutils literal notranslate"><span class="pre">LteInterferencePowerChunkProcessor</span></code>), in detail:</p>
<div class="math">
<p><img src="_images/math/6fa85ae014937b470d89d87bc01c5d68db2fb0ad.png" alt="P(k) = PSD_{RB}(k)*180000/12"/></p>
</div><p>where <img class="math" src="_images/math/96bae5028d0e9bbbf2bd72891903f7857efbea63.png" alt="PSD_{RB}(k)"/> is the power spectral density of the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, <img class="math" src="_images/math/4f8829c93a607985838dc4157a922a0f8898b418.png" alt="180000"/> is the bandwidth in Hz of the RB and <img class="math" src="_images/math/d147c12ac411feac5293f9328d82ee96665a8a9d.png" alt="12"/> is the number of REs per RB in an OFDM symbol.
Similarly, for RSSI we have</p>
<div class="math">
<p><img src="_images/math/1cb764562d1856d031e3e0593fedea30162a1ccc.png" alt="RSSI = \sum_{k=0}^{K-1} \frac{\sum_{s=0}^{S-1} \sum_{r=0}^{R-1}( P(k,s,r) + I(k,s,r) + N(k,s,r))}{S}"/></p>
</div><p>where <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> is the number of OFDM symbols carrying RS in a RB and <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is the number of REs carrying a RS in a OFDM symbol (which is fixed to <img class="math" src="_images/math/d94997a2318fec7e8e5bc4d8d79bb633675f9411.png" alt="2"/>) while <img class="math" src="_images/math/530a421607e7f1f771aaca2dcf0f727192aceec5.png" alt="P(k,s,r)"/>, <img class="math" src="_images/math/0c757ec90f351192094c259f8c5837886311a0f4.png" alt="I(k,s,r)"/> and <img class="math" src="_images/math/f67b6744a58e20dc47a96f67b56c52c5b761cbb1.png" alt="N(k,s,r)"/> represent respectively the perceived power of the serving cell, the interference power and the noise power of the RE <img class="math" src="_images/math/79a3d439d28652c547386f39b555d90d3aaf102d.png" alt="r"/> in symbol <img class="math" src="_images/math/106b04b320e75010b1d8029e59244f234f75e6f9.png" alt="s"/>. As for RSRP, the measurements within a RB are always equals among each others according to the PHY model; therefore <img class="math" src="_images/math/29b6ca01ebb393aca4fe4381287e7b06d9443118.png" alt="P(k,s,r) = P(k)"/>, <img class="math" src="_images/math/bef1eb9f85de27fc4c3f74ef8514c385d868f86f.png" alt="I(k,s,r) = I(k)"/> and <img class="math" src="_images/math/24a05fb376f90e41c02d06a15b46e98dceebe369.png" alt="N(k,s,r) = N(k)"/>, which implies that the RSSI can be calculated as:</p>
<div class="math">
<p><img src="_images/math/d70b8cb3902117511f5ad7202505ce3b37d1ef48.png" alt="RSSI = \sum_{k=0}^{K-1} \frac{S \times 2 \times ( P(k) + I(k) + N(k))}{S}
     = \sum_{k=0}^{K-1} 2 \times ( P(k) + I(k) + N (k))"/></p>
</div><p>Considering the constraints of the PHY reception chain implementation, and in order to maintain the level of computational complexity low, only RSRP can be directly obtained for all the cells. This is due to the fact that <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> is designed for evaluating the interference only respect to the signal of the serving eNB. This implies that the PHY layer is optimized for managing the power signals information with the serving eNB as a reference. However, RSRP and RSRQ of neighbor cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> can be extracted by the current information available of the serving cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> as detailed in the following:</p>
<div class="math">
<p><img src="_images/math/207385573feb57ddbd6cdf86af59f4a281b593c9.png" alt="RSRP_i = \frac{\sum_{k=0}^{K-1}(P_i(k))}{K}

RSSI_i = RSSI_j = \sum_{k=0}^{K-1} 2 \times ( I_j(k) + P_j(k) + N_j(k) )

RSRQ_i^j = K \times RSRP_i / RSSI_j"/></p>
</div><p>where <img class="math" src="_images/math/0d8bfdd3ec778a86ed2879f86d200f427557de4a.png" alt="RSRP_i"/> is the RSRP of the neighbor cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>, <img class="math" src="_images/math/592b22b544e4ce5265863554d8c9c25f3f97be53.png" alt="P_i(k)"/> is the power perceived at any RE within the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, <img class="math" src="_images/math/52ddc0cde6d632f631533173562fe3ca375b1f32.png" alt="K"/> is the total number of RBs, <img class="math" src="_images/math/af17ea1920c1cae040d8b90bb8dea0b45295df97.png" alt="RSSI_i"/> is the RSSI of the neighbor cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> when the UE is attached to cell  <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> (which, since it is the sum of all the received powers, coincides with <img class="math" src="_images/math/b3c5b0100d6e0f5eb3ee08eeb88895b4e223c13c.png" alt="RSSI_j"/>), <img class="math" src="_images/math/b4c0872c10c62bcc8f4999e1cbf2ecd1d09abd07.png" alt="I_j(k)"/> is the total interference perceived by UE in any RE of RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> when attached to cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> (obtained by the <code class="docutils literal notranslate"><span class="pre">LteInterferencePowerChunkProcessor</span></code>), <img class="math" src="_images/math/15fa8b1c0746439f2b80e17432d797f4bc579790.png" alt="P_j(k)"/> is the power perceived of cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> in any RE of the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> and <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> is the power noise spectral density in any RE. The sample is considered as valid in case of the RSRQ evaluated is above the <code class="docutils literal notranslate"><span class="pre">LteUePhy::RsrqUeMeasThreshold</span></code> attribute.</p>
</div>
</div>
<div class="section" id="harq">
<h2>HARQ<a class="headerlink" href="#harq" title="Permalink to this headline">¶</a></h2>
<p>The HARQ scheme implemented is based on a incremental redundancy (IR) solutions combined with multiple stop-and-wait processes for enabling a continuous data flow. In detail, the solution adopted is the <em>soft combining hybrid IR Full incremental redundancy</em> (also called IR Type II), which implies that the retransmissions contain only new information respect to the previous ones. The resource allocation algorithm of the HARQ has been implemented within the respective scheduler classes (i.e., <code class="docutils literal notranslate"><span class="pre">RrFfMacScheduler</span></code> and <code class="docutils literal notranslate"><span class="pre">PfFfMacScheduler</span></code>, refer to their correspondent sections for more info), while the decodification part of the HARQ has been implemented in the <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">LteHarqPhy</span></code> classes which will be detailed in this section.</p>
<p>According to the standard, the UL retransmissions are synchronous and therefore are allocated 7 ms after the original transmission. On the other hand, for the DL, they are asynchronous and therefore can be allocated in a more flexible way starting from 7 ms and it is a matter of the specific scheduler implementation. The HARQ processes behavior is depicted in Figure:ref:<cite>fig-harq-processes-scheme</cite>.</p>
<p>At the MAC layer, the HARQ entity residing in the scheduler is in charge of controlling the 8 HARQ processes for generating new packets and managing the retransmissions both for the DL and the UL. The scheduler collects the HARQ feedback from eNB and UE PHY layers (respectively for UL and DL connection) by means of the FF API primitives <code class="docutils literal notranslate"><span class="pre">SchedUlTriggerReq</span></code> and <code class="docutils literal notranslate"><span class="pre">SchedUlTriggerReq</span></code>. According to the HARQ feedback and the RLC buffers status, the scheduler generates a set of DCIs including both retransmissions of HARQ blocks received erroneous and new transmissions, in general, giving priority to the former. On this matter, the scheduler has to take into consideration one constraint when allocating the resource for HARQ retransmissions, it must use the same modulation order of the first transmission attempt (i.e., QPSK for MCS <img class="math" src="_images/math/51913cbad6eefab53a57ad4bdfec4d1a5054cef2.png" alt="\in [0..9]"/>, 16QAM for MCS <img class="math" src="_images/math/c03ac97eb57c0557d82b81ed6c4ee76571252483.png" alt="\in [10..16]"/> and 64QAM for MCS <img class="math" src="_images/math/6c1e8861452e52ec6f4b2c3e1eb53ed89966a66e.png" alt="\in [17..28]"/>). This restriction comes from the specification of the rate matcher in the 3GPP standard [
TS36212]_, where the algorithm fixes the modulation order for generating the different blocks of the redundancy versions.</p>
<p>The PHY Error Model model (i.e., the <code class="docutils literal notranslate"><span class="pre">LteMiErrorModel</span></code> class already presented before) has been extended for considering IR HARQ according to <a class="reference internal" href="lte-references.html#wimaxemd" id="id38"><span>[wimaxEmd]</span></a>, where the parameters for the AWGN curves mapping for MIESM mapping in case of retransmissions are given by:</p>
<div class="math">
<p><img src="_images/math/979e205c9e325a22173b86d31c3758ce3c14bb6c.png" alt="R_{eff} = \frac{X}{\sum\limits_{i=1}^q C_i}

M_{I eff} = \frac{\sum\limits_{i=1}^q C_i M_i}{\sum\limits_{i=1}^q C_i}"/></p>
</div><p>where <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/> is the number of original information bits, <img class="math" src="_images/math/113ecc79d1fabbf0ca98becf9d3728be649e9cc7.png" alt="C_i"/> are number of coded bits, <img class="math" src="_images/math/86810cecefe160a038ea1bf18596df24b14c6731.png" alt="M_i"/> are the mutual information per HARQ block received on the total number of <img class="math" src="_images/math/a5fa84b363f309ebc8fe7db38304541732c7de9a.png" alt="q"/> retransmissions. Therefore, in order to be able to return the error probability with the error model implemented in the simulator evaluates the <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/> and the <img class="math" src="_images/math/1761d6b5623f20b3521b0542b81144ee7a4c90d6.png" alt="MI_{I eff}"/> and return the value of error probability of the ECR of the same modulation with closest lower rate respect to the <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/>. In order to consider the effect of HARQ retransmissions a new sets of curves have been integrated respect to the standard one used for the original MCS. The new curves are intended for covering the cases when the most conservative MCS of a modulation is used which implies the generation of <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/> lower respect to the one of standard MCSs. On this matter the curves for 1, 2 and 3 retransmissions have been evaluated for 10 and 17. For MCS 0 we considered only the first retransmission since the
produced code rate is already very conservative (i.e., 0.04) and returns an error rate enough robust for the reception (i.e., the downturn of the BLER is centered around -18 dB).
It is to be noted that, the size of first TB transmission has been assumed as containing all the information bits to be coded; therefore <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/> is equal to the size of the first TB sent of a an HARQ process. The model assumes that the eventual presence of parity bits in the codewords is already considered in the link level curves. This implies that as soon as the minimum <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/> is reached the model is not including the gain due to the transmission of further parity bits.</p>
<div class="figure align-center" id="id163">
<span id="fig-harq-processes-scheme"></span><img alt="_images/lte-harq-processes-scheme.png" src="_images/lte-harq-processes-scheme.png" />
<p class="caption"><span class="caption-text">HARQ processes behavior in LTE</span><a class="headerlink" href="#id163" title="Permalink to this image">¶</a></p>
</div>
<p>The part of HARQ devoted to manage the decodification of the HARQ blocks has been implemented in the <code class="docutils literal notranslate"><span class="pre">LteHarqPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> classes. The former is in charge of maintaining the HARQ information for each active process . The latter interacts with <code class="docutils literal notranslate"><span class="pre">LteMiErrorModel</span></code> class for evaluating the correctness of the blocks received and includes the messaging algorithm in charge of communicating to the HARQ entity in the scheduler the result of the decodifications. These messages are encapsulated in the <code class="docutils literal notranslate"><span class="pre">dlInfoListElement</span></code> for DL and <code class="docutils literal notranslate"><span class="pre">ulInfoListElement</span></code> for UL and sent through the PUCCH and the PHICH respectively with an ideal error free model according to the assumptions in their implementation. A sketch of the iteration between HARQ and LTE protocol stack in represented in Figure:ref:<cite>fig-harq-architecture</cite>.</p>
<p>Finally, the HARQ engine is always active both at MAC and PHY layer; however, in case of the scheduler does not support HARQ the system will continue to work with the HARQ functions inhibited (i.e., buffers are filled but not used). This implementation characteristic gives backward compatibility with schedulers implemented before HARQ integration.</p>
<div class="figure align-center" id="id164">
<span id="fig-harq-architecture"></span><img alt="_images/lte-harq-architecture.png" src="_images/lte-harq-architecture.png" />
<p class="caption"><span class="caption-text">Interaction between HARQ and LTE protocol stack</span><a class="headerlink" href="#id164" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="mac">
<h2>MAC<a class="headerlink" href="#mac" title="Permalink to this headline">¶</a></h2>
<div class="section" id="resource-allocation-model">
<h3>Resource Allocation Model<a class="headerlink" href="#resource-allocation-model" title="Permalink to this headline">¶</a></h3>
<p>We now briefly describe how resource allocation is handled in LTE,
clarifying how it is modeled in the simulator. The scheduler is in
charge of generating specific structures called <em>Data Control Indication</em> (DCI)
which are then transmitted by the PHY of the eNB to the connected UEs, in order
to inform them of the resource allocation on a per subframe basis. In doing this
in the downlink direction, the scheduler has to fill some specific fields of the
DCI structure with all the information, such as: the Modulation and Coding
Scheme (MCS) to be used, the MAC Transport Block (TB) size, and the allocation
bitmap which identifies which RBs will contain the data
transmitted by the eNB to each user.</p>
<p>For the mapping of resources to
physical RBs, we adopt a <em>localized mapping</em> approach
(see <a class="reference internal" href="lte-references.html#sesia2009" id="id39"><span>[Sesia2009]</span></a>, Section 9.2.2.1);
hence in a given subframe each RB is always allocated to the same user in both
slots.
The allocation bitmap can be coded in
different formats; in this implementation, we considered the <em>Allocation
Type 0</em> defined in <a class="reference internal" href="lte-references.html#ts36213" id="id40"><span>[TS36213]</span></a>, according to which the RBs are grouped in
Resource Block Groups (RBG) of different size determined as a function of the
Transmission Bandwidth Configuration in use.</p>
<p>For certain bandwidth
values not all the RBs are usable, since the
group size is not a common divisor of the group. This is for instance the case
when the bandwidth is equal to 25 RBs, which results in a RBG size of 2 RBs, and
therefore 1 RB will result not addressable.
In uplink the format of the DCIs is different, since only adjacent RBs
can be used because of the SC-FDMA modulation. As a consequence, all
RBs can be allocated by the eNB regardless of the bandwidth
configuration.</p>
</div>
<div class="section" id="adaptive-modulation-and-coding">
<span id="sec-lte-amc"></span><h3>Adaptive Modulation and Coding<a class="headerlink" href="#adaptive-modulation-and-coding" title="Permalink to this headline">¶</a></h3>
<p>The simulator provides two Adaptive Modulation and Coding (AMC) models: one based on the GSoC model <a class="reference internal" href="lte-references.html#piro2011" id="id41"><span>[Piro2011]</span></a> and one based on the physical error model (described in the following sections).</p>
<p>The former model is a modified version of the model described in <a class="reference internal" href="lte-references.html#piro2011" id="id42"><span>[Piro2011]</span></a>,
which in turn is inspired from <a class="reference internal" href="lte-references.html#seo2004" id="id43"><span>[Seo2004]</span></a>. Our version is described in the
following. Let <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> denote the
generic user, and let <img class="math" src="_images/math/668b300393b9de22a5da2a6017ec36d8605f1ed7.png" alt="\gamma_i"/> be its SINR. We get the spectral efficiency
<img class="math" src="_images/math/c8696d0ccdce0a389e624bb720fccd288da119d7.png" alt="\eta_i"/> of user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> using the following equations:</p>
<div class="math">
<p><img src="_images/math/a27b050a8956bf65967cc8482e348b8c12fb345a.png" alt="\mathrm{BER} = 0.00005

\Gamma = \frac{ -\ln{ (5 * \mathrm{BER}) } }{ 1.5}

\eta_i = \log_2 { \left( 1 + \frac{ {\gamma}_i }{ \Gamma } \right)}"/></p>
</div><p>The procedure described in <a class="reference internal" href="lte-references.html#r1-081483" id="id44"><span>[R1-081483]</span></a> is used to get
the corresponding MCS scheme. The spectral efficiency is quantized based on the
channel quality indicator (CQI), rounding to the lowest value, and is mapped to the corresponding MCS
scheme.</p>
<p>Finally, we note that there are some discrepancies between the MCS index
in <a class="reference internal" href="lte-references.html#r1-081483" id="id45"><span>[R1-081483]</span></a>
and that indicated by the standard:  <a class="reference internal" href="lte-references.html#ts36213" id="id46"><span>[TS36213]</span></a> Table
7.1.7.1-1 says that the MCS index goes from 0 to 31, and 0 appears to be a valid
MCS scheme (TB size is not 0) but in <a class="reference internal" href="lte-references.html#r1-081483" id="id47"><span>[R1-081483]</span></a> the first useful MCS
index
is 1. Hence to get the value as intended by the standard we need to subtract 1
from the index reported in <a class="reference internal" href="lte-references.html#r1-081483" id="id48"><span>[R1-081483]</span></a>.</p>
<p>The alternative model is based on the physical error model developed for this simulator and explained in the following subsections. This scheme is able to adapt the MCS selection to the actual PHY layer performance according to the specific CQI report. According to their definition, a CQI index is assigned when a single PDSCH TB with the modulation coding scheme and code rate correspondent to that CQI index in table 7.2.3-1 of <a class="reference internal" href="lte-references.html#ts36213" id="id49"><span>[TS36213]</span></a> can be received with an error probability less than 0.1. In case of wideband CQIs, the reference TB includes all the RBGs available in order to have a reference based on the whole available resources; while, for subband CQIs, the reference TB is sized as the RBGs.</p>
</div>
<div class="section" id="transport-block-model">
<h3>Transport Block model<a class="headerlink" href="#transport-block-model" title="Permalink to this headline">¶</a></h3>
<p>The model of the MAC Transport Blocks (TBs) provided by the simulator
is simplified with respect to the 3GPP specifications. In particular,
a simulator-specific class (PacketBurst) is used to aggregate
MAC SDUs in order to achieve the simulator’s equivalent of a TB,
without the corresponding implementation complexity.
The multiplexing of different logical channels to and from the RLC
layer is performed using a dedicated packet tag (LteRadioBearerTag), which
performs a functionality which is partially equivalent to that of the
MAC headers specified by 3GPP.</p>
</div>
<div class="section" id="the-femtoforum-mac-scheduler-interface">
<span id="sec-ff-mac-scheduler"></span><h3>The FemtoForum MAC Scheduler Interface<a class="headerlink" href="#the-femtoforum-mac-scheduler-interface" title="Permalink to this headline">¶</a></h3>
<p>This section describes the ns-3 specific version of the LTE MAC
Scheduler Interface Specification published by the FemtoForum <a class="reference internal" href="lte-references.html#ffapi" id="id50"><span>[FFAPI]</span></a>.</p>
<p>We implemented the ns-3 specific version of the FemtoForum MAC Scheduler
Interface <a class="reference internal" href="lte-references.html#ffapi" id="id51"><span>[FFAPI]</span></a> as a set of C++ abstract
classes; in particular, each primitive is translated to a C++ method of a
given class. The term <em>implemented</em> here is used with the same
meaning adopted in <a class="reference internal" href="lte-references.html#ffapi" id="id52"><span>[FFAPI]</span></a>, and hence refers to the process of translating
the logical interface specification to a particular programming language.
The primitives in <a class="reference internal" href="lte-references.html#ffapi" id="id53"><span>[FFAPI]</span></a> are grouped in two groups: the CSCHED
primitives, which deal with scheduler configuration, and the SCHED primitives,
which deal with the execution of the scheduler. Furthermore, <a class="reference internal" href="lte-references.html#ffapi" id="id54"><span>[FFAPI]</span></a>
defines primitives of two different kinds: those of type REQ go from the MAC to
the Scheduler, and those of type IND/CNF go from the scheduler to the MAC. To
translate these characteristics into C++, we define the following abstract
classes that implement Service Access Points (SAPs) to be used to issue the
primitives:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacSchedSapProvider</span></code> class defines all the C++ methods that
correspond to SCHED primitives of type REQ;</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacSchedSapUser</span></code> class defines all the C++ methods that
correspond to SCHED primitives of type CNF/IND;</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacCschedSapProvider</span></code> class defines all the C++ methods that
correspond to CSCHED primitives of type REQ;</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacCschedSapUser</span></code> class defines all the C++ methods that
correspond to CSCHED primitives of type CNF/IND;</p></li>
</ul>
</div></blockquote>
<p>There are 3 blocks involved in the MAC Scheduler interface: Control block,
Subframe block and Scheduler block. Each of these blocks provide one part of the
MAC Scheduler interface. The figure below shows the relationship
between the blocks and the SAPs defined in our implementation of the MAC
Scheduler Interface.</p>
<div class="figure align-center">
<img alt="_images/ff-mac-saps.png" src="_images/ff-mac-saps.png" />
</div>
<p>In addition to the above principles, the following design choices have been
taken:</p>
<blockquote>
<div><ul class="simple">
<li><p>The definition of the MAC Scheduler interface classes follows the naming
conventions of the <em>ns-3</em> Coding Style. In particular, we follow the
CamelCase convention for the primitive names. For example, the primitive
<code class="docutils literal notranslate"><span class="pre">CSCHED_CELL_CONFIG_REQ</span></code> is translated to <code class="docutils literal notranslate"><span class="pre">CschedCellConfigReq</span></code>
in the <em>ns-3</em> code.</p></li>
<li><p>The same naming conventions are followed for the primitive parameters. As
the primitive parameters are member variables of classes, they are also prefixed
with a <code class="docutils literal notranslate"><span class="pre">m_</span></code>.</p></li>
<li><p>regarding the use of vectors and lists in data structures, we note
that <a class="reference internal" href="lte-references.html#ffapi" id="id55"><span>[FFAPI]</span></a> is a pretty much C-oriented API. However, considered that
C++ is used in ns-3, and that the use of C arrays is discouraged, we used STL
vectors (<code class="docutils literal notranslate"><span class="pre">std::vector</span></code>) for the implementation of the MAC Scheduler
Interface, instead of using C arrays as implicitly suggested by the
way <a class="reference internal" href="lte-references.html#ffapi" id="id56"><span>[FFAPI]</span></a> is written.</p></li>
<li><p>In C++, members with constructors and destructors are not allow in
<code class="docutils literal notranslate"><span class="pre">unions</span></code>. Hence all those data structures that are said to be
<code class="docutils literal notranslate"><span class="pre">unions</span></code> in <a class="reference internal" href="lte-references.html#ffapi" id="id57"><span>[FFAPI]</span></a> have been defined as <code class="docutils literal notranslate"><span class="pre">structs</span></code> in our code.</p></li>
</ul>
</div></blockquote>
<p>The figure below shows how the MAC Scheduler Interface is
used within the eNB.</p>
<div class="figure align-center">
<img alt="_images/ff-example.png" src="_images/ff-example.png" />
</div>
<p>The User side of both the CSCHED SAP and the SCHED SAP are
implemented within the eNB MAC, i.e., in the file <code class="docutils literal notranslate"><span class="pre">lte-enb-mac.cc</span></code>.
The eNB MAC can be used with different scheduler implementations without
modifications. The same figure also shows, as an example, how the Round Robin
Scheduler is implemented: to interact with the MAC of the eNB, the Round Robin
scheduler implements the Provider side of the SCHED SAP and CSCHED
SAP interfaces. A similar approach can be used to implement other schedulers as
well. A description of each of the scheduler implementations that we provide as
part of our LTE simulation module is provided in the following subsections.</p>
<div class="section" id="round-robin-rr-scheduler">
<h4>Round Robin (RR) Scheduler<a class="headerlink" href="#round-robin-rr-scheduler" title="Permalink to this headline">¶</a></h4>
<p>The Round Robin (RR) scheduler is probably the simplest scheduler found in the literature. It works by dividing the
available resources among the active flows, i.e., those logical channels which have a non-empty RLC queue. If the number of RBGs is greater than the number of active flows, all the flows can be allocated in the same subframe. Otherwise, if the number of active flows is greater than the number of RBGs, not all the flows can be scheduled in a given subframe; then, in the next subframe the allocation will start from the last flow that was not allocated.  The MCS to be adopted for each user is done according to the received wideband CQIs.</p>
<p>For what concern the HARQ, RR implements the non adaptive version, which implies that in allocating the retransmission attempts RR uses the same allocation configuration of the original block, which means maintaining the same RBGs and MCS. UEs that are allocated for HARQ retransmissions are not considered for the transmission of new data in case they have a transmission opportunity available in the same TTI. Finally, HARQ can be disabled with ns3 attribute system for maintaining backward compatibility with old test cases and code, in detail:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::RrFfMacScheduler::HarqEnabled&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>The scheduler implements the filtering of the uplink CQIs according to their nature with <code class="docutils literal notranslate"><span class="pre">UlCqiFilter</span></code> attribute, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SRS_UL_CQI</span></code>: only SRS based CQI are stored in the internal attributes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PUSCH_UL_CQI</span></code>: only PUSCH based CQI are stored in the internal attributes.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="proportional-fair-pf-scheduler">
<h4>Proportional Fair (PF) Scheduler<a class="headerlink" href="#proportional-fair-pf-scheduler" title="Permalink to this headline">¶</a></h4>
<p>The Proportional Fair (PF) scheduler <a class="reference internal" href="lte-references.html#sesia2009" id="id58"><span>[Sesia2009]</span></a> works by scheduling a user
when its
instantaneous channel quality is high relative to its own average channel
condition over time. Let <img class="math" src="_images/math/5183ea9096ac86aff6e13dd3d4389ae47617b059.png" alt="i,j"/> denote generic users; let <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> be the
subframe index, and <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> be the resource block index; let <img class="math" src="_images/math/5b56afc255250c48d60f4fad45bfb9b2d2879df5.png" alt="M_{i,k}(t)"/> be MCS
usable by user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> according to what reported by the AMC
model (see <a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a>); finally, let <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the TB
size in bits as defined in <a class="reference internal" href="lte-references.html#ts36213" id="id59"><span>[TS36213]</span></a> for the case where a number <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> of
resource blocks is used. The achievable rate <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/> in bit/s for user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
on resource block group <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is defined as</p>
<div class="math">
<p><img src="_images/math/6a0c5c4fec6eb724c85f973484dcd1f836e52fe3.png" alt="R_{i}(k,t) =  \frac{S\left( M_{i,k}(t), 1\right)}{\tau}"/></p>
</div><p>where <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> is the TTI duration.
At the start of each subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>, each RBG is assigned to a certain user.
In detail, the index <img class="math" src="_images/math/529ae47506915b95a60656c7325b87513bf0858d.png" alt="\widehat{i}_{k}(t)"/> to which RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is assigned at time
<img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is determined as</p>
<div class="math">
<p><img src="_images/math/a5500173c1c4098c614da4f2181d3c4b3de14e4a.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ T_\mathrm{j}(t) } \right)"/></p>
</div><p>where <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> is the past througput performance perceived by the
user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>.
According to the above scheduling algorithm, a user can be allocated to
different RBGs, which can be either adjacent or not, depending on the current
condition of the channel and the past throughput performance <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/>. The
latter is determined at the end of the subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> using the following
exponential moving average approach:</p>
<div class="math">
<p><img src="_images/math/290e8690afc5b85a80b1e9594009b27833f32f2c.png" alt="T_{j}(t) =
(1-\frac{1}{\alpha})T_{j}(t-1)
+\frac{1}{\alpha} \widehat{T}_{j}(t)"/></p>
</div><p>where <img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/> is the time constant (in number of subframes) of
the exponential moving average, and <img class="math" src="_images/math/d84d63215af51f74a3737b1ebbc4e3e4b24ce7b0.png" alt="\widehat{T}_{j}(t)"/> is the actual
throughput achieved by the user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> in the subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>. <img class="math" src="_images/math/d84d63215af51f74a3737b1ebbc4e3e4b24ce7b0.png" alt="\widehat{T}_{j}(t)"/>
is measured according to the following procedure. First we
determine the MCS <img class="math" src="_images/math/f67055e462b7d27afb83ad7f1ef4c4b1a13f3846.png" alt="\widehat{M}_j(t)"/> actually used by user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>:</p>
<div class="math">
<p><img src="_images/math/7bf955a2c223b9103317d127ebcedb766ee34588.png" alt="\widehat{M}_j(t) = \min_{k: \widehat{i}_{k}(t) = j}{M_{j,k}(t)}"/></p>
</div><p>then we determine the total number <img class="math" src="_images/math/51c44c8e4a605289d83736cf84d4b4cdd24becb0.png" alt="\widehat{B}_j(t)"/> of RBGs allocated to user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>:</p>
<div class="math">
<p><img src="_images/math/575735d17b97b7c5afc4b095a7eddb56d631a572.png" alt="\widehat{B}_j(t) = \left| \{ k :  \widehat{i}_{k}(t) = j \} \right|"/></p>
</div><p>where <img class="math" src="_images/math/98c3e1f8e7991b65e2e4f20e5dc8592c81a3fd74.png" alt="|\cdot|"/> indicates the cardinality of the set; finally,</p>
<div class="math">
<p><img src="_images/math/1eb93027b54850f8e9c2840f8a7bb05aa2cf2f83.png" alt="\widehat{T}_{j}(t) = \frac{S\left( \widehat{M}_j(t), \widehat{B}_j(t)
\right)}{\tau}"/></p>
</div><p>For what concern the HARQ, PF implements the non adaptive version, which implies that in allocating the retransmission attempts the scheduler uses the same allocation configuration of the original block, which means maintaining the same RBGs and MCS. UEs that are allocated for HARQ retransmissions are not considered for the transmission of new data in case they have a transmission opportunity available in the same TTI. Finally, HARQ can be disabled with ns3 attribute system for maintaining backward compatibility with old test cases and code, in detail:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::PfFfMacScheduler::HarqEnabled&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="maximum-throughput-mt-scheduler">
<h4>Maximum Throughput (MT) Scheduler<a class="headerlink" href="#maximum-throughput-mt-scheduler" title="Permalink to this headline">¶</a></h4>
<p>The Maximum Throughput (MT) scheduler <a class="reference internal" href="lte-references.html#fcapo2012" id="id60"><span>[FCapo2012]</span></a> aims to maximize the overall throughput of eNB.
It allocates each RB to the user that can achieve the maximum achievable rate in the current TTI.
Currently, MT scheduler in NS-3 has two versions: frequency domain (FDMT) and time domain (TDMT).
In FDMT, every TTI, MAC scheduler allocates RBGs to the UE who has highest achievable rate calculated
by subband CQI. In TDMT, every TTI, MAC scheduler selects one UE which has highest achievable rate
calculated by wideband CQI. Then MAC scheduler allocates all RBGs to this UE in current TTI.
The calculation of achievable rate in FDMT and TDMT is as same as the one in PF.
Let <img class="math" src="_images/math/5183ea9096ac86aff6e13dd3d4389ae47617b059.png" alt="i,j"/> denote generic users; let <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> be the
subframe index, and <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> be the resource block index; let <img class="math" src="_images/math/5b56afc255250c48d60f4fad45bfb9b2d2879df5.png" alt="M_{i,k}(t)"/> be MCS
usable by user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> according to what reported by the AMC
model (see <a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a>); finally, let <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the TB
size in bits as defined in <a class="reference internal" href="lte-references.html#ts36213" id="id61"><span>[TS36213]</span></a> for the case where a number <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> of
resource blocks is used. The achievable rate <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/> in bit/s for user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is defined as</p>
<div class="math">
<p><img src="_images/math/6a0c5c4fec6eb724c85f973484dcd1f836e52fe3.png" alt="R_{i}(k,t) =  \frac{S\left( M_{i,k}(t), 1\right)}{\tau}"/></p>
</div><p>where <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> is the TTI duration.
At the start of each subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>, each RB is assigned to a certain user.
In detail, the index <img class="math" src="_images/math/529ae47506915b95a60656c7325b87513bf0858d.png" alt="\widehat{i}_{k}(t)"/> to which RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is assigned at time
<img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is determined as</p>
<div class="math">
<p><img src="_images/math/89e69353c75aa394020ad56e8931520bc89dc68a.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
    \left( { R_{j}(k,t) } \right)"/></p>
</div><p>When there are several UEs having the same achievable rate, current implementation always selects
the first UE created in script. Although MT can maximize cell throughput, it cannot provide
fairness to UEs in poor channel condition.</p>
</div>
<div class="section" id="throughput-to-average-tta-scheduler">
<h4>Throughput to Average (TTA) Scheduler<a class="headerlink" href="#throughput-to-average-tta-scheduler" title="Permalink to this headline">¶</a></h4>
<p>The Throughput to Average (TTA) scheduler <a class="reference internal" href="lte-references.html#fcapo2012" id="id62"><span>[FCapo2012]</span></a> can be considered as an intermediate between MT and PF.
The metric used in TTA is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/238fd14047f8b0496e76c5cb1f54e1d5bea4ae6c.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ R_{j}(t) } \right)"/></p>
</div><p>Here, <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/> in bit/s represents the achievable rate for user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>. The
calculation method already is shown in MT and PF. Meanwhile, <img class="math" src="_images/math/0440d3b5e8182a23e45c6d15ec5c2fb6f1006c40.png" alt="R_{i}(t)"/> in bit/s stands
for the achievable rate for <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>. The difference between those two
achievable rates is how to get MCS. For <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/>, MCS is calculated by subband CQI while
<img class="math" src="_images/math/0440d3b5e8182a23e45c6d15ec5c2fb6f1006c40.png" alt="R_{i}(t)"/> is calculated by wideband CQI. TTA scheduler can only be implemented in frequency domain (FD) because
the achievable rate of particular RBG is only related to FD scheduling.</p>
</div>
<div class="section" id="blind-average-throughput-scheduler">
<h4>Blind Average Throughput Scheduler<a class="headerlink" href="#blind-average-throughput-scheduler" title="Permalink to this headline">¶</a></h4>
<p>The Blind Average Throughput scheduler <a class="reference internal" href="lte-references.html#fcapo2012" id="id63"><span>[FCapo2012]</span></a> aims to provide equal throughput to all UEs under eNB. The metric
used in TTA is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/05a375c3c9c3fef82b1e97d7b069589df8dd5ea4.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ 1 }{ T_\mathrm{j}(t) } \right)"/></p>
</div><p>where <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> is the past throughput performance perceived by the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> and can be calculated by the
same method in PF scheduler. In the time domain blind average throughput (TD-BET), the scheduler selects the UE
with largest priority metric and allocates all RBGs to this UE. On the other hand, in the frequency domain blind
average throughput (FD-BET), every TTI, the scheduler first selects one UE with lowest pastAverageThroughput (largest
priority metric). Then scheduler assigns one RBG to this UE, it calculates expected throughput of this UE and uses it
to compare with past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> of other UEs. The scheduler continues
to allocate RBG to this UE until its expected throughput is not the smallest one among past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/>
of all UE. Then the scheduler will use the same way to allocate RBG for a new UE which has the
lowest past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> until all RBGs are allocated to UEs. The principle behind this is
that, in every TTI, the scheduler tries the best to achieve the equal throughput among all UEs.</p>
</div>
<div class="section" id="token-bank-fair-queue-scheduler">
<h4>Token Bank Fair Queue Scheduler<a class="headerlink" href="#token-bank-fair-queue-scheduler" title="Permalink to this headline">¶</a></h4>
<p>Token Bank Fair Queue (TBFQ) is a QoS aware scheduler which derives from the leaky-bucket mechanism. In TBFQ,
a traffic flow of user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> is characterized by following parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><img class="math" src="_images/math/f49b9947abf64a02da421bd28023a1084bb15f04.png" alt="t_{i}"/>: packet arrival rate (byte/sec )</p></li>
<li><p><img class="math" src="_images/math/3d74960049ac5c5fdcec12db9931429a19e32265.png" alt="r_{i}"/>: token generation rate (byte/sec)</p></li>
<li><p><img class="math" src="_images/math/eb0043fd60f5bc7448bb03170eaeb5b087d0bdf4.png" alt="p_{i}"/>: token pool size (byte)</p></li>
<li><p><img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/>: counter that records the number of token borrowed from or given to the token bank by flow <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> ;
<img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> can be smaller than zero</p></li>
</ul>
</div></blockquote>
<p>Each K bytes data consumes k tokens. Also, TBFQ maintains a shared token bank (<img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>) so as to balance the traffic
between different flows. If token generation rate <img class="math" src="_images/math/3d74960049ac5c5fdcec12db9931429a19e32265.png" alt="r_{i}"/> is bigger than packet arrival rate <img class="math" src="_images/math/f49b9947abf64a02da421bd28023a1084bb15f04.png" alt="t_{i}"/>, then tokens
overflowing from token pool are added to the token bank, and <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> is increased by the same amount. Otherwise,
flow <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> needs to withdraw tokens from token bank based on a priority metric <img class="math" src="_images/math/4a056ace77c1645dd1c76f927fb28797da2e92f6.png" alt="frac{E_{i}}{r_{i}}"/>, and <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> is decreased.
Obviously, the user contributes more on token bank has higher priority to borrow tokens; on the other hand, the
user borrows more tokens from bank has lower priority to continue to withdraw tokens. Therefore, in case of several
users having the same token generation rate, traffic rate and token pool size, user suffers from higher interference
has more opportunity to borrow tokens from bank. In addition, TBFQ can police the traffic by setting the token
generation rate to limit the throughput.  Additionally, TBFQ also maintains following three parameters for each flow:</p>
<blockquote>
<div><ul class="simple">
<li><p>Debt limit <img class="math" src="_images/math/72b95dbd3f98453253ee3012e4b7dccb86d55c2f.png" alt="d_{i}"/>: if <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> belows this threshold, user i cannot further borrow tokens from bank. This is for
preventing malicious UE to borrow too much tokens.</p></li>
<li><p>Credit limit <img class="math" src="_images/math/cb5448c62c69431617901ff76ecf95172e07d606.png" alt="c_{i}"/>: the maximum number of tokens UE i can borrow from the bank in one time.</p></li>
<li><p>Credit threshold <img class="math" src="_images/math/4db5b6e16e06f929ce3f675c5e535d06ffb02ff7.png" alt="C"/>: once <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> reaches debt limit, UE i must store <img class="math" src="_images/math/4db5b6e16e06f929ce3f675c5e535d06ffb02ff7.png" alt="C"/> tokens to bank in order to further
borrow token from bank.</p></li>
</ul>
</div></blockquote>
<p>LTE in NS-3 has two versions of TBFQ scheduler: frequency domain TBFQ (FD-TBFQ) and time domain TBFQ (TD-TBFQ).
In FD-TBFQ, the scheduler always select UE with highest metric and allocates RBG with highest subband CQI until
there are no packets within UE’s RLC buffer or all RBGs are allocated <a class="reference internal" href="lte-references.html#fabokhari2009" id="id64"><span>[FABokhari2009]</span></a>. In TD-TBFQ, after selecting
UE with maximum metric, it allocates all RBGs to this UE by using wideband CQI <a class="reference internal" href="lte-references.html#wkwong2004" id="id65"><span>[WKWong2004]</span></a>.</p>
</div>
<div class="section" id="priority-set-scheduler">
<h4>Priority Set Scheduler<a class="headerlink" href="#priority-set-scheduler" title="Permalink to this headline">¶</a></h4>
<p>Priority set scheduler (PSS) is a QoS aware scheduler which combines time domain (TD) and frequency domain (FD)
packet scheduling operations into one scheduler <a class="reference internal" href="lte-references.html#gmonghal2008" id="id66"><span>[GMonghal2008]</span></a>. It controls the fairness among UEs by a specified
Target Bit Rate (TBR).</p>
<p>In TD scheduler part, PSS first selects UEs with non-empty RLC buffer and then divide them into two sets based
on the TBR:</p>
<ul class="simple">
<li><p>set 1: UE whose past average throughput is smaller than TBR; TD scheduler calculates their priority metric in
Blind Equal Throughput (BET) style:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/05a375c3c9c3fef82b1e97d7b069589df8dd5ea4.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ 1 }{ T_\mathrm{j}(t) } \right)"/></p>
</div><ul class="simple">
<li><p>set 2: UE whose past average throughput is larger (or equal) than TBR; TD scheduler calculates their priority
metric in Proportional Fair (PF) style:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/a5500173c1c4098c614da4f2181d3c4b3de14e4a.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ T_\mathrm{j}(t) } \right)"/></p>
</div><p>UEs belonged to set 1 have higher priority than ones in set 2. Then PSS will select <img class="math" src="_images/math/0ba10651d1358dfecda6df5acaeef6b0bb6c4bdf.png" alt="N_{mux}"/> UEs with
highest metric in two sets and forward those UE to FD scheduler. In PSS, FD scheduler allocates RBG k to UE n
that maximums the chosen metric. Two PF schedulers are used in PF scheduler:</p>
<ul class="simple">
<li><p>Proportional Fair scheduled (PFsch)</p></li>
</ul>
<div class="math">
<p><img src="_images/math/b0f14685dd771a061f32a1642c77f1493ce8596d.png" alt="\widehat{Msch}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ Tsch_\mathrm{j}(t) } \right)"/></p>
</div><ul class="simple">
<li><p>Carrier over Interference to Average (CoIta)</p></li>
</ul>
<div class="math">
<p><img src="_images/math/9bc37fb9dc9e089b88caff28daa0ff00e87c52ad.png" alt="\widehat{Mcoi}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ CoI[j,k] }{ \sum_{k=0}^{N_{RBG}} CoI[j,k] } \right)"/></p>
</div><p>where <img class="math" src="_images/math/dea73801bf14c41998f4dc5537647b4d2b3add38.png" alt="Tsch_{j}(t)"/> is similar past throughput performance perceived by the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, with the
difference that it is updated only when the i-th user is actually served. <img class="math" src="_images/math/93d721f1812648f6b2a991e1781d1714d824bfff.png" alt="CoI[j,k]"/> is an
estimation of the SINR on the RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> of UE <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>. Both PFsch and CoIta is for decoupling
FD metric from TD scheduler. In addition, PSS FD scheduler also provide a weight metric W[n] for helping
controlling fairness in case of low number of UEs.</p>
<div class="math">
<p><img src="_images/math/ca3fbfed2db469bba1852455d1db3bf534785610.png" alt="W[n] =  max (1, \frac{TBR}{ T_{j}(t) })"/></p>
</div><p>where <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> is the past throughput performance perceived by the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> . Therefore, on
RBG k, the FD scheduler selects the UE <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> that maximizes the product of the frequency domain
metric (<img class="math" src="_images/math/cae83948f0daac0ae9d9e8978a5061f8f89209f2.png" alt="Msch"/>, <img class="math" src="_images/math/be0d9c06d5708fa37aadc302cce45ea1ca4ea40c.png" alt="MCoI"/>) by weight <img class="math" src="_images/math/c9d18087ddac8b5a064ab652747bdc9dcac05205.png" alt="W[n]"/>. This strategy will guarantee the throughput of lower
quality UE tend towards the TBR.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::PfFfMacScheduler::HarqEnabled&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>The scheduler implements the filtering of the uplink CQIs according to their nature with <code class="docutils literal notranslate"><span class="pre">UlCqiFilter</span></code> attribute, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SRS_UL_CQI</span></code>: only SRS based CQI are stored in the internal attributes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PUSCH_UL_CQI</span></code>: only PUSCH based CQI are stored in the internal attributes.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="channel-and-qos-aware-scheduler">
<h4>Channel and QoS Aware Scheduler<a class="headerlink" href="#channel-and-qos-aware-scheduler" title="Permalink to this headline">¶</a></h4>
<p>The Channel and QoS Aware (CQA) Scheduler <a class="reference internal" href="lte-references.html#bbojovic2014" id="id67"><span>[Bbojovic2014]</span></a> is an LTE
MAC downlink scheduling algorithm that considers the head of line
(HOL) delay, the GBR parameters and channel quality over
different subbands. The CQA scheduler is based on joint TD and FD
scheduling.</p>
<p>In the TD (at each TTI) the CQA scheduler groups users by
priority. The purpose of grouping is to enforce the FD scheduling to
consider first the flows with highest HOL delay. The grouping metric
<img class="math" src="_images/math/95044d4c8d88cf05346cb52b150be65e12771129.png" alt="m_{td}"/> for user <img class="math" src="_images/math/58eed65d8e2ecaa6ca7b646b43e67c1452ca3e8d.png" alt="j=1,...,N"/> is defined in the
following way:</p>
<div class="math">
<p><img src="_images/math/262953297cd242589199e5169c27d2d7dd39dab6.png" alt="m_{td}^{j}(t) = \lceil\frac{d_{hol}^{j}(t)}{g}\rceil \;,"/></p>
</div><p>where <img class="math" src="_images/math/9453de1404a4b08c1d98f1eb0d7740dd448e733b.png" alt="d_{hol}^{j}(t)"/> is the current value of HOL delay of flow
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, and <img class="math" src="_images/math/157ba5711de84b4c715a0478fd8ae440e596d96e.png" alt="g"/> is a grouping parameter that determines
granularity of the groups, i.e. the number of the flows that will be
considered in the FD scheduling iteration.</p>
<p>The groups of flows selected in the TD iteration are forwarded to the FD
scheduling starting from the flows with the highest value of the
<img class="math" src="_images/math/95044d4c8d88cf05346cb52b150be65e12771129.png" alt="m_{td}"/> metric until all RBGs are assigned in the corresponding
TTI.  In the FD, for each RBG <img class="math" src="_images/math/d110585cc973170f2776ad9b5403b213f4bce892.png" alt="k=1,...,K"/>, the CQA scheduler
assigns the current RBG to the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> that has the maximum value of
the FD metric which we define in the following way:</p>
<div class="math">
<p><img src="_images/math/b7c31c7fd55172700595e02bac4d79b916b22064.png" alt="m_{fd}^{(k,j)}(t) = d_{HOL}^{j}(t) \cdot m_{GBR}^j(t) \cdot m_{ca}^{k,j}(t) \;,"/></p>
</div><p>where <img class="math" src="_images/math/e369538730674b9dae6189214229d041f235966b.png" alt="m_{GBR}^j(t)"/> is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/a3d7d25950dc8b9b749acc6c4242114e89b0ae82.png" alt="m_{GBR}^j(t)=\frac{GBR^j}{\overline{R^j}(t)}=\frac{GBR^j}{(1-\alpha)\cdot\overline{R^j}(t-1)+\alpha \cdot r^j(t)} \;,"/></p>
</div><p>where <img class="math" src="_images/math/a990c3dbbc585dc4a8898c7ac40be36799c4f2ba.png" alt="GBR^j"/> is the bit rate specified in EPS bearer of the
flow <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, <img class="math" src="_images/math/e8f7bf732b6e79bc9c09b2e3b898724f70e043fc.png" alt="\overline{R^j}(t)"/> is the past averaged throughput that is calculated with a
moving average, <img class="math" src="_images/math/ec6519a7e3688b7be939ac7c55b20c30004a5882.png" alt="r^{j}(t)"/> is the throughput achieved at the
time t, and <img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/> is a coefficient such that <img class="math" src="_images/math/56225237a759ac2ca9a716c653dd844d98eb1ab3.png" alt="0 \le \alpha
\le1"/>.</p>
<p>For <img class="math" src="_images/math/39c37098e41bcdba68593562a56215f6bf2f9530.png" alt="m_{ca}^{(k,j)}(t)"/> we consider two different
metrics: <img class="math" src="_images/math/7aa94467e9740f7195a6dee4e55858bcfa434d46.png" alt="m_{pf}^{(k,j)}(t)"/> and <img class="math" src="_images/math/4e00ef1b9d19afc22e5eed290cc4bf0ff39f2eef.png" alt="m_{ff}^{(k,j)}(t)"/>.
<img class="math" src="_images/math/f584781f9a1be2f51d4fb73882e1f5cd82055170.png" alt="m_{pf}"/> is the Proportional Fair metric which is defined as follows:</p>
<div class="math">
<p><img src="_images/math/e7595531392ecb3b4d7872206d7c4ed832a9a453.png" alt="m_{pf}^{(k,j)}(t) = \frac{R_e^{(k,j)}}{\overline{R^j}(t)} \;,"/></p>
</div><p>where <img class="math" src="_images/math/fef833d0d7b28bdf52287d8979a446d0e76ed662.png" alt="R_e^{(k,j)}(t)"/> is the estimated achievable throughput of user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> over RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> calculated by the Adaptive Modulation and Coding
(AMC) scheme that maps the channel quality indicator (CQI) value to
the transport block size in bits.</p>
<p>The other channel awareness metric that we consider is <img class="math" src="_images/math/973053008b49074a62ddc97445adeabfff3e68f8.png" alt="m_{ff}"/> which
is proposed in <a class="reference internal" href="lte-references.html#gmonghal2008" id="id68"><span>[GMonghal2008]</span></a> and it represents the frequency
selective fading gains over RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> for user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> and is calculated in
the following way:</p>
<div class="math">
<p><img src="_images/math/e06cf048ec2cc63fd7a5cb867266e0a5eeb0f50c.png" alt="m_{ff}^{(k,j)}(t) = \frac{CQI^{(k,j)}(t)}{\sum_{k=1}^{K}CQI(t)^{(k,j)}} \;,"/></p>
</div><p>where <img class="math" src="_images/math/3d549acbde45b6d90d466601b00d51dc9f3610d4.png" alt="CQI^{(k,j)}(t)"/> is the last reported CQI value from user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> for the <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>-th RBG.</p>
<p>The user can select whether <img class="math" src="_images/math/f584781f9a1be2f51d4fb73882e1f5cd82055170.png" alt="m_{pf}"/> or <img class="math" src="_images/math/973053008b49074a62ddc97445adeabfff3e68f8.png" alt="m_{ff}"/> is used
by setting the attribute <code class="docutils literal notranslate"><span class="pre">ns3::CqaFfMacScheduler::CqaMetric</span></code>
respectively to <code class="docutils literal notranslate"><span class="pre">&quot;CqaPf&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;CqaFf&quot;</span></code>.</p>
</div>
</div>
<div class="section" id="random-access">
<span id="sec-random-access"></span><h3>Random Access<a class="headerlink" href="#random-access" title="Permalink to this headline">¶</a></h3>
<p>The LTE model includes a model of the Random Access procedure based on
some simplifying assumptions, which are detailed in the following for
each of the messages and signals described in the specs <a class="reference internal" href="lte-references.html#ts36321" id="id69"><span>[TS36321]</span></a>.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Random Access (RA) preamble</strong>: in real LTE systems this
corresponds to a Zadoff-Chu (ZC)
sequence using one of several formats available and sent in the
PRACH slots which could in principle overlap with PUSCH.
PRACH Configuration Index 14 is assumed, i.e., preambles can be
sent on any system frame number and subframe number.
The RA preamble is modeled using the LteControlMessage class,
i.e., as an ideal message that does not consume any radio
resources. The collision of preamble transmission by multiple UEs
in the same cell are modeled using a protocol interference model,
i.e., whenever two or more identical preambles are transmitted in
same cell at the same TTI, no one of these identical preambles
will be received by the eNB. Other than this collision model, no
error model is associated with the reception of a RA preamble.</p></li>
<li><p><strong>Random Access Response (RAR)</strong>: in real LTE systems, this is a
special MAC PDU sent on the DL-SCH. Since MAC control elements are not
accurately modeled in the simulator (only RLC and above PDUs
are), the RAR is modeled as an LteControlMessage that does not
consume any radio resources. Still, during the RA procedure, the
LteEnbMac will request to the scheduler the allocation of
resources for the RAR using the FF MAC Scheduler primitive
SCHED_DL_RACH_INFO_REQ. Hence, an enhanced scheduler
implementation (not available at the moment) could allocate radio
resources for the RAR, thus modeling the consumption of Radio
Resources for the transmission of the RAR.</p></li>
<li><p><strong>Message 3</strong>:  in real LTE systems, this is an RLC TM
SDU sent over resources specified in the UL Grant in the RAR. In
the simulator, this is modeled as a real RLC TM RLC PDU
whose UL resources are allocated by the scheduler upon call to
SCHED_DL_RACH_INFO_REQ.</p></li>
<li><p><strong>Contention Resolution (CR)</strong>: in real LTE system, the CR phase
is needed to address the case where two or more UE sent the same
RA preamble in the same TTI, and the eNB was able to detect this
preamble in spite of the collision. Since this event does not
occur due to the protocol interference model used for the
reception of RA preambles, the CR phase is not modeled in the
simulator, i.e., the CR MAC CE is never sent by the eNB and the
UEs consider the RA to be successful upon reception of the
RAR. As a consequence, the radio resources consumed for the
transmission of the CR MAC CE are not modeled.</p></li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-mac-random-access-contention"><span class="std std-ref">Sequence diagram of the Contention-based MAC Random Access procedure</span></a> and
<a class="reference internal" href="#fig-mac-random-access-noncontention"><span class="std std-ref">Sequence diagram of the Non-contention-based MAC Random Access procedure</span></a> shows the sequence diagrams
of respectively the contention-based and non-contention-based MAC
random access procedure, highlighting the interactions between the MAC
and the other entities.</p>
<div class="figure align-center" id="id165">
<span id="fig-mac-random-access-contention"></span><img alt="_images/mac-random-access-contention.png" src="_images/mac-random-access-contention.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the Contention-based MAC Random Access procedure</span><a class="headerlink" href="#id165" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id166">
<span id="fig-mac-random-access-noncontention"></span><img alt="_images/mac-random-access-noncontention.png" src="_images/mac-random-access-noncontention.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the Non-contention-based MAC Random Access procedure</span><a class="headerlink" href="#id166" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="rlc">
<h2>RLC<a class="headerlink" href="#rlc" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id70">
<h3>Overview<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h3>
<p>The RLC entity is specified in the 3GPP technical specification
<a class="reference internal" href="lte-references.html#ts36322" id="id71"><span>[TS36322]</span></a>, and comprises three different types of RLC: Transparent
Mode (TM), Unacknowledged Mode (UM) and Acknowledged Mode (AM). The
simulator includes one model for each of these entities</p>
<p>The RLC entities provide the RLC service interface to the upper PDCP layer and the MAC service interface
to the lower MAC layer. The RLC entities use the PDCP service interface from the upper PDCP layer and
the MAC service interface from the lower MAC layer.</p>
<p>Figure <a class="reference internal" href="#fig-lte-rlc-implementation-model"><span class="std std-ref">Implementation Model of PDCP, RLC and MAC entities and SAPs</span></a> shows the
implementation model of the RLC entities and its relationship
with all the other entities and services in the protocol stack.</p>
<div class="figure align-default" id="id167">
<span id="fig-lte-rlc-implementation-model"></span><img alt="_images/lte-rlc-implementation-model.png" src="_images/lte-rlc-implementation-model.png" />
<p class="caption"><span class="caption-text">Implementation Model of PDCP, RLC and MAC entities and SAPs</span><a class="headerlink" href="#id167" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="service-interfaces">
<h3>Service Interfaces<a class="headerlink" href="#service-interfaces" title="Permalink to this headline">¶</a></h3>
<div class="section" id="rlc-service-interface">
<h4>RLC Service Interface<a class="headerlink" href="#rlc-service-interface" title="Permalink to this headline">¶</a></h4>
<p>The RLC service interface is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">RlcSapProvider</span></code> part is provided by the RLC layer and used by the upper PDCP layer and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">RlcSapUser</span></code> part is provided by the upper PDCP layer and used by the RLC layer.</p></li>
</ul>
</div></blockquote>
<p>Both the UM and the AM RLC entities provide the same RLC service interface to the upper PDCP layer.</p>
<div class="section" id="rlc-service-primitives">
<h5>RLC Service Primitives<a class="headerlink" href="#rlc-service-primitives" title="Permalink to this headline">¶</a></h5>
<p>The following list specifies which service primitives are provided by the RLC service interfaces:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RlcSapProvider::TransmitPdcpPdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The PDCP entity uses this primitive to send a PDCP PDU to the lower RLC entity
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">RlcSapUser::ReceivePdcpPdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RLC entity uses this primitive to send a PDCP PDU to the upper PDCP entity
in the receiver peer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="mac-service-interface">
<h4>MAC Service Interface<a class="headerlink" href="#mac-service-interface" title="Permalink to this headline">¶</a></h4>
<p>The MAC service interface is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">MacSapProvider</span></code> part is provided by the MAC layer and used by the upper RLC layer and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">MacSapUser</span></code>  part is provided by the upper RLC layer and used by the MAC layer.</p></li>
</ul>
</div></blockquote>
<div class="section" id="mac-service-primitives">
<h5>MAC Service Primitives<a class="headerlink" href="#mac-service-primitives" title="Permalink to this headline">¶</a></h5>
<p>The following list specifies which service primitives are provided by the MAC service interfaces:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapProvider::TransmitPdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RLC entity uses this primitive to send a RLC PDU to the lower MAC entity
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapProvider::ReportBufferStatus</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RLC entity uses this primitive to report the MAC entity the size of pending buffers
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapUser::NotifyTxOpportunity</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The MAC entity uses this primitive to notify the RLC entity a transmission opportunity</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapUser::ReceivePdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The MAC entity uses this primitive to send an RLC PDU to the upper RLC entity
in the receiver peer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="am-rlc">
<span id="sec-am-data-transfer"></span><h3>AM RLC<a class="headerlink" href="#am-rlc" title="Permalink to this headline">¶</a></h3>
<p>The processing of the data transfer in the Acknowledge Mode (AM) RLC entity is explained in section 5.1.3 of <a class="reference internal" href="lte-references.html#ts36322" id="id72"><span>[TS36322]</span></a>.
In this section we describe some details of the implementation of the
RLC entity.</p>
<div class="section" id="buffers-for-the-transmit-operations">
<h4>Buffers for the transmit operations<a class="headerlink" href="#buffers-for-the-transmit-operations" title="Permalink to this headline">¶</a></h4>
<p>Our implementation of the AM RLC entity maintains 3 buffers for the
transmit operations:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Transmission Buffer</strong>: it is the RLC SDU queue.
When the AM RLC entity receives a SDU in the TransmitPdcpPdu service primitive from the
upper PDCP entity, it enqueues it in the Transmission Buffer. We
put a limit on the RLC buffer size and just silently drop SDUs
when the buffer is full.</p></li>
<li><p><strong>Transmitted PDUs Buffer</strong>: it is the queue of transmitted RLC PDUs for which an ACK/NACK has not
been received yet. When the AM RLC entity sends a PDU to the MAC
entity, it also puts a copy of the transmitted PDU in the Transmitted PDUs Buffer.</p></li>
<li><p><strong>Retransmission Buffer</strong>: it is the queue of RLC PDUs which are considered for retransmission
(i.e., they have been NACKed). The AM RLC entity moves this PDU to the Retransmission Buffer,
when it retransmits a PDU from the Transmitted Buffer.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="transmit-operations-in-downlink">
<span id="sec-rlc-am-tx-operations"></span><h4>Transmit operations in downlink<a class="headerlink" href="#transmit-operations-in-downlink" title="Permalink to this headline">¶</a></h4>
<p>The following sequence diagram shows the interactions between the
different entities (RRC, PDCP, AM RLC, MAC and MAC scheduler) of the
eNB in the downlink to perform data communications.</p>
<p>Figure <a class="reference internal" href="#fig-lte-rlc-data-txon-dl"><span class="std std-ref">Sequence diagram of data PDU transmission in downlink</span></a> shows how the upper layers send
data PDUs and how the data flow is processed by the different
entities/services of the LTE protocol stack.</p>
<div class="figure align-default" id="id168">
<span id="fig-lte-rlc-data-txon-dl"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-txon-dl.png"><img alt="_images/lte-rlc-data-txon-dl.png" src="_images/lte-rlc-data-txon-dl.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-text">Sequence diagram of data PDU transmission in downlink</span><a class="headerlink" href="#id168" title="Permalink to this image">¶</a></p>
</div>
<p>The PDCP entity calls the <code class="docutils literal notranslate"><span class="pre">Transmit_PDCP_PDU</span> <span class="pre">service</span> <span class="pre">primitive</span></code> in
order to send a data PDU. The AM RLC entity processes this service
primitive according to the AM data transfer procedures defined in
section 5.1.3 of <a class="reference internal" href="lte-references.html#ts36322" id="id73"><span>[TS36322]</span></a>.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">Transmit_PDCP_PDU</span></code> service primitive is called, the AM RLC
entity performs the following operations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Put the data SDU in the Transmission Buffer.</p></li>
<li><p>Compute the size of the buffers (how the size of buffers is
computed will be explained afterwards).</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">Report_Buffer_Status</span></code> service primitive of the eNB
MAC entity in order to notify to the eNB MAC
entity the sizes of the buffers of the AM RLC entity. Then, the
eNB MAC entity updates the buffer status in the MAC scheduler
using the SchedDlRlcBufferReq service primitive of the FF MAC
Scheduler API.</p></li>
</ul>
</div></blockquote>
<p>Afterwards, when the MAC scheduler decides that some data can be sent,
the MAC entity notifies it to the RLC entity, i.e. it calls the
<code class="docutils literal notranslate"><span class="pre">Notify_Tx_Opportunity</span></code> service primitive, then the AM RLC entity
does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>Create a single data PDU by segmenting and/or concatenating the
SDUs in the Transmission Buffer.</p></li>
<li><p>Move the data PDU from the Transmission Buffer to the
Transmitted PDUs Buffer.</p></li>
<li><p>Update state variables according section 5.1.3.1.1 of
<a class="reference internal" href="lte-references.html#ts36322" id="id74"><span>[TS36322]</span></a>.</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">Transmit_PDU</span></code> primitive in order to send the data
PDU to the MAC entity.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="retransmission-in-downlink">
<h4>Retransmission in downlink<a class="headerlink" href="#retransmission-in-downlink" title="Permalink to this headline">¶</a></h4>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-rlc-data-retx-dl"><span class="std std-ref">Sequence diagram of data PDU retransmission in downlink</span></a> shows
the interactions between the different entities (AM RLC, MAC and MAC
scheduler) of the eNB in downlink when data PDUs must be retransmitted
by the AM RLC entity.</p>
<div class="figure align-default" id="id169">
<span id="fig-lte-rlc-data-retx-dl"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-retx-dl.png"><img alt="_images/lte-rlc-data-retx-dl.png" src="_images/lte-rlc-data-retx-dl.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">Sequence diagram of data PDU retransmission in downlink</span><a class="headerlink" href="#id169" title="Permalink to this image">¶</a></p>
</div>
<p>The transmitting AM RLC entity can receive STATUS PDUs from the peer AM RLC entity. STATUS PDUs are
sent according section 5.3.2 of <a class="reference internal" href="lte-references.html#ts36322" id="id75"><span>[TS36322]</span></a> and the processing of reception is made according
section 5.2.1 of <a class="reference internal" href="lte-references.html#ts36322" id="id76"><span>[TS36322]</span></a>.</p>
<p>When a data PDUs is retransmitted from the Transmitted PDUs Buffer, it is also moved to the
Retransmission Buffer.</p>
</div>
<div class="section" id="transmit-operations-in-uplink">
<h4>Transmit operations in uplink<a class="headerlink" href="#transmit-operations-in-uplink" title="Permalink to this headline">¶</a></h4>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-rlc-data-txon-ul"><span class="std std-ref">Sequence diagram of data PDU transmission in uplink</span></a> shows
the interactions between the different entities of the UE (RRC, PDCP,
RLC and MAC) and the eNB (MAC and Scheduler) in uplink when data PDUs
are sent by the upper layers.</p>
<div class="figure align-default" id="id170">
<span id="fig-lte-rlc-data-txon-ul"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-txon-ul.png"><img alt="_images/lte-rlc-data-txon-ul.png" src="_images/lte-rlc-data-txon-ul.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-text">Sequence diagram of data PDU transmission in uplink</span><a class="headerlink" href="#id170" title="Permalink to this image">¶</a></p>
</div>
<p>It is similar to the sequence diagram in downlink; the main difference
is that in this case the Report_Buffer_Status is sent from the UE MAC
to the MAC Scheduler in the eNB over the air using the control
channel.</p>
</div>
<div class="section" id="retransmission-in-uplink">
<h4>Retransmission in uplink<a class="headerlink" href="#retransmission-in-uplink" title="Permalink to this headline">¶</a></h4>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-rlc-data-retx-ul"><span class="std std-ref">Sequence diagram of data PDU retransmission in uplink</span></a> shows
the interactions between the different entities of the UE (AM RLC and
MAC) and the eNB (MAC) in uplink when data PDUs must be retransmitted
by the AM RLC entity.</p>
<div class="figure align-default" id="id171">
<span id="fig-lte-rlc-data-retx-ul"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-retx-ul.png"><img alt="_images/lte-rlc-data-retx-ul.png" src="_images/lte-rlc-data-retx-ul.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">Sequence diagram of data PDU retransmission in uplink</span><a class="headerlink" href="#id171" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="calculation-of-the-buffer-size">
<span id="sec-rlc-am-buffer-size"></span><h4>Calculation of the buffer size<a class="headerlink" href="#calculation-of-the-buffer-size" title="Permalink to this headline">¶</a></h4>
<p>The Transmission Buffer contains RLC SDUs. A RLC PDU is one or more SDU segments plus an RLC header.
The size of the RLC header of one RLC PDU depends on the number of SDU segments the PDU contains.</p>
<p>The 3GPP standard  (section 6.1.3.1 of <a class="reference internal" href="lte-references.html#ts36321" id="id77"><span>[TS36321]</span></a>) says clearly that,
for the uplink, the RLC and MAC headers are not considered in the
buffer size that is to be report as part of the Buffer Status Report.
For the downlink, the behavior is not specified. Neither <a class="reference internal" href="lte-references.html#ffapi" id="id78"><span>[FFAPI]</span></a> specifies
how to do it. Our RLC model works by assuming that the calculation of
the buffer size in the downlink is done exactly as in the uplink,
i.e., not considering the RLC and MAC header size.</p>
<p>We note that this choice affects the interoperation with the
MAC scheduler, since, in response to the
<code class="docutils literal notranslate"><span class="pre">Notify_Tx_Opportunity</span></code> service primitive, the RLC is expected to
create a PDU of no more than the size requested by the MAC, including
RLC overhead. Hence, unneeded fragmentation can occur if (for example)
the MAC notifies a transmission exactly equal to the buffer size
previously reported by the RLC. We assume that it is left to the Scheduler
to implement smart strategies for the selection of the size of the
transmission opportunity, in order to eventually avoid the inefficiency
of unneeded fragmentation.</p>
</div>
<div class="section" id="concatenation-and-segmentation">
<h4>Concatenation and Segmentation<a class="headerlink" href="#concatenation-and-segmentation" title="Permalink to this headline">¶</a></h4>
<p>The AM RLC entity generates and sends exactly one RLC PDU for each transmission opportunity even
if it is smaller than the size reported by the transmission opportunity. So for instance, if a
STATUS PDU is to be sent, then only this PDU will be sent in that transmission opportunity.</p>
<p>The segmentation and concatenation for the SDU queue of the AM RLC entity follows the same philosophy
as the same procedures of the UM RLC entity but there are new state
variables (see <a class="reference internal" href="lte-references.html#ts36322" id="id79"><span>[TS36322]</span></a> section 7.1) only present in the AM RLC entity.</p>
<p>It is noted that, according to the 3GPP specs, there is no concatenation for the Retransmission Buffer.</p>
</div>
<div class="section" id="re-segmentation">
<h4>Re-segmentation<a class="headerlink" href="#re-segmentation" title="Permalink to this headline">¶</a></h4>
<p>The current model of the AM RLC entity does not support the
re-segmentation of the retransmission buffer. Rather, the AM RLC
entity just waits to receive a big enough transmission
opportunity.</p>
</div>
<div class="section" id="unsupported-features">
<h4>Unsupported features<a class="headerlink" href="#unsupported-features" title="Permalink to this headline">¶</a></h4>
<p>We do not support the following procedures of <a class="reference internal" href="lte-references.html#ts36322" id="id80"><span>[TS36322]</span></a> :</p>
<blockquote>
<div><ul class="simple">
<li><p>“Send an indication of successful delivery of RLC SDU” (See section 5.1.3.1.1)</p></li>
<li><p>“Indicate to upper layers that max retransmission has been reached” (See section 5.2.1)</p></li>
<li><p>“SDU discard procedures” (See section 5.3)</p></li>
<li><p>“Re-establishment procedure” (See section 5.4)</p></li>
</ul>
</div></blockquote>
<p>We do not support any of the additional primitives of RLC SAP for AM RLC entity. In particular:</p>
<blockquote>
<div><ul class="simple">
<li><p>no SDU discard notified by PDCP</p></li>
<li><p>no notification of successful / failed delivery by AM RLC entity to PDCP entity</p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="um-rlc">
<h3>UM RLC<a class="headerlink" href="#um-rlc" title="Permalink to this headline">¶</a></h3>
<p>In this section we describe the implementation of the Unacknowledged Mode (UM) RLC entity.</p>
<div class="section" id="id81">
<h4>Transmit operations in downlink<a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h4>
<p>The transmit operations of the UM RLC are similar to those of the AM
RLC previously described in Section <a class="reference internal" href="#sec-rlc-am-tx-operations"><span class="std std-ref">Transmit operations in downlink</span></a>,
with the difference that, following the specifications of <a class="reference internal" href="lte-references.html#ts36322" id="id82"><span>[TS36322]</span></a>,
retransmission are not performed, and there are no STATUS PDUs.</p>
</div>
<div class="section" id="id83">
<h4>Transmit operations in uplink<a class="headerlink" href="#id83" title="Permalink to this headline">¶</a></h4>
<p>The transmit operations in the uplink are similar to those of the
downlink, with the main difference that the Report_Buffer_Status is
sent from the UE MAC to the MAC Scheduler in the eNB over the air
using the control channel.</p>
</div>
<div class="section" id="id84">
<h4>Calculation of the buffer size<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h4>
<p>The calculation of the buffer size for the UM RLC is done using the
same approach of the AM RLC, please refer to section
<a class="reference internal" href="#sec-rlc-am-buffer-size"><span class="std std-ref">Calculation of the buffer size</span></a> for the corresponding description.</p>
</div>
</div>
<div class="section" id="tm-rlc">
<h3>TM RLC<a class="headerlink" href="#tm-rlc" title="Permalink to this headline">¶</a></h3>
<p>In this section we describe the implementation of the Transparent Mode (TM) RLC entity.</p>
<div class="section" id="id85">
<h4>Transmit operations in downlink<a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h4>
<p>In the simulator, the TM RLC still provides to the upper layers the
same service interface provided by the AM and UM RLC
entities to the PDCP layer; in practice, this interface is used by an RRC
entity (not a PDCP entity) for the transmission of RLC SDUs. This
choice is motivated by the fact that the services provided by the TM
RLC to the upper layers, according to <a class="reference internal" href="lte-references.html#ts36322" id="id86"><span>[TS36322]</span></a>, is a subset of those
provided by the UM and AM RLC entities to the PDCP layer; hence,
we reused the same interface for simplicity.</p>
<p>The transmit operations in the downlink are performed as follows. When
the <code class="docutils literal notranslate"><span class="pre">Transmit_PDCP_PDU</span> <span class="pre">service</span> <span class="pre">primitive</span></code> is called by the upper
layers, the TM RLC does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>put the SDU in the Transmission Buffer</p></li>
<li><p>compute the size of the Transmission Buffer</p></li>
<li><p>call the <code class="docutils literal notranslate"><span class="pre">Report_Buffer_Status</span></code> service primitive of the eNB
MAC entity</p></li>
</ul>
</div></blockquote>
<p>Afterwards, when the MAC scheduler decides that some data can be sent
by the logical channel to which the TM RLC entity belongs, the MAC
entity notifies it to the TM RLC entity by calling the
<code class="docutils literal notranslate"><span class="pre">Notify_Tx_Opportunity</span></code> service primitive. Upon reception of this
primitive, the TM RLC entity does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>if the TX opportunity has a size that is greater than or equal to
the size of the head-of-line SDU in the Transmission Buffer</p>
<ul>
<li><p>dequeue the head-of-line SDU from the Transmission Buffer</p></li>
<li><p>create one RLC PDU that contains entirely that SDU, without any
RLC header</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">Transmit_PDU</span></code> primitive in order to send the RLC
PDU to the MAC entity.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id87">
<h4>Transmit operations in uplink<a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h4>
<p>The transmit operations in the uplink are similar to those of the
downlink, with the main difference that a transmission opportunity can
also arise from the assignment of the UL GRANT as part of the Random
Access procedure, without an explicit Buffer Status Report issued by
the TM RLC entity.</p>
</div>
<div class="section" id="id88">
<h4>Calculation of the buffer size<a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h4>
<p>As per the specifications <a class="reference internal" href="lte-references.html#ts36322" id="id89"><span>[TS36322]</span></a>, the TM RLC does not add any RLC
header to the PDUs being transmitted. Because of this, the buffer size
reported to the MAC layer is calculated simply by summing the size of
all packets in the transmission buffer, thus notifying to the MAC the
exact buffer size.</p>
</div>
</div>
<div class="section" id="sm-rlc">
<h3>SM RLC<a class="headerlink" href="#sm-rlc" title="Permalink to this headline">¶</a></h3>
<p>In addition to the AM, UM and TM implementations that are modeled
after the 3GPP specifications, a simplified RLC model is provided,
which is called Saturation Mode (SM) RLC. This RLC model does not accept
PDUs from any above layer (such as PDCP); rather, the SM RLC takes care of the
generation of RLC PDUs in response to
the notification of transmission opportunities notified by the MAC.
In other words, the SM RLC simulates saturation conditions, i.e., it
assumes that the RLC buffer is always full and can generate a new PDU
whenever notified by the scheduler.</p>
<p>The SM RLC is used for simplified simulation scenarios in which only the
LTE Radio model is used, without the EPC and hence without any IP
networking support. We note that, although the SM RLC is an
unrealistic traffic model, it still allows for the correct simulation
of scenarios with multiple flows belonging to different (non real-time)
QoS classes, in order to test the QoS performance obtained by different
schedulers. This can be
done since it is the task of the Scheduler to assign transmission
resources based on the characteristics (e.g., Guaranteed Bit Rate) of
each Radio Bearer, which are specified upon the definition of each
Bearer within the simulation program.</p>
<p>As for schedulers designed to work with real-time QoS
traffic that has delay constraints, the SM RLC is probably not an appropriate choice.
This is because the absence of actual RLC SDUs (replaced by the artificial
generation of Buffer Status Reports) makes it not possible to provide
the Scheduler with meaningful head-of-line-delay information, which is
often the metric of choice for the implementation of scheduling
policies for real-time traffic flows. For the simulation and testing
of such schedulers, it is advisable to use either the UM or the AM RLC
models instead.</p>
</div>
</div>
<div class="section" id="pdcp">
<h2>PDCP<a class="headerlink" href="#pdcp" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pdcp-model-overview">
<h3>PDCP Model Overview<a class="headerlink" href="#pdcp-model-overview" title="Permalink to this headline">¶</a></h3>
<p>The reference document for the specification of the PDCP entity is
<a class="reference internal" href="lte-references.html#ts36323" id="id90"><span>[TS36323]</span></a>. With respect to this specification, the PDCP model
implemented in the simulator supports only the following features:</p>
<blockquote>
<div><ul class="simple">
<li><p>transfer of data (user plane or control plane);</p></li>
<li><p>maintenance of PDCP SNs;</p></li>
<li><p>transfer of SN status (for use upon handover);</p></li>
</ul>
</div></blockquote>
<p>The following features are currently not supported:</p>
<blockquote>
<div><ul class="simple">
<li><p>header compression and decompression of IP data flows using the ROHC protocol;</p></li>
<li><p>in-sequence delivery of upper layer PDUs at re-establishment of lower layers;</p></li>
<li><p>duplicate elimination of lower layer SDUs at re-establishment of lower layers for radio bearers mapped on RLC AM;</p></li>
<li><p>ciphering and deciphering of user plane data and control plane data;</p></li>
<li><p>integrity protection and integrity verification of control plane data;</p></li>
<li><p>timer based discard;</p></li>
<li><p>duplicate discarding.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="pdcp-service-interface">
<h3>PDCP Service Interface<a class="headerlink" href="#pdcp-service-interface" title="Permalink to this headline">¶</a></h3>
<p>The PDCP service interface is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">PdcpSapProvider</span></code> part is provided by the PDCP layer and used by the upper layer and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">PdcpSapUser</span></code> part is provided by the upper layer and used by the PDCP layer.</p></li>
</ul>
</div></blockquote>
<div class="section" id="pdcp-service-primitives">
<h4>PDCP Service Primitives<a class="headerlink" href="#pdcp-service-primitives" title="Permalink to this headline">¶</a></h4>
<p>The following list specifies which service primitives are provided by the PDCP service interfaces:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">PdcpSapProvider::TransmitPdcpSdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RRC entity uses this primitive to send an RRC PDU to the lower PDCP entity
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PdcpSapUser::ReceivePdcpSdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The PDCP entity uses this primitive to send an RRC PDU to the upper RRC entity
in the receiver peer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="rrc">
<h2>RRC<a class="headerlink" href="#rrc" title="Permalink to this headline">¶</a></h2>
<div class="section" id="features">
<h3>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h3>
<p>The RRC model implemented in the simulator provides the following functionality:</p>
<blockquote>
<div><ul class="simple">
<li><p>generation (at the eNB) and interpretation (at the UE) of System
Information (in particular the Master Information Block and, at the
time of this writing, only System Information Block Type 1 and 2)</p></li>
<li><p>initial cell selection</p></li>
<li><p>RRC connection establishment procedure</p></li>
<li><p>RRC reconfiguration procedure, supporting the following use cases:
+ reconfiguration of the SRS configuration index
+ reconfiguration of the PHY TX mode (MIMO)
+ reconfiguration of UE measurements
+ data radio bearer setup
+ handover</p></li>
<li><p>RRC connection re-establishment, supporting the following use
cases:
+ handover</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id91">
<h3>Architecture<a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h3>
<p>The RRC model is divided into the following components:</p>
<blockquote>
<div><ul class="simple">
<li><p>the RRC entities <cite>LteUeRrc</cite> and <cite>LteEnbRrc</cite>, which implement the state
machines of the RRC entities respectively at the UE and the eNB;</p></li>
<li><p>the RRC SAPs <cite>LteUeRrcSapProvider</cite>, <cite>LteUeRrcSapUser</cite>,
<cite>LteEnbRrcSapProvider</cite>, <cite>LteEnbRrcSapUser</cite>, which allow the RRC
entities to send and receive RRC messages and information
elmenents;</p></li>
<li><p>the RRC protocol classes <cite>LteUeRrcProtocolIdeal</cite>,
<cite>LteEnbRrcProtocolIdeal</cite>, <cite>LteUeRrcProtocolReal</cite>,
<cite>LteEnbRrcProtocolReal</cite>, which implement two different models for
the transmission of RRC messages.</p></li>
</ul>
</div></blockquote>
<p>Additionally, the RRC components use various other SAPs in order to
interact with the rest of the protocol stack. A representation of all
the SAPs that are used is provided in the figures <a class="reference internal" href="#fig-lte-arch-ue-data"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the data plane</span></a>,
<a class="reference internal" href="#fig-lte-arch-ue-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the control plane</span></a>, <a class="reference internal" href="#fig-lte-arch-enb-data"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the data plane</span></a> and
<a class="reference internal" href="#fig-lte-arch-enb-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the control plane</span></a>.</p>
</div>
<div class="section" id="ue-rrc-state-machine">
<h3>UE RRC State Machine<a class="headerlink" href="#ue-rrc-state-machine" title="Permalink to this headline">¶</a></h3>
<p>In Figure <a class="reference internal" href="#fig-lte-ue-rrc-states"><span class="std std-ref">UE RRC State Machine</span></a> we represent the state machine
as implemented in the RRC UE entity.</p>
<div class="figure align-center" id="id172">
<span id="fig-lte-ue-rrc-states"></span><a class="reference internal image-reference" href="_images/lte-ue-rrc-states.png"><img alt="_images/lte-ue-rrc-states.png" src="_images/lte-ue-rrc-states.png" style="width: 538.1999999999999px; height: 769.8px;" /></a>
<p class="caption"><span class="caption-text">UE RRC State Machine</span><a class="headerlink" href="#id172" title="Permalink to this image">¶</a></p>
</div>
<p>All the states are transient, however, the UE in “CONNECTED_NORMALLY” state will
only switch to the IDLE state if the downlink SINR is below a defined threshold,
which would lead to radio link failure <a class="reference internal" href="#sec-radio-link-failure"><span class="std std-ref">Radio Link Failure</span></a>.
One the other hand, the UE would not be able switch to IDLE mode due to a handover
failure, as mentioned in <a class="reference internal" href="#sec-x2"><span class="std std-ref">X2</span></a>.</p>
</div>
<div class="section" id="enb-rrc-state-machine">
<h3>ENB RRC State Machine<a class="headerlink" href="#enb-rrc-state-machine" title="Permalink to this headline">¶</a></h3>
<p>The eNB RRC maintains the state for each UE that is attached to the
cell. From an implementation point of view, the state of each UE is
contained in an instance of the UeManager class. The state machine is
represented in Figure <a class="reference internal" href="#fig-lte-enb-rrc-states"><span class="std std-ref">ENB RRC State Machine for each UE</span></a>.</p>
<div class="figure align-center" id="id173">
<span id="fig-lte-enb-rrc-states"></span><a class="reference internal image-reference" href="_images/lte-enb-rrc-states.png"><img alt="_images/lte-enb-rrc-states.png" src="_images/lte-enb-rrc-states.png" style="width: 744.8px; height: 683.1999999999999px;" /></a>
<p class="caption"><span class="caption-text">ENB RRC State Machine for each UE</span><a class="headerlink" href="#id173" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="initial-cell-selection">
<span id="sec-initial-cell-selection"></span><h3>Initial Cell Selection<a class="headerlink" href="#initial-cell-selection" title="Permalink to this headline">¶</a></h3>
<p>Initial cell selection is an IDLE mode procedure, performed by UE when it has
not yet camped or attached to an eNodeB. The objective of the procedure is to
find a suitable cell and attach to it to gain access to the cellular network.</p>
<p>It is typically done at the beginning of simulation, as depicted in Figure
<a class="reference internal" href="#fig-lte-cell-selection-timeline"><span class="std std-ref">Sample runs of initial cell selection in UE and timing of related events</span></a> below. The time diagram on the left side
is illustrating the case where initial cell selection succeed on first try,
while the diagram on the right side is for the case where it fails on the first
try and succeed on the second try. The timing assumes the use of real RRC
protocol model (see <a class="reference internal" href="#sec-rrc-protocol-models"><span class="std std-ref">RRC protocol models</span></a>) and no transmission error.</p>
<div class="figure align-center" id="id174">
<span id="fig-lte-cell-selection-timeline"></span><a class="reference internal image-reference" href="_images/lte-cell-selection-timeline.png"><img alt="_images/lte-cell-selection-timeline.png" src="_images/lte-cell-selection-timeline.png" style="width: 687.2px; height: 644.0px;" /></a>
<p class="caption"><span class="caption-text">Sample runs of initial cell selection in UE and timing of related events</span><a class="headerlink" href="#id174" title="Permalink to this image">¶</a></p>
</div>
<p>The functionality is based on 3GPP IDLE mode specifications, such as in
<a class="reference internal" href="lte-references.html#ts36300" id="id92"><span>[TS36300]</span></a>, <a class="reference internal" href="lte-references.html#ts36304" id="id93"><span>[TS36304]</span></a>, and <a class="reference internal" href="lte-references.html#ts36331" id="id94"><span>[TS36331]</span></a>. However, a proper implementation of IDLE
mode is still missing in the simulator, so we reserve several simplifying
assumptions:</p>
<blockquote>
<div><ul class="simple">
<li><p>multiple carrier frequency is not supported;</p></li>
<li><p>multiple Public Land Mobile Network (PLMN) identities (i.e. multiple network
operators) is not supported;</p></li>
<li><p>RSRQ measurements are not utilized;</p></li>
<li><p>stored information cell selection is not supported;</p></li>
<li><p>“Any Cell Selection” state and camping to an acceptable cell is not
supported;</p></li>
<li><p>marking a cell as barred or reserved is not supported;</p></li>
<li><p>Idle cell reselection is not supported, hence it is not possible for UE to camp to
a different cell after the initial camp has been placed; and</p></li>
<li><p>UE’s Closed Subscriber Group (CSG) white list contains only one CSG identity.</p></li>
</ul>
</div></blockquote>
<p>Also note that initial cell selection is only available for EPC-enabled
simulations. LTE-only simulations must use the manual attachment method. See
section <a class="reference internal" href="lte-user.html#sec-network-attachment"><span class="std std-ref">Network Attachment</span></a> of the User Documentation for more
information on their differences in usage.</p>
<p>The next subsections cover different parts of initial cell selection, namely
<em>cell search</em>, <em>broadcast of system information</em>, and <em>cell selection evaluation</em>.</p>
<div class="section" id="cell-search">
<span id="sec-cell-search"></span><h4>Cell Search<a class="headerlink" href="#cell-search" title="Permalink to this headline">¶</a></h4>
<p>Cell search aims to detect surrounding cells and measure the strength of
received signal from each of these cells. One of these cells will become the
UE’s entry point to join the cellular network.</p>
<p>The measurements are based on the RSRP of the received PSS, averaged by Layer 1
filtering, and performed by the PHY layer, as previously described in more
detail in section <a class="reference internal" href="#sec-phy-ue-measurements"><span class="std std-ref">UE PHY Measurements Model</span></a>. PSS is transmitted by eNodeB
over the central 72 sub-carriers of the DL channel (Section 5.1.7.3 <a class="reference internal" href="lte-references.html#ts36300" id="id95"><span>[TS36300]</span></a>),
hence we model cell search to operate using a DL bandwidth of 6 RBs. Note that
measurements of RSRQ are not available at this point of time in simulation. As
a consequence, the <code class="docutils literal notranslate"><span class="pre">LteUePhy::RsrqUeMeasThreshold</span></code> attribute does not apply
during cell search.</p>
<p>By using the measured RSRP, the PHY entity is able to generate a list of
detected cells, each with its corresponding cell ID and averaged RSRP. This list
is periodically pushed via CPHY SAP to the RRC entity as a measurement report.</p>
<p>The RRC entity inspects the report and simply choose the cell with the strongest
RSRP, as also indicated in Section 5.2.3.1 of <a class="reference internal" href="lte-references.html#ts36304" id="id96"><span>[TS36304]</span></a>. Then it instructs back
the PHY entity to synchronize to this particular cell. The actual operating
bandwidth of the cell is still unknown at this time, so the PHY entity listens
only to the minimum bandwidth of 6 RBs. Nevertheless, the PHY entity will be
able to receive system broadcast message from this particular eNodeB, which is
the topic of the next subsection.</p>
</div>
<div class="section" id="broadcast-of-system-information">
<h4>Broadcast of System Information<a class="headerlink" href="#broadcast-of-system-information" title="Permalink to this headline">¶</a></h4>
<p>System information blocks are broadcasted by eNodeB to UEs at predefined time
intervals, adapted from Section 5.2.1.2 of <a class="reference internal" href="lte-references.html#ts36331" id="id97"><span>[TS36331]</span></a>. The supported system
information blocks are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Master Information Block (MIB)</dt><dd><p>Contains parameters related to the PHY layer, generated during cell
configuration and broadcasted every 10 ms at the beginning of radio frame
as a control message.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>System Information Block Type 1 (SIB1)</dt><dd><p>Contains information regarding network access, broadcasted every 20 ms at
the middle of radio frame as a control message. Not used in manual
attachment method. UE must have decoded MIB before it can receive SIB1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>System Information Block Type 2 (SIB2)</dt><dd><p>Contains UL- and RACH-related settings, scheduled to transmit via RRC
protocol at 16 ms after cell configuration, and then repeats every 80 ms
(configurable through <cite>LteEnbRrc::SystemInformationPeriodicity</cite> attribute.
UE must be camped to a cell in order to be able to receive its SIB2.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Reception of system information is fundamental for UE to advance in its
lifecycle. MIB enables the UE to increase the initial DL bandwidth of 6 RBs to
the actual operating bandwidth of the network. SIB1 provides information
necessary for cell selection evaluation (explained in the next section). And
finally SIB2 is required before the UE is allowed to switch to CONNECTED state.</p>
</div>
<div class="section" id="cell-selection-evaluation">
<span id="sec-cell-selection-evaluation"></span><h4>Cell Selection Evaluation<a class="headerlink" href="#cell-selection-evaluation" title="Permalink to this headline">¶</a></h4>
<p>UE RRC reviews the measurement report produced in <a class="reference internal" href="#sec-cell-search"><span class="std std-ref">Cell Search</span></a> and the
cell access information provided by SIB1. Once both information is available for
a specific cell, the UE triggers the evaluation process. The purpose of this
process is to determine whether the cell is a suitable cell to camp to.</p>
<p>The evaluation process is a slightly simplified version of Section 5.2.3.2 of
<a class="reference internal" href="lte-references.html#ts36304" id="id98"><span>[TS36304]</span></a>. It consists of the following criteria:</p>
<blockquote>
<div><ul class="simple">
<li><p>Rx level criterion; and</p></li>
<li><p>closed subscriber group (CSG) criterion.</p></li>
</ul>
</div></blockquote>
<p>The first criterion, Rx level, is based on the cell’s measured RSRP
<img class="math" src="_images/math/c3ea4d8593d3cb6fe33d1a0ca5def5ef94ae5164.png" alt="Q_{rxlevmeas}"/>, which has to be higher than a required minimum
<img class="math" src="_images/math/31fe99de5833e46d070576e6df3ea7df3e435030.png" alt="Q_{rxlevmin}"/> in order to pass the criterion:</p>
<div class="math">
<p><img src="_images/math/2bdca35105cbeb8515fffaa58cc35c1492bde075.png" alt="Q_{rxlevmeas} - Q_{rxlevmin} &gt; 0"/></p>
</div><p>where <img class="math" src="_images/math/31fe99de5833e46d070576e6df3ea7df3e435030.png" alt="Q_{rxlevmin}"/> is determined by each eNodeB and is obtainable by UE
from SIB1.</p>
<p>The last criterion, CSG, is a combination of a true-or-false parameter called
<em>CSG indication</em> and a simple number <em>CSG identity</em>. The basic rule is that UE
shall not camp to eNodeB with a different CSG identity. But this rule is only
enforced when CSG indication is valued as true. More details are provided in
Section <a class="reference internal" href="lte-user.html#sec-network-attachment"><span class="std std-ref">Network Attachment</span></a> of the User Documentation.</p>
<p>When the cell passes all the above criteria, the cell is deemed as <em>suitable</em>.
Then UE camps to it (<cite>IDLE_CAMPED_NORMALLY</cite> state).</p>
<p>After this, upper layer may request UE to enter CONNECTED mode. Please refer to
section <a class="reference internal" href="#sec-rrc-connection-establishment"><span class="std std-ref">RRC connection establishment</span></a> for details on this.</p>
<p>On the other hand, when the cell does not pass the CSG criterion, then the cell
is labeled as <em>acceptable</em> (Section 10.1.1.1 <a class="reference internal" href="lte-references.html#ts36300" id="id99"><span>[TS36300]</span></a>). In this case, the RRC
entity will tell the PHY entity to synchronize to the second strongest cell and
repeat the initial cell selection procedure using that cell. As long as no
suitable cell is found, the UE will repeat these steps while avoiding cells that
have been identified as acceptable.</p>
</div>
</div>
<div class="section" id="radio-admission-control">
<h3>Radio Admission Control<a class="headerlink" href="#radio-admission-control" title="Permalink to this headline">¶</a></h3>
<p>Radio Admission Control is supported by having the eNB RRC
reply to an RRC CONNECTION REQUEST message sent by the UE with either
an RRC CONNECTION SETUP message or an RRC CONNECTION REJECT message,
depending on whether the new UE is to be admitted or not. In the
current implementation, the behavior is determined by the boolean attribute
<code class="docutils literal notranslate"><span class="pre">ns3::LteEnbRrc::AdmitRrcConnectionRequest</span></code>. There is currently no Radio Admission
Control algorithm that dynamically decides whether a new connection
shall be admitted or not.</p>
</div>
<div class="section" id="radio-bearer-configuration">
<h3>Radio Bearer Configuration<a class="headerlink" href="#radio-bearer-configuration" title="Permalink to this headline">¶</a></h3>
<p>Some implementation choices have been made in the RRC regarding the setup of radio bearers:</p>
<blockquote>
<div><ul class="simple">
<li><p>three Logical Channel Groups (out of four available) are configured
for uplink buffer status report purposes, according to the following policy:</p>
<ul>
<li><p>LCG 0 is for signaling radio bearers</p></li>
<li><p>LCG 1 is for GBR data radio bearers</p></li>
<li><p>LCG 2 is for Non-GBR data radio bearers</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="radio-link-failure">
<span id="sec-radio-link-failure"></span><h3>Radio Link Failure<a class="headerlink" href="#radio-link-failure" title="Permalink to this headline">¶</a></h3>
<p>In real LTE networks, Radio link failure (RLF) can happen due to several reasons.
It can be triggered if a UE is unable to decode PDCCH due to poor signal quality,
upon maximum RLC retransmissions, RACH problems and other reasons. 3GPP only
specifies guidelines to detect RLF at the UE side, in <a class="reference internal" href="lte-references.html#ts36331" id="id100"><span>[TS36331]</span></a> and <a class="reference internal" href="lte-references.html#ts36133" id="id101"><span>[TS36133]</span></a>.
On the other hand, the eNB implementation is expected to be vendor specific.
To implement the RLF functionality in ns-3, we have assumed the following
simplifications:</p>
<blockquote>
<div><ul class="simple">
<li><p>The RLF detection procedure at eNodeB is not implemented. <strong>Instead, a direct
function call by using the SAP between UE and eNB RRC (for both ideal and real
RRC) is used to notify the eNB about the RLF</strong>.</p></li>
<li><p>No RRC connection re-establishment procedure is implemented, thus, the UE
directly goes to the IDLE state upon RLF. This is in fact as per the standard
<a class="reference internal" href="lte-references.html#ts36331" id="id102"><span>[TS36331]</span></a> sec 5.3.11.3, since, at this stage the LTE module does not support
the Access Stratum (AS) security.</p></li>
</ul>
</div></blockquote>
<p>The above mentioned RLF specifications can be divided into the following two
categories:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>RLF detection</p></li>
<li><p>Actions upon RLF detection</p></li>
</ol>
</div></blockquote>
<p>In the following, we will explain the RLF implementation in context of these
two categories.</p>
<div class="section" id="rlf-detection-implementation">
<h4>RLF detection implementation<a class="headerlink" href="#rlf-detection-implementation" title="Permalink to this headline">¶</a></h4>
<p>The RLF detection at the UE is implemented as per <a class="reference internal" href="lte-references.html#ts36133" id="id103"><span>[TS36133]</span></a>, i.e., by monitoring
the radio link quality based on the reference signals (which in the simulation
is equivalent to the PDCCH) in the downlink. Thus, it is independent of the method
used for the downlink CQI computation, i.e., <em>Ctrl</em> method and <em>Mixed method</em>.
Moreover, when using FFR, especially for hard-FFR, and CQIs based on <em>Mixed method</em>,
UEs might experience relatively good performance and RLF simultaneously. This is
due to the fact that the interference in PDSCH is affected by the actual data
transmissions on the specific RBs and the power control. Therefore, UEs might
experience good SINR in PDSCH, while bad SINR in PDCCH channel. For more details
about these methods please refer to <a class="reference internal" href="#sec-cqi-feedback"><span class="std std-ref">CQI feedback</span></a>. Also, it does not
matter if the DL control error model is disabled, a UE can still detect the RLF
since the SINR based on the control channel is reported to the LteUePhy class,
using a callback hooked in LteHelper while installing a UE device.</p>
<p>The RLF detection starts once the RRC connection is established between UE and
eNodeB, i.e., UE is in “CONNECTED_NORMALLY” state; upon which the RLF parameters
are configured (see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoConfigureRadioLinkFailureDetection</span></code>). In real
networks, these parameters are transmitted by the eNB using IE UE-TimersAndConstants or
RLF-TimersAndConstants. However, for the sake of simplification, in the simulator
they are presented as the attributes of the LteUePhy and LteUeRrc classes.
Moreover, what concerns the carrier aggregation, i.e., when a UE is configured
with multiple component carriers, the RLF detection is only performed by the
primary component carrier, i.e. component carrier id 0
(see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoNotifyConnectionSuccessful</span></code>). In LteUePhy class, CQI
calculation is triggered for every downlink subframe received,
and the average SINR value is measured across all resource blocks. For the RLF
detection, these SINR values are averaged over a downlink frame and if the result
is less than a defined threshold Qout (default: -5dB), the frame cannot be decoded
(see``LteUePhy::RadioLinkFailureDetection``). The Qout threshold corresponds to 10%
block error rate (BLER) of a hypothetical PDCCH transmission taking into account
the PCFICH errors <a class="reference internal" href="lte-references.html#r4-081920" id="id104"><span>[R4-081920]</span></a> (also refer to
<a class="reference internal" href="#sec-control-channles-phy-error-model"><span class="std std-ref">Control Channels PHY Error Model</span></a>). Once, the UE is unable to decode
20 consecutive frames, i.e., the Qout evaluation period (200ms) is reached, an
out-of-sync indication is sent to the UE RRC layer (see <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoNotifyOutOfSync</span></code>).
Else, the counter for the unsuccessfully decoded frames is reset to zero. At the
LteUeRrc, when the number of consecutive out-of-sync indications matches with the
value of N310 parameter, the T310 timer is started and LteUePhy is notified to start
measuring for in-sync indications (see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoStartInSnycDetection</span></code>). We note
that, the UE RRC state is not changed till the expiration of T310 timer. If the
resultant SINR values averaged over a downlink frame is greater than a defined
threshold Qin (default: -3.8dB), the frame is considered to be successfully
decoded. Qin corresponds to 2% BLER <a class="reference internal" href="lte-references.html#r4-081920" id="id105"><span>[R4-081920]</span></a> of a hypothetical PDCCH transmission
taking into account the PCFICH errors. Once the UE is able to decode 10
consecutive frames, an in-sync indication is sent to the UE RRC layer
(see <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoNotifyInSync</span></code>). Else, the counter for the successfully decoded
frames is reset to zero. If prior to the T310 timer expiry, the number of
consecutive in-sync indications matches with N311 parameter of LteUeRRC, the UE
is considered back in-sync. At this stage, the related parameters are reset to
initiate the radio link failure detection from the beginning
(see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoConfigureRadioLinkFailureDetection</span></code>). On the other hand, If the
T310 timer expires, the UE considers that a RLF has occurred
(see <code class="docutils literal notranslate"><span class="pre">LteUeRrc::RadioLinkFailureDetected</span></code>).</p>
</div>
<div class="section" id="actions-upon-rlf">
<h4>Actions upon RLF<a class="headerlink" href="#actions-upon-rlf" title="Permalink to this headline">¶</a></h4>
<p>Once the T310 timer is expired, a UE is considered to be in RLF; upon which the
UE RRC:</p>
<blockquote>
<div><ul class="simple">
<li><p>Sends a request to the eNB RRC to remove the UE context</p></li>
<li><p>Moves to “CONNECTED_PHY_PROBLEM” state</p></li>
<li><p>Notifies the UE NAS layer about the release of RRC connection.</p></li>
</ul>
</div></blockquote>
<p>Then, after getting the notification from the UE RRC the NAS does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>Delete all the TFTs</p></li>
<li><p>Reset the bearer counter</p></li>
<li><p>Restore the bearer list, which is used to activate the bearers for the next
RRC connection. This restoration of the bearers is achieved by maintaining an
additional list, i.e., m_bearersToBeActivatedListForReconnection in EpcUeNas
class</p></li>
<li><p>Switch the NAS state to OFF by calling EpcUeNas::Disconnect</p></li>
<li><p>Tells the UE RRC to disconnect</p></li>
</ul>
</div></blockquote>
<p>The UE RRC, upon receiving the call to disconnect from the EpcUeNas class,
performs the action as specified by <a class="reference internal" href="lte-references.html#ts36331" id="id106"><span>[TS36331]</span></a> 5.3.11.3, and finally leaves the
connected state, i.e., its RRC state is changed from “CONNECTED_PHY_PROBLEM” to
“IDLE_START” to perform cell selection as shown in figures <a class="reference internal" href="#fig-lte-ue-rrc-states"><span class="std std-ref">UE RRC State Machine</span></a>
and <a class="reference internal" href="#fig-lte-ue-procedures-after-rlf"><span class="std std-ref">UE procedures after radio link failure</span></a>.</p>
<p>At this stage, the LTE module does not support the paging functionality, therefore,
to allow a UE to read SIB2 message after camping on a suitable cell after RLF, a
work around is used in <code class="docutils literal notranslate"><span class="pre">LteUeRrc::EvaluateCellForSelection</span></code> method. As per this
workaround, the UE RRC invokes the call to <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoConnect</span></code> method, which
enables the UE to switch its state from “IDLE_CAMPED_NORMALLY” to “IDLE_WAIT_SIB2”,
thus, allowing it to perform the random access.</p>
<div class="figure align-center" id="id175">
<span id="fig-lte-ue-procedures-after-rlf"></span><a class="reference internal image-reference" href="_images/lte-ue-procedures-after-rlf.png"><img alt="_images/lte-ue-procedures-after-rlf.png" src="_images/lte-ue-procedures-after-rlf.png" style="width: 1155.2px; height: 1625.4499999999998px;" /></a>
<p class="caption"><span class="caption-text">UE procedures after radio link failure</span><a class="headerlink" href="#id175" title="Permalink to this image">¶</a></p>
</div>
<p>The eNB RRC, after receiving the notification from the UE RRC starts the procedure
of UE context deletion, which also involves the deletion of the UE context removal
from the EPC <a class="reference internal" href="#fig-lte-ue-context-removal-from-epc"><span class="std std-ref">UE context removal from EPC</span></a> and the eNB stack
<a class="reference internal" href="#fig-lte-ue-context-removal-from-enb-stack"><span class="std std-ref">UE context removal from eNB stack</span></a>. We note that, the UE context
at the MME is not removed since, bearers are only added at the start of a
simulation in MME, and cannot be added again unless scheduled for addition
during a simulation.</p>
<div class="figure align-center" id="id176">
<span id="fig-lte-ue-context-removal-from-epc"></span><a class="reference internal image-reference" href="_images/lte-ue-context-removal-from-epc.png"><img alt="_images/lte-ue-context-removal-from-epc.png" src="_images/lte-ue-context-removal-from-epc.png" style="width: 1126.4px; height: 680.0px;" /></a>
<p class="caption"><span class="caption-text">UE context removal from EPC</span><a class="headerlink" href="#id176" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id177">
<span id="fig-lte-ue-context-removal-from-enb-stack"></span><a class="reference internal image-reference" href="_images/lte-ue-context-removal-from-enb-stack.png"><img alt="_images/lte-ue-context-removal-from-enb-stack.png" src="_images/lte-ue-context-removal-from-enb-stack.png" style="width: 1433.6000000000001px; height: 548.8000000000001px;" /></a>
<p class="caption"><span class="caption-text">UE context removal from eNB stack</span><a class="headerlink" href="#id177" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="ue-rrc-measurements-model">
<span id="sec-ue-measurements"></span><h3>UE RRC Measurements Model<a class="headerlink" href="#ue-rrc-measurements-model" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ue-rrc-measurements-support">
<h4>UE RRC measurements support<a class="headerlink" href="#ue-rrc-measurements-support" title="Permalink to this headline">¶</a></h4>
<p>The UE RRC entity provides support for UE measurements; in particular, it
implements the procedures described in Section 5.5 of <a class="reference internal" href="lte-references.html#ts36331" id="id107"><span>[TS36331]</span></a>, with the
following simplifying assumptions:</p>
<blockquote>
<div><ul class="simple">
<li><p>only E-UTRA intra-frequency measurements are supported, which implies:</p>
<ul>
<li><p>only one measurement object is used during the simulation;</p></li>
<li><p>measurement gaps are not needed to perform the measurements;</p></li>
<li><p>Event B1 and B2 are not implemented;</p></li>
</ul>
</li>
<li><p>only <cite>reportStrongestCells</cite> purpose is supported, while <cite>reportCGI</cite> and
<cite>reportStrongestCellsForSON</cite> purposes are not supported;</p></li>
<li><p><cite>s-Measure</cite> is not supported;</p></li>
<li><p>carrier aggregation is now supported in the LTE module
- Event A6 is not implemented;</p></li>
<li><p>speed dependent scaling of time-to-trigger (Section 5.5.6.2 of <a class="reference internal" href="lte-references.html#ts36331" id="id108"><span>[TS36331]</span></a>) is
not supported.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="overall-design">
<h4>Overall design<a class="headerlink" href="#overall-design" title="Permalink to this headline">¶</a></h4>
<p>The model is based on the concept of <em>UE measurements consumer</em>, which is an
entity that may request an eNodeB RRC entity to provide UE measurement reports.
Consumers are, for example, <a class="reference internal" href="#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a>, which compute
handover decision based on UE measurement reports. Test cases and user’s
programs may also become consumers. Figure <a class="reference internal" href="#fig-ue-meas-consumer"><span class="std std-ref">Relationship between UE measurements and its consumers</span></a> depicts
the relationship between these entities.</p>
<div class="figure align-center" id="id178">
<span id="fig-ue-meas-consumer"></span><a class="reference internal image-reference" href="_images/ue-meas-consumer.png"><img alt="_images/ue-meas-consumer.png" src="_images/ue-meas-consumer.png" style="width: 513.6px; height: 501.6px;" /></a>
<p class="caption"><span class="caption-text">Relationship between UE measurements and its consumers</span><a class="headerlink" href="#id178" title="Permalink to this image">¶</a></p>
</div>
<p>The whole UE measurements function at the RRC level is divided into 4 major
parts:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Measurement configuration (handled by <code class="docutils literal notranslate"><span class="pre">LteUeRrc::ApplyMeasConfig</span></code>)</p></li>
<li><p>Performing measurements (handled by <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoReportUeMeasurements</span></code>)</p></li>
<li><p>Measurement report triggering (handled by
<code class="docutils literal notranslate"><span class="pre">LteUeRrc::MeasurementReportTriggering</span></code>)</p></li>
<li><p>Measurement reporting (handled by <code class="docutils literal notranslate"><span class="pre">LteUeRrc::SendMeasurementReport</span></code>)</p></li>
</ol>
</div></blockquote>
<p>The following sections will describe each of the parts above.</p>
</div>
<div class="section" id="measurement-configuration">
<h4>Measurement configuration<a class="headerlink" href="#measurement-configuration" title="Permalink to this headline">¶</a></h4>
<p>An eNodeB RRC entity configures UE measurements by sending the configuration
parameters to the UE RRC entity. This set of parameters are defined within the
<code class="docutils literal notranslate"><span class="pre">MeasConfig</span></code> Information Element (IE) of the RRC Connection Reconfiguration
message (<a class="reference internal" href="#sec-rrc-connection-reconfiguration"><span class="std std-ref">RRC connection reconfiguration</span></a>).</p>
<p>The eNodeB RRC entity implements the configuration parameters and procedures
described in Section 5.5.2 of <a class="reference internal" href="lte-references.html#ts36331" id="id109"><span>[TS36331]</span></a>, with the following simplifying
assumption:</p>
<blockquote>
<div><ul class="simple">
<li><p>configuration (i.e. addition, modification, and removal) can only be done
before the simulation begins;</p></li>
<li><p>all UEs attached to the eNodeB will be configured the same way, i.e. there is
no support for configuring specific measurement for specific UE; and</p></li>
<li><p>it is assumed that there is a one-to-one mapping between the PCI and the
E-UTRAN Global Cell Identifier (EGCI). This is consistent with the PCI
modeling assumptions described in <a class="reference internal" href="#sec-phy-ue-measurements"><span class="std std-ref">UE PHY Measurements Model</span></a>.</p></li>
</ul>
</div></blockquote>
<p>The eNodeB RRC instance here acts as an intermediary between the consumers and
the attached UEs. At the beginning of simulation, each consumer provides the
eNodeB RRC instance with the UE measurements configuration that it requires.
After that, the eNodeB RRC distributes the configuration to attached UEs.</p>
<p>Users may customize the measurement configuration using several methods. Please
refer to Section <a class="reference internal" href="lte-user.html#sec-configure-ue-measurements"><span class="std std-ref">Configure UE measurements</span></a> of the User Documentation
for the description of these methods.</p>
</div>
<div class="section" id="performing-measurements">
<span id="sec-performing-measurements"></span><h4>Performing measurements<a class="headerlink" href="#performing-measurements" title="Permalink to this headline">¶</a></h4>
<p>UE RRC receives both RSRP and RSRQ measurements on periodical basis from UE PHY,
as described in <a class="reference internal" href="#sec-phy-ue-measurements"><span class="std std-ref">UE PHY Measurements Model</span></a>. <em>Layer 3 filtering</em> will be
applied to these received measurements. The implementation of the filtering
follows Section 5.5.3.2 of <a class="reference internal" href="lte-references.html#ts36331" id="id110"><span>[TS36331]</span></a>:</p>
<div class="math">
<p><img src="_images/math/29c7857de953ba4fff359693c5f260c5af58a10d.png" alt="F_n = (1 - a) \times F_{n-1} + a \times M_n"/></p>
</div><p>where:</p>
<blockquote>
<div><ul class="simple">
<li><p><img class="math" src="_images/math/395593ebf06d44ee27b8d1fcf4974e7a387ee3bb.png" alt="M_n"/> is the latest received measurement result from the physical
layer;</p></li>
<li><p><img class="math" src="_images/math/7e5062a83a78f9dbf5931d241fe87ac860b6c506.png" alt="F_n"/> is the updated filtered measurement result;</p></li>
<li><p><img class="math" src="_images/math/dea2d90efaa338db9395aae41c80c6b618fca892.png" alt="F_{n-1}"/> is the old filtered measurement result, where
<img class="math" src="_images/math/b4a384ad79cbf7a46d3a613880c6946d82aac705.png" alt="F_0 = M_1"/> (i.e. the first measurement is not filtered); and</p></li>
<li><p><img class="math" src="_images/math/c71220e849a8cd1afd8c6338c7afaaf56ac6da14.png" alt="a = (\frac{1}{2})^{\frac{k}{4}}"/>, where <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is the configurable
<cite>filterCoefficent</cite> provided by the <code class="docutils literal notranslate"><span class="pre">QuantityConfig</span></code>;</p></li>
</ul>
</div></blockquote>
<p><img class="math" src="_images/math/c897d6ff926999a7065a946e221c87cc1690cf6c.png" alt="k = 4"/> is the default value, but can be configured by setting the
<cite>RsrpFilterCoefficient</cite> and <cite>RsrqFilterCoefficient</cite> attributes in
<code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code>.</p>
<p>Therefore <img class="math" src="_images/math/8b667b0c1fb52d7f5bfb2974ed74774496b5d97e.png" alt="k = 0"/> will disable Layer 3 filtering. On the other hand, past
measurements can be granted more influence on the filtering results by using
larger value of <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>.</p>
</div>
<div class="section" id="measurement-reporting-triggering">
<h4>Measurement reporting triggering<a class="headerlink" href="#measurement-reporting-triggering" title="Permalink to this headline">¶</a></h4>
<p>In this part, UE RRC will go through the list of active measurement
configuration and check whether the triggering condition is fulfilled in
accordance with Section 5.5.4 of <a class="reference internal" href="lte-references.html#ts36331" id="id111"><span>[TS36331]</span></a>. When at least one triggering
condition from all the active measurement configuration is fulfilled, the
measurement reporting procedure (described in the next subsection) will be
initiated.</p>
<p>3GPP defines two kinds of <cite>triggerType</cite>: <em>periodical</em> and <em>event-based</em>. At the
moment, only event-based criterion is supported. There are various events that
can be selected, which are briefly described in the table below:</p>
<table class="docutils align-default" id="id179">
<caption><span class="caption-text">List of supported event-based triggering criteria</span><a class="headerlink" href="#id179" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Event A1</p></td>
<td><p>Serving cell becomes better than <cite>threshold</cite></p></td>
</tr>
<tr class="row-odd"><td><p>Event A2</p></td>
<td><p>Serving cell becomes worse than <cite>threshold</cite></p></td>
</tr>
<tr class="row-even"><td><p>Event A3</p></td>
<td><p>Neighbour becomes <cite>offset</cite> dB better than serving cell</p></td>
</tr>
<tr class="row-odd"><td><p>Event A4</p></td>
<td><p>Neighbour becomes better than <cite>threshold</cite></p></td>
</tr>
<tr class="row-even"><td><p>Event A5</p></td>
<td><p>Serving becomes worse than <cite>threshold1</cite>
<em>AND</em> neighbour becomes better than <cite>threshold2</cite></p></td>
</tr>
</tbody>
</table>
<p>Two main conditions to be checked in an event-based trigger are the <em>entering
condition</em> and the <em>leaving condition</em>. More details on these two can be found
in Section 5.5.4 of <a class="reference internal" href="lte-references.html#ts36331" id="id112"><span>[TS36331]</span></a>.</p>
<p>An event-based trigger can be further configured by introducing hysteresis and
time-to-trigger. <em>Hysteresis</em> (<img class="math" src="_images/math/ebdf68e125df3458bab1f50f27f37bff5d30b47d.png" alt="Hys"/>) defines the distance between the
entering and leaving conditions in dB. Similarly, <em>time-to-trigger</em> introduces
delay to both entering and leaving conditions, but as a unit of time.</p>
<p>The <em>periodical</em> type of reporting trigger is not supported, but its behavior
can be easily obtained by using an event-based trigger. This can be done by
configuring the measurement in such a way that the entering condition is always
fulfilled, for example, by setting the threshold of Event A1 to zero (the
minimum level). As a result, the measurement reports will always be triggered
at every certain interval, as determined by the <cite>reportInterval</cite> field within
<code class="docutils literal notranslate"><span class="pre">LteRrcSap::ReportConfigEutra</span></code>, therefore producing the same behaviour as
periodical reporting.</p>
<p>As a limitation with respect to 3GPP specifications, the current model does not
support any cell-specific configuration. These configuration parameters are
defined in measurement object. As a consequence, incorporating a list of black
cells into the triggering process is not supported. Moreover, cell-specific
offset (i.e., <img class="math" src="_images/math/8a0700d16533af8a00972b62b90c339a1903cc30.png" alt="O_{cn}"/> and <img class="math" src="_images/math/f0ecb6d98e862c561316e94841668e6b80181806.png" alt="O_{cp}"/> in Event A3, A4, and A5) are not
supported as well. The value equal to zero is always assumed in place of them.</p>
</div>
<div class="section" id="measurement-reporting">
<h4>Measurement reporting<a class="headerlink" href="#measurement-reporting" title="Permalink to this headline">¶</a></h4>
<p>This part handles the submission of measurement report from the UE RRC entity
to the serving eNodeB entity via RRC protocol. Several simplifying assumptions
have been adopted:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>reportAmount</cite> is <em>not</em> applicable (i.e. always assumed to be infinite);</p></li>
<li><p>in measurement reports, the <cite>reportQuantity</cite> is always assumed to be <cite>BOTH</cite>,
i.e., both RSRP and RSRQ are always reported, regardless of the
<cite>triggerQuantity</cite>.</p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="handover">
<span id="sec-handover"></span><h3>Handover<a class="headerlink" href="#handover" title="Permalink to this headline">¶</a></h3>
<p>The RRC model supports UE mobility in CONNECTED mode by invoking the X2-based
handover procedure. The model is intra-EUTRAN and intra-frequency, as based on
Section 10.1.2.1 of <a class="reference internal" href="lte-references.html#ts36300" id="id113"><span>[TS36300]</span></a>.</p>
<p>This section focuses on the process of triggering a handover. The handover
execution procedure itself is covered in Section <a class="reference internal" href="#sec-x2"><span class="std std-ref">X2</span></a>.</p>
<p>There are two ways to trigger the handover procedure:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>explicitly</em> (or manually) triggered by the simulation program by scheduling
an execution of the method <code class="docutils literal notranslate"><span class="pre">LteEnbRrc::SendHandoverRequest</span></code>; or</p></li>
<li><p><em>automatically</em> triggered by the eNodeB RRC entity based on UE measurements
and according to the selected handover algorithm.</p></li>
</ul>
</div></blockquote>
<p>Section <a class="reference internal" href="lte-user.html#sec-x2-based-handover"><span class="std std-ref">X2-based handover</span></a> of the User Documentation provides some
examples on using both explicit and automatic handover triggers in simulation.
The next subsection will take a closer look on the automatic method, by
describing the design aspects of the handover algorithm interface and the
available handover algorithms.</p>
<div class="section" id="handover-algorithm">
<span id="sec-handover-algorithm"></span><h4>Handover algorithm<a class="headerlink" href="#handover-algorithm" title="Permalink to this headline">¶</a></h4>
<p>Handover in 3GPP LTE has the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>UE-assisted</dt><dd><p>The UE provides input to the network in the form of measurement reports.
This is handled by the <a class="reference internal" href="#sec-ue-measurements"><span class="std std-ref">UE RRC Measurements Model</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Network-controlled</dt><dd><p>The network (i.e. the source eNodeB and the target eNodeB) decides when to
trigger the handover and oversees its execution.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The <em>handover algorithm</em> operates at the source eNodeB and is responsible in
making handover decisions in an “automatic” manner. It interacts with an eNodeB
RRC instance via the <em>Handover Management SAP</em> interface. These relationships
are illustrated in Figure <a class="reference internal" href="#fig-ue-meas-consumer"><span class="std std-ref">Relationship between UE measurements and its consumers</span></a> from the previous section.</p>
<p>The handover algorithm interface consists of the following methods:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForHandover</span></code></dt><dd><p>(Handover Algorithm -&gt; eNodeB RRC) Used by the handover algorithm to
request measurement reports from the eNodeB RRC entity, by passing the
desired reporting configuration. The configuration will be applied to
all future attached UEs.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code></dt><dd><p>(eNodeB RRC -&gt; Handover Algorithm) Based on the UE measurements configured
earlier in <code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForHandover</span></code>, UE may submit measurement
reports to the eNodeB. The eNodeB RRC entity uses the <code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code>
interface to forward these measurement reports to the handover algorithm.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">TriggerHandover</span></code></dt><dd><p>(Handover Algorithm -&gt; eNodeB RRC) After examining the measurement reports
(but not necessarily), the handover algorithm may declare a handover. This
method is used to notify the eNodeB RRC entity about this decision, which
will then proceed to commence the handover procedure.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>One note for the <code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForHandover</span></code>. The method will return
the <code class="docutils literal notranslate"><span class="pre">measId</span></code> (measurement identity) of the newly created measurement
configuration. Typically a handover algorithm would store this unique number. It
may be useful in the <code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code> method, for example when more than one
configuration has been requested and the handover algorithm needs to
differentiate incoming reports based on the configuration that triggered them.</p>
<p>A handover algorithm is implemented by writing a subclass of the
<code class="docutils literal notranslate"><span class="pre">LteHandoverAlgorithm</span></code> abstract superclass and implementing each of the above
mentioned SAP interface methods. Users may develop their own handover algorithm
this way, and then use it in any simulation by following the steps outlined in
Section <a class="reference internal" href="lte-user.html#sec-x2-based-handover"><span class="std std-ref">X2-based handover</span></a> of the User Documentation.</p>
<p>Alternatively, users may choose to use one of the 3 built-in handover algorithms
provided by the LTE module: no-op, A2-A4-RSRQ, and strongest cell handover
algorithm. They are ready to be used in simulations or can be taken as an
example of implementing a handover algorithm. Each of these built-in algorithms
is covered in each of the following subsections.</p>
</div>
<div class="section" id="no-op-handover-algorithm">
<h4>No-op handover algorithm<a class="headerlink" href="#no-op-handover-algorithm" title="Permalink to this headline">¶</a></h4>
<p>The <em>no-op handover algorithm</em> (<code class="docutils literal notranslate"><span class="pre">NoOpHandoverAlgorithm</span></code> class) is the simplest
possible implementation of handover algorithm. It basically does nothing, i.e.,
does not call any of the Handover Management SAP interface methods. Users may
choose this handover algorithm if they wish to disable automatic handover
trigger in their simulation.</p>
</div>
<div class="section" id="a2-a4-rsrq-handover-algorithm">
<h4>A2-A4-RSRQ handover algorithm<a class="headerlink" href="#a2-a4-rsrq-handover-algorithm" title="Permalink to this headline">¶</a></h4>
<p>The <em>A2-A4-RSRQ handover algorithm</em> provides the functionality of the default
handover algorithm originally included in LENA M6 (ns-3.18), ported to the
Handover Management SAP interface as the <code class="docutils literal notranslate"><span class="pre">A2A4RsrqHandoverAlgorithm</span></code> class.</p>
<p>As the name implies, the algorithm utilizes the Reference Signal Received
Quality (RSRQ) measurements acquired from Event A2 and Event A4. Thus, the
algorithm will add 2 measurement configuration to the corresponding eNodeB RRC
instance. Their intended use are described as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>Event A2</em> (serving cell’s RSRQ becomes worse than <cite>threshold</cite>) is leveraged
to indicate that the UE is experiencing poor signal quality and may benefit
from a handover.</p></li>
<li><p><em>Event A4</em> (neighbour cell’s RSRQ becomes better than <cite>threshold</cite>) is used
to detect neighbouring cells and acquire their corresponding RSRQ from every
attached UE, which are then stored internally by the algorithm. By default,
the algorithm configures Event A4 with a very low threshold, so that the
trigger criteria are always true.</p></li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-lte-legacy-handover-algorithm"><span class="std std-ref">A2-A4-RSRQ handover algorithm</span></a> below summarizes this procedure.</p>
<div class="figure align-center" id="id180">
<span id="fig-lte-legacy-handover-algorithm"></span><a class="reference internal image-reference" href="_images/lte-legacy-handover-algorithm.png"><img alt="_images/lte-legacy-handover-algorithm.png" src="_images/lte-legacy-handover-algorithm.png" style="width: 655.1999999999999px; height: 574.6999999999999px;" /></a>
<p class="caption"><span class="caption-text">A2-A4-RSRQ handover algorithm</span><a class="headerlink" href="#id180" title="Permalink to this image">¶</a></p>
</div>
<p>Two attributes can be set to tune the algorithm behaviour:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ServingCellThreshold</span></code></dt><dd><p>The <cite>threshold</cite> for Event A2, i.e. a UE must have an RSRQ lower than this
threshold to be considered for a handover.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NeighbourCellOffset</span></code></dt><dd><p>The <cite>offset</cite> that aims to ensure that the UE would receive better signal
quality after the handover. A neighbouring cell is considered as a target
cell for the handover only if its RSRQ is higher than the serving cell’s
RSRQ by the amount of this <cite>offset</cite>.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The value of both attributes are expressed as RSRQ range (Section 9.1.7 of
<a class="reference internal" href="lte-references.html#ts36133" id="id114"><span>[TS36133]</span></a>), which is an integer between 0 and 34, with 0 as the lowest RSRQ.</p>
</div>
<div class="section" id="strongest-cell-handover-algorithm">
<h4>Strongest cell handover algorithm<a class="headerlink" href="#strongest-cell-handover-algorithm" title="Permalink to this headline">¶</a></h4>
<p>The <em>strongest cell handover algorithm</em>, or also sometimes known as the
<em>traditional power budget (PBGT) algorithm</em>, is developed using <a class="reference internal" href="lte-references.html#dimou2009" id="id115"><span>[Dimou2009]</span></a> as
reference. The idea is to provide each UE with the best possible Reference
Signal Received Power (RSRP). This is done by performing a handover as soon as
a better cell (i.e. with stronger RSRP) is detected.</p>
<p><em>Event A3</em> (neighbour cell’s RSRP becomes better than serving cell’s RSRP) is
chosen to realize this concept. The <code class="docutils literal notranslate"><span class="pre">A3RsrpHandoverAlgorithm</span></code> class is the
result of the implementation. Handover is triggered for the UE to the best cell
in the measurement report.</p>
<p>A simulation which uses this algorithm is usually more vulnerable to ping-pong
handover (consecutive handover to the previous source eNodeB within short period
of time), especially when the <a class="reference internal" href="#sec-fading-model"><span class="std std-ref">Fading Model</span></a> is enabled. This problem
is typically tackled by introducing a certain delay to the handover. The
algorithm does this by including hysteresis and time-to-trigger parameters
(Section 6.3.5 of <a class="reference internal" href="lte-references.html#ts36331" id="id116"><span>[TS36331]</span></a>) to the UE measurements configuration.</p>
<p><em>Hysteresis</em> (a.k.a. handover margin) delays the handover in regard of RSRP. The
value is expressed in dB, ranges between 0 to 15 dB, and have a 0.5 dB accuracy,
e.g., an input value of 2.7 dB is rounded to 2.5 dB.</p>
<p>On the other hand, <em>time-to-trigger</em> delays the handover in regard of time. 3GPP
defines 16 valid values for time-to-trigger (all in milliseconds): 0, 40, 64,
80, 100, 128, 160, 256, 320, 480, 512, 640, 1024, 1280, 2560, and 5120.</p>
<p>The difference between hysteresis and time-to-trigger is illustrated in Figure
<a class="reference internal" href="#fig-lte-strongest-cell-handover-algorithm"><span class="std std-ref">Effect of hysteresis and time-to-trigger in strongest cell handover algorithm</span></a> below, which is taken from the
<cite>lena-x2-handover-measures</cite> example. It depicts the perceived RSRP of serving
cell and a neighbouring cell by a UE which moves pass the border of the cells.</p>
<div class="figure align-center" id="id181">
<span id="fig-lte-strongest-cell-handover-algorithm"></span><img alt="_images/lte-strongest-cell-handover-algorithm.png" src="_images/lte-strongest-cell-handover-algorithm.png" />
<p class="caption"><span class="caption-text">Effect of hysteresis and time-to-trigger in strongest cell handover algorithm</span><a class="headerlink" href="#id181" title="Permalink to this image">¶</a></p>
</div>
<p>By default, the algorithm uses a hysteresis of 3.0 dB and time-to-trigger of
256 ms. These values can be tuned through the <code class="docutils literal notranslate"><span class="pre">Hysteresis</span></code> and
<code class="docutils literal notranslate"><span class="pre">TimeToTrigger</span></code> attributes of the <code class="docutils literal notranslate"><span class="pre">A3RsrpHandoverAlgorithm</span></code> class.</p>
</div>
</div>
<div class="section" id="neighbour-relation">
<h3>Neighbour Relation<a class="headerlink" href="#neighbour-relation" title="Permalink to this headline">¶</a></h3>
<p>LTE module supports a simplified <em>Automatic Neighbour Relation</em> (ANR) function.
This is handled by the <code class="docutils literal notranslate"><span class="pre">LteAnr</span></code> class, which interacts with an eNodeB RRC
instance through the ANR SAP interface.</p>
<div class="section" id="neighbour-relation-table">
<h4>Neighbour Relation Table<a class="headerlink" href="#neighbour-relation-table" title="Permalink to this headline">¶</a></h4>
<p>The ANR holds a <em>Neighbour Relation Table</em> (NRT), similar to the description in
Section 22.3.2a of <a class="reference internal" href="lte-references.html#ts36300" id="id117"><span>[TS36300]</span></a>. Each entry in the table is called a <em>Neighbour
Relation</em> (NR) and represents a detected neighbouring cell, which contains the
following boolean fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><cite>No Remove</cite></dt><dd><p>Indicates that the NR shall <em>not</em> be removed from the NRT. This is <cite>true</cite>
by default for user-provided NR and <cite>false</cite> otherwise.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>No X2</cite></dt><dd><p>Indicates that the NR shall <em>not</em> use an X2 interface in order to initiate
procedures towards the eNodeB parenting the target cell. This is <cite>false</cite> by
default for user-provided NR, and <cite>true</cite> otherwise.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>No HO</cite></dt><dd><p>Indicates that the NR shall <em>not</em> be used by the eNodeB for handover
reasons. This is <cite>true</cite> in most cases, except when the NR is both
user-provided and network-detected.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Each NR entry may have at least one of the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>User-provided</dt><dd><p>This type of NR is created as instructed by the simulation user. For
example, a NR is created automatically upon a user-initiated establishment
of X2 connection between 2 eNodeBs, e.g. as described in Section
<a class="reference internal" href="lte-user.html#sec-x2-based-handover"><span class="std std-ref">X2-based handover</span></a>. Another way to create a user-provided NR is
to call the <code class="docutils literal notranslate"><span class="pre">AddNeighbourRelation</span></code> function explicitly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Network-detected</dt><dd><p>This type of NR is automatically created during the simulation as a result
of the discovery of a nearby cell.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>In order to automatically create network-detected NR, ANR utilizes UE
measurements. In other words, ANR is a consumer of UE measurements, as depicted
in Figure <a class="reference internal" href="#fig-ue-meas-consumer"><span class="std std-ref">Relationship between UE measurements and its consumers</span></a>. RSRQ and Event A4 (neighbour becomes
better than <cite>threshold</cite>) are used for the reporting configuration. The default
Event A4 <cite>threshold</cite> is set to the lowest possible, i.e., maximum detection
capability, but can be changed by setting the <code class="docutils literal notranslate"><span class="pre">Threshold</span></code> attribute of
<code class="docutils literal notranslate"><span class="pre">LteAnr</span></code> class. Note that the A2-A4-RSRQ handover algorithm also utilizes a
similar reporting configuration. Despite the similarity, when both ANR and this
handover algorithm are active in the eNodeB, they use separate reporting
configuration.</p>
<p>Also note that automatic setup of X2 interface is not supported. This is the
reason why the <cite>No X2</cite> and <cite>No HO</cite> fields are true in a network-detected but not
user-detected NR.</p>
</div>
<div class="section" id="role-of-anr-in-simulation">
<h4>Role of ANR in Simulation<a class="headerlink" href="#role-of-anr-in-simulation" title="Permalink to this headline">¶</a></h4>
<p>The ANR SAP interface provides the means of communication between ANR and eNodeB
RRC. Some interface functions are used by eNodeB RRC to interact with the NRT,
as shown below:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddNeighbourRelation</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Add a new user-provided NR entry into the NRT.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetNoRemove</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Get the value of <cite>No Remove</cite> field of an NR entry of
the given cell ID.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetNoHo</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Get the value of <cite>No HO</cite> field of an NR entry of
the given cell ID.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetNoX2</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Get the value of <cite>No X2</cite> field of an NR entry of
the given cell ID.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Other interface functions exist to support the role of ANR as a UE measurements
consumer, as listed below:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForAnr</span></code></dt><dd><p>(ANR -&gt; eNodeB RRC) Used by the ANR to request measurement reports from the
eNodeB RRC entity, by passing the desired reporting configuration. The
configuration will be applied to all future attached UEs.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Based on the UE measurements configured earlier in
<code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForAnr</span></code>, UE may submit measurement reports to the
eNodeB. The eNodeB RRC entity uses the <code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code> interface to
forward these measurement reports to the ANR.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Please refer to the corresponding API documentation for <code class="docutils literal notranslate"><span class="pre">LteAnrSap</span></code> class for
more details on the usage and the required parameters.</p>
<p>The ANR is utilized by the eNodeB RRC instance as a data structure to keep track
of the situation of nearby neighbouring cells. The ANR also helps the eNodeB RRC
instance to determine whether it is possible to execute a handover procedure to
a neighbouring cell. This is realized by the fact that eNodeB RRC will only
allow a handover procedure to happen if the NR entry of the target cell has both
<cite>No HO</cite> and <cite>No X2</cite> fields set to <cite>false</cite>.</p>
<p>ANR is enabled by default in every eNodeB instance in the simulation. It can be
disabled by setting the <code class="docutils literal notranslate"><span class="pre">AnrEnabled</span></code> attribute in <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> class to
<cite>false</cite>.</p>
</div>
</div>
<div class="section" id="rrc-sequence-diagrams">
<h3>RRC sequence diagrams<a class="headerlink" href="#rrc-sequence-diagrams" title="Permalink to this headline">¶</a></h3>
<p>In this section we provide some sequence diagrams that explain the
most important RRC procedures being modeled.</p>
<div class="section" id="rrc-connection-establishment">
<span id="sec-rrc-connection-establishment"></span><h4>RRC connection establishment<a class="headerlink" href="#rrc-connection-establishment" title="Permalink to this headline">¶</a></h4>
<p>Figure <a class="reference internal" href="#fig-rrc-connection-establishment"><span class="std std-ref">Sequence diagram of the RRC Connection Establishment procedure</span></a> shows how the RRC
Connection Establishment procedure is modeled, highlighting the role
of the RRC layer at both the UE and the eNB, as well as the
interaction with the other layers.</p>
<div class="figure align-center" id="id182">
<span id="fig-rrc-connection-establishment"></span><img alt="_images/rrc-connection-establishment.png" src="_images/rrc-connection-establishment.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the RRC Connection Establishment procedure</span><a class="headerlink" href="#id182" title="Permalink to this image">¶</a></p>
</div>
<p>There are several timeouts related to this procedure, which are listed in the
following Table <a class="reference internal" href="#tab-rrc-connection-establishment-timer"><span class="std std-ref">Timers in RRC connection establishment procedure</span></a>. If any of these
timers expired, the RRC connection establishment procedure is terminated in
failure. At the UE side, if T300 timer has expired a consecutive
<em>connEstFailCount</em> times on the same cell it performs the cell selection again
<a class="reference internal" href="lte-references.html#ts36331" id="id118"><span>[TS36331]</span></a>. Else, the upper layer (UE NAS) will immediately attempt to retry
the procedure.</p>
<span id="tab-rrc-connection-establishment-timer"></span><table class="docutils align-default" id="id183">
<caption><span class="caption-text">Timers in RRC connection establishment procedure</span><a class="headerlink" href="#id183" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>Timer
starts</p></th>
<th class="head"><p>Timer
stops</p></th>
<th class="head"><p>Default
duration</p></th>
<th class="head"><p>When timer
expired</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Connection
request
timeout</p></td>
<td><p>eNodeB
RRC</p></td>
<td><p>New UE
context
added</p></td>
<td><p>Receive RRC
CONNECTION
REQUEST</p></td>
<td><p>15 ms
(Max)</p></td>
<td><p>Remove UE
context</p></td>
</tr>
<tr class="row-odd"><td><p>Connection
timeout
(T300
timer)</p></td>
<td><p>UE RRC</p></td>
<td><p>Send RRC
CONNECTION
REQUEST</p></td>
<td><p>Receive RRC
CONNECTION
SETUP or
REJECT</p></td>
<td><p>100 ms</p></td>
<td><p>Reset UE
MAC</p></td>
</tr>
<tr class="row-even"><td><p>Connection
setup
timeout</p></td>
<td><p>eNodeB
RRC</p></td>
<td><p>Send RRC
CONNECTION
SETUP</p></td>
<td><p>Receive RRC
CONNECTION
SETUP
COMPLETE</p></td>
<td><p>100 ms</p></td>
<td><p>Remove UE
context</p></td>
</tr>
<tr class="row-odd"><td><p>Connection
rejected
timeout</p></td>
<td><p>eNodeB
RRC</p></td>
<td><p>Send RRC
CONNECTION
REJECT</p></td>
<td><p>Never</p></td>
<td><p>30 ms</p></td>
<td><p>Remove UE
context</p></td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> The value of connection request timeout timer at the eNB RRC should
not be higher than the T300 timer at UE RRC. It is to make sure that the UE
context is already removed at the eNB, once the UE will perform cell selection
upon reaching the <em>connEstFailCount</em> count. Moreover, at the time of writing
this document the <a class="reference internal" href="#sec-cell-selection-evaluation"><span class="std std-ref">Cell Selection Evaluation</span></a> does not include
the <img class="math" src="_images/math/2913a255eab003c033596cd80ae2eba017abdb1c.png" alt="Qoffset_{temp}"/> parameter, thus, it is not applied while selecting
the same cell again.</p>
<span id="tab-rrc-connection-establishment-counter"></span><table class="docutils align-default" id="id184">
<caption><span class="caption-text">Counters in RRC connection establishment procedure</span><a class="headerlink" href="#id184" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 9%" />
<col style="width: 15%" />
<col style="width: 9%" />
<col style="width: 8%" />
<col style="width: 26%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>Msg</p></th>
<th class="head"><p>Monitored
by</p></th>
<th class="head"><p>Default
value</p></th>
<th class="head"><p>Limit not reached</p></th>
<th class="head"><p>Limit reached</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ConnEstFailCount</p></td>
<td><p>eNB MAC</p></td>
<td><p>RachConfigCommon
in SIB2, HO REQ
and HO Ack</p></td>
<td><p>UE RRC</p></td>
<td><p>1</p></td>
<td><p>Increment the local counter.
Invalided the prev SIB2 msg,
and try random access
with the same cell.</p></td>
<td><p>Reset the local
counter and perform
cell selection.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rrc-connection-reconfiguration">
<span id="sec-rrc-connection-reconfiguration"></span><h4>RRC connection reconfiguration<a class="headerlink" href="#rrc-connection-reconfiguration" title="Permalink to this headline">¶</a></h4>
<p>Figure <a class="reference internal" href="#fig-rrc-connection-reconfiguration"><span class="std std-ref">Sequence diagram of the RRC Connection Reconfiguration procedure</span></a> shows how the RRC
Connection Reconfiguration procedure is modeled for the case where
MobilityControlInfo is not provided, i.e., handover is not
performed.</p>
<div class="figure align-center" id="id185">
<span id="fig-rrc-connection-reconfiguration"></span><img alt="_images/rrc-connection-reconfiguration.png" src="_images/rrc-connection-reconfiguration.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the RRC Connection Reconfiguration procedure</span><a class="headerlink" href="#id185" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-rrc-connection-reconf-handover"><span class="std std-ref">Sequence diagram of the RRC Connection Reconfiguration procedure
for the handover case</span></a> shows how the RRC
Connection Reconfiguration procedure is modeled for the case where
MobilityControlInfo is provided, i.e., handover is to be performed.
As specified in <a class="reference internal" href="lte-references.html#ts36331" id="id119"><span>[TS36331]</span></a>, <em>After receiving the handover message,
the UE attempts to access the target cell at the first available RACH
occasion according to Random Access resource selection defined in [TS36321]_,
i.e. the handover is asynchronous. Consequently, when
allocating a dedicated preamble for the random access in the target
cell, E-UTRA shall ensure it is available from the first RACH occasion
the UE may use. Upon successful completion of the handover, the UE
sends a message used to confirm the handover.</em> Note that the random
access procedure in this case is non-contention based, hence in a real
LTE system it differs slightly from the one used in RRC connection
established. Also note that the RA Preamble ID is signaled via the
Handover Command included in the X2 Handover Request ACK message sent
from the target eNB to the source eNB; in particular, the preamble is
included in the RACH-ConfigDedicated IE which is part of
MobilityControlInfo.</p>
<div class="figure align-center" id="id186">
<span id="fig-rrc-connection-reconf-handover"></span><img alt="_images/rrc-connection-reconfiguration-handover.png" src="_images/rrc-connection-reconfiguration-handover.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the RRC Connection Reconfiguration procedure
for the handover case</span><a class="headerlink" href="#id186" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="rrc-protocol-models">
<span id="sec-rrc-protocol-models"></span><h3>RRC protocol models<a class="headerlink" href="#rrc-protocol-models" title="Permalink to this headline">¶</a></h3>
<p>As previously anticipated, we provide two different models  for the
transmission and reception of RRC messages: <em>Ideal</em>
and <em>Real</em>. Each of them is described in one of the following
subsections.</p>
<div class="section" id="ideal-rrc-protocol-model">
<h4>Ideal RRC protocol model<a class="headerlink" href="#ideal-rrc-protocol-model" title="Permalink to this headline">¶</a></h4>
<p>According to this model, implemented in the classes and <cite>LteUeRrcProtocolIdeal</cite> and
<cite>LteEnbRrcProtocolIdeal</cite>, all RRC messages and information elements
are transmitted between the eNB and the UE in an ideal fashion,
without consuming radio resources and without errors. From an
implementation point of view, this is achieved by passing the RRC data
structure directly between the UE and eNB RRC entities, without
involving the lower layers (PDCP, RLC, MAC, scheduler).</p>
</div>
<div class="section" id="real-rrc-protocol-model">
<h4>Real RRC protocol model<a class="headerlink" href="#real-rrc-protocol-model" title="Permalink to this headline">¶</a></h4>
<p>This model is implemented in the classes <cite>LteUeRrcProtocolReal</cite> and
<cite>LteEnbRrcProtocolReal</cite> and aims at modeling the transmission of RRC
PDUs as commonly performed in real LTE systems. In particular:</p>
<blockquote>
<div><ul class="simple">
<li><p>for every RRC message being sent, a real RRC PDUs is created
following the ASN.1 encoding of RRC PDUs and information elements (IEs)
specified in <a class="reference internal" href="lte-references.html#ts36331" id="id120"><span>[TS36331]</span></a>. Some simplification are made with respect
to the IEs included in the PDU, i.e., only those IEs that are
useful for simulation purposes are included. For a detailed list,
please see the IEs defined in <cite>lte-rrc-sap.h</cite> and compare with
<a class="reference internal" href="lte-references.html#ts36331" id="id121"><span>[TS36331]</span></a>.</p></li>
<li><p>the encoded RRC PDUs are sent on Signaling Radio Bearers and are
subject to the same transmission modeling used for data
communications, thus including scheduling, radio resource
consumption, channel errors, delays, retransmissions, etc.</p></li>
</ul>
</div></blockquote>
<div class="section" id="signaling-radio-bearer-model">
<h5>Signaling Radio Bearer model<a class="headerlink" href="#signaling-radio-bearer-model" title="Permalink to this headline">¶</a></h5>
<p>We now describe the Signaling Radio Bearer model that is used for the
<em>Real</em> RRC protocol model.</p>
<blockquote>
<div><ul>
<li><p><strong>SRB0</strong> messages (over CCCH):</p>
<ul class="simple">
<li><p><strong>RrcConnectionRequest</strong>: in real LTE systems, this is an RLC TM
SDU sent over resources specified in the UL Grant in the RAR (not
in UL DCIs); the reason is that C-RNTI is not known yet at this
stage. In the simulator, this is modeled as a real RLC TM RLC PDU
whose UL resources are allocated by the scheduler upon call to
SCHED_DL_RACH_INFO_REQ.</p></li>
<li><p><strong>RrcConnectionSetup</strong>: in the simulator this is implemented as in
real LTE systems, i.e., with an RLC TM SDU sent over resources
indicated by a regular UL DCI, allocated with
SCHED_DL_RLC_BUFFER_REQ triggered by the RLC TM instance that is
mapped to LCID 0 (the CCCH).</p></li>
</ul>
</li>
<li><p><strong>SRB1</strong> messages (over DCCH):</p>
<ul class="simple">
<li><p>All the SRB1 messages modeled in the simulator (e.g.,
<strong>RrcConnectionCompleted</strong>) are implemented as in real LTE systems,
i.e., with a real RLC SDU sent over RLC AM using DL resources
allocated via Buffer Status Reports. See the RLC model
documentation for details.</p></li>
</ul>
</li>
<li><p><strong>SRB2</strong> messages (over DCCH):</p>
<blockquote>
<div><ul class="simple">
<li><p>According to <a class="reference internal" href="lte-references.html#ts36331" id="id122"><span>[TS36331]</span></a>, “<em>SRB1 is for RRC messages (which may
include a piggybacked NAS message) as well as for NAS messages
prior to the establishment of SRB2, all using DCCH logical
channel</em>”, whereas “<em>SRB2 is for NAS messages, using DCCH
logical channel</em>” and “<em>SRB2 has a lower-priority than SRB1 and is
always configured by E-UTRAN after security
activation</em>”. Modeling security-related aspects is not a
requirement of the LTE simulation model, hence we always use
SRB1 and never activate SRB2.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="asn-1-encoding-of-rrc-ie-s">
<h5>ASN.1 encoding of RRC IE’s<a class="headerlink" href="#asn-1-encoding-of-rrc-ie-s" title="Permalink to this headline">¶</a></h5>
<p>The messages defined in RRC SAP, common to all Ue/Enb SAP Users/Providers, are transported in a transparent container to/from a Ue/Enb. The encoding format for the different Information Elements are specified in <a class="reference internal" href="lte-references.html#ts36331" id="id123"><span>[TS36331]</span></a>, using ASN.1 rules in the unaligned variant. The implementation in Ns3/Lte has been divided in the following classes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Asn1Header : Contains the encoding / decoding of basic ASN types</p></li>
<li><p>RrcAsn1Header : Inherits Asn1Header and contains the encoding / decoding of common IE’s defined in <a class="reference internal" href="lte-references.html#ts36331" id="id124"><span>[TS36331]</span></a></p></li>
<li><p>Rrc specific messages/IEs classes : A class for each of the messages defined in RRC SAP header</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="asn1header-class-implementation-of-base-asn-1-types">
<h5>Asn1Header class - Implementation of base ASN.1 types<a class="headerlink" href="#asn1header-class-implementation-of-base-asn-1-types" title="Permalink to this headline">¶</a></h5>
<p>This class implements the methods to Serialize / Deserialize the ASN.1 types being used in <a class="reference internal" href="lte-references.html#ts36331" id="id125"><span>[TS36331]</span></a>, according to the packed encoding rules in ITU-T X.691. The types considered are:</p>
<blockquote>
<div><ul class="simple">
<li><p>Boolean : a boolean value uses a single bit (1=true, 0=false).</p></li>
<li><p>Integer : a constrained integer (with min and max values defined) uses the minimum amount of bits to encode its range (max-min+1).</p></li>
<li><p>Bitstring : a bistring will be copied bit by bit to the serialization buffer.</p></li>
<li><p>Octetstring : not being currently used.</p></li>
<li><p>Sequence : the sequence generates a preamble indicating the presence of optional and default fields. It also adds a bit indicating the presence of extension marker.</p></li>
<li><p>Sequence…Of : the sequence…of type encodes the number of elements of the sequence as an integer (the subsequent elements will need to be encoded afterwards).</p></li>
<li><p>Choice : indicates which element among the ones in the choice set is being encoded.</p></li>
<li><p>Enumeration : is serialized as an integer indicating which value is used, among the ones in the enumeration, with the number of elements in the enumeration as upper bound.</p></li>
<li><p>Null : the null value is not encoded, although its serialization function is defined to provide a clearer map between specification and implementation.</p></li>
</ul>
</div></blockquote>
<p>The class inherits from ns-3 Header, but Deserialize() function is declared pure virtual, thus inherited classes having to implement it. The reason is that deserialization will retrieve the elements in RRC messages, each of them containing different information elements.</p>
<p>Additionally, it has to be noted that the resulting byte length of a specific type/message can vary, according to the presence of optional fields, and due to the optimized encoding. Hence, the serialized bits will be processed using PreSerialize() function, saving the result in m_serializationResult Buffer. As the methods to read/write in a ns3 buffer are defined in a byte basis, the serialization bits are stored into m_serializationPendingBits attribute, until the 8 bits are set and can be written to buffer iterator. Finally, when invoking Serialize(), the contents of the m_serializationResult attribute will be copied to Buffer::Iterator parameter</p>
</div>
<div class="section" id="rrcasn1header-common-ies">
<h5>RrcAsn1Header : Common IEs<a class="headerlink" href="#rrcasn1header-common-ies" title="Permalink to this headline">¶</a></h5>
<p>As some Information Elements are being used for several RRC messages, this class implements the following common IE’s:</p>
<blockquote>
<div><ul class="simple">
<li><p>SrbToAddModList</p></li>
<li><p>DrbToAddModList</p></li>
<li><p>LogicalChannelConfig</p></li>
<li><p>RadioResourceConfigDedicated</p></li>
<li><p>PhysicalConfigDedicated</p></li>
<li><p>SystemInformationBlockType1</p></li>
<li><p>SystemInformationBlockType2</p></li>
<li><p>RadioResourceConfigCommonSIB</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="rrc-specific-messages-ies-classes">
<h5>Rrc specific messages/IEs classes<a class="headerlink" href="#rrc-specific-messages-ies-classes" title="Permalink to this headline">¶</a></h5>
<p>The following RRC SAP have been implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p>RrcConnectionRequest</p></li>
<li><p>RrcConnectionSetup</p></li>
<li><p>RrcConnectionSetupCompleted</p></li>
<li><p>RrcConnectionReconfiguration</p></li>
<li><p>RrcConnectionReconfigurationCompleted</p></li>
<li><p>HandoverPreparationInfo</p></li>
<li><p>RrcConnectionReestablishmentRequest</p></li>
<li><p>RrcConnectionReestablishment</p></li>
<li><p>RrcConnectionReestablishmentComplete</p></li>
<li><p>RrcConnectionReestablishmentReject</p></li>
<li><p>RrcConnectionRelease</p></li>
</ul>
</div></blockquote>
</div>
</div>
</div>
</div>
<div class="section" id="nas">
<span id="sec-nas"></span><h2>NAS<a class="headerlink" href="#nas" title="Permalink to this headline">¶</a></h2>
<p>The focus of the LTE-EPC model is on the NAS Active state, which corresponds to EMM Registered, ECM connected, and RRC connected. Because of this, the following simplifications are made:</p>
<ul class="simple">
<li><p>EMM and ECM are not modeled explicitly; instead, the NAS entity at the UE will interact directly with the MME to perform actions that are equivalent (with gross simplifications) to taking the UE to the states EMM Connected and ECM Connected;</p></li>
<li><p>the NAS also takes care of multiplexing uplink data packets coming from the upper layers into the appropriate EPS bearer by using the Traffic Flow Template classifier (TftClassifier).</p></li>
<li><p>the NAS does not support PLMN and CSG selection</p></li>
<li><p>the NAS does not support any location update/paging procedure in idle mode</p></li>
</ul>
<p>Figure <a class="reference internal" href="#fig-nas-attach"><span class="std std-ref">Sequence diagram of the attach procedure</span></a> shows how the simplified NAS model
implements the attach procedure. Note that both the default and
eventual dedicated EPS bearers are activated as part of this
procedure.</p>
<div class="figure align-center" id="id187">
<span id="fig-nas-attach"></span><img alt="_images/nas-attach.png" src="_images/nas-attach.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the attach procedure</span><a class="headerlink" href="#id187" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="s1-s5-and-s11">
<h2>S1, S5 and S11<a class="headerlink" href="#s1-s5-and-s11" title="Permalink to this headline">¶</a></h2>
<div class="section" id="s1-u-and-s5-user-plane">
<h3>S1-U and S5 (user plane)<a class="headerlink" href="#s1-u-and-s5-user-plane" title="Permalink to this headline">¶</a></h3>
<p>The S1-U and S5 interfaces are modeled in a realistic way by encapsulating
data packets over GTP/UDP/IP, as done in real LTE-EPC systems. The
corresponding protocol stack is shown in Figure
<a class="reference internal" href="#fig-lte-epc-e2e-data-protocol-stack-with-split"><span class="std std-ref">LTE-EPC data plane protocol stack</span></a>. As shown in the figure,
there are two different layers of
IP networking. The first one is the end-to-end layer, which provides end-to-end
connectivity to the users; this layer involves the UEs, the PGW and
the remote host (including eventual internet routers and hosts in
between), but does not involve the eNB and the SGW. In this version of LTE, the EPC
supports both IPv4 and IPv6 type users. The 3GPP unique 64 bit IPv6 prefix
allocation process for each UE and PGW is followed here. Each EPC is assigned
a unique 16 bit IPv4 and a 48 bit IPv6 network address from the pool of
7.0.0.0/8 and 7777:f00d::/32 respectively. In the end-to-end IP connection
between UE and PGW, all addresses are configured using these prefixes.
The PGW’s address is used by all UEs as the gateway to reach the internet.</p>
<p>The second layer of IP networking is the EPC local area network. This
involves all eNB nodes, SGW nodes and PGW nodes. This network is
implemented as a set of point-to-point links which connect each eNB
with its corresponding SGW node and a point-to-point link which connect
each SGW node with its corresponding PGW node;
thus, each SGW has a set of point-to-point devices, each providing
connectivity to a different eNB. By default, a 10.x.y.z/30 subnet
is assigned to each point-to-point link (a /30 subnet is the smallest
subnet that allows for two distinct host addresses).</p>
<p>As specified by 3GPP, the end-to-end IP
communications is tunneled over the local EPC IP network using
GTP/UDP/IP. In the following, we explain how this tunneling is
implemented in the EPC model. The explanation is done by discussing the
end-to-end flow of data packets.</p>
<div class="figure align-center" id="id188">
<span id="fig-epc-data-flow-dl-with-split"></span><img alt="_images/epc-data-flow-dl-with-split.png" src="_images/epc-data-flow-dl-with-split.png" />
<p class="caption"><span class="caption-text">Data flow in the downlink between the internet and the UE</span><a class="headerlink" href="#id188" title="Permalink to this image">¶</a></p>
</div>
<p>To begin with, we consider the case of the downlink, which is depicted
in Figure <a class="reference internal" href="#fig-epc-data-flow-dl-with-split"><span class="std std-ref">Data flow in the downlink between the internet and the UE</span></a>.
Downlink IPv4/IPv6 packets are generated from a generic remote host, and
addressed to one of the UE device. Internet routing will take care of
forwarding the packet to the generic NetDevice of the PGW node
which is connected to the internet (this is the Gi interface according
to 3GPP terminology). The PGW has a VirtualNetDevice which is
assigned the base IPv4 address of the EPC network; hence, static
routing rules will cause the incoming packet from the internet to be
routed through this VirtualNetDevice. In case of IPv6 address as destination,
a manual route towards the VirtualNetDevice is inserted in the routing table,
containing the 48 bit IPv6 prefix from which all the IPv6 addresses of the UEs
and PGW are configured. Such device starts the GTP/UDP/IP tunneling procedure,
by forwarding the packet to a dedicated application in the PGW node which
is called EpcPgwApplication. This application does the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it determines the SGW node to which it must route the traffic
for this UE, by looking at the IP destination address
(which is the address of the UE);</p></li>
<li><p>it classifies the packet using Traffic Flow Templates (TFTs) to
identify to which EPS Bearer it belongs. EPS bearers have a
one-to-one mapping to S5 Bearers, so this operation returns the
GTP-U Tunnel Endpoint Identifier  (TEID) to which the packet
belongs;</p></li>
<li><p>it adds the corresponding GTP-U protocol header to the packet;</p></li>
<li><p>finally, it sends the packet over a UDP socket to the S5
point-to-point NetDevice, addressed to the appropriate SGW.</p></li>
</ol>
</div></blockquote>
<p>As a consequence, the end-to-end IP packet with newly added IP, UDP
and GTP headers is sent through one of the S5 links to the SGW, where
it is received and delivered locally (as the destination address of
the outermost IP header matches the SGW IP address). The local delivery
process will forward the packet, via an UDP socket, to a dedicated
application called EpcSgwApplication. This application then performs
the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it determines the eNB node to which the UE is attached, by looking
at the S5 TEID;</p></li>
<li><p>it maps the S5 TEID to get the S1 TEID. EPS bearers have a
one-to-one mapping to S1-U Bearers, so this operation returns the
S1 GTP-U Tunnel Endpoint Identifier (TEID) to which the packet
belongs;</p></li>
<li><p>it adds a new GTP-U protocol header to the packet;</p></li>
<li><p>finally, it sends the packet over a UDP socket to the S1-U
point-to-point NetDevice, addressed to the eNB to which the UE is
attached.</p></li>
</ol>
</div></blockquote>
<p>Finally, the end-to-end IP packet with newly added IP, UDP
and GTP headers is sent through one of the S1 links to the eNB, where
it is received and delivered locally (as the destination address of
the outermost IP header matches the eNB IP address). The local delivery
process will forward the packet, via an UDP socket, to a dedicated
application called EpcEnbApplication. This application then performs
the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it removes the GTP header and retrieves the S1 TEID which is
contained in it;</p></li>
<li><p>leveraging on the one-to-one mapping between S1-U bearers and
Radio Bearers (which is a 3GPP requirement), it determines the
Bearer ID (BID) to which the packet belongs;</p></li>
<li><p>it records the BID in a dedicated tag called EpsBearerTag,
which is added to the packet;</p></li>
<li><p>it forwards the packet to the LteEnbNetDevice of the eNB node via
a raw packet socket</p></li>
</ol>
</div></blockquote>
<p>Note that, at this point, the outmost header of the packet is the
end-to-end IP header, since the IP/UDP/GTP headers of the S1 protocol
stack have already been stripped. Upon reception of
the packet from the EpcEnbApplication, the LteEnbNetDevice will
retrieve the BID from the EpsBearerTag, and based on the BID
will determine the Radio Bearer instance (and the corresponding PDCP
and RLC protocol instances) which are then used to forward the packet
to the UE over the LTE radio interface. Finally, the LteUeNetDevice of
the UE will receive the packet, and delivery it locally to the IP
protocol stack, which will in turn delivery it to the application of
the UE, which is the end point of the downlink communication.</p>
<div class="figure align-center" id="id189">
<span id="fig-epc-data-flow-ul-with-split"></span><img alt="_images/epc-data-flow-ul-with-split.png" src="_images/epc-data-flow-ul-with-split.png" />
<p class="caption"><span class="caption-text">Data flow in the uplink between the UE and the internet</span><a class="headerlink" href="#id189" title="Permalink to this image">¶</a></p>
</div>
<p>The case of the uplink is depicted in Figure <a class="reference internal" href="#fig-epc-data-flow-ul-with-split"><span class="std std-ref">Data flow in the uplink between the UE and the internet</span></a>.
Uplink IP packets are generated by a generic application inside the UE,
and forwarded by the local TCP/IP stack to the LteUeNetDevice of the
UE. The LteUeNetDevice then performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it classifies the packet using TFTs and determines the
Radio Bearer to which the packet belongs (and the corresponding
RBID);</p></li>
<li><p>it identifies the corresponding PDCP protocol instance, which is
the entry point of the LTE Radio Protocol stack for this packet;</p></li>
<li><p>it sends the packet to the eNB over the LTE Radio Protocol stack.</p></li>
</ol>
</div></blockquote>
<p>The eNB receives the packet via its LteEnbNetDevice. Since there is a
single PDCP and RLC protocol instance for each Radio Bearer, the
LteEnbNetDevice is able to determine the BID of the packet. This BID
is then recorded onto an EpsBearerTag, which is added to the
packet. The LteEnbNetDevice then forwards the packet to the
EpcEnbApplication via a raw packet socket.</p>
<p>Upon receiving the packet, the EpcEnbApplication performs the
following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it retrieves the BID from the EpsBearerTag in the packet;</p></li>
<li><p>it determines the corresponding EPS Bearer instance and GTP-U TEID by
leveraging on the one-to-one mapping between S1-U bearers and Radio
Bearers;</p></li>
<li><p>it adds a GTP-U header on the packet, including the TEID
determined previously;</p></li>
<li><p>it sends the packet to the SGW node via the UDP socket
connected to the S1-U point-to-point net device.</p></li>
</ol>
</div></blockquote>
<p>At this point, the packet contains the S1-U IP, UDP and GTP headers in
addition to the original end-to-end IP header. When the packet is
received by the corresponding S1-U point-to-point NetDevice of the
SGW node, it is delivered locally (as the destination address of
the outmost IP header matches the address of the point-to-point net
device). The local delivery process will forward the packet to the
EpcSgwApplication via the corresponding UDP socket. The
EpcSgwApplication then perfoms the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it removes the GTP header and retrieves the S1-U TEID;</p></li>
<li><p>it maps the S1-U TEID to get the S5 TEID to which the packet
belongs;</p></li>
<li><p>it determines the PGW to which it must send the packet from
the TEID mapping;</p></li>
<li><p>it add a new GTP-U protocol header to the packet;</p></li>
<li><p>finally, it sends the packet over a UDP socket to the S5
point-to-point NetDevice, addressed to the corresponding PGW.</p></li>
</ol>
</div></blockquote>
<p>At this point, the packet contains the S5 IP, UDP and GTP headers in
addition to the original end-to-end IP header. When the packet is
received by the corresponding S5 point-to-point NetDevice of the
PGW node, it is delivered locally (as the destination address of
the outmost IP header matches the address of the point-to-point net
device). The local delivery process will forward the packet to the
EpcPgwApplication via the corresponding UDP socket. The
EpcPgwApplication then removes the GTP header and forwards the
packet to the VirtualNetDevice. At this point, the outmost header
of the packet is the end-to-end IP header. Hence, if the destination
address within this header is a remote host on the internet, the
packet is sent to the internet via the corresponding NetDevice of the
PGW. In the event that the packet is addressed to another UE, the
IP stack of the PGW will redirect the packet again to the
VirtualNetDevice, and the packet will go through the downlink delivery
process in order to reach its destination UE.</p>
<p>Note that the EPS Bearer QoS is not enforced on the S1-U and S5
links, it is assumed that the overprovisioning of the link bandwidth
is sufficient to meet the QoS requirements of all bearers.</p>
</div>
<div class="section" id="s1ap">
<h3>S1AP<a class="headerlink" href="#s1ap" title="Permalink to this headline">¶</a></h3>
<p>The S1-AP interface provides control plane interaction between the eNB
and the MME. In the simulator, this interface is modeled in a realistic
fashion transmitting the encoded S1AP messages and information elements
specified in <a class="reference internal" href="lte-references.html#ts36413" id="id126"><span>[TS36413]</span></a> on the S1-MME link.</p>
<p>The S1-AP primitives that are modeled are:</p>
<blockquote>
<div><ul class="simple">
<li><p>INITIAL UE MESSAGE</p></li>
<li><p>INITIAL CONTEXT SETUP REQUEST</p></li>
<li><p>INITIAL CONTEXT SETUP RESPONSE</p></li>
<li><p>PATH SWITCH REQUEST</p></li>
<li><p>PATH SWITCH REQUEST ACKNOWLEDGE</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="s5-and-s11">
<h3>S5 and S11<a class="headerlink" href="#s5-and-s11" title="Permalink to this headline">¶</a></h3>
<p>The S5 interface provides control plane interaction between the SGW
and the PGW. The S11 interface provides control plane interaction between
the SGw and the MME. Both interfaces use the GPRS Tunneling Protocol (GTPv2-C)
to tunnel signalling messages <a class="reference internal" href="lte-references.html#ts29274" id="id127"><span>[TS29274]</span></a> and use UDP as transport protocol.
In the simulator, these interfaces and protocol are modeled in a realistic
fashion transmitting the encoded GTP-C messages.</p>
<p>The GTPv2-C primitives that are modeled are:</p>
<blockquote>
<div><ul class="simple">
<li><p>CREATE SESSION REQUEST</p></li>
<li><p>CREATE SESSION RESPONSE</p></li>
<li><p>MODIFY BEARER REQUEST</p></li>
<li><p>MODIFY BEARER RESPONSE</p></li>
<li><p>DELETE SESSION REQUEST</p></li>
<li><p>DELETE SESSION RESPONSE</p></li>
<li><p>DELETE BEARER COMMAND</p></li>
<li><p>DELETE BEARER REQUEST</p></li>
<li><p>DELETE BEARER RESPONSE</p></li>
</ul>
</div></blockquote>
<p>Of these primitives, the first two are used upon initial UE attachment for the establishment
of the S1-U and S5 bearers. Section <a class="reference internal" href="#sec-nas"><span class="std std-ref">NAS</span></a> shows the implementation of the attach
procedure. The other primitives are used during the handover to switch the S1-U bearers from
the source eNB to the target eNB as a consequence of the reception by the MME of a
PATH SWITCH REQUEST S1-AP message.</p>
</div>
</div>
<div class="section" id="x2">
<span id="sec-x2"></span><h2>X2<a class="headerlink" href="#x2" title="Permalink to this headline">¶</a></h2>
<p>The X2 interface interconnects two eNBs <a class="reference internal" href="lte-references.html#ts36420" id="id128"><span>[TS36420]</span></a>. From a logical
point of view, the X2 interface is a point-to-point interface between
the two eNBs. In a real E-UTRAN, the logical point-to-point interface
should be feasible even in the absence of a physical direct connection
between the two eNBs. In the X2 model implemented in the simulator,
the X2 interface is a point-to-point link between the two eNBs. A
point-to-point device is created in both eNBs and the two
point-to-point devices are attached to the point-to-point link.</p>
<p>For a representation of how the X2 interface fits in the overall
architecture of the LENA simulation model, the reader is referred to
the figure <a class="reference internal" href="#fig-epc-topology"><span class="std std-ref">Overview of the LTE-EPC simulation model</span></a>.</p>
<p>The X2 interface implemented in the simulator provides detailed implementation of the following elementary procedures of the Mobility Management functionality <a class="reference internal" href="lte-references.html#ts36423" id="id129"><span>[TS36423]</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Handover Request procedure</p></li>
<li><p>Handover Request Acknowledgement procedure</p></li>
<li><p>SN Status Transfer procedure</p></li>
<li><p>UE Context Release procedure</p></li>
</ul>
</div></blockquote>
<p>These procedures are involved in the X2-based handover. You can find
the detailed description of the handover in section 10.1.2.1 of
<a class="reference internal" href="lte-references.html#ts36300" id="id130"><span>[TS36300]</span></a>. We note that the simulator model currently supports only
the <em>seamless handover</em> as defined in Section 2.6.3.1 of <a class="reference internal" href="lte-references.html#sesia2009" id="id131"><span>[Sesia2009]</span></a>;
in particular, <em>lossless handover</em> as described in Section 2.6.3.2 of
<a class="reference internal" href="lte-references.html#sesia2009" id="id132"><span>[Sesia2009]</span></a> is not supported at the time of this writing.</p>
<p>Figure <a class="reference internal" href="#fig-x2-based-handover-seq-diagram"><span class="std std-ref">Sequence diagram of the X2-based handover</span></a> below shows the interaction of
the entities of the X2 model in the simulator. The shaded labels indicate the
moments when the UE or eNodeB transition to another RRC state.</p>
<div class="figure align-center" id="id190">
<span id="fig-x2-based-handover-seq-diagram"></span><a class="reference internal image-reference" href="_images/lte-epc-x2-handover-seq-diagram.png"><img alt="_images/lte-epc-x2-handover-seq-diagram.png" src="_images/lte-epc-x2-handover-seq-diagram.png" style="width: 672.8000000000001px; height: 753.6px;" /></a>
<p class="caption"><span class="caption-text">Sequence diagram of the X2-based handover</span><a class="headerlink" href="#id190" title="Permalink to this image">¶</a></p>
</div>
<p>The figure also shows two timers within the handover procedure: the <em>handover
leaving timer</em> is maintained by the source eNodeB, while the <em>handover joining
timer</em> by the target eNodeB. The duration of the timers can be configured in
the <code class="docutils literal notranslate"><span class="pre">HandoverLeavingTimeoutDuration</span></code> and <code class="docutils literal notranslate"><span class="pre">HandoverJoiningTimeoutDuration</span></code>
attributes of the respective <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> instances. When one of these timers
expire, the handover procedure is considered as failed.</p>
<p>However, there is no proper handling of handover failure in the current version
of LTE module. Users should tune the simulation properly in order to avoid
handover failure, otherwise unexpected behaviour may occur. Please refer to
Section <a class="reference internal" href="lte-user.html#sec-tuning-handover-simulation"><span class="std std-ref">Tuning simulation with handover</span></a> of the User Documentation for some
tips regarding this matter.</p>
<p>The X2 model is an entity that uses services from:</p>
<blockquote>
<div><ul class="simple">
<li><p>the X2 interfaces,</p>
<ul>
<li><p>They are implemented as Sockets on top of the point-to-point devices.</p></li>
<li><p>They are used to send/receive X2 messages through the X2-C and X2-U interfaces (i.e. the point-to-point device attached to the point-to-point link) towards the peer eNB.</p></li>
</ul>
</li>
<li><p>the S1 application.</p>
<ul>
<li><p>Currently, it is the EpcEnbApplication.</p></li>
<li><p>It is used to get some information needed for the Elementary Procedures of the X2 messages.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>and it provides services to:</p>
<blockquote>
<div><ul class="simple">
<li><p>the RRC entity (X2 SAP)</p>
<ul>
<li><p>to send/receive RRC messages. The X2 entity sends the RRC message as a transparent container in the X2 message. This RRC message is sent to the UE.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-x2-entity-saps"><span class="std std-ref">Implementation Model of X2 entity and SAPs</span></a> shows the implementation model of the X2 entity and its relationship with all the other entities and services in the protocol stack.</p>
<div class="figure align-center" id="id191">
<span id="fig-x2-entity-saps"></span><a class="reference internal image-reference" href="_images/lte-epc-x2-entity-saps.png"><img alt="_images/lte-epc-x2-entity-saps.png" src="_images/lte-epc-x2-entity-saps.png" style="width: 550px;" /></a>
<p class="caption"><span class="caption-text">Implementation Model of X2 entity and SAPs</span><a class="headerlink" href="#id191" title="Permalink to this image">¶</a></p>
</div>
<p>The RRC entity manages the initiation of the handover procedure. This is done in the Handover Management submodule of the eNB RRC entity. The target eNB may perform some Admission Control procedures. This is done in the Admission Control submodule. Initially, this submodule will accept any handover request.</p>
<div class="section" id="x2-interfaces">
<h3>X2 interfaces<a class="headerlink" href="#x2-interfaces" title="Permalink to this headline">¶</a></h3>
<p>The X2 model contains two interfaces:</p>
<blockquote>
<div><ul class="simple">
<li><p>the X2-C interface. It is the control interface and it is used to send the X2-AP PDUs
(i.e. the elementary procedures).</p></li>
<li><p>the X2-U interface. It is used to send the bearer data when there is <cite>DL forwarding</cite>.</p></li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-lte-epc-x2-interface"><span class="std std-ref">X2 interface protocol stacks</span></a> shows the protocol stacks of the X2-U interface and X2-C interface modeled in the simulator.</p>
<div class="figure align-center" id="id192">
<span id="fig-lte-epc-x2-interface"></span><img alt="_images/lte-epc-x2-interface.png" src="_images/lte-epc-x2-interface.png" />
<p class="caption"><span class="caption-text">X2 interface protocol stacks</span><a class="headerlink" href="#id192" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="x2-c">
<h4>X2-C<a class="headerlink" href="#x2-c" title="Permalink to this headline">¶</a></h4>
<p>The X2-C interface is the control part of the X2 interface and it is
used to send the X2-AP PDUs (i.e. the elementary procedures).</p>
<p>In the original X2 interface control plane protocol stack, SCTP is
used as the transport protocol but currently, the SCTP protocol is not
modeled in the ns-3 simulator and its implementation is out-of-scope
of the project. The UDP protocol is used as the datagram oriented
protocol instead of the SCTP protocol.</p>
</div>
<div class="section" id="x2-u">
<h4>X2-U<a class="headerlink" href="#x2-u" title="Permalink to this headline">¶</a></h4>
<p>The X2-U interface is used to send the bearer data when there is <cite>DL
forwarding</cite> during the execution of the X2-based handover
procedure. Similarly to what done for the S1-U interface, data packets
are encapsulated over GTP/UDP/IP when being sent over this
interface. Note that the EPS Bearer QoS is not enforced on the X2-U
links, it is assumed that the overprovisioning of the link bandwidth
is sufficient to meet the QoS requirements of all bearers.</p>
</div>
</div>
<div class="section" id="x2-service-interface">
<h3>X2 Service Interface<a class="headerlink" href="#x2-service-interface" title="Permalink to this headline">¶</a></h3>
<p>The X2 service interface is used by the RRC entity to send and receive messages of the X2 procedures. It is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">EpcX2SapProvider</span></code> part is provided by the X2 entity and used by the RRC entity and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">EpcX2SapUser</span></code> part is provided by the RRC entity and used by the RRC enity.</p></li>
</ul>
</div></blockquote>
<p>The primitives that are supported in our X2-C model are described in the following subsections.</p>
<div class="section" id="x2-c-primitives-for-handover-execution">
<h4>X2-C primitives for handover execution<a class="headerlink" href="#x2-c-primitives-for-handover-execution" title="Permalink to this headline">¶</a></h4>
<p>The following primitives are used for the X2-based
handover:</p>
<blockquote>
<div><ul class="simple">
<li><p>HANDOVER REQUEST</p></li>
<li><p>HANDOVER REQUEST ACK</p></li>
<li><p>HANDOVER PREPARATION FAILURE</p></li>
<li><p>SN STATUS STRANSFER</p></li>
<li><p>UE CONTEXT RELEASE</p></li>
</ul>
</div></blockquote>
<p>all the above primitives are used by the currently implemented RRC
model during the preparation and execution of the handover
procedure. Their usage interacts with the RRC state machine;
therefore, they are not meant to be used for code customization, at
least unless it is desired to modify the RRC state machine.</p>
</div>
<div class="section" id="x2-c-son-primitives">
<h4>X2-C SON primitives<a class="headerlink" href="#x2-c-son-primitives" title="Permalink to this headline">¶</a></h4>
<p>The following primitives can be used  to implement Self-Organized Network (SON) functionalities:</p>
<blockquote>
<div><ul class="simple">
<li><p>LOAD INFORMATION</p></li>
<li><p>RESOURCE STATUS UPDATE</p></li>
</ul>
</div></blockquote>
<p>note that the current RRC model does not actually use these
primitives, they are included in the model just to make it possible to
develop SON algorithms included in the RRC logic that make use of
them.</p>
<p>As a first example, we show here how the load information primitive
can be used. We assume that the LteEnbRrc has been modified to include
the following new member variables:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">UlInterferenceOverloadIndicationItem</span><span class="o">&gt;</span>
  <span class="n">m_currentUlInterferenceOverloadIndicationList</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">UlHighInterferenceInformationItem</span><span class="o">&gt;</span>
  <span class="n">m_currentUlHighInterferenceInformationList</span><span class="p">;</span>
<span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">RelativeNarrowbandTxBand</span> <span class="n">m_currentRelativeNarrowbandTxBand</span><span class="p">;</span>
</pre></div>
</div>
<p>for a detailed description of the type of these variables, we suggest
to consult the file <code class="docutils literal notranslate"><span class="pre">epc-x2-sap.h</span></code>, the corresponding doxygen
documentation, and the references therein to the relevant sections of
3GPP TS 36.423. Now, assume that at run time these variables have been
set to meaningful values following the specifications just
mentioned. Then, you can add the following code in the LteEnbRrc class
implementation in order to send a load information primitive:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">CellInformationItem</span> <span class="n">cii</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">sourceCellId</span> <span class="o">=</span> <span class="n">m_cellId</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">ulInterferenceOverloadIndicationList</span> <span class="o">=</span> <span class="n">m_currentUlInterferenceOverloadIndicationList</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">ulHighInterferenceInformationList</span> <span class="o">=</span> <span class="n">m_currentUlHighInterferenceInformationList</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">relativeNarrowbandTxBand</span> <span class="o">=</span> <span class="n">m_currentRelativeNarrowbandTxBand</span><span class="p">;</span>

<span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">LoadInformationParams</span> <span class="n">params</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">targetCellId</span> <span class="o">=</span> <span class="n">cellId</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">cellInformationList</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">cii</span><span class="p">);</span>
<span class="n">m_x2SapProvider</span><span class="o">-&gt;</span><span class="n">SendLoadInformation</span> <span class="p">(</span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code allows the source eNB to send the message. The method
<code class="docutils literal notranslate"><span class="pre">LteEnbRrc::DoRecvLoadInformation</span></code> will be called when the target
eNB receives the message. The desired processing of the load
information should therefore be implemented within that method.</p>
<p>In the following second example we show how the resource
status update primitive is used. We assume that the LteEnbRrc has been
modified to include the following new member variable:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">CellMeasurementResultItem</span> <span class="n">m_cmri</span><span class="p">;</span>
</pre></div>
</div>
<p>similarly to before, we refer to <code class="docutils literal notranslate"><span class="pre">epc-x2-sap.h</span></code> and the references
therein for detailed information about this variable type.
Again, we assume that the variable has been already set to a
meaningful value. Then, you can add the following code in order to
send a resource status update:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">ResourceStatusUpdateParams</span> <span class="n">params</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">targetCellId</span> <span class="o">=</span> <span class="n">cellId</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">cellMeasurementResultList</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">m_cmri</span><span class="p">);</span>
<span class="n">m_x2SapProvider</span><span class="o">-&gt;</span><span class="n">SendResourceStatusUpdate</span> <span class="p">(</span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">eEnbRrc::DoRecvResourceStatusUpdate</span></code> will be called when
the target eNB receives the resource status update message. The
desired processing of this message should therefore be implemented
within that method.</p>
<p>Finally, we note that the setting and processing of the appropriate
values for the variable passed to the above described primitives is
deemed to be specific of the SON algorithm being implemented, and
hence is not covered by this documentation.</p>
</div>
<div class="section" id="unsupported-primitives">
<h4>Unsupported primitives<a class="headerlink" href="#unsupported-primitives" title="Permalink to this headline">¶</a></h4>
<p>Mobility Robustness Optimization primitives such as Radio Link Failure
indication and Handover Report are not supported at this stage.</p>
</div>
</div>
</div>
<div class="section" id="s11">
<h2>S11<a class="headerlink" href="#s11" title="Permalink to this headline">¶</a></h2>
<p>The S11 interface provides control plane interaction between the SGW
and the MME using the GTPv2-C protocol specified in <a class="reference internal" href="lte-references.html#ts29274" id="id133"><span>[TS29274]</span></a>. In the
simulator, this interface is modeled in an ideal
fashion, with direct interaction between the SGW and the MME objects,
without actually implementing the encoding of the messages and without actually
transmitting any PDU on any link.</p>
<p>The S11 primitives that are modeled are:</p>
<blockquote>
<div><ul class="simple">
<li><p>CREATE SESSION REQUEST</p></li>
<li><p>CREATE SESSION RESPONSE</p></li>
<li><p>MODIFY BEARER REQUEST</p></li>
<li><p>MODIFY BEARER RESPONSE</p></li>
</ul>
</div></blockquote>
<p>Of these primitives, the first two are used upon initial UE attachment
for the establishment of the S1-U bearers; the other two are used
during handover to switch the S1-U bearers from the source eNB to the
target eNB as a consequence of the reception by the MME of a PATH
SWITCH REQUEST S1-AP message.</p>
</div>
<div class="section" id="power-control">
<h2>Power Control<a class="headerlink" href="#power-control" title="Permalink to this headline">¶</a></h2>
<p>This section describes the ns-3 implementation of Downlink and Uplink Power Control.</p>
<div class="section" id="downlink-power-control">
<h3>Downlink Power Control<a class="headerlink" href="#downlink-power-control" title="Permalink to this headline">¶</a></h3>
<p>Since some of Frequency Reuse Algorithms require Downlink Power Control,
this feature was also implemented in ns-3.</p>
<div class="figure align-center" id="id193">
<span id="fig-lte-downlik-power-control"></span><img alt="_images/lte-dl-power-control.png" src="_images/lte-dl-power-control.png" />
<p class="caption"><span class="caption-text">Sequence diagram of Downlink Power Control</span><a class="headerlink" href="#id193" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-lte-downlik-power-control"><span class="std std-ref">Sequence diagram of Downlink Power Control</span></a> shows the sequence diagram of
setting downlink P_A value for UE, highlighting the interactions between
the RRC and the other entities. FR algorithm triggers RRC to change P_A values
for UE. Then RRC starts RrcConnectionReconfiguration function to inform UE
about new configuration. After successful RrcConnectionReconfiguration, RRC
can set P_A value for UE by calling function SetPa from CphySap, value is
saved in new map m_paMap which contain P_A values for each UE served by eNb.</p>
<p>When LteEnbPhy starts new subframe, DCI control messages are processed to get
vector of used RBs. Now also GeneratePowerAllocationMap(uint16_t rnti, int rbId)
function is also called. This function check P_A value for UE, generate power
for each RB and store it in m_dlPowerAllocationMap. Then this map is used by
CreateTxPowerSpectralDensityWithPowerAllocation function to create
Ptr&lt;SpectrumValue&gt; txPsd.</p>
<p>PdschConfigDedicated (TS 36.331, 6.3.2 PDSCH-Config) was added in
LteRrcSap::PhysicalConfigDedicated struct, which is used in
RrcConnectionReconfiguration process.</p>
</div>
<div class="section" id="uplink-power-control">
<h3>Uplink Power Control<a class="headerlink" href="#uplink-power-control" title="Permalink to this headline">¶</a></h3>
<p>Uplink power control controls the transmit power of the different uplink physical
channels. This functionality is described in 3GPP TS 36.213 section 5.</p>
<p>Uplink Power Control is enabled by default, and can be disabled by attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePhy::EnableUplinkPowerControl&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>Two Uplink Power Control mechanisms are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p>Open Loop Uplink Power Control: the UE transmission power depends on estimation of
the downlink path-loss and channel configuration</p></li>
<li><p>Closed Loop Uplink Power Control: as in Open Loop, in addition eNB can control the UE
transmission power by means of explicit Transmit Power Control TPC commands transmitted
in the downlink.</p></li>
</ul>
</div></blockquote>
<p>To switch between these two mechanism types, one should change parameter:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::ClosedLoop&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>By default, Closed Loop Power Control is enabled.</p>
<dl class="simple">
<dt>Two modes of Closed Loop Uplink Power Control are available:</dt><dd><ul class="simple">
<li><p>Absolute mode: TxPower is computed with absolute TPC values</p></li>
<li><p>Accumulative mode: TxPower is computed with accumulated TPC values</p></li>
</ul>
</dd>
</dl>
<p>To switch between these two modes, one should change parameter:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::AccumulationEnabled&quot;</span><span class="p">,</span> <span class="n">BooleanValue</span> <span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>By default, Accumulation Mode is enabled and TPC commands in DL-DCI are set by all schedulers to 1,
what is mapped to value of 0 in Accumulation Mode.</p>
<div class="section" id="uplink-power-control-for-pusch">
<span id="sec-uplink-power-control-pusch"></span><h4>Uplink Power Control for PUSCH<a class="headerlink" href="#uplink-power-control-for-pusch" title="Permalink to this headline">¶</a></h4>
<p>The setting of the UE Transmit power for a Physical Uplink Shared Channel (PUSCH) transmission
is defined as follows:</p>
<blockquote>
<div><ul>
<li><p>If the UE transmits PUSCH without a simultaneous PUCCH for the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, then the
UE transmit power <img class="math" src="_images/math/3d4e0601ab98953c5bd38157a12699834f55aad0.png" alt="P_{PUSCH,c}(i)"/> for PUSCH transmission in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for the
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is given by:</p>
<div class="math">
<p><img src="_images/math/14a3ce5a8521ace1e07c9030b2ad4b4f37bf6312.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               P_{CMAX,c}(i)\\
               10\log_{10}(M_{PUSCH,c}(i))+ P_{O\_PUSCH,c}(j)
               + \alpha_{c} (j) * PL_{c} + \Delta_{TF,c}(i) + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div></li>
<li><p>If the UE transmits PUSCH simultaneous with PUCCH for the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, then the UE
transmit power <img class="math" src="_images/math/3d4e0601ab98953c5bd38157a12699834f55aad0.png" alt="P_{PUSCH,c}(i)"/> for the PUSCH transmission in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for
the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is given by:</p>
<div class="math">
<p><img src="_images/math/96d61b5f5f0645ef73023f3a40fe9d6e16274a85.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               10\log_{10}(\hat{P}_{CMAX,c}(i) - \hat{P}_{PUCCH}(i))\\
               10\log_{10}(M_{PUSCH,c}(i))+ P_{O\_PUSCH,c}(j)
               + \alpha_{c} (j) * PL_{c} + \Delta_{TF,c}(i) + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div><p>Since Uplink Power Control for PUCCH is not implemented, this case is not implemented as well.</p>
</li>
<li><p>If the UE is not transmitting PUSCH for the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, for the accumulation of
TPC command received with DCI format 3/3A for PUSCH, the UE shall assume that the UE transmit
power <img class="math" src="_images/math/3d4e0601ab98953c5bd38157a12699834f55aad0.png" alt="P_{PUSCH,c}(i)"/> for the PUSCH transmission in    subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for the serving
cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is computed by</p>
<div class="math">
<p><img src="_images/math/813b0ed2ddaead0fba1bb14c1e08d7487ddeb147.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               {P}_{CMAX,c}(i)\\
               P_{O\_PUSCH,c}(1) + \alpha_{c} (1) * PL_{c} + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div></li>
</ul>
</div></blockquote>
<dl>
<dt>where:</dt><dd><ul>
<li><p><img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is the configured UE transmit power defined in 3GPP 36.101. Table 6.2.2-1
in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> and <img class="math" src="_images/math/2d9d562ae50e1e1cf6ad9ec553fa9e5cf9eb4332.png" alt="\hat{P}_{CMAX,c}(i)"/> is the linear
value of <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/>. Default value for <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is 23 dBm</p></li>
<li><p><img class="math" src="_images/math/57f5e05b541685ec156ba34f111255e11762f3e1.png" alt="M_{PUSCH,c}(i)"/> is the bandwidth of the PUSCH resource assignment expressed in number
of resource blocks valid for subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> and serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> .</p></li>
<li><p><img class="math" src="_images/math/9917641057b7ada394237bfd961000139a0d3dc2.png" alt="P_{O\_PUSCH,c}(j)"/> is a parameter composed of the sum of a component <img class="math" src="_images/math/392a794730f67b064bd47e5eea02a8e9d409b0b0.png" alt="P_{O\_NOMINAL\_PUSCH,c}(j)"/>
provided from higher layers for <img class="math" src="_images/math/3d2393215c8673f00280a58962bfb2268b804d41.png" alt="j={0,1}"/> and a component <img class="math" src="_images/math/4c4b38b275d16833b07526da845bcf7d583764f7.png" alt="P_{O\_UE\_PUSCH,c}(j)"/> provided by higher
layers for <img class="math" src="_images/math/3d2393215c8673f00280a58962bfb2268b804d41.png" alt="j={0,1}"/> for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>. SIB2 message needs to be extended to carry these two
components, but currently they can be set via attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::PoNominalPusch&quot;</span><span class="p">,</span> <span class="n">IntegerValue</span> <span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::PoUePusch&quot;</span><span class="p">,</span> <span class="n">IntegerValue</span> <span class="p">(</span><span class="mi">7</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p><img class="math" src="_images/math/6792c6513b51a54b77f54569c5174ff7757b59bf.png" alt="\alpha_{c} (j)"/> is a 3-bit parameter provided by higher layers for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>.
For <img class="math" src="_images/math/995460da8d4ed81292e6d694401f1f5e8b02e9fd.png" alt="j=0,1"/>,   <img class="math" src="_images/math/c5f0ec3bc05b87b5e1a78d4139c55c757e6b0ff0.png" alt="\alpha_c \in \left \{ 0, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1 \right \}"/>
For <img class="math" src="_images/math/d7412635262724ee2e5af7b01635a007c707a461.png" alt="j=2"/>,   <img class="math" src="_images/math/991a028630e9e2bfcd8047ddee88271198b03698.png" alt="\alpha_{c} (j) = 1"/>.
This parameter is configurable by attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::Alpha&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p><img class="math" src="_images/math/ce695e88739f5e6d1091722cdda6815a41435cda.png" alt="PL_{c}"/> is the downlink pathloss estimate calculated in the UE for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> in dB
and <img class="math" src="_images/math/c945dc552a51dc771b990a8890c24d026dd632e5.png" alt="PL_{c} = referenceSignalPower – higher layer filtered RSRP"/>, where <img class="math" src="_images/math/def53cc8b1453e42ed48e149dbe515d6b4edf7a2.png" alt="referenceSignalPower"/>
is provided by higher layers and RSRP. <img class="math" src="_images/math/def53cc8b1453e42ed48e149dbe515d6b4edf7a2.png" alt="referenceSignalPower"/> is provided in SIB2 message</p></li>
<li><p><img class="math" src="_images/math/ed03ffc1cc73e2da54b060cd9af68778a2d2f57c.png" alt="\Delta_{TF,c}(i) = 10\log_{10}((2^{BPRE\cdot K_s}-1)\cdot\beta_{offset}^{PUSCH} )"/> for <img class="math" src="_images/math/0d62e598dc8588e49abdb5a59a13f5af1a7aad5c.png" alt="K_{s} = 1.25"/>
and <img class="math" src="_images/math/4624a6e2cf0024d742a2e2451af5d0327c85313e.png" alt="\Delta_{TF,c}(i) = 0"/> for <img class="math" src="_images/math/84fd6b40fc0fc1aed6f5d0b456c81157d477439e.png" alt="K_{s} = 0"/>. Only second case is implemented.</p></li>
<li><p><img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is component of Closed Loop Power Control. It is the current PUSCH power control
adjustment state for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>.</p>
<p>If Accumulation Mode is enabled <img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is given by:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/c670de479da7636d7a044cad093f74566bcbc418.png" alt="f_{c}(i) = f_{c}(i-1) + \delta_{PUSCH,c}(i - K_{PUSCH})"/></p>
</div></div></blockquote>
<p>where: <img class="math" src="_images/math/6db51ac2339938d8692759bdadbf5412bdb20e63.png" alt="\delta_{PUSCH,c}"/> is a correction value, also referred to as a TPC command and is included
in PDCCH with DCI; <img class="math" src="_images/math/bebbca1273e36aa6c21fd211edb852d2489870f6.png" alt="\delta_{PUSCH,c}(i - K_{PUSCH})"/> was signalled on PDCCH/EPDCCH with DCI for
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> on subframe <img class="math" src="_images/math/a7494a518d151be25f144fa33cb0e2912e8c0997.png" alt="(i - K_{PUSCH})"/>; <img class="math" src="_images/math/bc1461dd38cda1059bdb24f112bf28fd42f36584.png" alt="K_{PUSCH} = 4"/> for FDD.</p>
<p>If UE has reached <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, positive TPC commands for serving cell
<img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> are not be accumulated. If UE has reached minimum power, negative TPC commands are not be accumulated.
Minimum UE power is defined in TS36.101 section 6.2.3.  Default value is -40 dBm.</p>
<p>If Accumulation Mode is not enabled <img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is given by:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/53bdd7e0269f9983789b6edcb6670d834b8a4d46.png" alt="f_{c}(i) = \delta_{PUSCH,c}(i - K_{PUSCH})"/></p>
</div></div></blockquote>
<p>where: <img class="math" src="_images/math/6db51ac2339938d8692759bdadbf5412bdb20e63.png" alt="\delta_{PUSCH,c}"/> is a correction value, also referred to as a TPC command and is included
in PDCCH with DCI; <img class="math" src="_images/math/bebbca1273e36aa6c21fd211edb852d2489870f6.png" alt="\delta_{PUSCH,c}(i - K_{PUSCH})"/> was signalled on PDCCH/EPDCCH with DCI for
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> on subframe <img class="math" src="_images/math/a7494a518d151be25f144fa33cb0e2912e8c0997.png" alt="(i - K_{PUSCH})"/>; <img class="math" src="_images/math/bc1461dd38cda1059bdb24f112bf28fd42f36584.png" alt="K_{PUSCH} = 4"/> for FDD.</p>
<p>Mapping of TPC Command Field in DCI format 0/3/4 to absolute and accumulated <img class="math" src="_images/math/6db51ac2339938d8692759bdadbf5412bdb20e63.png" alt="\delta_{PUSCH,c}"/>
values is defined in TS36.231 section 5.1.1.1 Table 5.1.1.1-2</p>
</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="uplink-power-control-for-pucch">
<h4>Uplink Power Control for PUCCH<a class="headerlink" href="#uplink-power-control-for-pucch" title="Permalink to this headline">¶</a></h4>
<p>Since all uplink control messages are an ideal messages and do not consume any radio resources,
Uplink Power Control for PUCCH is not needed and it is not implemented.</p>
</div>
<div class="section" id="uplink-power-control-for-srs">
<h4>Uplink Power Control for SRS<a class="headerlink" href="#uplink-power-control-for-srs" title="Permalink to this headline">¶</a></h4>
<p>The setting of the UE Transmit power <img class="math" src="_images/math/fd4f34d013414ca5575ca562a68ddd691469c8f3.png" alt="P_{SRS}"/> for the SRS transmitted on subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is defined by</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/fa2f9d41bb69b090f6be826348ecad4f2c39ccad.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               {P}_{CMAX,c}(i)\\
               P_{SRS\_OFFSET,c}(m) + 10\log_{10}(M_{SRS,c})+
               P_{O\_PUSCH,c}(j) + \alpha_{c}(j) * PL_{c} + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div></div></blockquote>
<dl>
<dt>where:</dt><dd><ul>
<li><p><img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is the configured UE transmit power defined in 3GPP 36.101. Table 6.2.2-1.
Default value for <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is 23 dBm</p></li>
<li><p><img class="math" src="_images/math/bd0dd68f06efe9f08d62b748d2b4cfc4e31914a9.png" alt="P_{SRS\_OFFSET,c}(m)"/> is semi-statically configured by higher layers for <img class="math" src="_images/math/db9078364746510069ca573244ca3af68829f920.png" alt="m=0,1"/> for
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> . For SRS transmission given trigger type 0 then <img class="math" src="_images/math/db9078364746510069ca573244ca3af68829f920.png" alt="m=0,1"/> and for SRS
transmission given trigger type 1 then <img class="math" src="_images/math/b8e21c1654af1be4509ddba1bdba20de45e397c0.png" alt="m=1"/>.
For <img class="math" src="_images/math/84fd6b40fc0fc1aed6f5d0b456c81157d477439e.png" alt="K_{s} = 0"/> P_Srs_Offset_Value is computed with equation:</p>
<div class="math">
<p><img src="_images/math/b631cb2b417b55aecb9aca353391a41145ab69ca.png" alt="P_{SRS\_OFFSET,c}(m)value = -10.5 + P_{SRS\_OFFSET,c}(m) * 1.5 [dBm]"/></p>
</div><p>This parameter is configurable by attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span> <span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::PsrsOffset&quot;</span><span class="p">,</span> <span class="n">IntegerValue</span> <span class="p">(</span><span class="mi">7</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p><img class="math" src="_images/math/b67ab1022e68b744c7123f2152b09c6f1e61b464.png" alt="M_{SRS,c}"/> is the bandwidth of the SRS transmission in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for serving
cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> expressed in number of resource blocks. In current implementation SRS is sent
over entire UL bandwidth.</p></li>
<li><p><img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is the current PUSCH power control adjustment state for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>,
as defined in    <a class="reference internal" href="#sec-uplink-power-control-pusch"><span class="std std-ref">Uplink Power Control for PUSCH</span></a></p></li>
<li><p><img class="math" src="_images/math/9917641057b7ada394237bfd961000139a0d3dc2.png" alt="P_{O\_PUSCH,c}(j)"/> and <img class="math" src="_images/math/e779569e20e9f40b7d9044f11f3f15f32d423f04.png" alt="\alpha_{c}(j)"/> are parameters as defined in
<a class="reference internal" href="#sec-uplink-power-control-pusch"><span class="std std-ref">Uplink Power Control for PUSCH</span></a>, where <img class="math" src="_images/math/e11665feca4a260df50360e8263134c58b35b653.png" alt="j = 1"/> .</p></li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="fractional-frequency-reuse">
<h2>Fractional Frequency Reuse<a class="headerlink" href="#fractional-frequency-reuse" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id134">
<h3>Overview<a class="headerlink" href="#id134" title="Permalink to this headline">¶</a></h3>
<p>This section describes the ns-3 support for Fractional Frequency Reuse
algorithms. All implemented algorithms are described in <a class="reference internal" href="lte-references.html#ashamza2013" id="id135"><span>[ASHamza2013]</span></a>.
Currently 7 FR algorithms are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrNoOpAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrHardAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrStrictAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrEnhancedAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrDistributedAlgorithm</span></code></p></li>
</ul>
</div></blockquote>
<p>New LteFfrAlgorithm class was created and it is a abstract class for
Frequency Reuse algorithms implementation. Also, two new SAPs between
FR-Scheduler and FR-RRC were added.</p>
<div class="figure align-center" id="id194">
<span id="fig-lte-ffr-scheduling"></span><img alt="_images/lte-ffr-scheduling.png" src="_images/lte-ffr-scheduling.png" />
<p class="caption"><span class="caption-text">Sequence diagram of Scheduling with FR algorithm</span><a class="headerlink" href="#id194" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-lte-ffr-scheduling"><span class="std std-ref">Sequence diagram of Scheduling with FR algorithm</span></a> shows the sequence diagram of
scheduling process with FR algorithm. In the beginning of scheduling
process, scheduler asks FR entity for available RBGs. According to
implementation FR returns all RBGs available in cell or filter them based
on its policy. Then when trying to assign some RBG to UE, scheduler asks FR
entity if this RBG is allowed for this UE. When FR returns true, scheduler
can assign this RBG to this UE, if not scheduler is checking another RBG
for this UE. Again, FR response depends on implementation and policy applied
to UE.</p>
</div>
<div class="section" id="supported-fr-algorithms">
<h3>Supported FR algorithms<a class="headerlink" href="#supported-fr-algorithms" title="Permalink to this headline">¶</a></h3>
<div class="section" id="no-frequency-reuse">
<h4>No Frequency Reuse<a class="headerlink" href="#no-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>The NoOp FR algorithm (LteFrNoOpAlgorithm class) is implementation of
Full Frequency Reuse scheme, that means no frequency partitioning is performed
between eNBs of the same network (frequency reuse factor, FRF equals 1). eNBs
uses entire system bandwidth and transmit with uniform power over all RBGs. It
is the simplest scheme and is the basic way of operating an LTE network. This
scheme allows for achieving the high peak data rate. But from the other hand,
due to heavy interference levels from neighbouring cells, cell-edge users
performance is greatly limited.</p>
<p>Figure <a class="reference internal" href="#fig-lte-full-frequency-reuse-scheme"><span class="std std-ref">Full Frequency Reuse scheme</span></a> below presents frequency and
power plan for Full Frequency Reuse scheme.</p>
<div class="figure align-center" id="id195">
<span id="fig-lte-full-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-full-frequency-reuse-scheme.png"><img alt="_images/fr-full-frequency-reuse-scheme.png" src="_images/fr-full-frequency-reuse-scheme.png" style="width: 550.1999999999999px; height: 289.8px;" /></a>
<p class="caption"><span class="caption-text">Full Frequency Reuse scheme</span><a class="headerlink" href="#id195" title="Permalink to this image">¶</a></p>
</div>
<p>In ns-3, the NoOp FR algorithm always allows scheduler to use full bandwidth
and allows all UEs to use any RBG. It simply does nothing new (i.e. it does not
limit eNB bandwidth, FR algorithm is disabled), it is the simplest implementation
of FrAlgorithm class and is installed in eNb by default.</p>
</div>
<div class="section" id="hard-frequency-reuse">
<span id="sec-fr-hard-algorithm"></span><h4>Hard Frequency Reuse<a class="headerlink" href="#hard-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>The Hard Frequency Reuse algorithm provides the simplest scheme which allows to
reduce inter-cell interference level. In this scheme whole frequency bandwidth is
divided into few (typically 3, 4, or 7) disjoint sub-bands. Adjacent eNBs are
allocated with different sub-band. Frequency reuse factor equals the number
of sub-bands. This scheme allows to significantly reduce ICI at the cell edge,
so the performance of cell-users is improved. But due to the fact, that each
eNB uses only one part of whole bandwidth, peak data rate level is also reduced
by the factor equal to the reuse factor.</p>
<p>Figure <a class="reference internal" href="#fig-lte-hard-frequency-reuse-scheme"><span class="std std-ref">Hard Frequency Reuse scheme</span></a> below presents frequency and
power plan for Hard Frequency Reuse scheme.</p>
<div class="figure align-center" id="id196">
<span id="fig-lte-hard-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-hard-frequency-reuse-scheme.png"><img alt="_images/fr-hard-frequency-reuse-scheme.png" src="_images/fr-hard-frequency-reuse-scheme.png" style="width: 550.1999999999999px; height: 291.0px;" /></a>
<p class="caption"><span class="caption-text">Hard Frequency Reuse scheme</span><a class="headerlink" href="#id196" title="Permalink to this image">¶</a></p>
</div>
<p>In our implementation, the Hard FR algorithm has only vector of RBGs available
for eNB and pass it to MAC Scheduler during scheduling functions. When scheduler
ask, if RBG is allowed for specific UE it always return true.</p>
</div>
<div class="section" id="strict-frequency-reuse">
<h4>Strict Frequency Reuse<a class="headerlink" href="#strict-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>Strict Frequency Reuse scheme is combination of Full and Hard Frequency Reuse
schemes. It consists of dividing the system bandwidth into two parts which will
have different frequency reuse. One common sub-band of the system bandwidth is
used in each cell interior (frequency reuse-1), while the other part of the
bandwidth is divided among the neighboring eNBs as in hard frequency reuse
(frequency reuse-N, N&gt;1), in order to create one sub-band with a low inter-cell
interference level in each sector. Center UEs will be granted with the fully-reused
frequency chunks, while cell-edge UEs with orthogonal chunks. It means that interior
UEs from one cell do not share any spectrum with edge UEs from second cell, which
reduces interference for both. As can be noticed, Strict FR requires a total of
N + 1 sub-bands, and allows to achieve RFR in the middle between 1 and 3.</p>
<p>Figure <a class="reference internal" href="#fig-lte-strict-frequency-reuse-scheme"><span class="std std-ref">Strict Frequency Reuse scheme</span></a> below presents frequency and
power plan for Strict Frequency Reuse scheme with a cell-edge reuse factor of N = 3.</p>
<div class="figure align-center" id="id197">
<span id="fig-lte-strict-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-strict-frequency-reuse-scheme.png"><img alt="_images/fr-strict-frequency-reuse-scheme.png" src="_images/fr-strict-frequency-reuse-scheme.png" style="width: 549.6px; height: 285.59999999999997px;" /></a>
<p class="caption"><span class="caption-text">Strict Frequency Reuse scheme</span><a class="headerlink" href="#id197" title="Permalink to this image">¶</a></p>
</div>
<p>In our implementation, Strict FR algorithm has two maps, one for each sub-band.
If UE can be served within private sub-band, its RNTI is added to m_privateSubBandUe
map. If UE can be served within common sub-band, its RNTI is added to
m_commonSubBandUe map. Strict FR algorithm needs to decide within which sub-band
UE should be served. It uses UE measurements provided by RRB and compare them
with signal quality threshold (this parameter can be easily tuned by attribute
mechanism). Threshold has influence on interior to cell radius ratio.</p>
</div>
<div class="section" id="soft-frequency-reuse">
<h4>Soft Frequency Reuse<a class="headerlink" href="#soft-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>In Soft Frequency Reuse (SFR) scheme each eNb transmits over the entire system
bandwidth, but there are two sub-bands, within UEs are served with different power
level. Since cell-center UEs share the bandwidth with neighboring cells, they
usually transmit at lower power level than the cell-edge UEs. SFR is more bandwidth
efficient than Strict FR, because it uses entire system bandwidth, but it also
results in more interference to both cell interior and edge users.</p>
<p>There are two possible versions of SFR scheme:</p>
<blockquote>
<div><ul>
<li><p>In first version, the sub-band dedicated for the cell-edge UEs may also be used
by the cell-center UEs but with reduced power level and only if it is not occupied
by the cell-edge UEs. Cell-center sub-band is available to the centre UEs only.
Figure <a class="reference internal" href="#fig-lte-soft-frequency-reuse-scheme-v1"><span class="std std-ref">Soft Frequency Reuse scheme version 1</span></a> below presents frequency and
power plan for this version of Soft Frequency Reuse scheme.</p>
<div class="figure align-center" id="id198">
<span id="fig-lte-soft-frequency-reuse-scheme-v1"></span><a class="reference internal image-reference" href="_images/fr-soft-frequency-reuse-scheme-v1.png"><img alt="_images/fr-soft-frequency-reuse-scheme-v1.png" src="_images/fr-soft-frequency-reuse-scheme-v1.png" style="width: 549.6px; height: 287.4px;" /></a>
<p class="caption"><span class="caption-text">Soft Frequency Reuse scheme version 1</span><a class="headerlink" href="#id198" title="Permalink to this image">¶</a></p>
</div>
</li>
<li><p>In second version, cell-center UEs do not have access to cell-edge sub-band.
In this way, each cell can use the whole system bandwidth while reducing the
interference to the neighbors cells. From the other hand, lower ICI level at
the cell-edge is achieved at the expense of lower spectrum utilization.
Figure <a class="reference internal" href="#fig-lte-soft-frequency-reuse-scheme-v2"><span class="std std-ref">Soft Frequency Reuse scheme version 2</span></a> below presents frequency
and power plan for this version of Soft Frequency Reuse scheme.</p>
<div class="figure align-center" id="id199">
<span id="fig-lte-soft-frequency-reuse-scheme-v2"></span><a class="reference internal image-reference" href="_images/fr-soft-frequency-reuse-scheme-v2.png"><img alt="_images/fr-soft-frequency-reuse-scheme-v2.png" src="_images/fr-soft-frequency-reuse-scheme-v2.png" style="width: 549.6px; height: 286.8px;" /></a>
<p class="caption"><span class="caption-text">Soft Frequency Reuse scheme version 2</span><a class="headerlink" href="#id199" title="Permalink to this image">¶</a></p>
</div>
</li>
</ul>
</div></blockquote>
<p>SFR algorithm maintain two maps. If UE should be served with lower power level,
its RNTI is added to m_lowPowerSubBandUe map. If UE should be served with higher
power level, its RNTI is added to m_highPowerSubBandUe map. To decide with which
power level UE should be served SFR algorithm utilize UE measurements, and
compares them to threshold. Signal quality threshold and PdschConfigDedicated
(i.e. P_A value) for inner and outer area can be configured by attributes system.
SFR utilizes Downlink Power Control described here.</p>
</div>
<div class="section" id="soft-fractional-frequency-reuse">
<h4>Soft Fractional Frequency Reuse<a class="headerlink" href="#soft-fractional-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>Soft Fractional Frequency Reuse (SFFR) is an combination of Strict and Soft
Frequency Reuse schemes. While Strict FR do not use the subbands allocated
for outer region in the adjacent cells, soft FFR uses these subbands for the
inner UEs with low transmit power. As a result, the SFFR, like SFR, use the
subband with high transmit power level and with low transmit power level.
Unlike the Soft FR and like Strict FR, the Soft FFR uses the common sub-band
which can enhance the throughput of the inner users.</p>
<p>Figure <a class="reference internal" href="#fig-lte-soft-fractional-frequency-reuse-scheme"><span class="std std-ref">Soft Fractional Fractional Frequency Reuse scheme</span></a> below presents
frequency and power plan for Soft Fractional Frequency Reuse.</p>
<div class="figure align-center" id="id200">
<span id="fig-lte-soft-fractional-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-soft-fractional-frequency-reuse-scheme.png"><img alt="_images/fr-soft-fractional-frequency-reuse-scheme.png" src="_images/fr-soft-fractional-frequency-reuse-scheme.png" style="width: 549.6px; height: 287.4px;" /></a>
<p class="caption"><span class="caption-text">Soft Fractional Fractional Frequency Reuse scheme</span><a class="headerlink" href="#id200" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="enhanced-fractional-frequency-reuse">
<h4>Enhanced Fractional Frequency Reuse<a class="headerlink" href="#enhanced-fractional-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>Enhanced Fractional Frequency Reuse (EFFR) described in <a class="reference internal" href="lte-references.html#zxie2009" id="id136"><span>[ZXie2009]</span></a> defines 3
cell-types for directly neighboring cells in a cellular system, and reserves
for each cell-type a part of the whole frequency band named <cite>Primary Segment</cite>,
which among different type cells should be orthogonal. The remaining subchannels
constitute the <cite>Secondary Segment</cite>. The <cite>Primary Segment</cite> of a cell-type is
at the same time a part of the <cite>Secondary Segments</cite> belonging to the other two
cell-types. Each cell can occupy all subchannels of its <cite>Primary Segment</cite> at
will, whereas only a part of subchannels in the <cite>Secondary Segment</cite> can be used
by this cell in an interference-aware manner.The <cite>Primary Segment</cite> of each cell
is divided into a reuse-3 part and reuse-1 part. The reuse-1 part can be reused
by all types of cells in the system, whereas reuse-3 part can only be exclusively
reused by other same type cells( i.e. the reuse-3 subchannels cannot be reused
by directly neighboring cells). On the <cite>Secondary Segment</cite> cell acts as a guest,
and occupying secondary subchannels is actually reuse the primary subchannels
belonging to the directly neighboring cells, thus reuse on the <cite>Secondary Segment</cite>
by each cell should conform to two rules:</p>
<blockquote>
<div><ul class="simple">
<li><p>monitor before use</p></li>
<li><p>resource reuse based on SINR estimation</p></li>
</ul>
</div></blockquote>
<p>Each cell listens on every secondary subchannel all the time. And before occupation,
it makes SINR evaluation according to the gathered channel quality information (CQI)
and chooses resources with best estimation values for reuse. If CQI value for RBG is
above configured threshold for some user, transmission for this user can be performed
using this RBG.</p>
<p>In <a class="reference internal" href="lte-references.html#zxie2009" id="id137"><span>[ZXie2009]</span></a> scheduling process is described, it consist of three steps and two
scheduling polices. Since none of currently implemented schedulers allow for
this behaviour, some simplification were applied. In our implementation reuse-1
subchannels can be used only by cell center users. Reuse-3 subchannels can be used by
edge users, and only if there is no edge user, transmission for cell center users can
be served in reuse-3 subchannels.</p>
<p>Figure <a class="reference internal" href="#fig-lte-enhanced-fractional-frequency-reuse-scheme"><span class="std std-ref">Enhanced Fractional Fractional Frequency Reuse scheme</span></a> below presents
frequency and power plan for Enhanced Fractional Frequency Reuse.</p>
<div class="figure align-center" id="id201">
<span id="fig-lte-enhanced-fractional-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-enhanced-fractional-frequency-reuse-scheme.png"><img alt="_images/fr-enhanced-fractional-frequency-reuse-scheme.png" src="_images/fr-enhanced-fractional-frequency-reuse-scheme.png" style="width: 549.6px; height: 283.8px;" /></a>
<p class="caption"><span class="caption-text">Enhanced Fractional Fractional Frequency Reuse scheme</span><a class="headerlink" href="#id201" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="distributed-fractional-frequency-reuse">
<h4>Distributed Fractional Frequency Reuse<a class="headerlink" href="#distributed-fractional-frequency-reuse" title="Permalink to this headline">¶</a></h4>
<p>This Distributed Fractional Frequency Reuse Algorithm was presented in <a class="reference internal" href="lte-references.html#dkimura2012" id="id138"><span>[DKimura2012]</span></a>. It
automatically optimizes cell-edge sub-bands by focusing on user distribution (in particular,
receive-power distribution). This algorithm adaptively selects RBs for cell-edge sub-band on
basis of coordination information from adjecent cells and notifies the base stations of the
adjacent cells, which RBs it selected to use in edge sub-band. The base station of each cell
uses the received information and the following equation to compute cell-edge-band metric
<img class="math" src="_images/math/ec1a9f4c7cad7557d240f475cdb90cfcc7257ef6.png" alt="A_{k}"/> for each RB.</p>
<div class="math">
<p><img src="_images/math/fa64c1de97c2a781c925d68e9b7d642cc5589ef6.png" alt="A_{k} = \sum_{j\in J}w_{j}X_{j,k}"/></p>
</div><p>where <img class="math" src="_images/math/32c06f8c59d4bd3d13eedea7765a8a74a11f2383.png" alt="J"/> is a set of neighbor cells, <img class="math" src="_images/math/ef2e800870b7cf1e347e083a13a2489d40956934.png" alt="X_{j,k}=\{0,1\}"/> is the RNTP from the <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>-th
neighbor cell. It takes a value of 1 when the <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>-th RB in the <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>-th neighbor cell is used
as a cell-edge sub-band and 0 otherwise. The symbol <img class="math" src="_images/math/d37fde55cb34e8cc3c01da0df07c8409de8bcd9b.png" alt="w_{j}"/> denotes weight with respect to adjacent
cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, that is, the number of users for which the difference between the power of the signal
received from the serving cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> and the power of the signal received from the adjacent cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>
is less than a threshold value (i.e., the number of users near the cell edge in the service cell). A large
received power difference means that cell-edge users in the <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>-th cell suffer strong interference
from the <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>-th cell.</p>
<p>The RB for which metric <img class="math" src="_images/math/ec1a9f4c7cad7557d240f475cdb90cfcc7257ef6.png" alt="A_{k}"/> is smallest is considered to be least affected by interference from
another cell. Serving cell selects a configured number of RBs as cell-edge sub-band in ascending order
of <img class="math" src="_images/math/ec1a9f4c7cad7557d240f475cdb90cfcc7257ef6.png" alt="A_{k}"/>. As a result, the RBs in which a small number of cell-edge users receive high
interference from adjacent base stations are selected.</p>
<p>The updated RNTP is then sent to all the neighbor cells. In order to avoid the meaningless oscillation
of cell-edge-band selection, a base station ignores an RNTP from another base station that has larger
cell ID than the base station.</p>
<p>Repeating this process across all cells enables the allocation of RBs to cell-edge areas to be optimized
over the system and to be adjusted with changes in user distribution.</p>
<p>Figure <a class="reference internal" href="#fig-lte-distributed-fractional-frequency-reuse-scheme"><span class="std std-ref">Sequence diagram of Distributed Frequency Reuse Scheme</span></a> below presents
sequence diagram of Distributed Fractional Frequency Reuse Scheme.</p>
<div class="figure align-center" id="id202">
<span id="fig-lte-distributed-fractional-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/ffr-distributed-scheme.png"><img alt="_images/ffr-distributed-scheme.png" src="_images/ffr-distributed-scheme.png" style="width: 479.20000000000005px; height: 525.6px;" /></a>
<p class="caption"><span class="caption-text">Sequence diagram of Distributed Frequency Reuse Scheme</span><a class="headerlink" href="#id202" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
</div>
<div class="section" id="carrier-aggregation">
<span id="sec-carrier-aggregation"></span><h2>Carrier Aggregation<a class="headerlink" href="#carrier-aggregation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id139">
<h3>Overview<a class="headerlink" href="#id139" title="Permalink to this headline">¶</a></h3>
<p>This section describes the ns-3 support for Carrier Aggregation.
The references in the standard are <a class="reference internal" href="lte-references.html#ts36211" id="id140"><span>[TS36211]</span></a>, <a class="reference internal" href="lte-references.html#ts36213" id="id141"><span>[TS36213]</span></a> and <a class="reference internal" href="lte-references.html#ts36331" id="id142"><span>[TS36331]</span></a>.</p>
<p><strong>Note:</strong> Carrier Aggregation was introduced in release 3.27 and currently, only works in downlink.</p>
<p>3GPP standardizes, in release R10, the Carrier Aggregation (CA) technology.</p>
<p>This technology consists of the possibility, to aggregate radio resources belonging to
different carriers, in order to have more bandwidth available, and to achieve a higher
throughput. Carrier Aggregation as defined by 3GPP can be used with both TDD and FDD.
Since ns-3 only supports FDD LTE implementation, we will consider only this case in
this section. Each aggregated carrier is referred to as a component carrier, CC.
The component carrier can have a bandwidth of 1.4, 3, 5, 10, 15 or 20 MHz and a maximum
of five component carriers can be aggregated, hence the maximum aggregated bandwidth is
100 MHz. In FDD the number of aggregated carriers can be different in DL and UL. However,
the number of UL component carriers is always equal to or lower than the number of DL
component carriers. The individual component carriers can also be of different bandwidths.
When carrier aggregation is used there are a number of serving cells, one for each
component carrier. The coverage of the serving cells may differ, for example due to
that CCs on different frequency bands will experience different pathloss. The RRC
connection is only handled by one cell, the Primary serving cell, served by the
Primary component carrier (DL and UL PCC). It is also on the DL PCC that the UE
receives NAS information, such as security parameters.</p>
<p>3GPP defines three different CA bandwidth classes in releases 10 and 11 (where ATBC
is Aggregated Transmission Bandwidth Configuration):</p>
<p>Class A: ATBC <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> 100, maximum number of CC = 1</p>
<p>Class B: ATBC <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> 100, maximum number of CC = 2</p>
<p>Class C: 100 <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> ATBC <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> 200, maximum number of CC = 2</p>
<p>Figure <a class="reference internal" href="#fig-lte-carrier-aggregation-impact"><span class="std std-ref">CA impact on different layers of LTE protocol stack (from 3gpp.org)</span></a> (from 3gpp.org) shows the main
impact of CA technology on the different layers of the LTE protocol stack.
Introduction of carrier aggregation influences mainly the MAC and new RRC messages
are introduced. In order to keep R8/R9 compatibility the protocol changes will be kept
to a minimum. Basically each component carrier is treated as an R8 carrier. However some
changes are required, such as new RRC messages in order to handle the secondary component
carrier (SCC), and MAC must be able to handle scheduling on a number of CCs. In the
following we describe the impact of the carrier aggregation implementation on the different
layers of the LTE protocol stack in ns-3.</p>
<div class="figure align-center" id="id203">
<span id="fig-lte-carrier-aggregation-impact"></span><a class="reference internal image-reference" href="_images/carrier-aggregation-impact.png"><img alt="_images/carrier-aggregation-impact.png" src="_images/carrier-aggregation-impact.png" style="width: 453.6px; height: 345.6px;" /></a>
<p class="caption"><span class="caption-text">CA impact on different layers of LTE protocol stack (from 3gpp.org)</span><a class="headerlink" href="#id203" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="impact-on-rrc-layer">
<h4>Impact on RRC layer<a class="headerlink" href="#impact-on-rrc-layer" title="Permalink to this headline">¶</a></h4>
<p>The main impacts on the RRC layer are related to secondary carrier configuration and
measurements reporting. To enable these features we have enhanced the already existing
procedures for the RRC Connection Reconfiguration and UE RRC Measurements Model.</p>
<p>The carrier aggregation enabling procedure is shown in figure <a class="reference internal" href="#fig-ca-rrc-reconf"><span class="std std-ref">A schematic overview of the secondary carrier enabling procedure</span></a>.
As per 3GPP definition, the secondary cell is a cell, operating on a secondary frequency,
which may be configured once an RRC connection is established and which may be used to
provide additional radio resources. Hence, the procedure starts when the UE is in the
CONNECTED_NORMALLY state (see the RRC state machine description). This part of the procedure
is the same as in the previous architecture. In order to simplify the implementation,
the <cite>UE Capability Inquiry</cite> and <cite>UE Capability Information</cite> are not implemented. This
implies to assume that each UE can support the carrier aggregation, and any specific
configuration provided by the eNB to which is attached. The eNB RRC sends to the UE the
secondary carrier configuration parameters through the RRC Connection Reconfiguration
procedure. This procedure may be used for various purposes related to modifications of
the RRC connection, e.g. to establish, modify or release RBs, to perform handover, to
setup, modify or release measurements, to add, modify and release secondary cells (SCells).
At UE side, the RRC is extended to configure the lower layers, in such a way that the
SCell(s) are considered. Once the carriers are configured, the <cite>Reconfiguration Completed</cite>
message is sent back to the eNB RRC, informing the eNB RRC and CCM that the secondary
carriers have been properly configured. The RRC layer at both the UE and the eNB sides
is extended to allow measurement reporting for the secondary carriers. Finally, in order
to allow the procedures for configuration and measurement reporting, the RRC is enhanced
to support serialization and deserialization of RRC message structures that carry information
related to the secondary carriers, e.g., if the <code class="docutils literal notranslate"><span class="pre">RRCConnectionReconfiguration</span></code> message
includes <code class="docutils literal notranslate"><span class="pre">sCellToAddModList</span></code> structure, SCell addition or modification will be performed,
or, if it contains <code class="docutils literal notranslate"><span class="pre">measConfig</span></code> the measurement reporting will be configured. To allow
transmission of this information the following structures are implemented for the sCell:
<code class="docutils literal notranslate"><span class="pre">RadioResourceConfigCommonSCell</span></code>, <code class="docutils literal notranslate"><span class="pre">RadioResourceConfigDedicatedSCell</span></code> and
<code class="docutils literal notranslate"><span class="pre">PhysicalConfigDedicatedSCell</span></code> and <code class="docutils literal notranslate"><span class="pre">NonCriticalExtensionConfiguration</span></code>.
<code class="docutils literal notranslate"><span class="pre">RadioResourceConfigCommonSCell</span></code> and <code class="docutils literal notranslate"><span class="pre">RadioResourceConfigDedicatedSCell</span></code> are
used for SCell addition and modification (see TS 36.331, 5.3.10.3b).
<code class="docutils literal notranslate"><span class="pre">PhysicalConfigDedicatedSCell</span></code> is used for physical channel reconfiguration
(see TS 36.331, 5.3.10.6). Finally, <code class="docutils literal notranslate"><span class="pre">NonCriticalExtensionConfiguration</span></code> is used to
carry information of <code class="docutils literal notranslate"><span class="pre">sCellToAddModeList</span></code> and <code class="docutils literal notranslate"><span class="pre">sCellToReleaseList</span></code>,
which is a modified structure comparing to TS 36.331, 6.6.2, according to which these
are directly in the root of RRCConnectionReconfiguration message. Measurement
reporting is extended with <code class="docutils literal notranslate"><span class="pre">measResultSCell</span></code> structure to include RSRP and RSRQ
measurements for each configured SCell. However, the measurement report triggering
event A6 (neighbour becomes offset better than SCell) is not implemented yet.</p>
<div class="figure align-center" id="id204">
<span id="fig-ca-rrc-reconf"></span><a class="reference internal image-reference" href="_images/ca-rrc-reconf.png"><img alt="_images/ca-rrc-reconf.png" src="_images/ca-rrc-reconf.png" style="width: 184.0px; height: 166.0px;" /></a>
<p class="caption"><span class="caption-text">A schematic overview of the secondary carrier enabling procedure</span><a class="headerlink" href="#id204" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="impact-on-pcdcp-layer">
<h4>Impact on PCDCP layer<a class="headerlink" href="#impact-on-pcdcp-layer" title="Permalink to this headline">¶</a></h4>
<p>There is no impact on PDCP layer.</p>
</div>
<div class="section" id="impact-on-rlc-layer">
<h4>Impact on RLC layer<a class="headerlink" href="#impact-on-rlc-layer" title="Permalink to this headline">¶</a></h4>
<p>The impact on the RLC layer is relatively small. There is some impact on configuration of
the buffer and the usage of SAP interfaces between RLC and MAC. Since the capacity of the
lower layers increases with the carrier aggregation it is necessary to accordingly adjust
the size of the RLC buffer. The impact on the implementation of the RLC layer is very small
thanks to the design choice that allows the CCM manager to serve the different RLC instances
through the <code class="docutils literal notranslate"><span class="pre">LteMacSapProvider</span> <span class="pre">interface</span></code>. Thanks to this design choice, the RLC is using
the same interface as in the earlier LTE module architecture, the <code class="docutils literal notranslate"><span class="pre">LteMacSapProvider</span></code>,
but the actual SAP provider in the new architecture is the CCM (some class that inherits
<code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>). The CCM acts as a proxy, it receives function calls
that are meant for the MAC, and forwards them to the MAC of the different component
carriers. Additionally, it uses the information of the UEs and the logical channels for
its own functionalities.</p>
</div>
<div class="section" id="impact-on-mac-layer">
<h4>Impact on MAC layer<a class="headerlink" href="#impact-on-mac-layer" title="Permalink to this headline">¶</a></h4>
<p>The impact on the MAC layer depends on the CA scheduling scheme in use. Two different
scheduling schemes are proposed in R10 and are shown in
figure <a class="reference internal" href="#fig-lte-carrier-aggregation-mac-impact"><span class="std std-ref">CA scheduling schemes (from 3gpp.org)</span></a>.</p>
<div class="figure align-center" id="id205">
<span id="fig-lte-carrier-aggregation-mac-impact"></span><a class="reference internal image-reference" href="_images/carrier-aggregation-mac-impact.png"><img alt="_images/carrier-aggregation-mac-impact.png" src="_images/carrier-aggregation-mac-impact.png" style="width: 510.3px; height: 374.40000000000003px;" /></a>
<p class="caption"><span class="caption-text">CA scheduling schemes (from 3gpp.org)</span><a class="headerlink" href="#id205" title="Permalink to this image">¶</a></p>
</div>
<p>The CIF (Carrier Indicator Field) on PDCCH (represented by the red area) indicates
on which carrier the scheduled resource is located. In the following we describe both
the schemes:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>scheduling grant and resources on the same carrier. One PDCCH is supported per carrier.</p></li>
<li><p>cross-carrier scheduling: it is used to schedule resources on the secondary carrier
without PDCCH.</p></li>
</ol>
</div></blockquote>
<p>Current implementation covers only option 1, so there is no cross-carrier scheduling.
The MAC layer of the eNodeB has suffered minor changes and they are mainly related to
addition of component carrier information in message exchange between layers.</p>
</div>
<div class="section" id="impact-on-phy-layer">
<h4>Impact on PHY layer<a class="headerlink" href="#impact-on-phy-layer" title="Permalink to this headline">¶</a></h4>
<p>The impact on PHY layer is minor. There is an instance of PHY layer per each component
carrier and the SAP interface functions remain unchanged. As shown
in <a class="reference internal" href="#fig-lte-carrier-aggregation-mac-impact"><span class="std std-ref">CA scheduling schemes (from 3gpp.org)</span></a> the difference is that since there are
multiple PHY instances, there are also multiple instances of PDCCH, HARQ, ACK/NACK and
CSI per carrier. So, at the eNB PHY, the changes are related to the addition of the
component carrier id information, while at the UE PHY the information of the Component
Carrier is used for some functionalities that depend on the Component Carrier to which
the PHY instance belongs. For example, the UE PHY is extended to allow disabling of
the sounding reference signal (SRS) at the secondary carriers. This is necessary
because there is one UE PHY instance per component carrier, but according
to <a class="reference internal" href="#fig-lte-carrier-aggregation-mac-impact"><span class="std std-ref">CA scheduling schemes (from 3gpp.org)</span></a>, only a single carrier is used
and the uplink traffic is transmitted only over the primary carrier.</p>
</div>
</div>
<div class="section" id="code-structure-design">
<h3>Code Structure Design<a class="headerlink" href="#code-structure-design" title="Permalink to this headline">¶</a></h3>
<p>This section briefly introduces the software design and implementation of the
carrier aggregation functionality.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> are created by the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>
using the method <code class="docutils literal notranslate"><span class="pre">InstallSingleEnbDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">InstallSingleUeDevice</span></code>. These
functions are now extended to allow the carrier aggregation configuration. In the
following we explain the main differences comparing to the previous architecture.</p>
<p>Figure <a class="reference internal" href="#fig-lte-enb-net-device-changes"><span class="std std-ref">Changes in LteEnbNetDevice to support CA</span></a> shows the attributes and associations
of the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> that are affected by the implementation, or are created
in order to support the carrier aggregation functionality. Since <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code>
may have several component carriers, the attributes that were formerly part of
the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> and are carrier specific are migrated to the ComponentCarrier
class, e.g. physical layer configuration parameters. The attributes that are
specific for the eNB component carrier are migrated to <code class="docutils literal notranslate"><span class="pre">ComponentCarrierEnb</span></code>, e.g.
pointers to MAC, PHY, scheduler, fractional frequency reuse instances.
<code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> can contain pointers to several <code class="docutils literal notranslate"><span class="pre">ComponentCarrierEnb</span></code> instances.
This architecture allows that each CC may have its own configuration for PHY, MAC,
scheduling algorithm and franctional frequency reuse algorithm.  These attributes are
currently maintained also in the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> for backward compatibility purpose.
By default the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> attributes are the same as the
primary carrier attributes.</p>
<div class="figure align-center" id="id206">
<span id="fig-lte-enb-net-device-changes"></span><a class="reference internal image-reference" href="_images/ca-lte-enb-net-device-changes.png"><img alt="_images/ca-lte-enb-net-device-changes.png" src="_images/ca-lte-enb-net-device-changes.png" style="width: 1002.6px; height: 608.4px;" /></a>
<p class="caption"><span class="caption-text">Changes in <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> to support CA</span><a class="headerlink" href="#id206" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-lte-ue-net-device-changes"><span class="std std-ref">Changes in LteUeNetDevice to support CA</span></a> shows the attributes and associations
of <code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> that are affected by the carrier aggregation implementation.
Similarly, to the changes in <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code>, pointers that are specific to UE
component carrier are migrated to the <code class="docutils literal notranslate"><span class="pre">ComponentCarrierUe</span></code> class.
<code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> has maintained m_dlEarfcn for initial cell selection purposes.</p>
<div class="figure align-center" id="id207">
<span id="fig-lte-ue-net-device-changes"></span><a class="reference internal image-reference" href="_images/ca-lte-ue-net-device-changes.png"><img alt="_images/ca-lte-ue-net-device-changes.png" src="_images/ca-lte-ue-net-device-changes.png" style="width: 809.1px; height: 342.90000000000003px;" /></a>
<p class="caption"><span class="caption-text">Changes in <code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> to support CA</span><a class="headerlink" href="#id207" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="ca-impact-on-data-plane-of-enodeb">
<h4>CA impact on data plane of eNodeB<a class="headerlink" href="#ca-impact-on-data-plane-of-enodeb" title="Permalink to this headline">¶</a></h4>
<p>Figure <a class="reference internal" href="#fig-ca-enb-data-plane"><span class="std std-ref">eNB Data Plane Architecture</span></a> shows the class diagram of the data plane at
the eNB.</p>
<p>The main impact is the insertion of the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> class
in the middle of the LTE protocol stack. During the design phase it was
decided to keep the same SAP interfaces design that existed between MAC and RLC
in order to avoid unnecessary changes in these parts of protocol stack.
To achieve this the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> implements all functions
that were previously exposed by RLC to MAC through <code class="docutils literal notranslate"><span class="pre">LteMacSapUser</span></code> interface.
It also implements functions that were previously exposed by MAC to RLC through
the <code class="docutils literal notranslate"><span class="pre">LteMacSapProvider</span></code> interface. In this way, the carrier aggregation is
transparent to upper and lower layers. The only difference is that the MAC
instance sees now only one <code class="docutils literal notranslate"><span class="pre">LteMacSapUser</span></code>, whereas formerly it was seeing only
one <code class="docutils literal notranslate"><span class="pre">LteMacSapUser</span></code> per RLC instance.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> is responsible for the forwarding messages
in both directions. In the current implementation, a PDCP and a RLC instances are
activated each time a new data radio bearer is configured. The correspondence
between a new  data radio bearer and a RLC instance is one to one. In order to
maintain the same behavior, when a new logical channel is activated, the logical
channel configurations is propagated to each MAC layer object in “as is” fashion.</p>
<div class="figure align-center" id="id208">
<span id="fig-ca-enb-data-plane"></span><img alt="_images/ca-enb-data-plane.png" src="_images/ca-enb-data-plane.png" />
<p class="caption"><span class="caption-text">eNB Data Plane Architecture</span><a class="headerlink" href="#id208" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-ca-downlink-bsr"><span class="std std-ref">Sequence Diagram of downlink buffer status reporting (BSR) with CA</span></a> shows a sequence diagram of downlink buffer status
reporting with a carrier aggregation implementation of only one secondary carrier.
Each time that an RLC instance sends a buffer status report (BSR), the
<code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> propagates the BSR to the MAC instances.
The <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> may modify a BSR before sending it to the
MAC instances. This modification depends on the traffic split algorithm implemented
in CCM class that inherits <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>.</p>
<div class="figure align-center" id="id209">
<span id="fig-ca-downlink-bsr"></span><img alt="_images/ca-downlink-bsr.png" src="_images/ca-downlink-bsr.png" />
<p class="caption"><span class="caption-text">Sequence Diagram of downlink buffer status reporting (BSR) with CA</span><a class="headerlink" href="#id209" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="ca-impact-on-control-plane-of-enodeb">
<h4>CA impact on control plane of eNodeB<a class="headerlink" href="#ca-impact-on-control-plane-of-enodeb" title="Permalink to this headline">¶</a></h4>
<p>Figure <a class="reference internal" href="#fig-ca-enb-ctrl-plane"><span class="std std-ref">eNB Control Plane Architecture</span></a> shows the class diagram of the control plane
at the eNB. During the design phase it was decided to maintain the same hooks as in
the former architecture. To do so, at each component carrier the PHY and the MAC are
directly associated to the RRC instance. However, the RRC instance is additionally
connected to the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>, which is responsible for enabling
and disabling the component carriers. When the simulation starts, the number of
component carrier is fixed, but only the primary carrier component is enabled.
Depending on the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> algorithm the other carrier
components could be activated or not.</p>
<div class="figure align-center" id="id210">
<span id="fig-ca-enb-ctrl-plane"></span><img alt="_images/ca-enb-ctrl-plane.png" src="_images/ca-enb-ctrl-plane.png" />
<p class="caption"><span class="caption-text">eNB Control Plane Architecture</span><a class="headerlink" href="#id210" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-ca-setup-radio-bearer"><span class="std std-ref">Sequence Diagram of Data Radio Bearer Setup</span></a> shows how the Radio Bearer are configured.</p>
<div class="figure align-center" id="id211">
<span id="fig-ca-setup-radio-bearer"></span><a class="reference internal image-reference" href="_images/ca-setup-radio-bearer.png"><img alt="_images/ca-setup-radio-bearer.png" src="_images/ca-setup-radio-bearer.png" style="width: 921.6px; height: 844.2px;" /></a>
<p class="caption"><span class="caption-text">Sequence Diagram of Data Radio Bearer Setup</span><a class="headerlink" href="#id211" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="ca-impact-on-data-plane-of-ue">
<h4>CA impact on data plane of UE<a class="headerlink" href="#ca-impact-on-data-plane-of-ue" title="Permalink to this headline">¶</a></h4>
<p>Figure <a class="reference internal" href="#fig-ca-ue-data-plane"><span class="std std-ref">UE Data Plane Architecture</span></a> shows the relation between the different classes
related to the UE data plane. The UE data plane architecture is similar to the eNB data
plane implementation. The <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code> is responsible to (re)map
each <code class="docutils literal notranslate"><span class="pre">MacSapUserProvider</span></code> to the corresponding RLC instance or to the proper MAC
instance. The channel remapping depends on algorithm used as <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code>.
A particular case is represented by the UE buffer status report (BSR) to eNB.
Since, i) the standard does not specify how the BSR has to be reported on each component
carrier and ii) it is decided to map one-to-one the logical channel to each MAC layer,
the only way to send BSRs to the eNB is through the primary carrier.
Figure <a class="reference internal" href="#fig-ca-uplink-bsr"><span class="std std-ref">Uplink buffer status reporting with CA</span></a> shows the sequence diagram.
Each time a BSR is generated, the <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code> sends it through
the primary carrier component. When the primary component carrier at the eNB receives
the BSR, it sends it to <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>. The latter, according to
algorithm dependent policies, forwards a BSR to component carriers. The communication
between the <code class="docutils literal notranslate"><span class="pre">LteEnbMac</span></code> and  the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> is done through a
specific set of SAP functions which are implemented in the <code class="docutils literal notranslate"><span class="pre">LteUlCcmRrcSapUser</span></code> and
the <code class="docutils literal notranslate"><span class="pre">LteUlCcmRrcSapProvider</span></code>.</p>
<div class="figure align-center" id="id212">
<span id="fig-ca-ue-data-plane"></span><a class="reference internal image-reference" href="_images/ca-ue-data-plane.png"><img alt="_images/ca-ue-data-plane.png" src="_images/ca-ue-data-plane.png" style="width: 297.0px; height: 438.59999999999997px;" /></a>
<p class="caption"><span class="caption-text">UE Data Plane Architecture</span><a class="headerlink" href="#id212" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-center" id="id213">
<span id="fig-ca-uplink-bsr"></span><img alt="_images/ca-uplink-bsr.png" src="_images/ca-uplink-bsr.png" />
<p class="caption"><span class="caption-text">Uplink buffer status reporting with CA</span><a class="headerlink" href="#id213" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="ca-impact-on-control-plane-of-ue">
<h4>CA impact on control plane of UE<a class="headerlink" href="#ca-impact-on-control-plane-of-ue" title="Permalink to this headline">¶</a></h4>
<p>Figure <a class="reference internal" href="#fig-ca-ue-ctrl-plane"><span class="std std-ref">UE Control Plane Architecture</span></a> shows the relation between the different classes
associated to the UE control plane. The control plane implementation at the UE is basically
the same as the eNB control plane implementation. Each component carrier control SAP
(both for PHY and MAC layer objects) is linked in a one-to-one fashion directly to the RRC
instance. The Ue RRC instance is then connected to the <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code>
in the same way as in the eNB.</p>
<div class="figure align-center" id="id214">
<span id="fig-ca-ue-ctrl-plane"></span><a class="reference internal image-reference" href="_images/ca-ue-ctrl-plane.png"><img alt="_images/ca-ue-ctrl-plane.png" src="_images/ca-ue-ctrl-plane.png" style="width: 870.3000000000001px; height: 416.7px;" /></a>
<p class="caption"><span class="caption-text">UE Control Plane Architecture</span><a class="headerlink" href="#id214" title="Permalink to this image">¶</a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CCHelper</span></code> is the class that is implemented to help the configuration of the physical
layer parameters, such as uplink and downlink,bandwidth and EARFCN of each carrier.</p>
</div>
<div class="section" id="ccm-rrc-mac-interfaces">
<h4>CCM RRC MAC interfaces<a class="headerlink" href="#ccm-rrc-mac-interfaces" title="Permalink to this headline">¶</a></h4>
<p>The Component carrier manager (CCM) is also developed by using the SAP interface design.
The following SAP interfaces are implemented for CCM and MAC:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapUser</span></code> part is provided by MAC and is used by the CCM</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapProvider</span></code> part is provided by CCM and is used by the MAC layer</p></li>
</ul>
</div></blockquote>
<p>When the primary component carrier receives an uplink BSR it uses the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapUser</span></code>
to forward it to the CCM, which should decide how to split the traffic corresponding to
this BSR among carriers. Once this decision is made, the CCM uses the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapProvider</span></code>
interface to send back an uplink BSR to some of the MAC instances. Additionally,
the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapUser</span></code> can be used by the MAC to notify about the PRB occupancy
in the downlink to the CCM. This information may be used by the CCM to decide how
to split the traffic and whether to use the secondary carriers.</p>
</div></blockquote>
</div>
<div class="section" id="ccm-rrc-sap-interfaces">
<h4>CCM RRC SAP interfaces<a class="headerlink" href="#ccm-rrc-sap-interfaces" title="Permalink to this headline">¶</a></h4>
<p>The following SAP interfaces are implemented for CCM and RRC:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapProvider</span></code> is provided by the CCM and is used by the RRC layer</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapUser</span></code> is provided by RRC and is used by the CCM</p></li>
</ul>
</div></blockquote>
<p>By using the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapUser</span></code> the CCM may request a specific measurement reporting
configuration to be fulfilled by the UEs attached to the eNB. When a UE measurement
report is received, as a result of this configuration, the eNB RRC entity shall forward
this report to the CCM through the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapProvider::ReportUeMeas</span></code> SAP function.
Additionally, the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapProvider</span></code> offers different functions to the RRC that can
be used to add and remove of UEs, setup or release of radio bearer, configuration of the
signalling bearer, etc.</p>
</div>
<div class="section" id="component-carrier-managers">
<h4>Component carrier managers<a class="headerlink" href="#component-carrier-managers" title="Permalink to this headline">¶</a></h4>
<p>Currently, there are two component carrier manager implementations available. The first one
is the <code class="docutils literal notranslate"><span class="pre">NoOpComponentCarrierManager</span></code>, which  is the default CCM choice. When this CCM is
used the carrier aggregation feature is disabled. This CCM forwards all traffic, the uplink
and the downlink, over
the primary carrier, and does not use secondary carriers.
Another implementation is the <code class="docutils literal notranslate"><span class="pre">RrComponentCarrierManager</span></code>, which splits the traffic
equally among carriers, by diving the buffer status report among different carriers.
SRB0 and SRB1 flows will be forwarded only over primary carrier.</p>
</div>
</div>
</div>
<div class="section" id="helpers">
<h2>Helpers<a class="headerlink" href="#helpers" title="Permalink to this headline">¶</a></h2>
<p>Two helper objects are used to setup simulations and configure the
various components. These objects are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>, which takes care of the configuration of the LTE radio access network,
as well as of coordinating the setup and release of EPS bearers. The <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> class
provides both the API definition and its implementation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code>, which takes care of the configuration of the Evolved Packet Core. The
<code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> class is an abstract base class, which only provides the API definition;
the implementation is delegated to the child classes in order to allow for different
EPC network models.</p></li>
</ul>
</div></blockquote>
<p>A third helper object is used to configure the <span class="xref std std-ref">_sec-carrier-aggregation</span> functionality:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CcHelper</span></code>, which takes care of the configuration of the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierMap</span></code>,
basically, it creates a user specified number of <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrier</span></code>.
<code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierMap</span></code> is currently created starting from the
<code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierMap</span></code>. <code class="docutils literal notranslate"><span class="pre">LteHelper:InstallSingleUeDevice</span></code>,
in this implementation, is needed to invoke after the <code class="docutils literal notranslate"><span class="pre">LteHelper:InstallSingleEnbDevice</span></code>
to ensure that the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierMap</span></code> is properly initialized.</p></li>
</ul>
</div></blockquote>
<p>It is possible to create a simple LTE-only simulations by
using the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> alone, or to create complete LTE-EPC simulations by using both
<code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code>. When both helpers are used, they interact in a master-slave
fashion, with the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> being the Master that interacts directly with the user program,
and the <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> working “under the hood” to configure the EPC upon explicit methods
called by the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>. The exact interactions are displayed in the Figure <a class="reference internal" href="#fig-helpers"><span class="std std-ref">Sequence diagram of the interaction between LteHelper and EpcHelper.</span></a>.</p>
<div class="figure align-center" id="id215">
<span id="fig-helpers"></span><img alt="_images/helpers.png" src="_images/helpers.png" />
<p class="caption"><span class="caption-text">Sequence diagram of the interaction between <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code>.</span><a class="headerlink" href="#id215" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Design Documentation</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#design-criteria">Design Criteria</a><ul>
<li><a class="reference internal" href="#lte-model">LTE Model</a></li>
<li><a class="reference internal" href="#epc-model">EPC Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#architecture">Architecture</a><ul>
<li><a class="reference internal" href="#id6">LTE Model</a><ul>
<li><a class="reference internal" href="#ue-architecture">UE architecture</a></li>
<li><a class="reference internal" href="#enb-architecture">eNB architecture</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">EPC Model</a><ul>
<li><a class="reference internal" href="#epc-data-plane">EPC data plane</a></li>
<li><a class="reference internal" href="#epc-control-plane">EPC control plane</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#channel-and-propagation">Channel and Propagation</a><ul>
<li><a class="reference internal" href="#use-of-the-buildings-model-with-lte">Use of the Buildings model with LTE</a></li>
<li><a class="reference internal" href="#fading-model">Fading Model</a></li>
<li><a class="reference internal" href="#antennas">Antennas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phy">PHY</a><ul>
<li><a class="reference internal" href="#id13">Overview</a></li>
<li><a class="reference internal" href="#subframe-structure">Subframe Structure</a></li>
<li><a class="reference internal" href="#mac-to-channel-delay">MAC to Channel delay</a></li>
<li><a class="reference internal" href="#cqi-feedback">CQI feedback</a></li>
<li><a class="reference internal" href="#interference-model">Interference Model</a></li>
<li><a class="reference internal" href="#lte-spectrum-model">LTE Spectrum Model</a></li>
<li><a class="reference internal" href="#data-phy-error-model">Data PHY Error Model</a><ul>
<li><a class="reference internal" href="#miesm">MIESM</a></li>
<li><a class="reference internal" href="#bler-curves">BLER Curves</a></li>
<li><a class="reference internal" href="#integration-of-the-bler-curves-in-the-ns-3-lte-module">Integration of the BLER curves in the ns-3 LTE module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-channels-phy-error-model">Control Channels PHY Error Model</a><ul>
<li><a class="reference internal" href="#pcfich-pdcch-error-model">PCFICH + PDCCH Error Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mimo-model">MIMO Model</a></li>
<li><a class="reference internal" href="#ue-phy-measurements-model">UE PHY Measurements Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#harq">HARQ</a></li>
<li><a class="reference internal" href="#mac">MAC</a><ul>
<li><a class="reference internal" href="#resource-allocation-model">Resource Allocation Model</a></li>
<li><a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a></li>
<li><a class="reference internal" href="#transport-block-model">Transport Block model</a></li>
<li><a class="reference internal" href="#the-femtoforum-mac-scheduler-interface">The FemtoForum MAC Scheduler Interface</a><ul>
<li><a class="reference internal" href="#round-robin-rr-scheduler">Round Robin (RR) Scheduler</a></li>
<li><a class="reference internal" href="#proportional-fair-pf-scheduler">Proportional Fair (PF) Scheduler</a></li>
<li><a class="reference internal" href="#maximum-throughput-mt-scheduler">Maximum Throughput (MT) Scheduler</a></li>
<li><a class="reference internal" href="#throughput-to-average-tta-scheduler">Throughput to Average (TTA) Scheduler</a></li>
<li><a class="reference internal" href="#blind-average-throughput-scheduler">Blind Average Throughput Scheduler</a></li>
<li><a class="reference internal" href="#token-bank-fair-queue-scheduler">Token Bank Fair Queue Scheduler</a></li>
<li><a class="reference internal" href="#priority-set-scheduler">Priority Set Scheduler</a></li>
<li><a class="reference internal" href="#channel-and-qos-aware-scheduler">Channel and QoS Aware Scheduler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-access">Random Access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rlc">RLC</a><ul>
<li><a class="reference internal" href="#id70">Overview</a></li>
<li><a class="reference internal" href="#service-interfaces">Service Interfaces</a><ul>
<li><a class="reference internal" href="#rlc-service-interface">RLC Service Interface</a><ul>
<li><a class="reference internal" href="#rlc-service-primitives">RLC Service Primitives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mac-service-interface">MAC Service Interface</a><ul>
<li><a class="reference internal" href="#mac-service-primitives">MAC Service Primitives</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#am-rlc">AM RLC</a><ul>
<li><a class="reference internal" href="#buffers-for-the-transmit-operations">Buffers for the transmit operations</a></li>
<li><a class="reference internal" href="#transmit-operations-in-downlink">Transmit operations in downlink</a></li>
<li><a class="reference internal" href="#retransmission-in-downlink">Retransmission in downlink</a></li>
<li><a class="reference internal" href="#transmit-operations-in-uplink">Transmit operations in uplink</a></li>
<li><a class="reference internal" href="#retransmission-in-uplink">Retransmission in uplink</a></li>
<li><a class="reference internal" href="#calculation-of-the-buffer-size">Calculation of the buffer size</a></li>
<li><a class="reference internal" href="#concatenation-and-segmentation">Concatenation and Segmentation</a></li>
<li><a class="reference internal" href="#re-segmentation">Re-segmentation</a></li>
<li><a class="reference internal" href="#unsupported-features">Unsupported features</a></li>
</ul>
</li>
<li><a class="reference internal" href="#um-rlc">UM RLC</a><ul>
<li><a class="reference internal" href="#id81">Transmit operations in downlink</a></li>
<li><a class="reference internal" href="#id83">Transmit operations in uplink</a></li>
<li><a class="reference internal" href="#id84">Calculation of the buffer size</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tm-rlc">TM RLC</a><ul>
<li><a class="reference internal" href="#id85">Transmit operations in downlink</a></li>
<li><a class="reference internal" href="#id87">Transmit operations in uplink</a></li>
<li><a class="reference internal" href="#id88">Calculation of the buffer size</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sm-rlc">SM RLC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pdcp">PDCP</a><ul>
<li><a class="reference internal" href="#pdcp-model-overview">PDCP Model Overview</a></li>
<li><a class="reference internal" href="#pdcp-service-interface">PDCP Service Interface</a><ul>
<li><a class="reference internal" href="#pdcp-service-primitives">PDCP Service Primitives</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rrc">RRC</a><ul>
<li><a class="reference internal" href="#features">Features</a></li>
<li><a class="reference internal" href="#id91">Architecture</a></li>
<li><a class="reference internal" href="#ue-rrc-state-machine">UE RRC State Machine</a></li>
<li><a class="reference internal" href="#enb-rrc-state-machine">ENB RRC State Machine</a></li>
<li><a class="reference internal" href="#initial-cell-selection">Initial Cell Selection</a><ul>
<li><a class="reference internal" href="#cell-search">Cell Search</a></li>
<li><a class="reference internal" href="#broadcast-of-system-information">Broadcast of System Information</a></li>
<li><a class="reference internal" href="#cell-selection-evaluation">Cell Selection Evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#radio-admission-control">Radio Admission Control</a></li>
<li><a class="reference internal" href="#radio-bearer-configuration">Radio Bearer Configuration</a></li>
<li><a class="reference internal" href="#radio-link-failure">Radio Link Failure</a><ul>
<li><a class="reference internal" href="#rlf-detection-implementation">RLF detection implementation</a></li>
<li><a class="reference internal" href="#actions-upon-rlf">Actions upon RLF</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ue-rrc-measurements-model">UE RRC Measurements Model</a><ul>
<li><a class="reference internal" href="#ue-rrc-measurements-support">UE RRC measurements support</a></li>
<li><a class="reference internal" href="#overall-design">Overall design</a></li>
<li><a class="reference internal" href="#measurement-configuration">Measurement configuration</a></li>
<li><a class="reference internal" href="#performing-measurements">Performing measurements</a></li>
<li><a class="reference internal" href="#measurement-reporting-triggering">Measurement reporting triggering</a></li>
<li><a class="reference internal" href="#measurement-reporting">Measurement reporting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#handover">Handover</a><ul>
<li><a class="reference internal" href="#handover-algorithm">Handover algorithm</a></li>
<li><a class="reference internal" href="#no-op-handover-algorithm">No-op handover algorithm</a></li>
<li><a class="reference internal" href="#a2-a4-rsrq-handover-algorithm">A2-A4-RSRQ handover algorithm</a></li>
<li><a class="reference internal" href="#strongest-cell-handover-algorithm">Strongest cell handover algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#neighbour-relation">Neighbour Relation</a><ul>
<li><a class="reference internal" href="#neighbour-relation-table">Neighbour Relation Table</a></li>
<li><a class="reference internal" href="#role-of-anr-in-simulation">Role of ANR in Simulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rrc-sequence-diagrams">RRC sequence diagrams</a><ul>
<li><a class="reference internal" href="#rrc-connection-establishment">RRC connection establishment</a></li>
<li><a class="reference internal" href="#rrc-connection-reconfiguration">RRC connection reconfiguration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rrc-protocol-models">RRC protocol models</a><ul>
<li><a class="reference internal" href="#ideal-rrc-protocol-model">Ideal RRC protocol model</a></li>
<li><a class="reference internal" href="#real-rrc-protocol-model">Real RRC protocol model</a><ul>
<li><a class="reference internal" href="#signaling-radio-bearer-model">Signaling Radio Bearer model</a></li>
<li><a class="reference internal" href="#asn-1-encoding-of-rrc-ie-s">ASN.1 encoding of RRC IE’s</a></li>
<li><a class="reference internal" href="#asn1header-class-implementation-of-base-asn-1-types">Asn1Header class - Implementation of base ASN.1 types</a></li>
<li><a class="reference internal" href="#rrcasn1header-common-ies">RrcAsn1Header : Common IEs</a></li>
<li><a class="reference internal" href="#rrc-specific-messages-ies-classes">Rrc specific messages/IEs classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#nas">NAS</a></li>
<li><a class="reference internal" href="#s1-s5-and-s11">S1, S5 and S11</a><ul>
<li><a class="reference internal" href="#s1-u-and-s5-user-plane">S1-U and S5 (user plane)</a></li>
<li><a class="reference internal" href="#s1ap">S1AP</a></li>
<li><a class="reference internal" href="#s5-and-s11">S5 and S11</a></li>
</ul>
</li>
<li><a class="reference internal" href="#x2">X2</a><ul>
<li><a class="reference internal" href="#x2-interfaces">X2 interfaces</a><ul>
<li><a class="reference internal" href="#x2-c">X2-C</a></li>
<li><a class="reference internal" href="#x2-u">X2-U</a></li>
</ul>
</li>
<li><a class="reference internal" href="#x2-service-interface">X2 Service Interface</a><ul>
<li><a class="reference internal" href="#x2-c-primitives-for-handover-execution">X2-C primitives for handover execution</a></li>
<li><a class="reference internal" href="#x2-c-son-primitives">X2-C SON primitives</a></li>
<li><a class="reference internal" href="#unsupported-primitives">Unsupported primitives</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#s11">S11</a></li>
<li><a class="reference internal" href="#power-control">Power Control</a><ul>
<li><a class="reference internal" href="#downlink-power-control">Downlink Power Control</a></li>
<li><a class="reference internal" href="#uplink-power-control">Uplink Power Control</a><ul>
<li><a class="reference internal" href="#uplink-power-control-for-pusch">Uplink Power Control for PUSCH</a></li>
<li><a class="reference internal" href="#uplink-power-control-for-pucch">Uplink Power Control for PUCCH</a></li>
<li><a class="reference internal" href="#uplink-power-control-for-srs">Uplink Power Control for SRS</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#fractional-frequency-reuse">Fractional Frequency Reuse</a><ul>
<li><a class="reference internal" href="#id134">Overview</a></li>
<li><a class="reference internal" href="#supported-fr-algorithms">Supported FR algorithms</a><ul>
<li><a class="reference internal" href="#no-frequency-reuse">No Frequency Reuse</a></li>
<li><a class="reference internal" href="#hard-frequency-reuse">Hard Frequency Reuse</a></li>
<li><a class="reference internal" href="#strict-frequency-reuse">Strict Frequency Reuse</a></li>
<li><a class="reference internal" href="#soft-frequency-reuse">Soft Frequency Reuse</a></li>
<li><a class="reference internal" href="#soft-fractional-frequency-reuse">Soft Fractional Frequency Reuse</a></li>
<li><a class="reference internal" href="#enhanced-fractional-frequency-reuse">Enhanced Fractional Frequency Reuse</a></li>
<li><a class="reference internal" href="#distributed-fractional-frequency-reuse">Distributed Fractional Frequency Reuse</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#carrier-aggregation">Carrier Aggregation</a><ul>
<li><a class="reference internal" href="#id139">Overview</a><ul>
<li><a class="reference internal" href="#impact-on-rrc-layer">Impact on RRC layer</a></li>
<li><a class="reference internal" href="#impact-on-pcdcp-layer">Impact on PCDCP layer</a></li>
<li><a class="reference internal" href="#impact-on-rlc-layer">Impact on RLC layer</a></li>
<li><a class="reference internal" href="#impact-on-mac-layer">Impact on MAC layer</a></li>
<li><a class="reference internal" href="#impact-on-phy-layer">Impact on PHY layer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-structure-design">Code Structure Design</a><ul>
<li><a class="reference internal" href="#ca-impact-on-data-plane-of-enodeb">CA impact on data plane of eNodeB</a></li>
<li><a class="reference internal" href="#ca-impact-on-control-plane-of-enodeb">CA impact on control plane of eNodeB</a></li>
<li><a class="reference internal" href="#ca-impact-on-data-plane-of-ue">CA impact on data plane of UE</a></li>
<li><a class="reference internal" href="#ca-impact-on-control-plane-of-ue">CA impact on control plane of UE</a></li>
<li><a class="reference internal" href="#ccm-rrc-mac-interfaces">CCM RRC MAC interfaces</a></li>
<li><a class="reference internal" href="#ccm-rrc-sap-interfaces">CCM RRC SAP interfaces</a></li>
<li><a class="reference internal" href="#component-carrier-managers">Component carrier managers</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#helpers">Helpers</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="lte.html"
                        title="previous chapter">LTE Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="lte-user.html"
                        title="next chapter">User Documentation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/lte-design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="lte-user.html" title="User Documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="lte.html" title="LTE Module"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="lte.html" >LTE Module</a><span class="navelem">&nbsp;</span></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2019.
      Last updated on Apr 29, 2020 17:37.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.2.
    </div>
  </body>
</html>