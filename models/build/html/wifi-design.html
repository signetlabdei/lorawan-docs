
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>35.1. Design Documentation &#8212; Model Library</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/default.css?v=bb97339c" />
    <script src="_static/documentation_options.js?v=316584e3"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="35.2. User Documentation" href="wifi-user.html" />
    <link rel="prev" title="35. Wi-Fi Module" href="wifi.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico"
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>


  </head><body>
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" width="100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo">
              <a id="ns3_home1"
                 href="http://www.nsnam.org/">
                 <img alt="ns-3 Logo" style="background-color: unset;"
                      src="_static/ns-3-inverted-notext-small.png"/>
              </a>
            </td>
            <td id="projecttext">
              <div id="projectbrief">A Discrete-Event Network Simulator</div>
              <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
            </td>

            <td id="ns3-menu">
              <div class="menu">
                <ul >
                  <li style="background-image:none">
                    <a id="ns3_home2"
                         href="http://www.nsnam.org/"
                         >&nbsp;&nbsp;Home</a>
                  </li>
                  <li><span
                        onmouseover="mopen('mTuts')"
                        onmouseout="mclosetime()"
                          >Tutorials &nbsp;&#x25BC;</span>
                      <div id="mTuts"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_tut"
                           href="/docs/tutorial/html/index.html"
                            >English</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDocs')"
                        onmouseout="mclosetime()"
                          >Documentation &nbsp;&#x25BC;</span>
                      <div id="mDocs"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_ins"
                           href="/docs/installation/html/index.html"
                           >Installation</a><br/>
                        <a id="ns3_man"
                           href="/docs/manual/html/index.html"
                           >Manual</a><br/>
                        <a id="ns3_mod"
                           href="/docs/models/html/index.html"
                           >Models</a><br/>
                        <a id="ns3_con"
                           href="/docs/contributing/html/index.html"
                           >Contributing</a><br/>
                        <a id="ns3_wiki"
                           href="http://www.nsnam.org/wiki"
                           >Wiki</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDev')"
                        onmouseout="mclosetime()"
                          >Development &nbsp;&#x25BC;</span>
                      <div id="mDev"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_api"
                           href="/docs/doxygen/html/index.html"
                           >API Docs</a><br/>
                        <a id="ns3_bugs"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/issues"
                           >Issue Tracker</a><br/>
                        <a id="ns3_merge"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests"
                           >Merge Requests</a><br/>
                      </div>
                  </li>
                </ul>
              </div>
            </td>

            <td id="projectsection">
              <span style="margin-right:10px">Models</span>
            </td>
          </tr>
        </tbody>
      </table>
      <script  type="text/javascript">ns3_write_links()</script>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="wifi-user.html" title="35.2. User Documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wifi.html" title="35. Wi-Fi Module"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="wifi.html" accesskey="U"><span class="section-number">35. </span>Wi-Fi Module</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">35.1. </span>Design Documentation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="design-documentation">
<h1><span class="section-number">35.1. </span>Design Documentation<a class="headerlink" href="#design-documentation" title="Link to this heading">¶</a></h1>
<p><em>ns-3</em> nodes can contain a collection of NetDevice objects, much like an actual
computer contains separate interface cards for Ethernet, Wifi, Bluetooth, etc.
This chapter describes the <em>ns-3</em> WifiNetDevice and related models. By adding
WifiNetDevice objects to <em>ns-3</em> nodes, one can create models of 802.11-based
infrastructure and ad hoc networks.</p>
<section id="overview-of-the-model">
<h2><span class="section-number">35.1.1. </span>Overview of the model<a class="headerlink" href="#overview-of-the-model" title="Link to this heading">¶</a></h2>
<p>The WifiNetDevice models a wireless network interface controller based
on the IEEE 802.11 standard <a class="reference internal" href="wifi-references.html#ieee80211" id="id1"><span>[ieee80211]</span></a>. We will go into more detail below but in brief,
<em>ns-3</em> provides models for these aspects of 802.11:</p>
<ul class="simple">
<li><p>basic 802.11 DCF with <strong>infrastructure</strong> and <strong>adhoc</strong> modes</p></li>
<li><p><strong>802.11a</strong>, <strong>802.11b</strong>, <strong>802.11g</strong>, <strong>802.11n</strong> (both 2.4 and 5 GHz bands), <strong>802.11ac</strong>, <strong>802.11ax</strong> (2.4, 5 and 6 GHz bands) and <strong>802.11be</strong> physical layers</p></li>
<li><p><strong>MSDU aggregation</strong> and <strong>MPDU aggregation</strong> extensions of 802.11n, and both can be combined together (two-level aggregation)</p></li>
<li><p>802.11ax <strong>DL OFDMA</strong> and <strong>UL OFDMA</strong> (including support for the MU EDCA Parameter Set)</p></li>
<li><p>802.11be <strong>Multi-link</strong> discovery and setup</p></li>
<li><p>QoS-based EDCA and queueing extensions of <strong>802.11e</strong></p></li>
<li><p>the ability to use different propagation loss models and propagation delay models,
please see the chapter on <a class="reference internal" href="propagation.html#propagation"><span class="std std-ref">Propagation</span></a> for more detail</p></li>
<li><p>packet error models and frame detection models that have been validated
against link simulations and other references</p></li>
<li><p>various rate control algorithms including <strong>Aarf, Arf, Cara, Onoe, Rraa,
ConstantRate, Minstrel and Minstrel-HT</strong></p></li>
<li><p>802.11s (mesh), described in another chapter</p></li>
<li><p>802.11p and WAVE (vehicular), described in another chapter</p></li>
</ul>
<p>The set of 802.11 models provided in <em>ns-3</em> attempts to provide an accurate
MAC-level implementation of the 802.11 specification and to provide a
packet-level abstraction of the PHY-level for different PHYs, corresponding to
802.11a/b/e/g/n/ac/ax/be specifications.</p>
<p>In <em>ns-3</em>, nodes can have multiple WifiNetDevices on separate channels, and the
WifiNetDevice can coexist with other device types.
With the use of the <strong>SpectrumWifiPhy</strong> framework, one can also build scenarios
involving cross-channel interference or multiple wireless technologies on
a single channel.</p>
<p>The source code for the WifiNetDevice and its models lives in the directory
<code class="docutils literal notranslate"><span class="pre">src/wifi</span></code>.</p>
<p>The implementation is modular and provides roughly three sublayers of models:</p>
<ul class="simple">
<li><p>the <strong>PHY layer models</strong>: they model amendment-specific and common
PHY layer operations and functions.</p></li>
<li><p>the so-called <strong>MAC low models</strong>: they model functions such as medium
access (DCF and EDCA), frame protection (RTS/CTS) and acknowledgment (ACK/BlockAck).
In <em>ns-3</em>, the lower-level MAC is comprised of a <strong>Frame Exchange Manager</strong> hierarchy,
a <strong>Channel Access Manager</strong> and a <strong>MAC middle</strong> entity.</p></li>
<li><p>the so-called <strong>MAC high models</strong>: they implement non-time-critical processes
in Wifi such as the MAC-level beacon generation, probing, and association
state machines, and a set of <strong>Rate control algorithms</strong>.  In the literature,
this sublayer is sometimes called the <strong>upper MAC</strong> and consists of more
software-oriented implementations vs. time-critical hardware implementations.</p></li>
</ul>
<p>Next, we provide a design overview of each layer, shown in
Figure <a class="reference internal" href="#wifi-architecture"><span class="std std-ref">WifiNetDevice architecture</span></a>. For 802.11be Multi-Link Devices (MLDs),
there as many instances of WifiPhy, FrameExchangeManager and ChannelAccessManager
as the number of links.</p>
<figure class="align-default" id="id39">
<span id="wifi-architecture"></span><img alt="_images/WifiArchitecture.png" src="_images/WifiArchitecture.png" />
<figcaption>
<p><span class="caption-text"><em>WifiNetDevice architecture</em></span><a class="headerlink" href="#id39" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="mac-high-models">
<h3><span class="section-number">35.1.1.1. </span>MAC high models<a class="headerlink" href="#mac-high-models" title="Link to this heading">¶</a></h3>
<p>There are presently three <strong>MAC high models</strong> that provide for the three
(non-mesh; the mesh equivalent, which is a sibling of these with common
parent <code class="docutils literal notranslate"><span class="pre">ns3::WifiMac</span></code>, is not discussed here) Wi-Fi topological
elements - Access Point (AP) (<code class="docutils literal notranslate"><span class="pre">ns3::ApWifiMac</span></code>),
non-AP Station (STA) (<code class="docutils literal notranslate"><span class="pre">ns3::StaWifiMac</span></code>), and STA in an Independent
Basic Service Set (IBSS) - also commonly referred to as an ad hoc
network (<code class="docutils literal notranslate"><span class="pre">ns3::AdhocWifiMac</span></code>).</p>
<p>The simplest of these is <code class="docutils literal notranslate"><span class="pre">ns3::AdhocWifiMac</span></code>, which implements a
Wi-Fi MAC that does not perform any kind of beacon generation,
probing, or association. The <code class="docutils literal notranslate"><span class="pre">ns3::StaWifiMac</span></code> class implements
an active probing and association state machine that handles automatic
re-association whenever too many beacons are missed. Finally,
<code class="docutils literal notranslate"><span class="pre">ns3::ApWifiMac</span></code> implements an AP that generates periodic
beacons, and that accepts every attempt to associate.</p>
<p>These three MAC high models share a common parent in
<code class="docutils literal notranslate"><span class="pre">ns3::WifiMac</span></code>, which exposes, among other MAC
configuration, an attribute <code class="docutils literal notranslate"><span class="pre">QosSupported</span></code> that allows
configuration of 802.11e/WMM-style QoS support.</p>
<p>There are also several <strong>rate control algorithms</strong> that can be used by the
MAC low layer.  A complete list of available rate control algorithms is
provided in a separate section.</p>
</section>
<section id="mac-low-layer">
<h3><span class="section-number">35.1.1.2. </span>MAC low layer<a class="headerlink" href="#mac-low-layer" title="Link to this heading">¶</a></h3>
<p>The <strong>MAC low layer</strong> is split into three main components:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::FrameExchangeManager</span></code> a class hierarchy which implement the frame exchange
sequences introduced by the supported IEEE 802.11 amendments. It also handles
frame aggregation, frame retransmissions, protection and acknowledgment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::ChannelAccessManager</span></code> which implements the DCF and EDCAF
functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Txop</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::QosTxop</span></code> which handle the packet queue.
The <code class="docutils literal notranslate"><span class="pre">ns3::Txop</span></code> object is used by high MACs that are not QoS-enabled,
and for transmission of frames (e.g., of type Management)
that the standard says should access the medium using the DCF.
<code class="docutils literal notranslate"><span class="pre">ns3::QosTxop</span></code> is used by QoS-enabled high MACs.</p></li>
</ol>
</section>
<section id="phy-layer-models">
<h3><span class="section-number">35.1.1.3. </span>PHY layer models<a class="headerlink" href="#phy-layer-models" title="Link to this heading">¶</a></h3>
<p>In short, the physical layer models are mainly responsible for modeling
the reception of packets and for tracking energy consumption.  There
are typically three main components to packet reception:</p>
<ul class="simple">
<li><p>each packet received is probabilistically evaluated for successful or
failed reception.  The probability depends on the modulation, on
the signal to noise (and interference) ratio for the packet, and on
the state of the physical layer (e.g. reception is not possible while
transmission or sleeping is taking place);</p></li>
<li><p>an object exists to track (bookkeeping) all received signals so that
the correct interference power for each packet can be computed when
a reception decision has to be made; and</p></li>
<li><p>one or more error models corresponding to the modulation and standard
are used to look up probability of successful reception.</p></li>
</ul>
<p><em>ns-3</em> offers users a choice between two physical layer models, with a
base interface defined in the <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> class.  The YansWifiPhy
class implements a simple physical layer model, which is described
in a paper entitled
<a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/1190455.1190467?download=true">Yet Another Network Simulator</a>
The acronym <em>Yans</em> derives from this paper title.  The SpectrumWifiPhy
class is a more advanced implementation based on the Spectrum framework
used for other <em>ns-3</em> wireless models.  Spectrum allows a fine-grained
frequency decomposition of the signal, and permits scenarios to
include multiple technologies coexisting on the same channel.</p>
</section>
</section>
<section id="scope-and-limitations">
<h2><span class="section-number">35.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h2>
<p>The IEEE 802.11 standard <a class="reference internal" href="wifi-references.html#ieee80211" id="id2"><span>[ieee80211]</span></a> is a large specification,
and not all aspects are covered by <em>ns-3</em>; the documentation of <em>ns-3</em>’s
conformance by itself would lead to a very long document.  This section
attempts to summarize compliance with the standard and with behavior
found in practice.</p>
<p>The physical layer and channel models operate on a per-packet basis, with
no frequency-selective propagation nor interference effects when using
the default YansWifiPhy model.  Directional antennas are also not
supported at this time.  For additive white Gaussian noise (AWGN)
scenarios, or wideband interference scenarios, performance is governed
by the application of analytical models (based on modulation and factors
such as channel width) to the received signal-to-noise ratio, where noise
combines the effect of thermal noise and of interference from other Wi-Fi
packets.  Interference from other wireless technologies is only modeled
when the SpectrumWifiPhy is used.
The following details pertain to the physical layer and channel models:</p>
<ul class="simple">
<li><p>802.11n/ac/ax/be beamforming is not supported</p></li>
<li><p>802.11n RIFS is not supported</p></li>
<li><p>802.11 PCF/HCF/HCCA are not implemented</p></li>
<li><p>Channel Switch Announcement is not supported</p></li>
<li><p>Authentication and encryption are missing</p></li>
<li><p>Processing delays are not modeled</p></li>
<li><p>Cases where RTS/CTS and ACK are transmitted using HT/VHT/HE/EHT formats are not supported</p></li>
<li><p>Energy consumption model does not consider MIMO</p></li>
<li><p>802.11ax preamble puncturing is supported by the PHY but is currently not exploited by the MAC</p></li>
<li><p>Only minimal MU-MIMO is supported (ideal PHY assumed, no MAC layer yet)</p></li>
</ul>
<p>At the MAC layer, most of the main functions found in deployed Wi-Fi
equipment for 802.11a/b/e/g/n/ac/ax/be are implemented, but there are scattered instances
where some limitations in the models exist. Support for 802.11n, ac, ax and be is evolving.</p>
<p>Some implementation choices that are not imposed by the standard are listed below:</p>
<ul class="simple">
<li><p>BSSBasicRateSet for 802.11b has been assumed to be 1-2 Mbit/s</p></li>
<li><p>BSSBasicRateSet for 802.11a/g has been assumed to be 6-12-24 Mbit/s</p></li>
<li><p>OperationalRateSet is assumed to contain all mandatory rates (see
<a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/183">issue 183</a>)</p></li>
<li><p>The wifi manager always selects the lowest basic rate for management frames.</p></li>
</ul>
</section>
<section id="design-details">
<h2><span class="section-number">35.1.3. </span>Design Details<a class="headerlink" href="#design-details" title="Link to this heading">¶</a></h2>
<p>The remainder of this section is devoted to more in-depth design descriptions
of some of the Wi-Fi models.  Users interested in skipping to the section
on usage of the wifi module (<a class="reference internal" href="wifi-user.html#sec-wifi-user-doc"><span class="std std-ref">User Documentation</span></a>) may do so at this point.
We organize these more detailed sections from the bottom-up, in terms of
layering, by describing the channel and PHY models first, followed by
the MAC models.</p>
<p>We focus first on the choice between physical layer frameworks.  <em>ns-3</em>
contains support for a Wi-Fi-only physical layer model called YansWifiPhy
that offers no frequency-level decomposition of the signal.  For simulations
that involve only Wi-Fi signals on the Wi-Fi channel, and that do not
involve frequency-dependent propagation loss or fading models, the default
YansWifiPhy framework is a suitable choice.  For simulations involving
mixed technologies on the same channel, or frequency dependent effects,
the SpectrumWifiPhy is more appropriate.  The two frameworks are very
similarly configured.</p>
<p>The SpectrumWifiPhy framework uses the <a class="reference internal" href="spectrum.html#sec-spectrum-module"><span class="std std-ref">Spectrum Module</span></a> channel
framework.</p>
<p>The YansWifiChannel is the only concrete channel model class in
the <em>ns-3</em> wifi module.  The
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code> implementation uses the propagation loss and
delay models provided within the <em>ns-3</em> <a class="reference internal" href="propagation.html#propagation"><span class="std std-ref">Propagation</span></a> module.
In particular, a number of propagation models can be added (chained together,
if multiple loss models are added) to the channel object, and a propagation
delay model also added. Packets sent from a <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> object
onto the channel with a particular signal power, are copied to all of the
other <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> objects after the signal power is reduced due
to the propagation loss model(s), and after a delay corresponding to
transmission (serialization) delay and propagation delay due to
any channel propagation delay model (typically due to speed-of-light
delay between the positions of the devices).</p>
<p>Only objects of <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> may be attached to a
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code>; therefore, objects modeling other
(interfering) technologies such as LTE are not allowed. Furthermore,
packets from different channels do not interact; if a channel is logically
configured for e.g. channels 5 and 6, the packets do not cause
adjacent channel interference (even if their channel numbers overlap).</p>
<section id="wifiphy-and-related-models">
<h3><span class="section-number">35.1.3.1. </span>WifiPhy and related models<a class="headerlink" href="#wifiphy-and-related-models" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> is an abstract base class representing the 802.11
physical layer functions.  Packets passed to this object (via a
<code class="docutils literal notranslate"><span class="pre">Send()</span></code> method) are sent over a channel object, and
upon reception, the receiving PHY object decides (based on signal power
and interference) whether the packet was successful or not.  This class
also provides a number of callbacks for notifications of physical layer
events, exposes a notion of a state machine that can be monitored for
MAC-level processes such as carrier sense, and handles sleep/wake/off models
and energy consumption.  The <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> hooks to the <code class="docutils literal notranslate"><span class="pre">ns3::FrameExchangeManager</span></code>
object in the WifiNetDevice.</p>
<p>There are currently two implementations of the <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code>: the
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> and the <code class="docutils literal notranslate"><span class="pre">ns3::SpectrumWifiPhy</span></code>.  They each work in
conjunction with five other objects:</p>
<ul class="simple">
<li><p><strong>PhyEntity</strong>: Contains the amendment-specific part of the PHY processing</p></li>
<li><p><strong>WifiPpdu</strong>: Models the amendment-specific PHY protocol data unit (PPDU)</p></li>
<li><p><strong>WifiPhyStateHelper</strong>:  Maintains the PHY state machine</p></li>
<li><p><strong>InterferenceHelper</strong>:  Tracks all packets observed on the channel</p></li>
<li><p><strong>ErrorModel</strong>:  Computes a probability of error for a given SNR</p></li>
</ul>
<section id="phyentity">
<h4><span class="section-number">35.1.3.1.1. </span>PhyEntity<a class="headerlink" href="#phyentity" title="Link to this heading">¶</a></h4>
<section id="a-bit-of-background">
<h5><span class="section-number">35.1.3.1.1.1. </span>A bit of background<a class="headerlink" href="#a-bit-of-background" title="Link to this heading">¶</a></h5>
<p>Some restructuring of <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::WifiMode</span></code> (among others) was necessary
considering the size and complexity of the corresponding files.
In addition, adding and maintaining new PHY amendments had become a complex
task (especially those implemented inside other modules, e.g. DMG).
The adopted solution was to have <code class="docutils literal notranslate"><span class="pre">PhyEntity</span></code> classes that contain the “clause”
specific (i.e. HT/VHT/HE/EHT etc) parts of the PHY process.</p>
<p>The notion of “PHY entity” is in the standard at the beginning of each PHY
layer description clause, e.g. section 21.1.1 of IEEE 802.11-2016:</p>
<p>::
Clause 21 specifies the <strong>PHY entity</strong> for a very high throughput (VHT) orthogonal
frequency division multiplexing (OFDM) system.</p>
<p><em>Note that there is already such a name inside the wave module
(e.g. ``WaveNetDevice::AddPhy``) to designate the WifiPhys on each 11p channel,
but the wording is only used within the classes and there is no file using
that name, so no ambiguity in using the name for 802.11 amendments.</em></p>
</section>
<section id="architecture">
<h5><span class="section-number">35.1.3.1.1.2. </span>Architecture<a class="headerlink" href="#architecture" title="Link to this heading">¶</a></h5>
<p>The abstract base class <code class="docutils literal notranslate"><span class="pre">ns3::PhyEntity</span></code> enables to have a unique set of APIs
to be used by each PHY entity, corresponding to the different amendments of
the IEEE 802.11 standard. The currently implemented PHY entities are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::DsssPhy</span></code>: PHY entity for DSSS and HR/DSSS (11b)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::OfdmPhy</span></code>: PHY entity for OFDM (11a and 11p)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::ErpOfdmPhy</span></code>: PHY entity for ERP-OFDM (11g)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HtPhy</span></code>: PHY entity for HT (11n)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::VhtPhy</span></code>: PHY entity for VHT (11ac)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HePhy</span></code>: PHY entity for HE (11ax)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::EhtPhy</span></code>: PHY entity for EHT (11be)</p></li>
</ul>
<p>Their inheritance diagram is given in Figure <a class="reference internal" href="#phyentity-hierarchy"><span class="std std-ref">PhyEntity hierarchy</span></a> and
closely follows the standard’s logic, e.g. section 21.1.1 of IEEE 802.11-2016:</p>
<p>::
The VHT PHY is <strong>based</strong> on the HT PHY defined in Clause 19, which <strong>in turn</strong>
is <strong>based</strong> on the OFDM PHY defined in Clause 17.</p>
<figure class="align-default" id="id40">
<span id="phyentity-hierarchy"></span><img alt="_images/PhyEntityHierarchy.png" src="_images/PhyEntityHierarchy.png" />
<figcaption>
<p><span class="caption-text"><em>PhyEntity hierarchy</em></span><a class="headerlink" href="#id40" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Such an architecture enables to handle the following operations in an amendment-
specific manner:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WifiMode</span></code> handling and data/PHY rate computation,</p></li>
<li><p>PPDU field size and duration computation, and</p></li>
<li><p>Transmit and receive paths.</p></li>
</ul>
</section>
</section>
<section id="wifippdu">
<h4><span class="section-number">35.1.3.1.2. </span>WifiPpdu<a class="headerlink" href="#wifippdu" title="Link to this heading">¶</a></h4>
<p>In the same vein as <code class="docutils literal notranslate"><span class="pre">PhyEntity</span></code>, the <code class="docutils literal notranslate"><span class="pre">ns3::WifiPpdu</span></code> base class has been
specialized into the following amendment-specific PPDUs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::DsssPpdu</span></code>: PPDU for DSSS and HR/DSSS (11b)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::OfdmPpdu</span></code>: PPDU for OFDM (11a and 11p)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::ErpOfdmPpdu</span></code>: PPDU for ERP-OFDM (11g)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HtPpdu</span></code>: PPDU for HT (11n)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::VhtPpdu</span></code>: PPDU for VHT (11ac)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HePpdu</span></code>: PPDU for HE (11ax)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::EhtPpdu</span></code>: PPDU for EHT (11be)</p></li>
</ul>
<p>Their inheritance diagram is given in Figure <a class="reference internal" href="#wifippdu-hierarchy"><span class="std std-ref">WifiPpdu hierarchy</span></a> and
closely follows the standard’s logic, e.g. section 21.3.8.1 of IEEE 802.11-2016:</p>
<p>::
To maintain compatibility with non-VHT STAs, specific non-VHT fields are defined
that can be received by non-VHT STAs compliant with <strong>Clause 17</strong> [OFDM] or <strong>Clause 19</strong> [HT].</p>
<figure class="align-default" id="id41">
<span id="wifippdu-hierarchy"></span><img alt="_images/WifiPpduHierarchy.png" src="_images/WifiPpduHierarchy.png" />
<figcaption>
<p><span class="caption-text"><em>WifiPpdu hierarchy</em></span><a class="headerlink" href="#id41" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="yanswifiphy-and-wifiphystatehelper">
<h4><span class="section-number">35.1.3.1.3. </span>YansWifiPhy and WifiPhyStateHelper<a class="headerlink" href="#yanswifiphy-and-wifiphystatehelper" title="Link to this heading">¶</a></h4>
<p>Class <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> is responsible for taking packets passed to
it from the MAC (the <code class="docutils literal notranslate"><span class="pre">ns3::FrameExchangeManager</span></code> object) and sending them onto the
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code> to which it is attached.  It is also responsible
to receive packets from that channel, and, if reception is deemed to have
been successful, to pass them up to the MAC.</p>
<p>The energy of the signal intended to be received is
calculated from the transmission power and adjusted based on the Tx gain
of the transmitter, Rx gain of the receiver, and any path loss propagation
model in effect.</p>
<p>Class <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhyStateHelper</span></code> manages the state machine of the PHY
layer, and allows other objects to hook as <em>listeners</em> to monitor PHY
state.  The main use of listeners is for the MAC layer to know when
the PHY is busy or not (for transmission and collision avoidance).</p>
<p>The PHY layer can be in one of these states:</p>
<ol class="arabic simple">
<li><p>TX: the PHY is currently transmitting a signal on behalf of its associated
MAC</p></li>
<li><p>RX: the PHY is synchronized on a signal and is waiting until it has received
its last bit to forward it to the MAC.</p></li>
<li><p>CCA_BUSY: the PHY is issuing a PHY-CCA.indication(BUSY) indication for the primary channel.</p></li>
<li><p>IDLE: the PHY is not in the TX, RX, or CCA_BUSY states.</p></li>
<li><p>SWITCHING: the PHY is switching channels.</p></li>
<li><p>SLEEP: the PHY is in a power save mode and cannot send nor receive frames.</p></li>
<li><p>OFF: the PHY is powered off and cannot send nor receive frames.</p></li>
</ol>
<p>Packet reception works as follows.  For <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, most of the logic
is implemented in the <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code> base class.  The <code class="docutils literal notranslate"><span class="pre">YansWifiChannel</span></code> calls
<code class="docutils literal notranslate"><span class="pre">WifiPhy::StartReceivePreamble</span> <span class="pre">()</span></code>. The latter calls
<code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceivePreamble</span> <span class="pre">()</span></code> of the appropriate PHY entity
to start packet reception, but first
there is a check of the packet’s notional signal power level against a
threshold value stored in the attribute <code class="docutils literal notranslate"><span class="pre">WifiPhy::RxSensitivity</span></code>.  Any
packet with a power lower than RxSensitivity will be dropped with no
further processing.  The default value is -101 dBm, which is the thermal
noise floor for 20 MHz signal at room temperature.  The purpose of this
attribute is two-fold:  1) very weak signals that will not affect the
outcome will otherwise consume simulation memory and event processing, so
they are discarded, and 2) this value can be adjusted upwards to function as
a basic carrier sense threshold limitation for experiments involving
spatial reuse considerations.  Users are cautioned about the behavior of
raising this threshold; namely, that all packets with power below this
threshold will be discarded upon reception.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">StartReceivePreamble</span> <span class="pre">()</span></code>, the packet is immediately added
to the interference helper for signal-to-noise
tracking, and then further reception steps are decided upon the state of
the PHY.  In the case that the PHY is transmitting, for instance, the
packet will be dropped.  If the PHY is IDLE, or if the PHY is receiving and
an optional FrameCaptureModel is being used (and the packet is within
the capture window), then <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartPreambleDetectionPeriod</span> <span class="pre">()</span></code> is called next.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartPreambleDetectionPeriod</span> <span class="pre">()</span></code> will typically schedule an event,
<code class="docutils literal notranslate"><span class="pre">PhyEntity::EndPreambleDetectionPeriod</span> <span class="pre">()</span></code>, to occur at
the notional end of the first OFDM symbol, to check whether the preamble
has been detected.  As of revisions to the model in ns-3.30, any state
machine transitions from IDLE state are suppressed until after the preamble
detection event.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PhyEntity::EndPreambleDetectionPeriod</span> <span class="pre">()</span></code> method will check, with a preamble detection
model, whether the signal is strong enough to be received, and if so,
an event <code class="docutils literal notranslate"><span class="pre">PhyEntity::EndReceiveField</span> <span class="pre">()</span></code> is scheduled for the end of the
preamble and the PHY is put into the CCA_BUSY state. Currently, there is only a
simple threshold-based preamble detection model in ns-3,
called <code class="docutils literal notranslate"><span class="pre">ThresholdPreambleDetectionModel</span></code>.  If there is no preamble detection
model, the preamble is assumed to have been detected.
It is important to note that, starting with the ns-3.30 release, the default
in the WifiPhyHelper is to add the <code class="docutils literal notranslate"><span class="pre">ThresholdPreambleDetectionModel</span></code> with
a threshold RSSI of -82 dBm, and a threshold SNR of 4 dB.  Both the RSSI
and SNR must be above these respective values for the preamble to be
successfully detected.  The default sensitivity has been reduced in ns-3.30
compared with that of previous releases, so some packet receptions that were
previously successful will now fail on this check.  More details on the
modeling behind this change are provided in <a class="reference internal" href="wifi-references.html#lanante2019" id="id3"><span>[lanante2019]</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PhyEntity::EndReceiveField</span> <span class="pre">()</span></code> method will check the correct reception
of the current preamble and header field and, if so, calls <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceiveField</span> <span class="pre">()</span></code>
for the next field,
otherwise the reception is aborted and PHY is put either in IDLE state or in CCA_BUSY state,
depending on whether a PHY-CCA.indication(BUSY) is being issued on not for the primary channel
.</p>
<p>The next event at <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceiveField</span> <span class="pre">()</span></code> checks, using the interference
helper and error model, whether the header was successfully decoded, and if so,
a <code class="docutils literal notranslate"><span class="pre">PhyRxPayloadBegin</span></code> callback (equivalent to the PHY-RXSTART primitive)
is triggered. The PHY header is often transmitted
at a lower modulation rate than is the payload. The portion of the packet
corresponding to the PHY header is evaluated for probability of error
based on the observed SNR.  The InterferenceHelper object returns a value
for “probability of error (PER)” for this header based on the SNR that has
been tracked by the InterferenceHelper.  The <code class="docutils literal notranslate"><span class="pre">PhyEntity</span></code> then draws
a random number from a uniform distribution and compares it against the
PER and decides success or failure.</p>
<p>This is iteratively performed up to the beginning of the data field
upon which <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceivePayload</span> <span class="pre">()</span></code> is called.</p>
<p>Even if packet objects received by the PHY are not part of the reception
process, they are tracked by the InterferenceHelper object for purposes
of SINR computation and making clear channel assessment decisions.
If, in the course of reception, a packet is errored or dropped due to
the PHY being in a state in which it cannot receive a packet, the packet
is added to the interference helper, and the aggregate of the energy of
all such signals is compared against an energy detection threshold to
determine whether the PHY should enter a CCA_BUSY state.</p>
<p>A PHY-CCA.indication(BUSY) is issued if a signal occupying the primary channel with a received
power above <code class="docutils literal notranslate"><span class="pre">WifiPhy::CcaSensitivity</span></code> (defaulted to -82 dBm) has been received by the PHY or if the
measured energy on the primary channel is higher than the energy detection threshold <code class="docutils literal notranslate"><span class="pre">WifiPhy::CcaEdThreshold</span></code>
(defaulted to -62 dBm).</p>
<p>When channel bonding is used, CCA indication for signals not occupying the primary channel is also reported.
Since 802.11ac and above needs to sense CCA sensitivity for secondary channels larger than 20 MHz, CCA sensitivity thresholds
can be adjusted per secondary channel width using <code class="docutils literal notranslate"><span class="pre">VhtConfiguration::SecondaryCcaSensitivityThresholds</span></code> attribute.</p>
<p>For 802.11ax and above, and if the operational bandwidth is equal or larger than 40 MHz, each 20 MHz subchannel of the operational bandwidth
is being sensed and PHY-CCA.indication also reports a CCA_BUSY duration indication for each of these 20 MHz subchannel. A zero duration for
a given 20 MHz subchannel indicates the 20 MHz subchannel is IDLE.</p>
<p>The above describes the case in which the packet is a single MPDU.  For
more recent Wi-Fi standards using MPDU aggregation, <code class="docutils literal notranslate"><span class="pre">StartReceivePayload</span></code>
schedules an event for reception of each individual MPDU (<code class="docutils literal notranslate"><span class="pre">ScheduleEndOfMpdus</span></code>),
which then forwards each MPDU as they arrive up to FrameExchangeManager, if the
reception of the MPDU has been successful. Once the A-MPDU reception is finished,
FrameExchangeManager is also notified about the amount of successfully received MPDUs.</p>
</section>
<section id="interferencehelper">
<h4><span class="section-number">35.1.3.1.4. </span>InterferenceHelper<a class="headerlink" href="#interferencehelper" title="Link to this heading">¶</a></h4>
<p>The InterferenceHelper is an object that tracks all incoming packets and
calculates probability of error values for packets being received, and
also evaluates whether and for how long energy on the channel rises above
a given threshold.</p>
<p>The basic operation of probability of error calculations is shown in Figure
<a class="reference internal" href="#snir"><span class="std std-ref">SNIR function over time</span></a>.  Packets are represented as bits (not symbols) in the <em>ns-3</em>
model, and the InterferenceHelper breaks the packet into one or more
“chunks”, each with a different signal to noise (and interference) ratio
(SNIR).  Each chunk is separately evaluated by asking for the probability
of error for a given number of bits from the error model in use.  The
InterferenceHelper builds an aggregate “probability of error” value
based on these chunks and their duration, and returns this back to
the <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code> for a reception decision.</p>
<figure class="align-default" id="id42">
<span id="snir"></span><img alt="_images/snir.png" src="_images/snir.png" />
<figcaption>
<p><span class="caption-text"><em>SNIR function over time</em></span><a class="headerlink" href="#id42" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>From the SNIR function we can derive the Bit Error Rate (BER) and Packet
Error Rate (PER) for
the modulation and coding scheme being used for the transmission.</p>
<p>If MIMO is used and the number of spatial streams is lower than the number
of active antennas at the receiver, then a gain is applied to the calculated
SNIR as follows (since STBC is not used):</p>
<div class="math">
<p><img src="_images/math/0f97e17f4081ee66e266aed9d4a079023e580bc0.png" alt="gain (dB) = 10 \log(\frac{RX \ antennas}{spatial \ streams})"/></p>
</div><p>Having more TX antennas can be safely ignored for AWGN. The resulting gain is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">antennas</span><span class="w">   </span><span class="n">NSS</span><span class="w">    </span><span class="n">gain</span>
<span class="mi">2</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">2</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="w">       </span><span class="mi">1</span><span class="w">   </span><span class="mf">4.8</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="w">       </span><span class="mi">2</span><span class="w">   </span><span class="mf">1.8</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="w">       </span><span class="mi">3</span><span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">6</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">2</span><span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">3</span><span class="w">   </span><span class="mf">1.2</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">4</span><span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="n">dB</span>
<span class="p">...</span>
</pre></div>
</div>
</section>
<section id="errorratemodel">
<h4><span class="section-number">35.1.3.1.5. </span>ErrorRateModel<a class="headerlink" href="#errorratemodel" title="Link to this heading">¶</a></h4>
<p><em>ns-3</em> makes a packet error or success decision based on the input received
SNR of a frame and based on any possible interfering frames that may overlap
in time; i.e. based on the signal-to-noise (plus interference) ratio, or
SINR.  The relationship between packet error ratio (PER) and SINR in <em>ns-3</em>
is defined by the <code class="docutils literal notranslate"><span class="pre">ns3::ErrorRateModel</span></code>, of which there are several.
The PER is a function of the frame’s modulation and coding (MCS), its SINR,
and the specific ErrorRateModel configured for the MCS.</p>
<p><em>ns-3</em> has updated its default ErrorRateModel over time.  The current
(as of ns-3.33 release) model for recent OFDM-based standards (i.e.,
802.11n/ac/ax), is the <code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code>.  The default
for 802.11a/g is the <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code>, and the default for
802.11b is the <code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code>.  The error rate model for
recent standards was updated during the ns-3.33 release cycle (previously,
it was the <code class="docutils literal notranslate"><span class="pre">ns3::NistErrorRateModel</span></code>).</p>
<p>The error models are described in more detail in outside references.  The
current OFDM model is based on work published in <a class="reference internal" href="wifi-references.html#patidar2017" id="id4"><span>[patidar2017]</span></a>, using
link simulations results from the MATLAB WLAN Toolbox, and validated against
IEEE TGn results <a class="reference internal" href="wifi-references.html#erceg2004" id="id5"><span>[erceg2004]</span></a>.  For publications related to other error models,
please refer to <a class="reference internal" href="wifi-references.html#pei80211ofdm" id="id6"><span>[pei80211ofdm]</span></a>, <a class="reference internal" href="wifi-references.html#pei80211b" id="id7"><span>[pei80211b]</span></a>, <a class="reference internal" href="wifi-references.html#lacage2006yans" id="id8"><span>[lacage2006yans]</span></a>, <a class="reference internal" href="wifi-references.html#haccoun" id="id9"><span>[Haccoun]</span></a>,
<a class="reference internal" href="wifi-references.html#hepner2015" id="id10"><span>[hepner2015]</span></a> and <a class="reference internal" href="wifi-references.html#frenger" id="id11"><span>[Frenger]</span></a> for a detailed description of the legacy PER models.</p>
<p>The current <em>ns-3</em> error rate models are for additive white gaussian
noise channels (AWGN) only; any potential frequency-selective fading
effects are not modeled.</p>
<p>In summary, there are four error models:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code>: for OFDM modes and reuses
<code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code> for 802.11b modes.
This is the default for 802.11n/ac/ax.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code>: for OFDM modes and reuses
<code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code> for 802.11b modes.
This is the default for 802.11a/g.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code>:  contains models for 802.11b modes.  The
802.11b 1 Mbps and 2 Mbps error models are based on classical modulation
analysis.  If GNU Scientific Library (GSL) is installed, the 5.5 Mbps
and 11 Mbps from <a class="reference internal" href="wifi-references.html#pursley2009" id="id12"><span>[pursley2009]</span></a> are used for CCK modulation;
otherwise, results from a backup MATLAB-based CCK model are used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::NistErrorRateModel</span></code>: for OFDM modes and reuses
<code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code> for 802.11b modes.</p></li>
</ol>
<p>Users may select either NIST, YANS or Table-based models for OFDM,
and DSSS will be used in either case for 802.11b.  The NIST model was
a long-standing default in ns-3 (through release 3.32).</p>
</section>
<section id="tablebasederrorratemodel">
<h4><span class="section-number">35.1.3.1.6. </span>TableBasedErrorRateModel<a class="headerlink" href="#tablebasederrorratemodel" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code> has been recently added and is now the <em>ns-3</em> default
for 802.11n/ac/ax, while <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code> is the <em>ns-3</em> default for 802.11a/g.</p>
<p>Unlike analytical error models based on error bounds, <code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code> contains
end-to-end link simulation tables (PER vs SNR) for AWGN channels. Since it is infeasible to generate
such look-up tables for all desired packet sizes and input SNRs, we adopt the recommendation of IEEE P802.11 TGax <a class="reference internal" href="wifi-references.html#porat2016" id="id13"><span>[porat2016]</span></a> that proposed
estimating PER for any desired packet length using BCC FEC encoding by extrapolating the results from two reference lengths:
32 (all lengths less than 400) bytes and 1458 (all lengths greater or equal to 400) bytes respectively.
In case of LDPC FEC encoding, IEEE P802.11 TGax recommends the use of a single reference length.
Hence, we provide two tables for BCC and one table for LDPC that are generated using a reliable and publicly
available commercial link simulator (MATLAB WLAN Toolbox) for each modulation and coding scheme.
Note that BCC tables are limited to MCS 9. For higher MCSs, the models fall back to the use of the YANS analytical model.</p>
<p>The validation scenario is set as follows:</p>
<ol class="arabic simple">
<li><p>Ideal channel and perfect channel estimation.</p></li>
<li><p>Perfect packet synchronization and detection.</p></li>
<li><p>Phase tracking, phase correction, phase noise, carrier frequency offset, power amplifier non-linearities etc. are not considered.</p></li>
</ol>
<p>Several packets are simulated across the link to obtain PER, the number of packets needed to reliably
estimate a PER value is computed using the consideration that the ratio of the estimation error to the
true value should be within 10 % with probability 0.95.
For each SNR value, simulations were run until a total of 40000 packets were simulated.</p>
<p>The obtained results are very close to TGax curves as shown in Figure
<a class="reference internal" href="#default-table-based-error-model-validation"><span class="std std-ref">Comparison of table-based OFDM Error Model with TGax results.</span></a></p>
<figure class="align-default" id="id43">
<span id="default-table-based-error-model-validation"></span><a class="reference internal image-reference" href="_images/default-table-based-error-model-validation.png"><img alt="_images/default-table-based-error-model-validation.png" src="_images/default-table-based-error-model-validation.png" style="width: 420.0px; height: 315.0px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Comparison of table-based OFDM Error Model with TGax results.</em></span><a class="headerlink" href="#id43" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="legacy-errorratemodels">
<h4><span class="section-number">35.1.3.1.7. </span>Legacy ErrorRateModels<a class="headerlink" href="#legacy-errorratemodels" title="Link to this heading">¶</a></h4>
<p>The original error rate model was called the <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code> and
was based on analytical results.  For 802.11b modulations, the 1 Mbps mode
is based on DBPSK. BER is from equation 5.2-69 from <a class="reference internal" href="wifi-references.html#proakis2001" id="id14"><span>[proakis2001]</span></a>.
The 2 Mbps model is based on DQPSK. Equation 8 of <a class="reference internal" href="wifi-references.html#ferrari2004" id="id15"><span>[ferrari2004]</span></a>.
More details are provided in <a class="reference internal" href="wifi-references.html#lacage2006yans" id="id16"><span>[lacage2006yans]</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::NistErrorRateModel</span></code> was later added.
The model was largely aligned with the previous <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code>
for DSSS modulations 1 Mbps and 2 Mbps, but the 5.5 Mbps and 11 Mbps models
were re-based on equations (17) and (18) from <a class="reference internal" href="wifi-references.html#pursley2009" id="id17"><span>[pursley2009]</span></a>.
For OFDM modulations, newer results were
obtained based on work previously done at NIST <a class="reference internal" href="wifi-references.html#miller2003" id="id18"><span>[miller2003]</span></a>.  The results
were also compared against the CMU wireless network emulator, and details
of the validation are provided in <a class="reference internal" href="wifi-references.html#pei80211ofdm" id="id19"><span>[pei80211ofdm]</span></a>.  Since OFDM modes use
hard-decision of punctured codes, the coded BER is calculated using
Chernoff bounds <a class="reference internal" href="wifi-references.html#hepner2015" id="id20"><span>[hepner2015]</span></a>.</p>
<p>The 802.11b model was split from the OFDM model when the NIST error rate
model was added, into a new model called DsssErrorRateModel.</p>
<p>Furthermore, the 5.5 Mbps and 11 Mbps models for 802.11b rely on library
methods implemented in the GNU Scientific Library (GSL).  The ns3 build
system tries to detect whether the host platform has GSL installed; if so,
it compiles in the newer models from <a class="reference internal" href="wifi-references.html#pursley2009" id="id21"><span>[pursley2009]</span></a> for 5.5 Mbps and 11 Mbps;
if not, it uses a backup model derived from MATLAB simulations.</p>
<p>The error curves for analytical models are shown to diverge from link simulation results for higher MCS in
Figure <a class="reference internal" href="#error-models-comparison"><span class="std std-ref">YANS and NIST error model comparison with TGn results</span></a>. This prompted the move to a new error
model based on link simulations (the default TableBasedErrorRateModel, which
provides curves close to those depicted by the TGn dashed line).</p>
<figure class="align-default" id="id44">
<span id="error-models-comparison"></span><img alt="_images/error-models-comparison.png" src="_images/error-models-comparison.png" />
<figcaption>
<p><span class="caption-text"><em>YANS and NIST error model comparison with TGn results</em></span><a class="headerlink" href="#id44" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="spectrumwifiphy">
<h4><span class="section-number">35.1.3.1.8. </span>SpectrumWifiPhy<a class="headerlink" href="#spectrumwifiphy" title="Link to this heading">¶</a></h4>
<p>This section describes the implementation of the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code>
class that can be found in <code class="docutils literal notranslate"><span class="pre">src/wifi/model/spectrum-wifi-phy.{cc,h}</span></code>.</p>
<p>The implementation also makes use of additional classes found in the
same directory:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wifi-spectrum-phy-interface.{cc,h}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wifi-spectrum-signal-parameters.{cc,h}</span></code></p></li>
</ul>
<p>and classes found in the spectrum module:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wifi-spectrum-value-helper.{cc,h}</span></code></p></li>
</ul>
<p>The current <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> class
reuses the existing interference manager and error rate models originally
built for <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, but allows, as a first step, foreign (non Wi-Fi)
signals to be treated as additive noise.</p>
<p>Two main changes were needed to adapt the Spectrum framework to Wi-Fi.
First, the physical layer must send signals compatible with the
Spectrum channel framework, and in particular, the
<code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> that allows signals from different
technologies to coexist.  Second, the InterferenceHelper must be
extended to support the insertion of non-Wi-Fi signals and to
add their received power to the noise, in the same way that
unintended Wi-Fi signals (perhaps from a different SSID or arriving
late from a hidden node) are added to the noise.</p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, where there are no foreign signals, CCA_BUSY state
will be raised for foreign signals that are higher than CcaEdThreshold
(see section 16.4.8.5 in the 802.11-2012 standard for definition of
CCA Mode 1).  The attribute <code class="docutils literal notranslate"><span class="pre">WifiPhy::CcaEdThreshold</span></code> therefore
potentially plays a larger role in this model than in the <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>
model.</p>
<p>To support the Spectrum channel, the <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code> transmit and receive methods
were adapted to use the Spectrum channel API.  This required developing
a few <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code>-related classes.  The class
<code class="docutils literal notranslate"><span class="pre">WifiSpectrumValueHelper</span></code> is used to create Wi-Fi signals with the
spectrum framework and spread their energy across the bands. The
spectrum is sub-divided into sub-bands (the width of an OFDM
subcarrier, which depends on the technology). The power allocated to a particular channel
is spread across the sub-bands roughly according to how power would
be allocated to sub-carriers. Adjacent channels are models by the use of
OFDM transmit spectrum masks as defined in the standards.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">WifiBandwidthFilter</span></code> is used to discard signals early in the
transmission process by ignoring any Wi-Fi PPDU whose TX band (including guard bands)
does not overlap the current operating channel. Therefore, it bypasses the signal
propagation/loss calculations reducing the computational load and increasing the
simulation performance. To enable the <code class="docutils literal notranslate"><span class="pre">WifiBandwidthFilter</span></code>, the user can use object
aggregation as follows:
.. sourcecode:: cpp</p>
<blockquote>
<div><p>Ptr&lt;WifiBandwidthFilter&gt; wifiFilter = CreateObject&lt;WifiBandwidthFilter&gt; ();
Ptr&lt;MultiModelSpectrumChannel&gt; spectrumChannel = CreateObject&lt;MultiModelSpectrumChannel&gt; ();
spectrumChannel-&gt;AddSpectrumTransmitFilter(wifiFilter);</p>
</div></blockquote>
<p>To support an easier user configuration experience, the existing
YansWifi helper classes (in <code class="docutils literal notranslate"><span class="pre">src/wifi/helper</span></code>) were copied and
adapted to provide equivalent SpectrumWifi helper classes.</p>
<p>Finally, for reasons related to avoiding C++ multiple inheritance
issues, a small forwarding class called <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code>
was inserted as a shim between the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> and the
Spectrum channel.  The <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code> calls a different
<code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy::StartRx</span> <span class="pre">()</span></code> method to start the reception process.
This method performs the check of the signal power against the
<code class="docutils literal notranslate"><span class="pre">WifiPhy::RxSensitivity</span></code> attribute and discards weak signals, and
also checks if the signal is a Wi-Fi signal; non-Wi-Fi signals are added
to the InterferenceHelper and can raise CCA_BUSY but are not further processed
in the reception chain.   After this point, valid Wi-Fi signals cause
<code class="docutils literal notranslate"><span class="pre">WifiPhy::StartReceivePreamble</span></code> to be called, and the processing continues
as described above.</p>
<p>Furthermore, in order to support more flexible channel switching,
the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> can hold multiple instances of <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code>
(<a class="reference internal" href="#fig-spectrum-wifi-phy-multiple-interfaces"><span class="std std-ref">Multiple RF interfaces concept</span></a>).
Each of these instances handles a given frequency range of the spectrum, identified by
a start and a stop frequency expressed in MHz, and there can be no overlap in spectrum between them.
Only one of these <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code> instances corresponds to the active RF interface of the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code>,
the other ones are referred to as inactive RF interfaces and might be disconnected from the spectrum channel.</p>
<figure class="align-center" id="id45">
<span id="fig-spectrum-wifi-phy-multiple-interfaces"></span><img alt="_images/spectrum-wifi-phy-multiple-interfaces.png" src="_images/spectrum-wifi-phy-multiple-interfaces.png" />
<figcaption>
<p><span class="caption-text">Multiple RF interfaces concept</span><a class="headerlink" href="#id45" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>If the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy::TrackSignalsFromInactiveInterfaces</span></code> attribute is set to true (default),
inactive RF interfaces are connected to their respective spectrum channels and the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code>
also receive signals from these inactive RF interfaces when they belong to a configured portion
of the frequency range covered by the interface.
The portion of the spectrum being monitored by an inactive interface is specified by a center frequency
and a channel width, and is seamlessly set to equivalent of the operating channel of the spectrum PHY
that is actively using that frequency range. The <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy``forwards</span> <span class="pre">these</span> <span class="pre">received</span> <span class="pre">signals</span>
<span class="pre">from</span> <span class="pre">inactive</span> <span class="pre">interfaces</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">``InterferenceHelper</span></code> without further processing them.
The benefit of the latter is that more accurate PHY-CCA.indication can be generated upon channel switching
if one or more signals started to be transmitted on the new channel before the switch occurs,
which would be ignored otherwise. This is illustrated in Figure <a class="reference internal" href="#fig-cca-channel-switching-multiple-interfaces"><span class="std std-ref">Illustration of signals tracking upon channel switching</span></a>, where the parts in red are only generated when <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy::TrackSignalsFromInactiveInterfaces</span></code> is set to true.</p>
<figure class="align-center" id="id46">
<span id="fig-cca-channel-switching-multiple-interfaces"></span><img alt="_images/cca-channel-switching-multiple-interfaces.png" src="_images/cca-channel-switching-multiple-interfaces.png" />
<figcaption>
<p><span class="caption-text">Illustration of signals tracking upon channel switching</span><a class="headerlink" href="#id46" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="the-mac-model">
<h3><span class="section-number">35.1.3.2. </span>The MAC model<a class="headerlink" href="#the-mac-model" title="Link to this heading">¶</a></h3>
<section id="infrastructure-association">
<h4><span class="section-number">35.1.3.2.1. </span>Infrastructure association<a class="headerlink" href="#infrastructure-association" title="Link to this heading">¶</a></h4>
<p>Association in infrastructure mode is a high-level MAC function performed by
the Association Manager, which is implemented through a base class (<code class="docutils literal notranslate"><span class="pre">WifiAssocManager</span></code>)
and a default subclass (<code class="docutils literal notranslate"><span class="pre">WifiDefaultAssocManager</span></code>). The interaction between
the station MAC, the Association Manager base class and subclass is illustrated
in Figure <a class="reference internal" href="#fig-assoc-manager"><span class="std std-ref">Scanning procedure</span></a>.</p>
<figure class="align-center" id="id47">
<span id="fig-assoc-manager"></span><img alt="_images/assoc-manager.png" src="_images/assoc-manager.png" />
<figcaption>
<p><span class="caption-text">Scanning procedure</span><a class="headerlink" href="#id47" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The STA wifi MAC requests the Association Manager to start a scanning procedure
with specified parameters, including the type of scanning (active or passive),
the desired SSID, the list of channels to scan, etc. The STA wifi MAC then expects
to be notified of the best AP to associate with at the end of the scanning procedure.
Every Beacon or Probe Response frame received during scanning is forwarded to the
Association Manager, which keeps a list of candidate APs that match the scanning
parameters. The sorting criterium for such a list is defined by the Association
Manager subclass. The default Association Manager sorts APs in decreasing order
of the SNR of the received Beacon/Probe Response frame.</p>
<p>When notified of the start of a scanning procedure, the default Association Manager
schedules a call to a method that processes the information included in the frames
received up to the time such a method is called. When both the AP and the STA have
multiple links (i.e., they are 802.11be MLDs), the default Association Manager attempts
to setup as many links as possible. This involves switching operating channel on some of
the STA’s links to match those on which the APs affiliated with the AP MLD are operating.</p>
<p>If association is rejected by the AP for some reason, the STA will try to
associate to the next best AP until the candidate list is exhausted which
then sends STA to ‘REFUSED’ state. If this occurs, the simulation user will
need to force reassociation retry in some way, perhaps by changing
configuration (i.e. the STA will not persistently try to associate upon a
refusal).</p>
<p>When associated, if the configuration is changed by the simulation user,
the STA will try to reassociate with the existing AP.</p>
<p>If the number of missed beacons exceeds the threshold, the STA will notify
the rest of the device that the link is down (association is lost) and
restart the scanning process. Note that this can also happen when an
association request fails without explicit refusal (i.e., the AP fails to
respond to association request).</p>
</section>
<section id="roaming">
<h4><span class="section-number">35.1.3.2.2. </span>Roaming<a class="headerlink" href="#roaming" title="Link to this heading">¶</a></h4>
<p>Roaming at layer-2 (i.e. a STA migrates its association from one AP to
another) is not presently supported. Because of that, the Min/Max channel
dwelling time implementation as described by the IEEE 802.11 standard
<a class="reference internal" href="wifi-references.html#ieee80211" id="id22"><span>[ieee80211]</span></a> is also omitted, since it is only meaningful on the context
of channel roaming.</p>
</section>
<section id="channel-access">
<h4><span class="section-number">35.1.3.2.3. </span>Channel access<a class="headerlink" href="#channel-access" title="Link to this heading">¶</a></h4>
<p>The 802.11 Distributed Coordination Function is used to calculate when to grant
access to the transmission medium. While implementing the DCF would have been
particularly easy if we had used a recurring timer that expired every slot, we
chose to use the method described in <a class="reference internal" href="wifi-references.html#ji2004sslswn" id="id23"><span>[ji2004sslswn]</span></a>
where the backoff timer duration is lazily calculated whenever needed since it
is claimed to have much better performance than the simpler recurring timer
solution.</p>
<p>The DCF basic access is described in section 10.3.4.2 of <a class="reference internal" href="wifi-references.html#ieee80211-2016" id="id24"><span>[ieee80211-2016]</span></a>.</p>
<ul class="simple">
<li><p>“A STA may transmit an MPDU when it is operating under the DCF access method
[..] when the STA determines that the medium is idle when a frame is queued
for transmission, and remains idle for a period of a DIFS, or an EIFS
(10.3.2.3.7) from the end of the immediately preceding medium-busy event,
whichever is the greater, and the backoff timer is zero. Otherwise the random
backoff procedure described in 10.3.4.3 shall be followed.”</p></li>
</ul>
<p>Thus, a station is allowed not to invoke the backoff procedure if all of the
following conditions are met:</p>
<ul class="simple">
<li><p>the medium is idle when a frame is queued for transmission</p></li>
<li><p>the medium remains idle until the most recent of these two events: a DIFS
from the time when the frame is queued for transmission; an EIFS from the
end of the immediately preceding medium-busy event (associated with the
reception of an erroneous frame)</p></li>
<li><p>the backoff timer is zero</p></li>
</ul>
<p>The backoff procedure of DCF is described in section 10.3.4.3 of <a class="reference internal" href="wifi-references.html#ieee80211-2016" id="id25"><span>[ieee80211-2016]</span></a>.</p>
<ul class="simple">
<li><p>“A STA shall invoke the backoff procedure to transfer a frame
when finding the medium busy as indicated by either the physical or
virtual CS mechanism.”</p></li>
<li><p>“A backoff procedure shall be performed immediately after the end of
every transmission with the More Fragments bit set to 0 of an MPDU of
type Data, Management, or Control with subtype PS-Poll, even if no
additional transmissions are currently queued.”</p></li>
</ul>
<p>The EDCA backoff procedure is slightly different than the DCF backoff procedure
and is described in section 10.22.2.2 of <a class="reference internal" href="wifi-references.html#ieee80211-2016" id="id26"><span>[ieee80211-2016]</span></a>. The backoff procedure
shall be invoked by an EDCAF when any of the following events occur:</p>
<ul class="simple">
<li><p>a frame is “queued for transmission such that one of the transmit queues
associated with that AC has now become non-empty and any other transmit queues
associated with that AC are empty; the medium is busy on the primary channel”</p></li>
<li><p>“The transmission of the MPDU in the final PPDU transmitted by the TXOP holder
during the TXOP for that AC has completed and the TXNAV timer has expired, and
the AC was a primary AC”</p></li>
<li><p>“The transmission of an MPDU in the initial PPDU of a TXOP fails [..] and the
AC was a primary AC”</p></li>
<li><p>“The transmission attempt collides internally with another EDCAF of an AC that
has higher priority”</p></li>
<li><p>(optionally) “The transmission by the TXOP holder of an MPDU in a non-initial
PPDU of a TXOP fails”</p></li>
</ul>
<p>Additionally, section 10.22.2.4 of <a class="reference internal" href="wifi-references.html#ieee80211-2016" id="id27"><span>[ieee80211-2016]</span></a> introduces the notion of
slot boundary, which basically occurs following SIFS + AIFSN * slotTime of idle
medium after the last busy medium that was the result of a reception of a frame
with a correct FCS or following EIFS - DIFS + AIFSN * slotTime + SIFS of idle
medium after the last indicated busy medium that was the result of a frame reception
that has resulted in FCS error, or following a slotTime of idle medium occurring
immediately after any of these conditions.</p>
<p>On these specific slot boundaries, each EDCAF shall make a determination to perform
one and only one of the following functions:</p>
<ul class="simple">
<li><p>Decrement the backoff timer.</p></li>
<li><p>Initiate the transmission of a frame exchange sequence.</p></li>
<li><p>Invoke the backoff procedure due to an internal collision.</p></li>
<li><p>Do nothing.</p></li>
</ul>
<p>Thus, if an EDCAF decrements its backoff timer on a given slot boundary and, as
a result, the backoff timer has a zero value, the EDCAF cannot immediately
transmit, but it has to wait for another slotTime of idle medium before transmission
can start.</p>
<p>When the Channel Access Manager determines that channel access can be granted, it
determines the largest primary channel that is considered idle based on the CCA-BUSY
indication provided by the PHY. Such an information is passed to the Frame Exchange
Manager, which in turn informs the Multi-User Scheduler (if any) and the Wifi Remote
Station Manager. As a result, PPDUs are transmitted on the largest idle primary channel.
For example, if a STA is operating on a 40 MHz channel and the secondary20 channel
is indicated to be busy, transmissions will occur on the primary20 channel.</p>
<p>The higher-level MAC functions are implemented in a set of other C++ classes and
deal with:</p>
<ul class="simple">
<li><p>packet fragmentation and defragmentation,</p></li>
<li><p>use of the RTS/CTS protocol,</p></li>
<li><p>rate control algorithm,</p></li>
<li><p>connection and disconnection to and from an Access Point,</p></li>
<li><p>the MAC transmission queue,</p></li>
<li><p>beacon generation,</p></li>
<li><p>MSDU aggregation,</p></li>
<li><p>etc.</p></li>
</ul>
</section>
<section id="frame-exchange-managers">
<h4><span class="section-number">35.1.3.2.4. </span>Frame Exchange Managers<a class="headerlink" href="#frame-exchange-managers" title="Link to this heading">¶</a></h4>
<p>As the IEEE 802.11 standard evolves, more and more features are added and it is
more and more difficult to have a single component handling all of the allowed
frame exchange sequences. A hierarchy of FrameExchangeManager classes has been
introduced to make the code clean and scalable, while avoiding code duplication.
Each FrameExchangeManager class handles the frame exchange sequences introduced
by a given amendment. The FrameExchangeManager hierarchy is depicted in Figure
<a class="reference internal" href="#fem-hierarchy"><span class="std std-ref">FrameExchangeManager hierarchy</span></a>.</p>
<figure class="align-default" id="id48">
<span id="fem-hierarchy"></span><img alt="_images/FemHierarchy.png" src="_images/FemHierarchy.png" />
<figcaption>
<p><span class="caption-text"><em>FrameExchangeManager hierarchy</em></span><a class="headerlink" href="#id48" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The features supported by every FrameExchangeManager class are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FrameExchangeManager</span></code> is the base class. It handles the basic sequences
for non-QoS stations: MPDU followed by Normal Ack, RTS/CTS and CTS-to-self,
NAV setting and resetting, MPDU fragmentation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QosFrameExchangeManager</span></code> adds TXOP support: multiple protection setting,
TXOP truncation via CF-End, TXOP recovery, ignore NAV when responding to an
RTS sent by the TXOP holder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HtFrameExchangeManager</span></code> adds support for Block Ack (compressed variant),
A-MSDU and A-MPDU aggregation, Implicit Block Ack Request policy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VhtFrameExchangeManager</span></code> adds support for S-MPDUs</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HeFrameExchangeManager</span></code> adds support for the transmission and reception of
multi-user frames via DL OFDMA and UL OFDMA, as detailed below.</p></li>
</ul>
</section>
<section id="mac-queues">
<span id="wifi-mu-ack-sequences"></span><h4><span class="section-number">35.1.3.2.5. </span>MAC queues<a class="headerlink" href="#mac-queues" title="Link to this heading">¶</a></h4>
<p>Each EDCA function (on QoS stations) and the DCF (on non-QoS stations) have their own
MAC queue (an instance of the <code class="docutils literal notranslate"><span class="pre">WifiMacQueue</span></code> class) to store packets received from
the upper layer and waiting for transmission. On QoS stations, each received packet is
assigned a User Priority based on the socket priority (see, e.g., the wifi-multi-tos or
the wifi-mac-ofdma examples), which determines the Access Category that handles the
packet. By default, wifi MAC queues support flow control, hence upper layers do not
forward a packet down if there is no room for it in the corresponding MAC queue.
Wifi MAC queues do not support dynamic queue limits (byte queue limits); therefore,
there is no backpressure into the traffic control layer until the WifiMacQueue for
an access category is completely full (i.e., when the queue depth reaches the value
of the MaxSize attribute, which defaults to 500 packets).
TCP small queues (TSQ) <a class="reference internal" href="wifi-references.html#corbet2012" id="id28"><span>[corbet2012]</span></a> is a Linux feature that provides feedback from the
Wi-Fi device to the socket layer, to control how much data is queued at the Wi-Fi
level.  <em>ns-3</em> TCP does not implement TSQ, nor does the WifiNetDevice provide that
specific feedback (although some use of the existing trace sources may be enough to
support it).  Regardless, experimental tests have demonstrated that TSQ interferes with
Wi-Fi aggregation on uplink transfers <a class="reference internal" href="wifi-references.html#grazia2022" id="id29"><span>[grazia2022]</span></a>.
Packets stay in the wifi MAC queue until they are acknowledged or discarded. A packet
may be discarded because, e.g., its lifetime expired (i.e., it stayed in the queue for too
long) or the maximum number of retries was reached. The maximum lifetime for a packet can
be configured via the <code class="docutils literal notranslate"><span class="pre">MaxDelay</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">WifiMacQueue</span></code>. There are a number of
traces that can be used to track the outcome of a packet transmission (see the corresponding
doxygen documentation):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WifiMac</span></code> trace sources: <code class="docutils literal notranslate"><span class="pre">AckedMpdu</span></code>, <code class="docutils literal notranslate"><span class="pre">NAckedMpdu</span></code>, <code class="docutils literal notranslate"><span class="pre">DroppedMpdu</span></code>,
<code class="docutils literal notranslate"><span class="pre">MpduResponseTimeout</span></code>, <code class="docutils literal notranslate"><span class="pre">PsduResponseTimeout</span></code>, <code class="docutils literal notranslate"><span class="pre">PsduMapResponseTimeout</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WifiMacQueue</span></code> trace source: <code class="docutils literal notranslate"><span class="pre">Expired</span></code></p></li>
</ul>
<p>Internally, a wifi MAC queue is made of multiple sub-queues, each storing frames of
a given type (i.e., data or management) and having a given receiver address and TID.
For single-user transmissions, the next station to serve is determined by a wifi MAC
queue scheduler (held by the <code class="docutils literal notranslate"><span class="pre">WifiMac</span></code> instance). A wifi MAC queue scheduler is
implemented through a base class (<code class="docutils literal notranslate"><span class="pre">WifiMacQueueScheduler</span></code>) and subclasses defining
specific scheduling policies. The default scheduler (<code class="docutils literal notranslate"><span class="pre">FcfsWifiQueueScheduler</span></code>)
gives management frames higher priority than data frames and serves data frames in a
first come first serve fashion. For multi-user transmissions (see below), scheduling
is performed by a Multi-User scheduler, which may or may not consult the wifi MAC queue
scheduler to identify the stations to serve with a Multi-User DL or UL transmission.</p>
</section>
<section id="multi-user-transmissions">
<h4><span class="section-number">35.1.3.2.6. </span>Multi-user transmissions<a class="headerlink" href="#multi-user-transmissions" title="Link to this heading">¶</a></h4>
<p>Since the introduction of the IEEE 802.11ax amendment, multi-user (MU) transmissions are
possible, both in downlink (DL) and uplink (UL), by using OFDMA and/or MU-MIMO. Currently,
ns-3 only supports multi-user transmissions via OFDMA. Three acknowledgment sequences are
implemented for DL OFDMA.</p>
<p>The first acknowledgment sequence is made of multiple BlockAckRequest/BlockAck frames sent
as single-user frames, as shown in Figure <a class="reference internal" href="#fig-ack-su-format-80211ax"><span class="std std-ref">Acknowledgment of DL MU frames in single-user format</span></a>.</p>
<figure class="align-center" id="id49">
<span id="fig-ack-su-format-80211ax"></span><img alt="_images/ack-su-format.png" src="_images/ack-su-format.png" />
<figcaption>
<p><span class="caption-text">Acknowledgment of DL MU frames in single-user format</span><a class="headerlink" href="#id49" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For the second acknowledgment sequence, an MU-BAR Trigger Frame is sent (as a single-user
frame) to solicit BlockAck responses sent in TB PPDUs, as shown in Figure <a class="reference internal" href="#fig-mu-bar-80211ax"><span class="std std-ref">Acknowledgment of DL MU frames via MU-BAR Trigger Frame sent as single-user frame</span></a>.</p>
<figure class="align-center" id="id50">
<span id="fig-mu-bar-80211ax"></span><img alt="_images/mu-bar.png" src="_images/mu-bar.png" />
<figcaption>
<p><span class="caption-text">Acknowledgment of DL MU frames via MU-BAR Trigger Frame sent as single-user frame</span><a class="headerlink" href="#id50" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For the third acknowledgment sequence, an MU-BAR Trigger Frame is aggregated to every PSDU
included in the DL MU PPDU and the BlockAck responses are sent in TB PPDUs, as shown in
Figure <a class="reference internal" href="#fig-aggr-mu-bar-80211ax"><span class="std std-ref">Acknowledgment of DL MU frames via aggregated MU-BAR Trigger Frames</span></a>.</p>
<figure class="align-center" id="id51">
<span id="fig-aggr-mu-bar-80211ax"></span><img alt="_images/aggr-mu-bar.png" src="_images/aggr-mu-bar.png" />
<figcaption>
<p><span class="caption-text">Acknowledgment of DL MU frames via aggregated MU-BAR Trigger Frames</span><a class="headerlink" href="#id51" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For UL OFDMA, both BSRP Trigger Frames and Basic Trigger Frames are supported, as shown in
Figure <a class="reference internal" href="#fig-ul-ofdma-80211ax"><span class="std std-ref">Frame exchange sequences using UL OFDMA</span></a>. A BSRP Trigger Frame is sent by an AP to solicit stations
to send QoS Null frames containing Buffer Status Reports. A Basic Trigger Frame is sent by an AP
to solicit stations to send data frames in TB PPDUs, which are acknowledged by the AP via a
Multi-STA BlockAck frame. Note that, in order for the two frame exchange sequences to be separated
by a SIFS (as shown in Figure <a class="reference internal" href="#fig-ul-ofdma-80211ax"><span class="std std-ref">Frame exchange sequences using UL OFDMA</span></a>), it is necessary that the transmitting
Access Category has a non-zero TXOP Limit, there is enough remaining time in the TXOP to perform
the frame exchange sequence initiated by the Basic Trigger Frame and the Multi-User scheduler
(described next) chooses to send a Basic Trigger Frame after a BSRP Trigger Frame.</p>
<figure class="align-center" id="id52">
<span id="fig-ul-ofdma-80211ax"></span><img alt="_images/ul-ofdma.png" src="_images/ul-ofdma.png" />
<figcaption>
<p><span class="caption-text">Frame exchange sequences using UL OFDMA</span><a class="headerlink" href="#id52" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="multi-user-scheduler">
<h4><span class="section-number">35.1.3.2.7. </span>Multi-User Scheduler<a class="headerlink" href="#multi-user-scheduler" title="Link to this heading">¶</a></h4>
<p>A new component, named <strong>MultiUserScheduler</strong>, is in charge of determining what frame exchange
sequence the aggregated AP has to perform when gaining a TXOP (DL OFDMA, UL OFDMA or BSRP Trigger
Frame), along with the information needed to perform the selected frame exchange sequence (e.g.,
the set of PSDUs to send in case of DL OFDMA). A TXOP is gained (some time) after requesting
channel access, which is normally done by DCF/EDCA (Txop/QosTxop) if the device has frames to transmit. In order for an AP to coordinate UL MU transmissions even without DL traffic, the
duration of the access request interval can be set to a non-zero value through the
<code class="docutils literal notranslate"><span class="pre">AccessReqInterval</span></code> attribute. The access request interval is the interval between two
consecutive requests for channel access made by the MultiUserScheduler; such requests are made
independently of the presence of frames in the queues of the AP. It is also possible to set the
Access Category for which the MultiUserScheduler makes requests for channel access (via the
<code class="docutils literal notranslate"><span class="pre">AccessReqAc</span></code> attribute) and to choose whether the access request interval is measured starting
from the last time the MultiUserScheduler made a request for channel access or from the last time
channel access was obtained by DCF/EDCA (via the <code class="docutils literal notranslate"><span class="pre">DelayAccessReqUponAccess</span></code> attribute).</p>
<p><code class="docutils literal notranslate"><span class="pre">MultiUserScheduler</span></code> is an abstract base class. Currently, the only available subclass is
<strong>RrMultiUserScheduler</strong>. By default, no multi-user scheduler is aggregated to an AP (hence,
OFDMA is not enabled).</p>
</section>
<section id="round-robin-multi-user-scheduler">
<h4><span class="section-number">35.1.3.2.8. </span>Round-robin Multi-User Scheduler<a class="headerlink" href="#round-robin-multi-user-scheduler" title="Link to this heading">¶</a></h4>
<p>The Round-robin Multi-User Scheduler dynamically assigns a priority to each station to ensure
airtime fairness in the selection of stations for DL multi-user transmissions. The <code class="docutils literal notranslate"><span class="pre">NStations</span></code>
attribute enables to set the maximum number of stations that can be the recipients of a DL
multi-user frame. Therefore, every time an HE AP accesses the channel to transmit a DL
multi-user frame, the scheduler determines the number of stations the AP has frames to send
to (capped at the value specified through the mentioned attribute) and attempts to allocate
equal sized RUs to as many such stations as possible without leaving RUs of the same size
unused. For instance, if the channel bandwidth is 40 MHz and the determined number of stations
is 5, the first 4 stations (in order of priority) are allocated a 106-tone RU each (if 52-tone
RUs were allocated, we would have three 52-tone RUs unused). If central 26-tone RUs can be
allocated (as determined by the <code class="docutils literal notranslate"><span class="pre">UseCentral26TonesRus</span></code> attribute), possible stations that
have not been allocated an RU are assigned one of such 26-tone RU. In the previous example,
the fifth station would have been allocated one of the two available central 26-tone RUs.</p>
<p>When UL OFDMA is enabled (via the <code class="docutils literal notranslate"><span class="pre">EnableUlOfdma</span></code> attribute), every DL OFDMA frame exchange
is followed by an UL OFDMA frame exchange involving the same set of stations and the same RU
allocation as the preceding DL multi-user frame. The transmission of a BSRP Trigger Frame can
optionally (depending on the value of the <code class="docutils literal notranslate"><span class="pre">EnableBsrp</span></code> attribute) precede the transmission
of a Basic Trigger Frame in order for the AP to collect information about the buffer status
of the stations.</p>
</section>
<section id="enhanced-multi-link-single-radio-operation-emlsr">
<h4><span class="section-number">35.1.3.2.9. </span>Enhanced multi-link single radio operation (EMLSR)<a class="headerlink" href="#enhanced-multi-link-single-radio-operation-emlsr" title="Link to this heading">¶</a></h4>
<p>The IEEE 802.11be amendment introduced EMLSR operating mode to allow a non-AP MLD to alternate
frame exchanges over a subset of setup links identified as EMLSR links. <em>ns-3</em> supports EMLSR
operations as described in the following.</p>
<section id="non-ap-mld-side">
<h5><span class="section-number">35.1.3.2.9.1. </span>Non-AP MLD side<a class="headerlink" href="#non-ap-mld-side" title="Link to this heading">¶</a></h5>
<p>A non-AP MLD supports EMLSR operating mode if the <code class="docutils literal notranslate"><span class="pre">EmlsrActivated</span></code> attribute of the EHT
configuration is set to true. In such a case, the WifiMacHelper will install an EMLSR Manager
by using the type and attribute values configured through the <code class="docutils literal notranslate"><span class="pre">SetEmlsrManager</span></code> method. The
EMLSR Manager is a base class providing the <code class="docutils literal notranslate"><span class="pre">EmlsrLinkSet</span></code> attribute, which can be used to
enable or disable EMLSR mode (after multi-link setup, EMLSR mode is disabled by default). Setting
the <code class="docutils literal notranslate"><span class="pre">EmlsrLinkSet</span></code> attribute triggers the transmission of an EML Operating Mode Notification
frame to the AP to communicate the new set of EMLSR links, if ML setup has been completed.
Otherwise, the set of EMLSR links is stored and the EML Operating Mode Notification frame is
sent as soon as the ML setup is completed. The selection of the link used to transmit
the EML Operating Mode Notification frame is done by the EMLSR Manager subclass. The default
EMLSR Manager subclass, <code class="docutils literal notranslate"><span class="pre">DefaultEmlsrManager</span></code>, selects the link that was used to perform
ML setup. When the non-AP MLD receives the acknowledgment for the EML Operating Mode Notification
frame, it starts a timer whose duration is the transition timeout advertised by the AP MLD.
When the timer expires, or the non-AP MLD receives an EML Operating Mode Notification frame
from the AP MLD, the EMLSR mode is assumed to be enabled (or disabled).</p>
</section>
<section id="ap-mld-side">
<h5><span class="section-number">35.1.3.2.9.2. </span>AP MLD side<a class="headerlink" href="#ap-mld-side" title="Link to this heading">¶</a></h5>
<p>An AP MLD supports EMLSR operating mode if the <code class="docutils literal notranslate"><span class="pre">EmlsrActivated</span></code> attribute of the EHT
configuration is set to true. When an AP MLD that supports EMLSR operating mode has to initiate a
frame exchange with a non-AP MLD that is operating in EMLSR mode, it sends an MU-RTS Trigger Frame
soliciting a response from the non-AP MLD (and possibly others) as the initial Control frame for
that exchange. The MU-RTS Trigger Frame includes a Padding field whose transmission duration is the
maximum among the padding delays advertised by all the EMLSR clients solicited by the MU-RTS
Trigger Frame. Also, the MU-RTS Trigger Frame is carried in a non-HT (duplicate) PPDU transmitted
at a rate of 6 Mbps, 12 Mbps or 24 Mbps. When the transmission of an initial Control frame starts,
the AP MLD blocks transmissions to the solicited EMLSR clients on the EMLSR links other than the
link used to transmit the initial Control frame, so that the AP MLD does not initiate another
frame exchange on such links. The frame exchange with an EMLSR client is assumed to terminate
when the AP MLD does not start a frame transmission a SIFS after the response to the last frame
transmitted by the AP MLD or the AP MLD transmits a frame that is not addressed to the EMLSR
client. When a frame exchange with an EMLSR client terminates, the AP MLD blocks transmissions on
all the EMLSR links and starts a timer whose duration is the transition delay advertised by the
EMLSR client. When the timer expires, the EMLSR client is assumed to be back to the listening
operations and transmissions on all the EMLSR links are unblocked.</p>
</section>
</section>
<section id="ack-manager">
<h4><span class="section-number">35.1.3.2.10. </span>Ack manager<a class="headerlink" href="#ack-manager" title="Link to this heading">¶</a></h4>
<p>Since the introduction of the IEEE 802.11e amendment, multiple acknowledgment policies
are available, which are coded in the Ack Policy subfield in the QoS Control field of
QoS Data frames (see Section 9.2.4.5.4 of the IEEE 802.11-2016 standard). For instance,
an A-MPDU can be sent with the <em>Normal Ack or Implicit Block Ack Request</em> policy, in which
case the receiver replies with a Normal Ack or a Block Ack depending on whether the A-MPDU
contains a single MPDU or multiple MPDUs, or with the <em>Block Ack</em> policy, in which case
the receiver waits to receive a Block Ack Request in the future to which it replies with
a Block Ack.</p>
<p><code class="docutils literal notranslate"><span class="pre">WifiAckManager</span></code> is the abstract base class introduced to provide an interface
for multiple ack managers. Currently, the default ack manager is
the <code class="docutils literal notranslate"><span class="pre">WifiDefaultAckManager</span></code>.</p>
</section>
<section id="wifidefaultackmanager">
<h4><span class="section-number">35.1.3.2.11. </span>WifiDefaultAckManager<a class="headerlink" href="#wifidefaultackmanager" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">WifiDefaultAckManager</span></code> allows to determine which acknowledgment policy
to use depending on the value of its attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UseExplicitBar</span></code>: used to determine the ack policy to use when a response is needed from
the recipient and the current transmission includes multiple frames (A-MPDU) or there are
frames transmitted previously for which an acknowledgment is needed. If this attribute is
true, the <em>Block Ack</em> policy is used. Otherwise, the <em>Implicit Block Ack Request</em> policy is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BaThreshold</span></code>: used to determine when the originator of a Block Ack agreement needs to
request a response from the recipient. A value of zero means that a response is requested
at every frame transmission. Otherwise, a non-zero value (less than or equal to 1) means
that a response is requested upon transmission of a frame whose sequence number is distant
at least BaThreshold multiplied by the transmit window size from the starting sequence
number of the transmit window.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlMuAckSequenceType</span></code>: used to select the acknowledgment sequence for DL MU frames
(acknowledgment in single-user format, acknowledgment via MU-BAR Trigger Frame sent as
single-user frame, or acknowledgment via MU-BAR Trigger Frames aggregated to the data
frames).</p></li>
</ul>
</section>
<section id="protection-manager">
<h4><span class="section-number">35.1.3.2.12. </span>Protection manager<a class="headerlink" href="#protection-manager" title="Link to this heading">¶</a></h4>
<p>The protection manager is in charge of determining the protection mechanism to use,
if any, when sending a frame.</p>
<p><code class="docutils literal notranslate"><span class="pre">WifiProtectionManager</span></code> is the abstract base class introduced to provide an interface
for multiple protection managers. Currently, the default protection manager is
the <code class="docutils literal notranslate"><span class="pre">WifiDefaultProtectionManager</span></code>.</p>
</section>
<section id="wifidefaultprotectionmanager">
<h4><span class="section-number">35.1.3.2.13. </span>WifiDefaultProtectionManager<a class="headerlink" href="#wifidefaultprotectionmanager" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">WifiDefaultProtectionManager</span></code> selects a protection mechanism based on the
information provided by the remote station manager.</p>
</section>
<section id="rate-control-algorithms">
<h4><span class="section-number">35.1.3.2.14. </span>Rate control algorithms<a class="headerlink" href="#rate-control-algorithms" title="Link to this heading">¶</a></h4>
<p>Multiple rate control algorithms are available in <em>ns-3</em>.
Some rate control algorithms are modeled after real algorithms used in real devices;
others are found in literature.
The following rate control algorithms can be used by the MAC low layer:</p>
<p>Algorithms found in real devices:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ArfWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OnoeWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConstantRateWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinstrelWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinstrelHtWifiManager</span></code></p></li>
</ul>
<p>Algorithms in literature:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IdealWifiManager</span></code>  (default for <code class="docutils literal notranslate"><span class="pre">WifiHelper</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AarfWifiManager</span></code> <a class="reference internal" href="wifi-references.html#lacage2004aarfamrr" id="id30"><span>[lacage2004aarfamrr]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AmrrWifiManager</span></code> <a class="reference internal" href="wifi-references.html#lacage2004aarfamrr" id="id31"><span>[lacage2004aarfamrr]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CaraWifiManager</span></code> <a class="reference internal" href="wifi-references.html#kim2006cara" id="id32"><span>[kim2006cara]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RraaWifiManager</span></code> <a class="reference internal" href="wifi-references.html#wong2006rraa" id="id33"><span>[wong2006rraa]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AarfcdWifiManager</span></code> <a class="reference internal" href="wifi-references.html#maguolo2008aarfcd" id="id34"><span>[maguolo2008aarfcd]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParfWifiManager</span></code> <a class="reference internal" href="wifi-references.html#akella2007parf" id="id35"><span>[akella2007parf]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AparfWifiManager</span></code> <a class="reference internal" href="wifi-references.html#chevillat2005aparf" id="id36"><span>[chevillat2005aparf]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThompsonSamplingWifiManager</span></code> <a class="reference internal" href="wifi-references.html#krotov2020rate" id="id37"><span>[krotov2020rate]</span></a></p></li>
</ul>
</section>
<section id="constantratewifimanager">
<h4><span class="section-number">35.1.3.2.15. </span>ConstantRateWifiManager<a class="headerlink" href="#constantratewifimanager" title="Link to this heading">¶</a></h4>
<p>The constant rate control algorithm always uses the same
transmission mode for every packet. Users can set a desired
‘DataMode’ for all ‘unicast’ packets and ‘ControlMode’ for all
‘request’ control packets (e.g. RTS).</p>
<p>To specify different data mode for non-unicast packets, users
must set the ‘NonUnicastMode’ attribute of the
WifiRemoteStationManager.  Otherwise, WifiRemoteStationManager
will use a mode with the lowest rate for non-unicast packets.</p>
<p>The 802.11 standard is quite clear on the rules for selection
of transmission parameters for control response frames (e.g.
CTS and ACK).  <em>ns-3</em> follows the standard and selects the rate
of control response frames from the set of basic rates or
mandatory rates. This means that control response frames may
be sent using different rate even though the ConstantRateWifiManager
is used.  The ControlMode attribute of the ConstantRateWifiManager
is used for RTS frames only.  The rate of CTS and ACK frames are
selected according to the 802.11 standard.  However, users can still
manually add WifiMode to the basic rate set that will allow control
response frames to be sent at other rates.  Please consult the
<a class="reference external" href="https://www.nsnam.org/wiki/HOWTO_add_basic_rates_to_802.11">project wiki</a> on how to do this.</p>
<p>Available attributes:</p>
<ul class="simple">
<li><p>DataMode (default WifiMode::OfdmRate6Mbps): specify a mode for
all non-unicast packets</p></li>
<li><p>ControlMode (default WifiMode::OfdmRate6Mbps): specify a mode for
all ‘request’ control packets</p></li>
</ul>
</section>
<section id="idealwifimanager">
<h4><span class="section-number">35.1.3.2.16. </span>IdealWifiManager<a class="headerlink" href="#idealwifimanager" title="Link to this heading">¶</a></h4>
<p>The ideal rate control algorithm selects the best
mode according to the SNR of the previous packet sent.
Consider node <em>A</em> sending a unicast packet to node <em>B</em>.
When <em>B</em> successfully receives the packet sent from <em>A</em>,
<em>B</em> records the SNR of the received packet into a <code class="docutils literal notranslate"><span class="pre">ns3::SnrTag</span></code>
and adds the tag to an ACK back to <em>A</em>.
By doing this, <em>A</em> is able to learn the SNR of the packet sent to <em>B</em>
using an out-of-band mechanism (thus the name ‘ideal’).
<em>A</em> then uses the SNR to select a transmission mode based
on a set of SNR thresholds, which was built from a target BER and
mode-specific SNR/BER curves.</p>
<p>Available attribute:</p>
<ul class="simple">
<li><p>BerThreshold (default 1e-6): The maximum Bit Error Rate
that is used to calculate the SNR threshold for each mode.</p></li>
</ul>
<p>Note that the BerThreshold has to be low enough to select a robust enough MCS
(or mode) for a given SNR value, without being too restrictive on the target BER.
Indeed we had noticed that the previous default value (i.e. 1e-5) led to the
selection of HE MCS-11 which resulted in high PER.
With this new default value (i.e. 1e-6), a HE STA moving away from a HE AP has
smooth throughput decrease (whereas with 1e-5, better performance was seen further
away, which is not “ideal”).</p>
</section>
<section id="thompsonsamplingwifimanager">
<h4><span class="section-number">35.1.3.2.17. </span>ThompsonSamplingWifiManager<a class="headerlink" href="#thompsonsamplingwifimanager" title="Link to this heading">¶</a></h4>
<p>Thompson Sampling (TS) is a classical solution to the Multi-Armed
Bandit problem.  <cite>ThompsonSamplingWifiManager</cite> implements a rate
control algorithm based on TS with the goal of providing a simple
statistics-based algorithm with a low number of parameters.</p>
<p>The algorithm maintains the number of successful transmissions
<img class="math" src="_images/math/bc58c6693b4ac49be11f139916296dcbc22c3191.png" alt="\alpha_i"/> and the number of unsuccessful transmissions
<img class="math" src="_images/math/f83fcfca3eb762c71e468c16e685f3fcea7fe2f0.png" alt="\beta_i"/> for each MCS <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>, both of which are initially
set to zero.</p>
<p>To select MCS for a data frame, the algorithm draws a sample frame
success rate <img class="math" src="_images/math/a554e42bdccfdc2c87802f5d26d2fff6d3c72a6f.png" alt="q_i"/> from the beta distribution with shape
parameters <img class="math" src="_images/math/5c3caccd34cb5a5655847f730a199259be544471.png" alt="(1 + \alpha_i, 1 + \beta_i)"/> for each MCS and then
selects MCS with the highest expected throughput calculated as the
sample frame success rate multiplied by MCS rate.</p>
<p>To account for changing channel conditions, exponential decay is
applied to <img class="math" src="_images/math/bc58c6693b4ac49be11f139916296dcbc22c3191.png" alt="\alpha_i"/> and <img class="math" src="_images/math/f83fcfca3eb762c71e468c16e685f3fcea7fe2f0.png" alt="\beta_i"/>. The rate of
exponential decay is controlled with the <cite>Decay</cite> attribute which is
the inverse of the time constant. Default value of 1 Hz results in
using exponential window with the time constant of 1 second.  Setting
this value to zero effectively disables exponential decay and can be
used in static scenarios.</p>
<p>Control frames are always transmitted using the most robust MCS,
except when the standard specifies otherwise, such as for ACK frames.</p>
<p>As the main goal of this algorithm is to provide a stable baseline, it
does not take into account backoff overhead, inter-frame spaces and
aggregation for MCS rate calculation. For an example of a more complex
statistics-based rate control algorithm used in real devices, consider
Minstrel-HT described below.</p>
</section>
<section id="minstrelwifimanager">
<h4><span class="section-number">35.1.3.2.18. </span>MinstrelWifiManager<a class="headerlink" href="#minstrelwifimanager" title="Link to this heading">¶</a></h4>
<p>The minstrel rate control algorithm is a rate control algorithm originated from
madwifi project. It is currently the default rate control algorithm of the Linux kernel.</p>
<p>Minstrel keeps track of the probability of successfully sending a frame of each available rate.
Minstrel then calculates the expected throughput by multiplying the probability with the rate.
This approach is chosen to make sure that lower rates are not selected in favor of the higher
rates (since lower rates are more likely to have higher probability).</p>
<p>In minstrel, roughly 10 percent of transmissions are sent at the so-called lookaround rate.
The goal of the lookaround rate is to force minstrel to try higher rate than the currently used rate.</p>
<p>For a more detailed information about minstrel, see <a class="reference internal" href="wifi-references.html#linuxminstrel" id="id38"><span>[linuxminstrel]</span></a>.</p>
</section>
<section id="minstrelhtwifimanager">
<h4><span class="section-number">35.1.3.2.19. </span>MinstrelHtWifiManager<a class="headerlink" href="#minstrelhtwifimanager" title="Link to this heading">¶</a></h4>
<p>This is the extension of minstrel for 802.11n/ac/ax.</p>
</section>
<section id="ax-obss-pd-spatial-reuse">
<h4><span class="section-number">35.1.3.2.20. </span>802.11ax OBSS PD spatial reuse<a class="headerlink" href="#ax-obss-pd-spatial-reuse" title="Link to this heading">¶</a></h4>
<p>802.11ax mode supports OBSS PD spatial reuse feature.
OBSS PD stands for Overlapping Basic Service Set Preamble-Detection.
OBSS PD is an 802.11ax specific feature that allows a STA, under specific conditions,
to ignore an inter-BSS PPDU.</p>
</section>
<section id="obss-pd-algorithm">
<h4><span class="section-number">35.1.3.2.21. </span>OBSS PD Algorithm<a class="headerlink" href="#obss-pd-algorithm" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ObssPdAlgorithm</span></code> is the base class of OBSS PD algorithms.
It implements the common functionalities. First, it makes sure the necessary callbacks are setup.
Second, when a PHY reset is requested by the algorithm, it performs the computation to determine the TX power
restrictions and informs the PHY object.</p>
<p>The PHY keeps tracks of incoming requests from the MAC to get access to the channel.
If a request is received and if PHY reset(s) indicating TX power limitations occurred
before a packet was transmitted, the next packet to be transmitted will be sent with
a reduced power. Otherwise, no TX power restrictions will be applied.</p>
</section>
<section id="constant-obss-pd-algorithm">
<h4><span class="section-number">35.1.3.2.22. </span>Constant OBSS PD Algorithm<a class="headerlink" href="#constant-obss-pd-algorithm" title="Link to this heading">¶</a></h4>
<p>Constant OBSS PD algorithm is a simple OBSS PD algorithm implemented in the <code class="docutils literal notranslate"><span class="pre">ConstantObssPdAlgorithm</span></code> class.</p>
<p>Once a HE preamble and its header have been received by the PHY, <code class="docutils literal notranslate"><span class="pre">ConstantObssPdAlgorithm::</span>
<span class="pre">ReceiveHeSig</span></code> is triggered.
The algorithm then checks whether this is an OBSS frame by comparing its own BSS color with the BSS color of the received preamble.
If this is an OBSS frame, it compares the received RSSI with its configured OBSS PD level value. The PHY then gets reset to IDLE
state in case the received RSSI is lower than that constant OBSS PD level value, and is informed about a TX power restrictions.</p>
<p>Note: since our model is based on a single threshold, the PHY only supports one restricted power level.</p>
</section>
<section id="modifying-wifi-model">
<h4><span class="section-number">35.1.3.2.23. </span>Modifying Wifi model<a class="headerlink" href="#modifying-wifi-model" title="Link to this heading">¶</a></h4>
<p>Modifying the default wifi model is one of the common tasks when performing research.
We provide an overview of how to make changes to the default wifi model in this section.
Depending on your goal, the common tasks are (in no particular order):</p>
<ul class="simple">
<li><p>Creating or modifying the default Wi-Fi frames/headers by making changes to <code class="docutils literal notranslate"><span class="pre">wifi-mac-header.*</span></code>.</p></li>
<li><p>MAC low modification. For example, handling new/modified control frames (think RTS/CTS/ACK/Block ACK),
making changes to two-way transaction/four-way transaction.  Users usually make changes to
<code class="docutils literal notranslate"><span class="pre">frame-exchange-manager.*</span></code> or its subclasses to accomplish this.
Handling of control frames is performed in <code class="docutils literal notranslate"><span class="pre">FrameExchangeManager::ReceiveMpdu</span></code>.</p></li>
<li><p>MAC high modification. For example, handling new management frames (think beacon/probe),
beacon/probe generation.  Users usually make changes to <code class="docutils literal notranslate"><span class="pre">wifi-mac.*</span></code>,``sta-wifi-mac.*``, <code class="docutils literal notranslate"><span class="pre">ap-wifi-mac.*</span></code>, or <code class="docutils literal notranslate"><span class="pre">adhoc-wifi-mac.*</span></code> to accomplish this.</p></li>
<li><p>Wi-Fi queue management.  The files <code class="docutils literal notranslate"><span class="pre">txop.*</span></code> and <code class="docutils literal notranslate"><span class="pre">qos-txop.*</span></code> are of interest for this task.</p></li>
<li><p>Channel access management.  Users should modify the files <code class="docutils literal notranslate"><span class="pre">channel-access-manager.*</span></code>, which grant access to
<code class="docutils literal notranslate"><span class="pre">Txop</span></code> and <code class="docutils literal notranslate"><span class="pre">QosTxop</span></code>.</p></li>
<li><p>Fragmentation and RTS threholds are handled by Wi-Fi remote station manager.  Note that Wi-Fi remote
station manager simply indicates if fragmentation and RTS are needed.  Fragmentation is handled by
<code class="docutils literal notranslate"><span class="pre">Txop</span></code> or <code class="docutils literal notranslate"><span class="pre">QosTxop</span></code> while RTS/CTS transaction is handled by <code class="docutils literal notranslate"><span class="pre">FrameExchangeManager</span></code>.</p></li>
<li><p>Modifying or creating new rate control algorithms can be done by creating a new child class of Wi-Fi remote
station manager or modifying the existing ones.</p></li>
</ul>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">35.1. Design Documentation</a><ul>
<li><a class="reference internal" href="#overview-of-the-model">35.1.1. Overview of the model</a><ul>
<li><a class="reference internal" href="#mac-high-models">35.1.1.1. MAC high models</a></li>
<li><a class="reference internal" href="#mac-low-layer">35.1.1.2. MAC low layer</a></li>
<li><a class="reference internal" href="#phy-layer-models">35.1.1.3. PHY layer models</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scope-and-limitations">35.1.2. Scope and Limitations</a></li>
<li><a class="reference internal" href="#design-details">35.1.3. Design Details</a><ul>
<li><a class="reference internal" href="#wifiphy-and-related-models">35.1.3.1. WifiPhy and related models</a><ul>
<li><a class="reference internal" href="#phyentity">35.1.3.1.1. PhyEntity</a><ul>
<li><a class="reference internal" href="#a-bit-of-background">35.1.3.1.1.1. A bit of background</a></li>
<li><a class="reference internal" href="#architecture">35.1.3.1.1.2. Architecture</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wifippdu">35.1.3.1.2. WifiPpdu</a></li>
<li><a class="reference internal" href="#yanswifiphy-and-wifiphystatehelper">35.1.3.1.3. YansWifiPhy and WifiPhyStateHelper</a></li>
<li><a class="reference internal" href="#interferencehelper">35.1.3.1.4. InterferenceHelper</a></li>
<li><a class="reference internal" href="#errorratemodel">35.1.3.1.5. ErrorRateModel</a></li>
<li><a class="reference internal" href="#tablebasederrorratemodel">35.1.3.1.6. TableBasedErrorRateModel</a></li>
<li><a class="reference internal" href="#legacy-errorratemodels">35.1.3.1.7. Legacy ErrorRateModels</a></li>
<li><a class="reference internal" href="#spectrumwifiphy">35.1.3.1.8. SpectrumWifiPhy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-mac-model">35.1.3.2. The MAC model</a><ul>
<li><a class="reference internal" href="#infrastructure-association">35.1.3.2.1. Infrastructure association</a></li>
<li><a class="reference internal" href="#roaming">35.1.3.2.2. Roaming</a></li>
<li><a class="reference internal" href="#channel-access">35.1.3.2.3. Channel access</a></li>
<li><a class="reference internal" href="#frame-exchange-managers">35.1.3.2.4. Frame Exchange Managers</a></li>
<li><a class="reference internal" href="#mac-queues">35.1.3.2.5. MAC queues</a></li>
<li><a class="reference internal" href="#multi-user-transmissions">35.1.3.2.6. Multi-user transmissions</a></li>
<li><a class="reference internal" href="#multi-user-scheduler">35.1.3.2.7. Multi-User Scheduler</a></li>
<li><a class="reference internal" href="#round-robin-multi-user-scheduler">35.1.3.2.8. Round-robin Multi-User Scheduler</a></li>
<li><a class="reference internal" href="#enhanced-multi-link-single-radio-operation-emlsr">35.1.3.2.9. Enhanced multi-link single radio operation (EMLSR)</a><ul>
<li><a class="reference internal" href="#non-ap-mld-side">35.1.3.2.9.1. Non-AP MLD side</a></li>
<li><a class="reference internal" href="#ap-mld-side">35.1.3.2.9.2. AP MLD side</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ack-manager">35.1.3.2.10. Ack manager</a></li>
<li><a class="reference internal" href="#wifidefaultackmanager">35.1.3.2.11. WifiDefaultAckManager</a></li>
<li><a class="reference internal" href="#protection-manager">35.1.3.2.12. Protection manager</a></li>
<li><a class="reference internal" href="#wifidefaultprotectionmanager">35.1.3.2.13. WifiDefaultProtectionManager</a></li>
<li><a class="reference internal" href="#rate-control-algorithms">35.1.3.2.14. Rate control algorithms</a></li>
<li><a class="reference internal" href="#constantratewifimanager">35.1.3.2.15. ConstantRateWifiManager</a></li>
<li><a class="reference internal" href="#idealwifimanager">35.1.3.2.16. IdealWifiManager</a></li>
<li><a class="reference internal" href="#thompsonsamplingwifimanager">35.1.3.2.17. ThompsonSamplingWifiManager</a></li>
<li><a class="reference internal" href="#minstrelwifimanager">35.1.3.2.18. MinstrelWifiManager</a></li>
<li><a class="reference internal" href="#minstrelhtwifimanager">35.1.3.2.19. MinstrelHtWifiManager</a></li>
<li><a class="reference internal" href="#ax-obss-pd-spatial-reuse">35.1.3.2.20. 802.11ax OBSS PD spatial reuse</a></li>
<li><a class="reference internal" href="#obss-pd-algorithm">35.1.3.2.21. OBSS PD Algorithm</a></li>
<li><a class="reference internal" href="#constant-obss-pd-algorithm">35.1.3.2.22. Constant OBSS PD Algorithm</a></li>
<li><a class="reference internal" href="#modifying-wifi-model">35.1.3.2.23. Modifying Wifi model</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="wifi.html"
                          title="previous chapter"><span class="section-number">35. </span>Wi-Fi Module</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="wifi-user.html"
                          title="next chapter"><span class="section-number">35.2. </span>User Documentation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/wifi-design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="wifi-user.html" title="35.2. User Documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="wifi.html" title="35. Wi-Fi Module"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="wifi.html" ><span class="section-number">35. </span>Wi-Fi Module</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">35.1. </span>Design Documentation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006-2019.
      Last updated on Dec 18, 2023 10:42.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>