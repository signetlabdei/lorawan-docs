
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>20.2. User Documentation &#8212; Model Library</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/default.css?v=bb97339c" />
    <script src="_static/documentation_options.js?v=316584e3"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="20.3. Testing Documentation" href="lte-testing.html" />
    <link rel="prev" title="20.1. Design Documentation" href="lte-design.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico"
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>


  </head><body>
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" width="100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo">
              <a id="ns3_home1"
                 href="http://www.nsnam.org/">
                 <img alt="ns-3 Logo" style="background-color: unset;"
                      src="_static/ns-3-inverted-notext-small.png"/>
              </a>
            </td>
            <td id="projecttext">
              <div id="projectbrief">A Discrete-Event Network Simulator</div>
              <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
            </td>

            <td id="ns3-menu">
              <div class="menu">
                <ul >
                  <li style="background-image:none">
                    <a id="ns3_home2"
                         href="http://www.nsnam.org/"
                         >&nbsp;&nbsp;Home</a>
                  </li>
                  <li><span
                        onmouseover="mopen('mTuts')"
                        onmouseout="mclosetime()"
                          >Tutorials &nbsp;&#x25BC;</span>
                      <div id="mTuts"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_tut"
                           href="/docs/tutorial/html/index.html"
                            >English</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDocs')"
                        onmouseout="mclosetime()"
                          >Documentation &nbsp;&#x25BC;</span>
                      <div id="mDocs"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_ins"
                           href="/docs/installation/html/index.html"
                           >Installation</a><br/>
                        <a id="ns3_man"
                           href="/docs/manual/html/index.html"
                           >Manual</a><br/>
                        <a id="ns3_mod"
                           href="/docs/models/html/index.html"
                           >Models</a><br/>
                        <a id="ns3_con"
                           href="/docs/contributing/html/index.html"
                           >Contributing</a><br/>
                        <a id="ns3_wiki"
                           href="http://www.nsnam.org/wiki"
                           >Wiki</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDev')"
                        onmouseout="mclosetime()"
                          >Development &nbsp;&#x25BC;</span>
                      <div id="mDev"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_api"
                           href="/docs/doxygen/html/index.html"
                           >API Docs</a><br/>
                        <a id="ns3_bugs"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/issues"
                           >Issue Tracker</a><br/>
                        <a id="ns3_merge"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests"
                           >Merge Requests</a><br/>
                      </div>
                  </li>
                </ul>
              </div>
            </td>

            <td id="projectsection">
              <span style="margin-right:10px">Models</span>
            </td>
          </tr>
        </tbody>
      </table>
      <script  type="text/javascript">ns3_write_links()</script>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="lte-testing.html" title="20.3. Testing Documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lte-design.html" title="20.1. Design Documentation"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="lte.html" accesskey="U"><span class="section-number">20. </span>LTE Module</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">20.2. </span>User Documentation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="user-documentation">
<h1><span class="section-number">20.2. </span>User Documentation<a class="headerlink" href="#user-documentation" title="Link to this heading">¶</a></h1>
<section id="background">
<h2><span class="section-number">20.2.1. </span>Background<a class="headerlink" href="#background" title="Link to this heading">¶</a></h2>
<p>We assume the reader is already familiar with how to use the ns-3
simulator to run generic simulation programs. If this is not the case,
we strongly recommend the reader to consult <a class="reference internal" href="lte-references.html#ns3tutorial" id="id1"><span>[ns3tutorial]</span></a>.</p>
</section>
<section id="usage-overview">
<h2><span class="section-number">20.2.2. </span>Usage Overview<a class="headerlink" href="#usage-overview" title="Link to this heading">¶</a></h2>
<p>The ns-3 LTE model is a software library that allows the simulation of
LTE networks, optionally including the Evolved Packet Core (EPC).  The
process of performing such simulations typically involves the
following steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><em>Define the scenario</em> to be simulated</p></li>
<li><p><em>Write a simulation program</em> that recreates the desired scenario
topology/architecture. This is done accessing the ns-3 LTE model
library using the <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper</span></code> API defined in <code class="docutils literal notranslate"><span class="pre">src/lte/helper/lte-helper.h</span></code>.</p></li>
<li><p><em>Specify configuration parameters</em> of the objects that are being
used for the simulation. This can be done using input files (via the
<code class="docutils literal notranslate"><span class="pre">ns3::ConfigStore</span></code>) or directly within the simulation program.</p></li>
<li><p><em>Configure the desired output</em> to be produced by the simulator</p></li>
<li><p><em>Run</em> the simulation.</p></li>
</ol>
</div></blockquote>
<p>All these aspects will be explained in the following sections by means
of practical examples.</p>
</section>
<section id="basic-simulation-program">
<span id="sec-basic-simulation-program"></span><h2><span class="section-number">20.2.3. </span>Basic simulation program<a class="headerlink" href="#basic-simulation-program" title="Link to this heading">¶</a></h2>
<p>Here is the minimal simulation program that is needed to do an LTE-only simulation (without EPC).</p>
<ol class="arabic">
<li><p>Initial boilerplate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;ns3/core-module.h&gt;
#include &lt;ns3/network-module.h&gt;
#include &lt;ns3/mobility-module.h&gt;
#include &lt;ns3/lte-module.h&gt;

using namespace ns3;

int main(int argc, char *argv[])
{
  // the rest of the simulation program follows
</pre></div>
</div>
</li>
<li><p>Create an <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
</pre></div>
</div>
<p>This will instantiate some common
objects (e.g., the Channel object) and provide the methods to add
eNBs and UEs and configure them.</p>
</li>
<li><p>Create <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects for the eNB(s) and the UEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NodeContainer enbNodes;
enbNodes.Create(1);
NodeContainer ueNodes;
ueNodes.Create(2);
</pre></div>
</div>
<p>Note that the above Node instances at this point still don’t have
an LTE protocol stack installed; they’re just empty nodes.</p>
</li>
<li><p>Configure the Mobility model for all the nodes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MobilityHelper mobility;
mobility.SetMobilityModel(&quot;ns3::ConstantPositionMobilityModel&quot;);
mobility.Install(enbNodes);
mobility.SetMobilityModel(&quot;ns3::ConstantPositionMobilityModel&quot;);
mobility.Install(ueNodes);
</pre></div>
</div>
<p>The above will place all nodes at the coordinates (0,0,0). Please
refer to the documentation of the ns-3 mobility model for how to
set your own position or configure node movement.</p>
</li>
<li><p>Install an LTE protocol stack on the eNB(s):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer enbDevs;
enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes);
</pre></div>
</div>
</li>
<li><p>Install an LTE protocol stack on the UEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer ueDevs;
ueDevs = lteHelper-&gt;InstallUeDevice(ueNodes);
</pre></div>
</div>
</li>
<li><p>Attach the UEs to an eNB. This will configure each UE according to
the eNB configuration, and create an RRC connection between them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(ueDevs, enbDevs.Get(0));
</pre></div>
</div>
</li>
<li><p>Activate a data radio bearer between each UE and the eNB it is attached to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
EpsBearer bearer(q);
lteHelper-&gt;ActivateDataRadioBearer(ueDevs, bearer);
</pre></div>
</div>
<p>this method will also activate two saturation traffic generators for
that bearer, one in uplink and one in downlink.</p>
</li>
<li><p>Set the stop time:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Stop(Seconds(0.005));
</pre></div>
</div>
<p>This is needed otherwise the simulation will last forever, because
(among others) the start-of-subframe event is scheduled repeatedly, and the
ns-3 simulator scheduler will hence never run out of events.</p>
</li>
<li><p>Run the simulation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Run();
</pre></div>
</div>
</li>
<li><p>Cleanup and exit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Destroy();
return 0;
}
</pre></div>
</div>
</li>
</ol>
<p>For how to compile and run simulation programs, please refer to <a class="reference internal" href="lte-references.html#ns3tutorial" id="id2"><span>[ns3tutorial]</span></a>.</p>
</section>
<section id="configuration-of-lte-model-parameters">
<h2><span class="section-number">20.2.4. </span>Configuration of LTE model parameters<a class="headerlink" href="#configuration-of-lte-model-parameters" title="Link to this heading">¶</a></h2>
<p>All the relevant LTE model parameters are managed through the ns-3
attribute system. Please refer to the <a class="reference internal" href="lte-references.html#ns3tutorial" id="id3"><span>[ns3tutorial]</span></a> and <a class="reference internal" href="lte-references.html#ns3manual" id="id4"><span>[ns3manual]</span></a>
for detailed information on all the possible methods to do it
(environmental variables, C++ API, GtkConfigStore…).</p>
<p>In the following, we just briefly summarize
how to do it using input files together with the ns-3 ConfigStore.
First of all, you need to put the following in your simulation
program, right after <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">()</span></code> starts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CommandLine cmd(__FILE__);
cmd.Parse(argc, argv);
ConfigStore inputConfig;
inputConfig.ConfigureDefaults();
// parse again so you can override default values from the command line
cmd.Parse(argc, argv);
</pre></div>
</div>
<p>for the above to work, make sure you also <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;ns3/config-store.h&quot;</span></code>.
Now create a text file named (for example) <code class="docutils literal notranslate"><span class="pre">input-defaults.txt</span></code>
specifying the new default values that you want to use for some attributes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default ns3::LteHelper::Scheduler &quot;ns3::PfFfMacScheduler&quot;
default ns3::LteHelper::PathlossModel &quot;ns3::FriisSpectrumPropagationLossModel&quot;
default ns3::LteEnbNetDevice::UlBandwidth &quot;25&quot;
default ns3::LteEnbNetDevice::DlBandwidth &quot;25&quot;
default ns3::LteEnbNetDevice::DlEarfcn &quot;100&quot;
default ns3::LteEnbNetDevice::UlEarfcn &quot;18100&quot;
default ns3::LteUePhy::TxPower &quot;10&quot;
default ns3::LteUePhy::NoiseFigure &quot;9&quot;
default ns3::LteEnbPhy::TxPower &quot;30&quot;
default ns3::LteEnbPhy::NoiseFigure &quot;5&quot;
</pre></div>
</div>
<p>Supposing your simulation program is called
<code class="docutils literal notranslate"><span class="pre">src/lte/examples/lte-sim-with-input</span></code>, you can now pass these
settings to the simulation program in the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run src/lte/examples/lte-sim-with-input
--command-template=&quot;%s --ns3::ConfigStore::Filename=input-defaults.txt
--ns3::ConfigStore::Mode=Load --ns3::ConfigStore::FileFormat=RawText&quot;
</pre></div>
</div>
<p>Furthermore, you can generate a template input file with the following
command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run src/lte/examples/lte-sim-with-input
--command-template=&quot;%s --ns3::ConfigStore::Filename=input-defaults.txt
--ns3::ConfigStore::Mode=Save --ns3::ConfigStore::FileFormat=RawText&quot;
</pre></div>
</div>
<p>note that the above will put in the file <code class="docutils literal notranslate"><span class="pre">input-defaults.txt</span></code> <em>all</em>
the default values that are registered in your particular build of the
simulator, including lots of non-LTE attributes.</p>
</section>
<section id="configure-lte-mac-scheduler">
<h2><span class="section-number">20.2.5. </span>Configure LTE MAC Scheduler<a class="headerlink" href="#configure-lte-mac-scheduler" title="Link to this heading">¶</a></h2>
<p>There are several types of LTE MAC scheduler user can choose here. User can use following codes to define scheduler type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetSchedulerType(&quot;ns3::FdMtFfMacScheduler&quot;);    // FD-MT scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TdMtFfMacScheduler&quot;);    // TD-MT scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TtaFfMacScheduler&quot;);     // TTA scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::FdBetFfMacScheduler&quot;);   // FD-BET scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TdBetFfMacScheduler&quot;);   // TD-BET scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::FdTbfqFfMacScheduler&quot;);  // FD-TBFQ scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TdTbfqFfMacScheduler&quot;);  // TD-TBFQ scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::PssFfMacScheduler&quot;);     //PSS scheduler
</pre></div>
</div>
<p>TBFQ and PSS have more parameters than other schedulers. Users can define those parameters in following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* TBFQ scheduler::

 Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
 lteHelper-&gt;SetSchedulerAttribute(&quot;DebtLimit&quot;, IntegerValue(yourvalue)); // default value -625000 bytes(-5Mb)
 lteHelper-&gt;SetSchedulerAttribute(&quot;CreditLimit&quot;, UintegerValue(yourvalue)); // default value 625000 bytes(5Mb)
 lteHelper-&gt;SetSchedulerAttribute(&quot;TokenPoolSize&quot;, UintegerValue(yourvalue)); // default value 1 byte
 lteHelper-&gt;SetSchedulerAttribute(&quot;CreditableThreshold&quot;, UintegerValue(yourvalue)); // default value 0

* PSS scheduler::

 Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
 lteHelper-&gt;SetSchedulerAttribute(&quot;nMux&quot;, UIntegerValue(yourvalue)); // the maximum number of UE selected by TD scheduler
 lteHelper-&gt;SetSchedulerAttribute(&quot;PssFdSchedulerType&quot;, StringValue(&quot;CoItA&quot;)); // PF scheduler type in PSS
</pre></div>
</div>
<p>In TBFQ, default values of debt limit and credit limit are set to -5Mb and 5Mb respectively based on paper <a class="reference internal" href="lte-references.html#fabokhari2009" id="id5"><span>[FABokhari2009]</span></a>.
Current implementation does not consider credit threshold (<img class="math" src="_images/math/4db5b6e16e06f929ce3f675c5e535d06ffb02ff7.png" alt="C"/> = 0). In PSS, if user does not define nMux,
PSS will set this value to half of total UE. The default FD scheduler is PFsch.</p>
<p>In addition, token generation rate in TBFQ and target bit rate in PSS need to be configured by Guarantee Bit Rate (GBR) or
Maximum Bit Rate (MBR) in epc bearer QoS parameters. Users can use following codes to define GBR and MBR in both downlink and uplink:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
enum EpsBearer::Qci q = EpsBearer::yourvalue;  // define Qci type
GbrQosInformation qos;
qos.gbrDl = yourvalue; // Downlink GBR
qos.gbrUl = yourvalue; // Uplink GBR
qos.mbrDl = yourvalue; // Downlink MBR
qos.mbrUl = yourvalue; // Uplink MBR
EpsBearer bearer(q, qos);
lteHelper-&gt;ActivateDedicatedEpsBearer(ueDevs, bearer, EpcTft::Default());
</pre></div>
</div>
<p>In PSS, TBR is obtained from GBR in bearer level QoS parameters. In TBFQ, token generation rate is obtained from the MBR
setting in bearer level QoS parameters, which therefore needs to be configured consistently.
For constant bit rate (CBR) traffic, it is suggested to set MBR to GBR. For variance bit rate (VBR) traffic,
it is suggested to set MBR k times larger than GBR in order to cover the peak traffic rate. In current implementation, k is set to
three based on paper <a class="reference internal" href="lte-references.html#fabokhari2009" id="id6"><span>[FABokhari2009]</span></a>. In addition, current version of TBFQ does not consider RLC header and PDCP header length in
MBR and GBR. Another parameter in TBFQ is packet arrival rate. This parameter is calculated within scheduler and equals to the past
average throughput which is used in PF scheduler.</p>
<p>Many useful attributes of the LTE-EPC model will be described in the
following subsections. Still, there are many attributes which are not
explicitly mentioned in the design or user documentation, but which
are clearly documented using the ns-3 attribute system. You can easily
print a list of the attributes of a given object together with their
description and default value passing <code class="docutils literal notranslate"><span class="pre">--PrintAttributes=</span></code> to a simulation
program, like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteHelper&quot;
</pre></div>
</div>
<p>You can try also with other LTE and EPC objects, like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteEnbNetDevice&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteEnbMac&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteEnbPhy&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteUePhy&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::PointToPointEpcHelper&quot;
</pre></div>
</div>
</section>
<section id="simulation-output">
<span id="sec-simulation-output"></span><h2><span class="section-number">20.2.6. </span>Simulation Output<a class="headerlink" href="#simulation-output" title="Link to this heading">¶</a></h2>
<p>The ns-3 LTE model currently supports the output to file of PHY, MAC, RLC
and PDCP level Key Performance Indicators (KPIs). You can enable it in
the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();

// configure all the simulation scenario here...

lteHelper-&gt;EnablePhyTraces();
lteHelper-&gt;EnableMacTraces();
lteHelper-&gt;EnableRlcTraces();
lteHelper-&gt;EnablePdcpTraces();

Simulator::Run();
</pre></div>
</div>
<p>RLC and PDCP KPIs are calculated over a time interval and stored on ASCII
files, two for RLC KPIs and two for PDCP KPIs, in each case one for
uplink and one for downlink. The time interval duration can be controlled using the attribute
<code class="docutils literal notranslate"><span class="pre">ns3::RadioBearerStatsCalculator::EpochDuration</span></code>.</p>
<p>The columns of the RLC KPI files is the following (the same
for uplink and downlink):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>start time of measurement interval in seconds since the start of simulation</p></li>
<li><p>end time of measurement interval in seconds since the start of simulation</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>Logical Channel ID</p></li>
<li><p>Number of transmitted RLC PDUs</p></li>
<li><p>Total bytes transmitted.</p></li>
<li><p>Number of received RLC PDUs</p></li>
<li><p>Total bytes received</p></li>
<li><p>Average RLC PDU delay in seconds</p></li>
<li><p>Standard deviation of the RLC PDU delay</p></li>
<li><p>Minimum value of the RLC PDU delay</p></li>
<li><p>Maximum value of the RLC PDU delay</p></li>
<li><p>Average RLC PDU size, in bytes</p></li>
<li><p>Standard deviation of the RLC PDU size</p></li>
<li><p>Minimum RLC PDU size</p></li>
<li><p>Maximum RLC PDU size</p></li>
</ol>
</div></blockquote>
<p>Similarly, the columns of the PDCP KPI files is the following (again, the same
for uplink and downlink):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>start time of measurement interval in seconds since the start of simulation</p></li>
<li><p>end time of measurement interval in seconds since the start of simulation</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>Logical Channel ID</p></li>
<li><p>Number of transmitted PDCP PDUs</p></li>
<li><p>Total bytes transmitted.</p></li>
<li><p>Number of received PDCP PDUs</p></li>
<li><p>Total bytes received</p></li>
<li><p>Average PDCP PDU delay in seconds</p></li>
<li><p>Standard deviation of the PDCP PDU delay</p></li>
<li><p>Minimum value of the PDCP PDU delay</p></li>
<li><p>Maximum value of the PDCP PDU delay</p></li>
<li><p>Average PDCP PDU size, in bytes</p></li>
<li><p>Standard deviation of the PDCP PDU size</p></li>
<li><p>Minimum PDCP PDU size</p></li>
<li><p>Maximum PDCP PDU size</p></li>
</ol>
</div></blockquote>
<p><strong>Note:</strong> The PDCP traces for data radio bearers are not generated when
<a class="reference internal" href="lte-design.html#sec-sm-rlc"><span class="std std-ref">SM RLC</span></a> is used.</p>
<p>MAC KPIs are basically a trace of the resource allocation reported by
the scheduler upon the start of every subframe. They are stored in
ASCII files. For downlink MAC KPIs the format is the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>Frame number</p></li>
<li><p>Subframe number</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>MCS of TB 1</p></li>
<li><p>size of TB 1</p></li>
<li><p>MCS of TB 2 (0 if not present)</p></li>
<li><p>size of TB 2 (0 if not present)</p></li>
</ol>
</div></blockquote>
<p>while for uplink MAC KPIs the format is:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>Frame number</p></li>
<li><p>Subframe number</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>MCS of TB</p></li>
<li><p>size of TB</p></li>
</ol>
</div></blockquote>
<p>The names of the files used for MAC KPI output can be customized via
the ns-3 attributes <code class="docutils literal notranslate"><span class="pre">ns3::MacStatsCalculator::DlOutputFilename</span></code> and
<code class="docutils literal notranslate"><span class="pre">ns3::MacStatsCalculator::UlOutputFilename</span></code>.</p>
<p>PHY KPIs are distributed in seven different files, configurable through the attributes</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::DlRsrpSinrFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::UeSinrFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::InterferenceFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::DlTxOutputFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::UlTxOutputFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::DlRxOutputFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::UlRxOutputFilename</span></code></p></li>
</ol>
</div></blockquote>
<p>In the RSRP/SINR file, the following content is available:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>RSRP</p></li>
<li><p>Linear average over all RBs of the downlink SINR in linear units</p></li>
</ol>
</div></blockquote>
<p>The contents in the UE SINR file are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>uplink SINR in linear units for the UE</p></li>
</ol>
</div></blockquote>
<p>In the interference filename the content is:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>List of interference values per RB</p></li>
</ol>
</div></blockquote>
<p>In UL and DL transmission files the parameters included are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in milliseconds</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>RNTI</p></li>
<li><p>Layer of transmission</p></li>
<li><p>MCS</p></li>
<li><p>size of the TB</p></li>
<li><p>Redundancy version</p></li>
<li><p>New Data Indicator flag</p></li>
</ol>
</div></blockquote>
<p>And finally, in UL and DL reception files the parameters included are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in milliseconds</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>RNTI</p></li>
<li><p>Transmission Mode</p></li>
<li><p>Layer of transmission</p></li>
<li><p>MCS</p></li>
<li><p>size of the TB</p></li>
<li><p>Redundancy version</p></li>
<li><p>New Data Indicator flag</p></li>
<li><p>Correctness in the reception of the TB</p></li>
</ol>
</div></blockquote>
<p><strong>Note:</strong> The traces generated by simulating the scenarios involving the RLF
will have a discontinuity in time from the moment of the RLF event until the UE
connects again to an eNB.</p>
</section>
<section id="fading-trace-usage">
<h2><span class="section-number">20.2.7. </span>Fading Trace Usage<a class="headerlink" href="#fading-trace-usage" title="Link to this heading">¶</a></h2>
<p>In this section we will describe how to use fading traces within LTE simulations.</p>
<section id="fading-traces-generation">
<h3><span class="section-number">20.2.7.1. </span>Fading Traces Generation<a class="headerlink" href="#fading-traces-generation" title="Link to this heading">¶</a></h3>
<p>It is possible to generate fading traces by using a dedicated matlab script provided with the code (<code class="docutils literal notranslate"><span class="pre">/lte/model/fading-traces/fading-trace-generator.m</span></code>). This script already includes the typical taps configurations for three 3GPP scenarios (i.e., pedestrian, vehicular and urban as defined in Annex B.2 of <a class="reference internal" href="lte-references.html#ts36104" id="id7"><span>[TS36104]</span></a>); however users can also introduce their specific configurations. The list of the configurable parameters is provided in the following:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fc</span></code> : the frequency in use (it affects the computation of the doppler speed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v_km_h</span></code> : the speed of the users</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">traceDuration</span></code> : the duration in seconds of the total length of the trace.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numRBs</span></code> : the number of the resource block to be evaluated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tag</span></code> : the tag to be applied to the file generated.</p></li>
</ul>
</div></blockquote>
<p>The file generated contains ASCII-formatted real values organized in a matrix fashion: every row corresponds to a different RB, and every column correspond to a different temporal fading trace sample.</p>
<p>It has to be noted that the ns-3 LTE module is able to work with any fading trace file that complies with the above described ASCII format. Hence, other external tools can be used to generate custom fading traces, such as for example other simulators or experimental devices.</p>
</section>
<section id="fading-traces-usage">
<h3><span class="section-number">20.2.7.2. </span>Fading Traces Usage<a class="headerlink" href="#fading-traces-usage" title="Link to this heading">¶</a></h3>
<p>When using a fading trace, it is of paramount importance to specify correctly the trace parameters in the simulation, so that the fading model can load and use it correctly.
The parameters to be configured are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TraceFilename</span></code> : the name of the trace to be loaded (absolute path, or relative path w.r.t. the path from where the simulation program is executed);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TraceLength</span></code> : the trace duration in seconds;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SamplesNum</span></code> : the number of samples;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WindowSize</span></code> : the size of the fading sampling window in seconds;</p></li>
</ul>
</div></blockquote>
<p>It is important to highlight that the sampling interval of the fading trace has to be 1 ms or greater, and in the latter case it has to be an integer multiple of 1 ms in order to be correctly processed by the fading module.</p>
<p>The default configuration of the matlab script provides a trace 10 seconds long, made of 10,000 samples (i.e., 1 sample per TTI=1ms) and used with a windows size of 0.5 seconds amplitude. These are also the default values of the parameters above used in the simulator; therefore their settage can be avoided in case the fading trace respects them.</p>
<p>In order to activate the fading module (which is not active by default) the following code should be included in the simulation program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetFadingModel(&quot;ns3::TraceFadingLossModel&quot;);
</pre></div>
</div>
<p>And for setting the parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFadingModelAttribute(&quot;TraceFilename&quot;, StringValue(&quot;src/lte/model/fading-traces/fading_trace_EPA_3kmph.fad&quot;));
lteHelper-&gt;SetFadingModelAttribute(&quot;TraceLength&quot;, TimeValue(Seconds(10.0)));
lteHelper-&gt;SetFadingModelAttribute(&quot;SamplesNum&quot;, UintegerValue(10000));
lteHelper-&gt;SetFadingModelAttribute(&quot;WindowSize&quot;, TimeValue(Seconds(0.5)));
lteHelper-&gt;SetFadingModelAttribute(&quot;RbNum&quot;, UintegerValue(100));
</pre></div>
</div>
<p>It has to be noted that, <code class="docutils literal notranslate"><span class="pre">TraceFilename</span></code> does not have a default value, therefore is has to be always set explicitly.</p>
<p>The simulator provide natively three fading traces generated according to the configurations defined in in Annex B.2 of <a class="reference internal" href="lte-references.html#ts36104" id="id8"><span>[TS36104]</span></a>. These traces are available in the folder <code class="docutils literal notranslate"><span class="pre">src/lte/model/fading-traces/</span></code>). An excerpt from these traces is represented in the following figures.</p>
<figure class="align-center" id="id16">
<span id="fig-fadingpedestriantrace"></span><img alt="Fading trace 3 kmph" src="_images/fading_pedestrian.png" />
<figcaption>
<p><span class="caption-text">Excerpt of the fading trace included in the simulator for a pedestrian scenario (speed of 3 kmph).</span><a class="headerlink" href="#id16" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id17">
<span id="fig-fadingvehiculartrace"></span><img alt="Fading trace 60 kmph" src="_images/fading_vehicular.png" />
<figcaption>
<p><span class="caption-text">Excerpt of the fading trace included in the simulator for a vehicular  scenario (speed of 60 kmph).</span><a class="headerlink" href="#id17" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id18">
<span id="fig-fadingurbantrace"></span><img alt="Fading trace 3 kmph" src="_images/fading_urban_3kmph.png" />
<figcaption>
<p><span class="caption-text">Excerpt of the fading trace included in the simulator for an urban  scenario (speed of 3 kmph).</span><a class="headerlink" href="#id18" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="mobility-model-with-buildings">
<h2><span class="section-number">20.2.8. </span>Mobility Model with Buildings<a class="headerlink" href="#mobility-model-with-buildings" title="Link to this heading">¶</a></h2>
<p>We now explain by examples how to use the buildings model (in particular, the <code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> and the <code class="docutils literal notranslate"><span class="pre">BuildingPropagationModel</span></code> classes) in an ns-3 simulation program to setup an LTE simulation scenario that includes buildings and indoor nodes.</p>
<ol class="arabic">
<li><p>Header files to be included:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;ns3/mobility-building-info.h&gt;
#include &lt;ns3/buildings-propagation-loss-model.h&gt;
#include &lt;ns3/building.h&gt;
</pre></div>
</div>
</li>
<li><p>Pathloss model selection:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();

lteHelper-&gt;SetAttribute(&quot;PathlossModel&quot;, StringValue(&quot;ns3::BuildingsPropagationLossModel&quot;));
</pre></div>
</div>
</li>
<li><p>EUTRA Band Selection</p></li>
</ol>
<p>The selection of the working frequency of the propagation model has to be done with the standard ns-3 attribute system as described in the correspond section (“Configuration of LTE model parameters”) by means of the DlEarfcn and UlEarfcn parameters, for instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEnbDeviceAttribute(&quot;DlEarfcn&quot;, UintegerValue(100));
lteHelper-&gt;SetEnbDeviceAttribute(&quot;UlEarfcn&quot;, UintegerValue(18100));
</pre></div>
</div>
<p>It is to be noted that using other means to configure the frequency used by the propagation model (i.e., configuring the corresponding BuildingsPropagationLossModel attributes directly) might generates conflicts in the frequencies definition in the modules during the simulation, and is therefore not advised.</p>
<ol class="arabic">
<li><p>Mobility model selection:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MobilityHelper mobility;
mobility.SetMobilityModel(&quot;ns3::ConstantPositionMobilityModel&quot;);

It is to be noted that any mobility model can be used.
</pre></div>
</div>
</li>
<li><p>Building creation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double x_min = 0.0;
double x_max = 10.0;
double y_min = 0.0;
double y_max = 20.0;
double z_min = 0.0;
double z_max = 10.0;
Ptr&lt;Building&gt; b = CreateObject&lt;Building&gt;();
b-&gt;SetBoundaries(Box(x_min, x_max, y_min, y_max, z_min, z_max));
b-&gt;SetBuildingType(Building::Residential);
b-&gt;SetExtWallsType(Building::ConcreteWithWindows);
b-&gt;SetNFloors(3);
b-&gt;SetNRoomsX(3);
b-&gt;SetNRoomsY(2);
</pre></div>
</div>
<p>This will instantiate a residential building with base of 10 x 20 meters and height of 10 meters whose external walls are of concrete with windows; the building has three floors and has an internal 3 x 2  grid of rooms of equal size.</p>
</li>
<li><p>Node creation and positioning:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ueNodes.Create(2);
mobility.Install(ueNodes);
BuildingsHelper::Install(ueNodes);
NetDeviceContainer ueDevs;
ueDevs = lteHelper-&gt;InstallUeDevice(ueNodes);
Ptr&lt;ConstantPositionMobilityModel&gt; mm0 = enbNodes.Get(0)-&gt;GetObject&lt;ConstantPositionMobilityModel&gt;();
Ptr&lt;ConstantPositionMobilityModel&gt; mm1 = enbNodes.Get(1)-&gt;GetObject&lt;ConstantPositionMobilityModel&gt;();
mm0-&gt;SetPosition(Vector(5.0, 5.0, 1.5));
mm1-&gt;SetPosition(Vector(30.0, 40.0, 1.5));
</pre></div>
</div>
</li>
<li><p>Finalize the building and mobility model configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BuildingsHelper::MakeMobilityModelConsistent();
</pre></div>
</div>
</li>
</ol>
<p>See the documentation of the <em>buildings</em> module for more detailed information.</p>
</section>
<section id="phy-error-model">
<h2><span class="section-number">20.2.9. </span>PHY Error Model<a class="headerlink" href="#phy-error-model" title="Link to this heading">¶</a></h2>
<p>The Physical error model consists of the data error model and the downlink control error model, both of them active by default. It is possible to deactivate them with the ns3 attribute system, in detail:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteSpectrumPhy::CtrlErrorModelEnabled&quot;, BooleanValue(false));
Config::SetDefault(&quot;ns3::LteSpectrumPhy::DataErrorModelEnabled&quot;, BooleanValue(false));
</pre></div>
</div>
</section>
<section id="mimo-model">
<h2><span class="section-number">20.2.10. </span>MIMO Model<a class="headerlink" href="#mimo-model" title="Link to this heading">¶</a></h2>
<p>Is this subsection we illustrate how to configure the MIMO parameters. LTE defines 7 types of transmission modes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Transmission Mode 1: SISO.</p></li>
<li><p>Transmission Mode 2: MIMO Tx Diversity.</p></li>
<li><p>Transmission Mode 3: MIMO Spatial Multiplexity Open Loop.</p></li>
<li><p>Transmission Mode 4: MIMO Spatial Multiplexity Closed Loop.</p></li>
<li><p>Transmission Mode 5: MIMO Multi-User.</p></li>
<li><p>Transmission Mode 6: Closer loop single layer precoding.</p></li>
<li><p>Transmission Mode 7: Single antenna port 5.</p></li>
</ul>
</div></blockquote>
<p>According to model implemented, the simulator includes the first three transmission modes types. The default one is the Transmission Mode 1 (SISO). In order to change the default Transmission Mode to be used, the attribute <code class="docutils literal notranslate"><span class="pre">DefaultTransmissionMode</span></code> of the <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> can be used, as shown in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteEnbRrc::DefaultTransmissionMode&quot;, UintegerValue(0)); // SISO
Config::SetDefault(&quot;ns3::LteEnbRrc::DefaultTransmissionMode&quot;, UintegerValue(1)); // MIMO Tx diversity(1 layer)
Config::SetDefault(&quot;ns3::LteEnbRrc::DefaultTransmissionMode&quot;, UintegerValue(2)); // MIMO Spatial Multiplexity(2 layers)
</pre></div>
</div>
<p>For changing the transmission mode of a certain user during the simulation a specific interface has been implemented in both standard schedulers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode);
</pre></div>
</div>
<p>This method can be used both for developing transmission mode decision engine (i.e., for optimizing the transmission mode according to channel condition and/or user’s requirements) and for manual switching from simulation script. In the latter case, the switching can be done as shown in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteEnbNetDevice&gt; lteEnbDev = enbDevs.Get(0)-&gt;GetObject&lt;LteEnbNetDevice&gt;();
PointerValue ptrval;
enbNetDev-&gt;GetAttribute(&quot;FfMacScheduler&quot;, ptrval);
Ptr&lt;RrFfMacScheduler&gt; rrsched = ptrval.Get&lt;RrFfMacScheduler&gt;();
Simulator::Schedule(Seconds(0.2), &amp;RrFfMacScheduler::TransmissionModeConfigurationUpdate, rrsched, rnti, 1);
</pre></div>
</div>
<p>Finally, the model implemented can be reconfigured according to different MIMO models by updating the gain values (the only constraints is that the gain has to be constant during simulation run-time and common for the layers). The gain of each Transmission Mode can be changed according to the standard ns3 attribute system, where the attributes are: <code class="docutils literal notranslate"><span class="pre">TxMode1Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode2Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode3Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode4Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode5Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode6Gain</span></code> and <code class="docutils literal notranslate"><span class="pre">TxMode7Gain</span></code>. By default only <code class="docutils literal notranslate"><span class="pre">TxMode1Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode2Gain</span></code> and <code class="docutils literal notranslate"><span class="pre">TxMode3Gain</span></code> have a meaningful value, that are the ones derived by _[CatreuxMIMO] (i.e., respectively 0.0, 4.2 and -2.8 dB).</p>
</section>
<section id="use-of-antennamodel">
<h2><span class="section-number">20.2.11. </span>Use of AntennaModel<a class="headerlink" href="#use-of-antennamodel" title="Link to this heading">¶</a></h2>
<p>We now show how associate a particular AntennaModel with an eNB device
in order to model a sector of a macro eNB. For this purpose, it is
convenient to use the <code class="docutils literal notranslate"><span class="pre">CosineAntennaModel</span></code> provided by the ns-3
antenna module. The configuration of the eNB is to be done via the
<code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> instance right before the creation of the
<code class="docutils literal notranslate"><span class="pre">EnbNetDevice</span></code>, as shown in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEnbAntennaModelType(&quot;ns3::CosineAntennaModel&quot;);
lteHelper-&gt;SetEnbAntennaModelAttribute(&quot;Orientation&quot;, DoubleValue(0));
lteHelper-&gt;SetEnbAntennaModelAttribute(&quot;Beamwidth&quot;,   DoubleValue(60));
lteHelper-&gt;SetEnbAntennaModelAttribute(&quot;MaxGain&quot;,     DoubleValue(0.0));
</pre></div>
</div>
<p>the above code will generate an antenna model with a 60 degrees
beamwidth pointing along the X axis. The orientation is measured
in degrees from the X axis, e.g., an orientation of 90 would point
along the Y axis, and an orientation of -90 would point in the
negative direction along the Y axis. The beamwidth is the -3 dB
beamwidth, e.g, for a 60 degree beamwidth the antenna gain at an angle
of <img class="math" src="_images/math/ef9b1eccc37b378d3b0cbca837b4f3842f8fe3a7.png" alt="\pm 30"/> degrees from the direction of orientation is -3 dB.</p>
<p>To create a multi-sector site, you need to create different ns-3 nodes
placed at the same position, and to configure separate <code class="docutils literal notranslate"><span class="pre">EnbNetDevice</span></code>
with different antenna orientations to be installed on each node.</p>
</section>
<section id="radio-environment-maps">
<span id="sec-radio-environment-maps"></span><h2><span class="section-number">20.2.12. </span>Radio Environment Maps<a class="headerlink" href="#radio-environment-maps" title="Link to this heading">¶</a></h2>
<p>By using the class <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper</span></code> it is possible to output
to a file a Radio Environment Map (REM), i.e., a uniform 2D grid of values
that represent the Signal-to-noise ratio in the downlink with respect
to the eNB that has the strongest signal at each point. It is possible
to specify if REM should be generated for data or control channel. Also user
can set the RbId, for which REM will be generated. Default RbId is -1, what
means that REM will generated with averaged Signal-to-noise ratio from all RBs.</p>
<p>To do this, you just need to add the following code to your simulation
program towards the end, right before the call to Simulator::Run():</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;RadioEnvironmentMapHelper&gt; remHelper = CreateObject&lt;RadioEnvironmentMapHelper&gt;();
remHelper-&gt;SetAttribute(&quot;Channel&quot;, PointerValue(lteHelper-&gt;GetDownlinkSpectrumChannel()));
remHelper-&gt;SetAttribute(&quot;OutputFile&quot;, StringValue(&quot;rem.out&quot;));
remHelper-&gt;SetAttribute(&quot;XMin&quot;, DoubleValue(-400.0));
remHelper-&gt;SetAttribute(&quot;XMax&quot;, DoubleValue(400.0));
remHelper-&gt;SetAttribute(&quot;XRes&quot;, UintegerValue(100));
remHelper-&gt;SetAttribute(&quot;YMin&quot;, DoubleValue(-300.0));
remHelper-&gt;SetAttribute(&quot;YMax&quot;, DoubleValue(300.0));
remHelper-&gt;SetAttribute(&quot;YRes&quot;, UintegerValue(75));
remHelper-&gt;SetAttribute(&quot;Z&quot;, DoubleValue(0.0));
remHelper-&gt;SetAttribute(&quot;UseDataChannel&quot;, BooleanValue(true));
remHelper-&gt;SetAttribute(&quot;RbId&quot;, IntegerValue(10));
remHelper-&gt;Install();
</pre></div>
</div>
<p>By configuring the attributes of the <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper</span></code> object
as shown above, you can tune the parameters of the REM to be
generated. Note that each <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper</span></code> instance can
generate only one REM; if you want to generate more REMs, you need to
create one separate instance for each REM.</p>
<p>Note that the REM generation is very demanding, in particular:</p>
<blockquote>
<div><ul class="simple">
<li><p>the run-time memory consumption is approximately 5KB per pixel. For example,
a REM with a resolution of 500x500 would need about 1.25 GB of memory, and
a resolution of 1000x1000 would need needs about 5 GB (too much for a
regular PC at the time of this writing). To overcome this issue,
the REM is generated at successive steps, with each step evaluating
at most a number of pixels determined by the value of the
the attribute <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper::MaxPointsPerIteration</span></code>.</p></li>
<li><p>if you generate a REM at the beginning of a simulation, it will
slow down the execution of the rest of the simulation. If you want
to generate a REM for a program and also use the same program to
get simulation result, it is recommended to add a command-line
switch that allows to either generate the REM or run the complete
simulation. For this purpose, note that there is an attribute
<code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper::StopWhenDone</span></code> (default: true) that
will force the simulation to stop right after the REM has been generated.</p></li>
</ul>
</div></blockquote>
<p>The REM is stored in an ASCII file in the following format:</p>
<blockquote>
<div><ul class="simple">
<li><p>column 1 is the x coordinate</p></li>
<li><p>column 2 is the y coordinate</p></li>
<li><p>column 3 is the z coordinate</p></li>
<li><p>column 4 is the SINR in linear units</p></li>
</ul>
</div></blockquote>
<p>A minimal gnuplot script that allows you to plot the REM is given
below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set view map;
set xlabel &quot;X&quot;
set ylabel &quot;Y&quot;
set cblabel &quot;SINR (dB)&quot;
unset key
plot &quot;rem.out&quot; using ($1):($2):(10*log10($4)) with image
</pre></div>
</div>
<p>As an example, here is the REM that can be obtained with the example program lena-dual-stripe, which shows a three-sector LTE macrocell in a co-channel deployment with some residential femtocells randomly deployed in two blocks of apartments.</p>
<figure class="align-center" id="id19">
<span id="fig-lena-dual-stripe"></span><img alt="_images/lena-dual-stripe.png" src="_images/lena-dual-stripe.png" />
<figcaption>
<p><span class="caption-text">REM obtained from the lena-dual-stripe example</span><a class="headerlink" href="#id19" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Note that the lena-dual-stripe example program also generate
gnuplot-compatible output files containing information about the
positions of the UE and eNB nodes as well as of the buildings,
respectively in the files <code class="docutils literal notranslate"><span class="pre">ues.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">enbs.txt</span></code> and
<code class="docutils literal notranslate"><span class="pre">buildings.txt</span></code>. These can be easily included when using
gnuplot. For example, assuming that your gnuplot script (e.g., the
minimal gnuplot script described above) is saved in a file named
<code class="docutils literal notranslate"><span class="pre">my_plot_script</span></code>, running the following command would plot the
location of UEs, eNBs and buildings on top of the REM:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gnuplot -p enbs.txt ues.txt buildings.txt my_plot_script
</pre></div>
</div>
</section>
<section id="amc-model-and-cqi-calculation">
<h2><span class="section-number">20.2.13. </span>AMC Model and CQI Calculation<a class="headerlink" href="#amc-model-and-cqi-calculation" title="Link to this heading">¶</a></h2>
<p>The simulator provides two possible schemes for what concerns the selection of the MCSs and
correspondingly the generation of the CQIs. The first one is based on the GSoC module <a class="reference internal" href="lte-references.html#piro2011" id="id9"><span>[Piro2011]</span></a>
and works per RB basis. This model can be activated with the ns3 attribute system, as presented in
the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteAmc::AmcModel&quot;, EnumValue(LteAmc::PiroEW2010));
</pre></div>
</div>
<p>While, the solution based on the physical error model can be controlled with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteAmc::AmcModel&quot;, EnumValue(LteAmc::MiErrorModel));
</pre></div>
</div>
<p>Finally, the required efficiency of the <code class="docutils literal notranslate"><span class="pre">PiroEW2010</span></code> AMC module can be tuned thanks to the <code class="docutils literal notranslate"><span class="pre">Ber</span></code> attribute(), for instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteAmc::Ber&quot;, DoubleValue(0.00005));
</pre></div>
</div>
</section>
<section id="evolved-packet-core-epc">
<span id="sec-evolved-packet-core"></span><h2><span class="section-number">20.2.14. </span>Evolved Packet Core (EPC)<a class="headerlink" href="#evolved-packet-core-epc" title="Link to this heading">¶</a></h2>
<p>We now explain how to write a simulation program that allows to
simulate the EPC in addition to the LTE radio access network. The use
of EPC allows to use IPv4 and IPv6 networking with LTE devices. In other words,
you will be able to use the regular ns-3 applications and sockets over
IPv4 and IPv6 over LTE, and also to connect an LTE network to any other IPv4 and IPv6
network you might have in your simulation.</p>
<p>First of all, in addition to <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> that we already introduced
in <a class="reference internal" href="#sec-basic-simulation-program"><span class="std std-ref">Basic simulation program</span></a>, you need to use an additional
<code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> class, which will take care of creating the EPC entities and
network topology. Note that you can’t use <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> directly, as
it is an abstract base class; instead, you need to use one of its
child classes, which provide different EPC topology implementations. In
this example we will consider <code class="docutils literal notranslate"><span class="pre">PointToPointEpcHelper</span></code>, which
implements an EPC based on point-to-point links. To use it, you need
first to insert this code in your simulation program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
Ptr&lt;PointToPointEpcHelper&gt; epcHelper = CreateObject&lt;PointToPointEpcHelper&gt;();
</pre></div>
</div>
<p>Then, you need to tell the LTE helper that the EPC will be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEpcHelper(epcHelper);
</pre></div>
</div>
<p>the above step is necessary so that the LTE helper will trigger the
appropriate EPC configuration in correspondence with some important
configuration, such as when a new eNB or UE is added to the
simulation, or an EPS bearer is created. The EPC helper will
automatically take care of the necessary setup, such as S1 link
creation and S1 bearer setup. All this will be done without the
intervention of the user.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">lteHelper-&gt;SetEpcHelper(epcHelper)</span></code> enables the use of
EPC, and has the side effect that any new <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> that is
created will have the <code class="docutils literal notranslate"><span class="pre">EpsBearerToRlcMapping</span></code> attribute set to
<code class="docutils literal notranslate"><span class="pre">RLC_UM_ALWAYS</span></code> instead of <code class="docutils literal notranslate"><span class="pre">RLC_SM_ALWAYS</span></code> if the latter was
the default; otherwise, the attribute won’t be changed (e.g., if
you changed the default to <code class="docutils literal notranslate"><span class="pre">RLC_AM_ALWAYS</span></code>, it won’t be touched).</p>
<p>It is to be noted that the <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> will also automatically
create the PGW node and configure it so that it can properly handle
traffic from/to the LTE radio access network.  Still,
you need to add some explicit code to connect the PGW to other
IPv4/IPv6 networks (e.g., the internet, another EPC). Here is a very
simple example about how to connect a single remote host (IPv4 type)
to the PGW via a point-to-point link:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;Node&gt; pgw = epcHelper-&gt;GetPgwNode();

// Create a single RemoteHost
NodeContainer remoteHostContainer;
remoteHostContainer.Create(1);
Ptr&lt;Node&gt; remoteHost = remoteHostContainer.Get(0);
InternetStackHelper internet;
internet.Install(remoteHostContainer);

// Create the internet
PointToPointHelper p2ph;
p2ph.SetDeviceAttribute(&quot;DataRate&quot;, DataRateValue(DataRate(&quot;100Gb/s&quot;)));
p2ph.SetDeviceAttribute(&quot;Mtu&quot;, UintegerValue(1500));
p2ph.SetChannelAttribute(&quot;Delay&quot;, TimeValue(Seconds(0.010)));
NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);
Ipv4AddressHelper ipv4h;
ipv4h.SetBase(&quot;1.0.0.0&quot;, &quot;255.0.0.0&quot;);
Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
// interface 0 is localhost, 1 is the p2p device
Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);


Ipv4StaticRoutingHelper ipv4RoutingHelper;
Ptr&lt;Ipv4StaticRouting&gt; remoteHostStaticRouting;
remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting(remoteHost-&gt;GetObject&lt;Ipv4&gt;());
remoteHostStaticRouting-&gt;AddNetworkRouteTo(epcHelper-&gt;GetEpcIpv4NetworkAddress(),
                                           Ipv4Mask(&quot;255.255.0.0&quot;), 1);
</pre></div>
</div>
<p>Now, you should go on and create LTE eNBs and UEs as explained in the
previous sections. You can of course configure other LTE aspects such
as pathloss and fading models. Right after you created the UEs, you
should also configure them for IP networking. This is done as
follows. We assume you have a container for UE and eNodeB nodes like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NodeContainer ueNodes;
NodeContainer enbNodes;
</pre></div>
</div>
<p>to configure an LTE-only simulation, you would then normally do
something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer ueLteDevs = lteHelper-&gt;InstallUeDevice(ueNodes);
lteHelper-&gt;Attach(ueLteDevs, enbLteDevs.Get(0));
</pre></div>
</div>
<p>in order to configure the UEs for IP networking, you just need to
additionally do like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// we install the IP stack on the UEs
InternetStackHelper internet;
internet.Install(ueNodes);

// assign IP address to UEs
for (uint32_t u = 0; u &lt; ueNodes.GetN(); ++u)
  {
    Ptr&lt;Node&gt; ue = ueNodes.Get(u);
    Ptr&lt;NetDevice&gt; ueLteDevice = ueLteDevs.Get(u);
    Ipv4InterfaceContainer ueIpIface;
    ueIpIface = epcHelper-&gt;AssignUeIpv4Address(NetDeviceContainer(ueLteDevice));
    // set the default gateway for the UE
    Ptr&lt;Ipv4StaticRouting&gt; ueStaticRouting;
    ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(ue-&gt;GetObject&lt;Ipv4&gt;());
    ueStaticRouting-&gt;SetDefaultRoute(epcHelper-&gt;GetUeDefaultGatewayAddress(), 1);
  }
</pre></div>
</div>
<p>The activation of bearers is done in a slightly different way with
respect to what done for an LTE-only simulation. First, the method
ActivateDataRadioBearer is not to be used when the EPC is
used. Second, when EPC is used, the default EPS bearer will be
activated automatically when you call <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach()</span></code>. Third, if
you want to setup dedicated EPS bearer, you can do so using the method
<code class="docutils literal notranslate"><span class="pre">LteHelper::ActivateDedicatedEpsBearer()</span></code>. This method takes as a
parameter the Traffic Flow Template(TFT), which is a struct that
identifies the type of traffic that will be mapped to the dedicated
EPS bearer. Here is an example for how to setup a dedicated bearer
for an application at the UE communicating on port 1234:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;EpcTft&gt; tft = Create&lt;EpcTft&gt;();
EpcTft::PacketFilter pf;
pf.localPortStart = 1234;
pf.localPortEnd = 1234;
tft-&gt;Add(pf);
lteHelper-&gt;ActivateDedicatedEpsBearer(ueLteDevs,
                                      EpsBearer(EpsBearer::NGBR_VIDEO_TCP_DEFAULT),
                                      tft);
</pre></div>
</div>
<p>you can of course use custom EpsBearer and EpcTft configurations,
please refer to the doxygen documentation for how to do it.</p>
<p>Finally, you can install applications on the LTE UE nodes that communicate
with remote applications over the internet. This is done following the
usual ns-3 procedures. Following our simple example with a single
remoteHost, here is how to setup downlink communication, with an
UdpClient application on the remote host, and a PacketSink on the LTE UE
(using the same variable names of the previous code snippets)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>uint16_t dlPort = 1234;
PacketSinkHelper packetSinkHelper(&quot;ns3::UdpSocketFactory&quot;,
                                  InetSocketAddress(Ipv4Address::GetAny(), dlPort));
ApplicationContainer serverApps = packetSinkHelper.Install(ue);
serverApps.Start(Seconds(0.01));
UdpClientHelper client(ueIpIface.GetAddress(0), dlPort);
ApplicationContainer clientApps = client.Install(remoteHost);
clientApps.Start(Seconds(0.01));
</pre></div>
</div>
<p>That’s all! You can now start your simulation as usual:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Stop(Seconds(10.0));
Simulator::Run();
</pre></div>
</div>
</section>
<section id="using-the-epc-with-emulation-mode">
<h2><span class="section-number">20.2.15. </span>Using the EPC with emulation mode<a class="headerlink" href="#using-the-epc-with-emulation-mode" title="Link to this heading">¶</a></h2>
<p>In the previous section we used PointToPoint links for the connection between the eNBs and the SGW (S1-U interface) and among eNBs (X2-U and X2-C interfaces). The LTE module supports using emulated links instead of PointToPoint links. This is achieved by just replacing the creation of <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> with the following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
Ptr&lt;EmuEpcHelper&gt;  epcHelper = CreateObject&lt;EmuEpcHelper&gt;();
lteHelper-&gt;SetEpcHelper(epcHelper);
epcHelper-&gt;Initialize();
</pre></div>
</div>
<p>The attributes <code class="docutils literal notranslate"><span class="pre">ns3::EmuEpcHelper::sgwDeviceName</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::EmuEpcHelper::enbDeviceName</span></code> are used to set the name of the devices used for transporting the S1-U, X2-U and X2-C interfaces at the SGW and eNB, respectively. We will now show how this is done in an example where we execute the example program <code class="docutils literal notranslate"><span class="pre">lena-simple-epc-emu</span></code> using two virtual ethernet interfaces.</p>
<p>First of all we build ns-3 appropriately:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># configure
./ns3 configure --enable-sudo --enable-modules=lte,fd-net-device --enable-examples

# build
./ns3
</pre></div>
</div>
<p>Then we setup two virtual ethernet interfaces, and start wireshark to look at the traffic going through:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># note: you need to be root

# create two paired veth devices
ip link add name veth0 type veth peer name veth1
ip link show

# enable promiscuous mode
ip link set veth0 promisc on
ip link set veth1 promisc on

# bring interfaces up
ip link set veth0 up
ip link set veth1 up

# start wireshark and capture on veth0
wireshark &amp;
</pre></div>
</div>
<p>We can now run the example program with the simulated clock:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --ns3::EmuEpcHelper::sgwDeviceName=veth0
--ns3::EmuEpcHelper::enbDeviceName=veth1&quot;
</pre></div>
</div>
<p>Using wireshark, you should see ARP resolution first, then some GTP
packets exchanged both in uplink and downlink.</p>
<p>The default setting of the example program is 1 eNB and 1UE. You can change this via command line parameters, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --ns3::EmuEpcHelper::sgwDeviceName=veth0
--ns3::EmuEpcHelper::enbDeviceName=veth1 --nEnbs=2 --nUesPerEnb=2&quot;
</pre></div>
</div>
<p>To get a list of the available parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --PrintHelp&quot;
</pre></div>
</div>
<p>To run with the realtime clock: it turns out that the default debug
build is too slow for realtime. Softening the real time constraints
with the BestEffort mode is not a good idea: something can go wrong
(e.g., ARP can fail) and, if so, you won’t get any data packets out.
So you need a decent hardware and the optimized build with statically
linked modules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 configure -d optimized --enable-static --enable-modules=lte --enable-examples
--enable-sudo
</pre></div>
</div>
<p>Then run the example program like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --ns3::EmuEpcHelper::sgwDeviceName=veth0
--ns3::EmuEpcHelper::enbDeviceName=veth1
--SimulatorImplementationType=ns3::RealtimeSimulatorImpl
--ns3::RealtimeSimulatorImpl::SynchronizationMode=HardLimit&quot;
</pre></div>
</div>
<p>note the HardLimit setting, which will cause the program to terminate
if it cannot keep up with real time.</p>
<p>The approach described in this section can be used with any type of
net device. For instance, <a class="reference internal" href="lte-references.html#baldo2014" id="id10"><span>[Baldo2014]</span></a> describes how it was used to
run an emulated LTE-EPC network over a real multi-layer packet-optical
transport network.</p>
</section>
<section id="custom-backhaul">
<span id="sec-custom-backhaul"></span><h2><span class="section-number">20.2.16. </span>Custom Backhaul<a class="headerlink" href="#custom-backhaul" title="Link to this heading">¶</a></h2>
<p>In the previous sections, <a class="reference internal" href="#sec-evolved-packet-core"><span class="std std-ref">Evolved Packet Core (EPC)</span></a>, we explained how to write a simulation
program using EPC with a predefined backhaul network between the RAN and the EPC. We used the
<code class="docutils literal notranslate"><span class="pre">PointToPointEpcHelper</span></code>. This <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> creates point-to-point links between the eNBs and the SGW.</p>
<p>We now explain how to write a simulation program that allows the simulator user to create any kind
of backhaul network in the simulation program.</p>
<p>First of all, in addition to <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>, you need to use the <code class="docutils literal notranslate"><span class="pre">NoBackhaulEpcHelper</span></code> class, which
implements an EPC but without connecting the eNBs with the core network. It just creates the network
elements of the core network:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
Ptr&lt;NoBackhaulEpcHelper&gt; epcHelper = CreateObject&lt;NoBackhaulEpcHelper&gt;();
</pre></div>
</div>
<p>Then, as usual, you need to tell the LTE helper that the EPC will be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEpcHelper(epcHelper);
</pre></div>
</div>
<p>Now, you should create the backhaul network. Here we create point-to-point links as it is done
by the <code class="docutils literal notranslate"><span class="pre">PointToPointEpcHelper</span></code>. We assume you have a container for eNB nodes like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NodeContainer enbNodes;
</pre></div>
</div>
<p>We get the SGW node:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;Node&gt; sgw = epcHelper-&gt;GetSgwNode();
</pre></div>
</div>
<p>And we connect every eNB from the container with the SGW with a point-to-point link. We also assign
IPv4 addresses to the interfaces of eNB and SGW with <code class="docutils literal notranslate"><span class="pre">s1uIpv4AddressHelper.Assign(sgwEnbDevices)</span></code>
and finally we tell the EpcHelper that this <code class="docutils literal notranslate"><span class="pre">enb</span></code> has a new S1 interface with
<code class="docutils literal notranslate"><span class="pre">epcHelper-&gt;AddS1Interface(enb,</span> <span class="pre">enbS1uAddress,</span> <span class="pre">sgwS1uAddress)</span></code>, where <code class="docutils literal notranslate"><span class="pre">enbS1uAddress</span></code> and
<code class="docutils literal notranslate"><span class="pre">sgwS1uAddress</span></code> are the IPv4 addresses of the eNB and the SGW, respectively:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ipv4AddressHelper s1uIpv4AddressHelper;

// Create networks of the S1 interfaces
s1uIpv4AddressHelper.SetBase(&quot;10.0.0.0&quot;, &quot;255.255.255.252&quot;);

for (uint16_t i = 0; i &lt; enbNodes.GetN(); ++i)
  {
    Ptr&lt;Node&gt; enb = enbNodes.Get(i);

    // Create a point to point link between the eNB and the SGW with
    // the corresponding new NetDevices on each side
    PointToPointHelper p2ph;
    DataRate s1uLinkDataRate = DataRate(&quot;10Gb/s&quot;);
    uint16_t s1uLinkMtu = 2000;
    Time s1uLinkDelay = Time(0);
    p2ph.SetDeviceAttribute(&quot;DataRate&quot;, DataRateValue(s1uLinkDataRate));
    p2ph.SetDeviceAttribute(&quot;Mtu&quot;, UintegerValue(s1uLinkMtu));
    p2ph.SetChannelAttribute(&quot;Delay&quot;, TimeValue(s1uLinkDelay));
    NetDeviceContainer sgwEnbDevices = p2ph.Install(sgw, enb);

    Ipv4InterfaceContainer sgwEnbIpIfaces = s1uIpv4AddressHelper.Assign(sgwEnbDevices);
    s1uIpv4AddressHelper.NewNetwork();

    Ipv4Address sgwS1uAddress = sgwEnbIpIfaces.GetAddress(0);
    Ipv4Address enbS1uAddress = sgwEnbIpIfaces.GetAddress(1);

    // Create S1 interface between the SGW and the eNB
    epcHelper-&gt;AddS1Interface(enb, enbS1uAddress, sgwS1uAddress);
  }
</pre></div>
</div>
<p>This is just an example how to create a custom backhaul network. In this other example, we connect
all eNBs and the SGW to the same CSMA network:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Create networks of the S1 interfaces
s1uIpv4AddressHelper.SetBase(&quot;10.0.0.0&quot;, &quot;255.255.255.0&quot;);

NodeContainer sgwEnbNodes;
sgwEnbNodes.Add(sgw);
sgwEnbNodes.Add(enbNodes);

CsmaHelper csmah;
NetDeviceContainer sgwEnbDevices = csmah.Install(sgwEnbNodes);
Ptr&lt;NetDevice&gt; sgwDev = sgwEnbDevices.Get(0);

Ipv4InterfaceContainer sgwEnbIpIfaces = s1uIpv4AddressHelper.Assign(sgwEnbDevices);
Ipv4Address sgwS1uAddress = sgwEnbIpIfaces.GetAddress(0);

for (uint16_t i = 0; i &lt; enbNodes.GetN(); ++i)
  {
    Ptr&lt;Node&gt; enb = enbNodes.Get(i);
    Ipv4Address enbS1uAddress = sgwEnbIpIfaces.GetAddress(i + 1);

    // Create S1 interface between the SGW and the eNB
    epcHelper-&gt;AddS1Interface(enb, enbS1uAddress, sgwS1uAddress);
  }
</pre></div>
</div>
<p>As you can see, apart from how you create the backhaul network, i.e. the point-to-point links or
the CSMA network, the important point is to tell the <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> that an <code class="docutils literal notranslate"><span class="pre">eNB</span></code> has a new S1 interface.</p>
<p>Now, you should continue configuring your simulation program as it is explained in
<a class="reference internal" href="#sec-evolved-packet-core"><span class="std std-ref">Evolved Packet Core (EPC)</span></a> subsection. This configuration includes: the internet, installing the LTE eNBs
and possibly configuring other LTE aspects, installing the LTE UEs and configuring them as IP nodes,
activation of the dedicated EPS bearers and installing applications on the LTE UEs and on the remote hosts.</p>
</section>
<section id="network-attachment">
<span id="sec-network-attachment"></span><h2><span class="section-number">20.2.17. </span>Network Attachment<a class="headerlink" href="#network-attachment" title="Link to this heading">¶</a></h2>
<p>As shown in the basic example in section <a class="reference internal" href="#sec-basic-simulation-program"><span class="std std-ref">Basic simulation program</span></a>,
attaching a UE to an eNodeB is done by calling <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function.</p>
<p>There are 2 possible ways of network attachment. The first method is the
<em>“manual”</em> one, while the second one has a more <em>“automatic”</em> sense on it. Each
of them will be covered in this section.</p>
<section id="manual-attachment">
<h3><span class="section-number">20.2.17.1. </span>Manual attachment<a class="headerlink" href="#manual-attachment" title="Link to this heading">¶</a></h3>
<p>This method uses the <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function mentioned above. It has been
the only available network attachment method in earlier versions of LTE module.
It is typically invoked before the simulation begins:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(ueDevs, enbDev); // attach one or more UEs to a single eNodeB
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LteHelper::InstallEnbDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">LteHelper::InstallUeDevice</span></code> functions
must have been called before attaching. In an EPC-enabled simulation, it is also
required to have IPv4/IPv6 properly pre-installed in the UE.</p>
<p>This method is very simple, but requires you to know exactly which UE belongs to
to which eNodeB before the simulation begins. This can be difficult when the UE
initial position is randomly determined by the simulation script.</p>
<p>One may choose the distance between the UE and the eNodeB as a criterion for
selecting the appropriate cell. It is quite simple (at least from the
simulator’s point of view) and sometimes practical. But it is important to note
that sometimes distance does not make a single correct criterion. For instance,
the eNodeB antenna directivity should be considered as well. Besides that, one
should also take into account the channel condition, which might be fluctuating
if there is fading or shadowing in effect. In these kind of cases, network
attachment should not be based on distance alone.</p>
<p>In real life, UE will automatically evaluate certain criteria and select the
best cell to attach to, without manual intervention from the user. Obviously
this is not the case in this <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function. The other network
attachment method uses more <em>“automatic”</em> approach to network attachment, as
will be described next.</p>
</section>
<section id="automatic-attachment-using-idle-mode-cell-selection-procedure">
<h3><span class="section-number">20.2.17.2. </span>Automatic attachment using Idle mode cell selection procedure<a class="headerlink" href="#automatic-attachment-using-idle-mode-cell-selection-procedure" title="Link to this heading">¶</a></h3>
<p>The strength of the received signal is the standard criterion used for selecting
the best cell to attach to. The use of this criterion is implemented in the
<cite>initial cell selection</cite> process, which can be invoked by calling another
version of the <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function, as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(ueDevs); // attach one or more UEs to a strongest cell
</pre></div>
</div>
<p>The difference with the manual method is that the destination eNodeB is not
specified. The procedure will find the best cell for the UEs, based on several
criteria, including the strength of the received signal (RSRP).</p>
<p>After the method is called, the UE will spend some time to measure the
neighbouring cells, and then attempt to attach to the best one. More details can
be found in section <a class="reference internal" href="lte-design.html#sec-initial-cell-selection"><span class="std std-ref">Initial Cell Selection</span></a> of the Design
Documentation.</p>
<p>It is important to note that this method only works in EPC-enabled simulations.
LTE-only simulations must resort to manual attachment method.</p>
</section>
<section id="closed-subscriber-group">
<h3><span class="section-number">20.2.17.3. </span>Closed Subscriber Group<a class="headerlink" href="#closed-subscriber-group" title="Link to this heading">¶</a></h3>
<p>An interesting use case of the initial cell selection process is to setup a
simulation environment with Closed Subscriber Group (CSG).</p>
<p>For example, a certain eNodeB, typically a smaller version such as femtocell,
might belong to a private owner (e.g. a household or business), allowing access
only to some UEs which have been previously registered by the owner. The eNodeB
and the registered UEs altogether form a CSG.</p>
<p>The access restriction can be simulated by “labeling” the CSG members with the
same CSG ID. This is done through the attributes in both eNodeB and UE, for
example using the following <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// label the following eNodeBs with CSG identity of 1 and CSG indication enabled
lteHelper-&gt;SetEnbDeviceAttribute(&quot;CsgId&quot;, UintegerValue(1));
lteHelper-&gt;SetEnbDeviceAttribute(&quot;CsgIndication&quot;, BooleanValue(true));

// label one or more UEs with CSG identity of 1
lteHelper-&gt;SetUeDeviceAttribute(&quot;CsgId&quot;, UintegerValue(1));

// install the eNodeBs and UEs
NetDeviceContainer csgEnbDevs = lteHelper-&gt;InstallEnbDevice(csgEnbNodes);
NetDeviceContainer csgUeDevs = lteHelper-&gt;InstallUeDevice(csgUeNodes);
</pre></div>
</div>
<p>Then enable the initial cell selection procedure on the UEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(csgUeDevs);
</pre></div>
</div>
<p>This is necessary because the CSG restriction only works with automatic method
of network attachment, but not in the manual method.</p>
<p>Note that setting the CSG indication of an eNodeB as false (the default value)
will disable the restriction, i.e., any UEs can connect to this eNodeB.</p>
</section>
</section>
<section id="configure-ue-measurements">
<span id="sec-configure-ue-measurements"></span><h2><span class="section-number">20.2.18. </span>Configure UE measurements<a class="headerlink" href="#configure-ue-measurements" title="Link to this heading">¶</a></h2>
<p>The active UE measurement configuration in a simulation is dictated by the
selected so called “consumers”, such as handover algorithm. Users may add their
own configuration into action, and there are several ways to do so:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>direct configuration in eNodeB RRC entity;</p></li>
<li><p>configuring existing handover algorithm; and</p></li>
<li><p>developing a new handover algorithm.</p></li>
</ol>
</div></blockquote>
<p>This section will cover the first method only. The second method is covered in
<a class="reference internal" href="#sec-automatic-handover"><span class="std std-ref">Automatic handover trigger</span></a>, while the third method is explained in length in
Section <a class="reference internal" href="lte-design.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> of the Design Documentation.</p>
<p>Direct configuration in eNodeB RRC works as follows. User begins by creating a
new <code class="docutils literal notranslate"><span class="pre">LteRrcSap::ReportConfigEutra</span></code> instance and pass it to the
<code class="docutils literal notranslate"><span class="pre">LteEnbRrc::AddUeMeasReportConfig</span></code> function. The function will return the
<code class="docutils literal notranslate"><span class="pre">measId</span></code> (measurement identity) which is a unique reference of the
configuration in the eNodeB instance. This function must be called before the
simulation begins. The measurement configuration will be active in all UEs
attached to the eNodeB throughout the duration of the simulation. During the
simulation, user can capture the measurement reports produced by the UEs by
listening to the existing <code class="docutils literal notranslate"><span class="pre">LteEnbRrc::RecvMeasurementReport</span></code> trace source.</p>
<p>The structure <cite>ReportConfigEutra</cite> is in accord with 3GPP specification.
Definition of the structure and each member field can be found in Section 6.3.5
of <a class="reference internal" href="lte-references.html#ts36331" id="id11"><span>[TS36331]</span></a>.</p>
<p>The code sample below configures Event A1 RSRP measurement to every eNodeB
within the container <code class="docutils literal notranslate"><span class="pre">devs</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LteRrcSap::ReportConfigEutra config;
config.eventId = LteRrcSap::ReportConfigEutra::EVENT_A1;
config.threshold1.choice = LteRrcSap::ThresholdEutra::THRESHOLD_RSRP;
config.threshold1.range = 41;
config.triggerQuantity = LteRrcSap::ReportConfigEutra::RSRP;
config.reportInterval = LteRrcSap::ReportConfigEutra::MS480;

std::vector&lt;uint8_t&gt; measIdList;

NetDeviceContainer::Iterator it;
for (it = devs.Begin(); it != devs.End(); it++)
{
  Ptr&lt;NetDevice&gt; dev = *it;
  Ptr&lt;LteEnbNetDevice&gt; enbDev = dev-&gt;GetObject&lt;LteEnbNetDevice&gt;();
  Ptr&lt;LteEnbRrc&gt; enbRrc = enbDev-&gt;GetRrc();

  uint8_t measId = enbRrc-&gt;AddUeMeasReportConfig(config);
  measIdList.push_back(measId); // remember the measId created

  enbRrc-&gt;TraceConnect(&quot;RecvMeasurementReport&quot;,
                       &quot;context&quot;,
                       MakeCallback(&amp;RecvMeasurementReportCallback));
}
</pre></div>
</div>
<p>Note that thresholds are expressed as range. In the example above, the range 41
for RSRP corresponds to -100 dBm. The conversion from and to the range format is
due to Section 9.1.4 and 9.1.7 of <a class="reference internal" href="lte-references.html#ts36133" id="id12"><span>[TS36133]</span></a>. The <code class="docutils literal notranslate"><span class="pre">EutranMeasurementMapping</span></code>
class has several static functions that can be used for this purpose.</p>
<p>The corresponding callback function would have a definition similar as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
RecvMeasurementReportCallback(std::string context,
                              uint64_t imsi,
                              uint16_t cellId,
                              uint16_t rnti,
                              LteRrcSap::MeasurementReport measReport);
</pre></div>
</div>
<p>This method will register the callback function as a consumer of UE
measurements. In the case where there are more than one consumers in the
simulation (e.g. handover algorithm), the measurements intended for other
consumers will also be captured by this callback function. Users may utilize the
the <code class="docutils literal notranslate"><span class="pre">measId</span></code> field, contained within the <code class="docutils literal notranslate"><span class="pre">LteRrcSap::MeasurementReport</span></code>
argument of the callback function, to tell which measurement configuration has
triggered the report.</p>
<p>In general, this mechanism prevents one consumer to unknowingly intervene with
another consumer’s reporting configuration.</p>
<p>Note that only the reporting configuration part (i.e.
<code class="docutils literal notranslate"><span class="pre">LteRrcSap::ReportConfigEutra</span></code>) of the UE measurements parameter is open for
consumers to configure, while the other parts are kept hidden. The
intra-frequency limitation is the main motivation behind this API implementation
decision:</p>
<blockquote>
<div><ul class="simple">
<li><p>there is only one, unambiguous and definitive <em>measurement object</em>, thus
there is no need to configure it;</p></li>
<li><p><em>measurement identities</em> are kept hidden because of the fact that there is
one-to-one mapping between reporting configuration and measurement identity,
thus a new measurement identity is set up automatically when a new reporting
configuration is created;</p></li>
<li><p><em>quantity configuration</em> is configured elsewhere, see
<a class="reference internal" href="lte-design.html#sec-performing-measurements"><span class="std std-ref">Performing measurements</span></a>; and</p></li>
<li><p><em>measurement gaps</em> are not supported, because it is only applicable for
inter-frequency settings;</p></li>
</ul>
</div></blockquote>
</section>
<section id="x2-based-handover">
<span id="sec-x2-based-handover"></span><h2><span class="section-number">20.2.19. </span>X2-based handover<a class="headerlink" href="#x2-based-handover" title="Link to this heading">¶</a></h2>
<p>As defined by 3GPP, handover is a procedure for changing the serving cell of a
UE in CONNECTED mode. The two eNodeBs involved in the process are typically
called the <em>source eNodeB</em> and the <em>target eNodeB</em>.</p>
<p>In order to enable the execution of X2-based handover in simulation, there are
two requirements that must be met. Firstly, EPC must be enabled in the
simulation (see <a class="reference internal" href="#sec-evolved-packet-core"><span class="std std-ref">Evolved Packet Core (EPC)</span></a>).</p>
<p>Secondly, an X2 interface must be configured between the two eNodeBs, which
needs to be done explicitly within the simulation program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;AddX2Interface(enbNodes);
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">enbNodes</span></code> is a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> that contains the two eNodeBs between
which the X2 interface is to be configured. If the container has more than two
eNodeBs, the function will create an X2 interface between every pair of eNodeBs
in the container.</p>
<p>Lastly, the target eNodeB must be configured as “open” to X2 HANDOVER REQUEST.
Every eNodeB is open by default, so no extra instruction is needed in most
cases. However, users may set the eNodeB to “closed” by setting the boolean
attribute <code class="docutils literal notranslate"><span class="pre">LteEnbRrc::AdmitHandoverRequest</span></code> to <cite>false</cite>. As an example, you can
run the <code class="docutils literal notranslate"><span class="pre">lena-x2-handover</span></code> program and setting the attribute in this way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NS_LOG=EpcX2:LteEnbRrc ./ns3 run lena-x2-handover --command=&quot;%s --ns3::LteEnbRrc::AdmitHandoverRequest=false&quot;
</pre></div>
</div>
<p>After the above three requirements are fulfilled, the handover procedure can be
triggered manually or automatically. Each will be presented in the following
subsections.</p>
<section id="manual-handover-trigger">
<h3><span class="section-number">20.2.19.1. </span>Manual handover trigger<a class="headerlink" href="#manual-handover-trigger" title="Link to this heading">¶</a></h3>
<p>Handover event can be triggered “manually” within the simulation program by
scheduling an explicit handover event. The <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object provides a
convenient method for the scheduling of a handover event. As an example, let us
assume that <code class="docutils literal notranslate"><span class="pre">ueLteDevs</span></code> is a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code> that contains the UE that
is to be handed over, and that <code class="docutils literal notranslate"><span class="pre">enbLteDevs</span></code> is another <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>
that contains the source and the target eNB. Then, a handover at 0.1s can be
scheduled like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;HandoverRequest(Seconds(0.100),
                           ueLteDevs.Get(0),
                           enbLteDevs.Get(0),
                           enbLteDevs.Get(1));
</pre></div>
</div>
<p>Note that the UE needs to be already connected to the source eNB, otherwise the
simulation will terminate with an error message.</p>
<p>For an example with full source code, please refer to the <code class="docutils literal notranslate"><span class="pre">lena-x2-handover</span></code>
example program.</p>
</section>
<section id="automatic-handover-trigger">
<span id="sec-automatic-handover"></span><h3><span class="section-number">20.2.19.2. </span>Automatic handover trigger<a class="headerlink" href="#automatic-handover-trigger" title="Link to this heading">¶</a></h3>
<p>Handover procedure can also be triggered “automatically” by the serving eNodeB
of the UE. The logic behind the trigger depends on the handover algorithm
currently active in the eNodeB RRC entity. Users may select and configure the
handover algorithm that will be used in the simulation, which will be explained
shortly in this section. Users may also opt to write their own implementation of
handover algorithm, as described in Section <a class="reference internal" href="lte-design.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> of the
Design Documentation.</p>
<p>Selecting a handover algorithm is done via the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object and its
<code class="docutils literal notranslate"><span class="pre">SetHandoverAlgorithmType</span></code> method as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetHandoverAlgorithmType(&quot;ns3::A2A4RsrqHandoverAlgorithm&quot;);
</pre></div>
</div>
<p>The selected handover algorithm may also provide several configurable
attributes, which can be set as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;ServingCellThreshold&quot;,
                                         UintegerValue(30));
lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;NeighbourCellOffset&quot;,
                                         UintegerValue(1));
</pre></div>
</div>
<p>Three options of handover algorithm are included in the LTE module. The
<em>A2-A4-RSRQ</em> handover algorithm (named as <code class="docutils literal notranslate"><span class="pre">ns3::A2A4RsrqHandoverAlgorithm</span></code>) is
the default option, and the usage has already been shown above.</p>
<p>Another option is the <em>strongest cell</em> handover algorithm (named as
<code class="docutils literal notranslate"><span class="pre">ns3::A3RsrpHandoverAlgorithm</span></code>), which can be selected and configured by the
following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetHandoverAlgorithmType(&quot;ns3::A3RsrpHandoverAlgorithm&quot;);
lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;Hysteresis&quot;,
                                         DoubleValue(3.0));
lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;TimeToTrigger&quot;,
                                         TimeValue(MilliSeconds(256)));
</pre></div>
</div>
<p>The last option is a special one, called the <em>no-op</em> handover algorithm, which
basically disables automatic handover trigger. This is useful for example in
cases where manual handover trigger need an exclusive control of all handover
decision. It does not have any configurable attributes. The usage is as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetHandoverAlgorithmType(&quot;ns3::NoOpHandoverAlgorithm&quot;);
</pre></div>
</div>
<p>For more information on each handover algorithm’s decision policy and their
attributes, please refer to their respective subsections in Section
<a class="reference internal" href="lte-design.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> of the Design Documentation.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">InstallEnbDevice</span></code> function of <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> will instantiate one
instance of the selected handover algorithm for each eNodeB device. In other
words, make sure to select the right handover algorithm before finalizing it in
the following line of code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer enbLteDevs = lteHelper-&gt;InstallEnbDevice(enbNodes);
</pre></div>
</div>
<p>Example with full source code of using automatic handover trigger can be found
in the <code class="docutils literal notranslate"><span class="pre">lena-x2-handover-measures</span></code> example program.</p>
</section>
<section id="tuning-simulation-with-handover">
<span id="sec-tuning-handover-simulation"></span><h3><span class="section-number">20.2.19.3. </span>Tuning simulation with handover<a class="headerlink" href="#tuning-simulation-with-handover" title="Link to this heading">¶</a></h3>
<p>As mentioned in the Design Documentation, the current implementation of handover
model may produce unpredicted behaviour when handover failure occurs. This
subsection will focus on the steps that should be taken into account by users
if they plan to use handover in their simulations.</p>
<p>The major cause of handover failure that we will tackle is the error in
transmitting handover-related signaling messages during the execution of a
handover procedure. As apparent from the Figure
<a class="reference internal" href="lte-design.html#fig-x2-based-handover-seq-diagram"><span class="std std-ref">Sequence diagram of the X2-based handover</span></a> from the Design Documentation, there
are many of them and they use different interfaces and protocols. For the sake
of simplicity, we can safely assume that the X2 interface (between the source
eNodeB and the target eNodeB) and the S1 interface (between the target eNodeB
and the SGW/PGW) are quite stable. Therefore we will focus our attention to the
RRC protocol (between the UE and the eNodeBs) and the Random Access procedure,
which are normally transmitted through the air and susceptible to degradation of
channel condition.</p>
<p>A general tips to reduce transmission error is to <em>ensure high enough SINR</em>
level in every UE. This can be done by a proper planning of the network topology
that <em>minimizes network coverage hole</em>. If the topology has a known coverage
hole, then the UE should be configured not to venture to that area.</p>
<p>Another approach to keep in mind is to <em>avoid too-late handovers</em>. In other
words, handover should happen before the UE’s SINR becomes too low, otherwise
the UE may fail to receive the handover command from the source eNodeB. Handover
algorithms have the means to control how early or late a handover decision is
made. For example, A2-A4-RSRQ handover algorithm can be configured with a higher
threshold to make it decide a handover earlier. Similarly, smaller hysteresis
and/or shorter time-to-trigger in the strongest cell handover algorithm
typically results in earlier handovers. In order to find the right values for
these parameters, one of the factors that should be considered is the UE
movement speed. Generally, a faster moving UE requires the handover to be
executed earlier. Some research work have suggested recommended values, such as
in <a class="reference internal" href="lte-references.html#lee2010" id="id13"><span>[Lee2010]</span></a>.</p>
<p>The above tips should be enough in normal simulation uses, but in the case some
special needs arise then an extreme measure can be taken into consideration.
For instance, users may consider <em>disabling the channel error models</em>. This will
ensure that all handover-related signaling messages will be transmitted
successfully, regardless of distance and channel condition. However, it will
also affect all other data or control packets not related to handover, which may
be an unwanted side effect. Otherwise, it can be done as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteSpectrumPhy::CtrlErrorModelEnabled&quot;, BooleanValue(false));
Config::SetDefault(&quot;ns3::LteSpectrumPhy::DataErrorModelEnabled&quot;, BooleanValue(false));
</pre></div>
</div>
<p>By using the above code, we disable the error model in both control and data
channels and in both directions (downlink and uplink). This is necessary because
handover-related signaling messages are transmitted using these channels. An
exception is when the simulation uses the ideal RRC protocol. In this case, only
the Random Access procedure is left to be considered. The procedure consists of
control messages, therefore we only need to disable the control channel’s error
model.</p>
</section>
<section id="handover-traces">
<span id="sec-handover-traces"></span><h3><span class="section-number">20.2.19.4. </span>Handover traces<a class="headerlink" href="#handover-traces" title="Link to this heading">¶</a></h3>
<p>The RRC model, in particular the <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> and <code class="docutils literal notranslate"><span class="pre">LteUeRrc</span></code>
objects, provide some useful traces which can be hooked up to some
custom functions so that they are called upon start and end of the
handover execution phase at both the UE and eNB side. As an example,
in your simulation program you can declare the following methods:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
NotifyHandoverStartUe(std::string context,
                      uint64_t imsi,
                      uint16_t cellId,
                      uint16_t rnti,
                      uint16_t targetCellId)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; UE IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot;: previously connected to CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot; with RNTI &quot; &lt;&lt; rnti
            &lt;&lt; &quot;, doing handover to CellId &quot; &lt;&lt; targetCellId
            &lt;&lt; std::endl;
}

void
NotifyHandoverEndOkUe(std::string context,
                      uint64_t imsi,
                      uint16_t cellId,
                      uint16_t rnti)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; UE IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot;: successful handover to CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot; with RNTI &quot; &lt;&lt; rnti
            &lt;&lt; std::endl;
}

void
NotifyHandoverStartEnb(std::string context,
                       uint64_t imsi,
                       uint16_t cellId,
                       uint16_t rnti,
                       uint16_t targetCellId)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; eNB CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot;: start handover of UE with IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot; RNTI &quot; &lt;&lt; rnti
            &lt;&lt; &quot; to CellId &quot; &lt;&lt; targetCellId
            &lt;&lt; std::endl;
}

void
NotifyHandoverEndOkEnb(std::string context,
                       uint64_t imsi,
                       uint16_t cellId,
                       uint16_t rnti)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; eNB CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot;: completed handover of UE with IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot; RNTI &quot; &lt;&lt; rnti
            &lt;&lt; std::endl;
}
</pre></div>
</div>
<p>Then, you can hook up these methods to the corresponding trace sources
like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverStart&quot;,
                MakeCallback(&amp;NotifyHandoverStartEnb));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteUeRrc/HandoverStart&quot;,
                MakeCallback(&amp;NotifyHandoverStartUe));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk&quot;,
                MakeCallback(&amp;NotifyHandoverEndOkEnb));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk&quot;,
                MakeCallback(&amp;NotifyHandoverEndOkUe));
</pre></div>
</div>
<p>Handover failure events can also be traced by trace sink functions with
a similar signature as above(including IMSI, cell ID, and RNTI). Four
different failure events are traced:</p>
<ol class="arabic simple">
<li><p>HandoverFailureNoPreamble: Handover failure due to non allocation of
non-contention-based preamble at eNB</p></li>
<li><p>HandoverFailureMaxRach: Handover failure due to maximum RACH attempts</p></li>
<li><p>HandoverFailureLeaving: Handover leaving timeout at source eNB</p></li>
<li><p>HandoverFailureJoining: Handover joining timeout at target eNB</p></li>
</ol>
<p>Similarly, one can hook up methods to the corresponding trace sources
like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureNoPreamble&quot;,
                MakeCallback(&amp;NotifyHandoverFailureNoPreamble));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureMaxRach&quot;,
                MakeCallback(&amp;NotifyHandoverFailureMaxRach));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureLeaving&quot;,
                MakeCallback(&amp;NotifyHandoverFailureLeaving));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureJoining&quot;,
                MakeCallback(&amp;NotifyHandoverFailureJoining));
</pre></div>
</div>
<p>The example program <code class="docutils literal notranslate"><span class="pre">src/lte/examples/lena-x2-handover.cc</span></code>
illustrates how the above instructions can be integrated in a
simulation program. You can run the program like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-x2-handover
</pre></div>
</div>
<p>and it will output the messages printed by the custom handover trace
hooks. In order to additionally print out some meaningful logging
information, you can run the program like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NS_LOG=LteEnbRrc:LteUeRrc:EpcX2 ./ns3 run lena-x2-handover
</pre></div>
</div>
</section>
</section>
<section id="frequency-reuse-algorithms">
<h2><span class="section-number">20.2.20. </span>Frequency Reuse Algorithms<a class="headerlink" href="#frequency-reuse-algorithms" title="Link to this heading">¶</a></h2>
<p>In this section we will describe how to use Frequency Reuse Algorithms
in eNb within LTE simulations.
There are two possible ways of configuration. The first approach is the
“manual” one, it requires more parameters to be configured, but allow user
to configure FR algorithm as he/she needs. The second approach is more
“automatic”. It is very convenient, because is the same for each FR algorithm,
so user can switch FR algorithm very quickly by changing only type of FR
algorithm. One drawback is that “automatic” approach uses only limited set
of configurations for each algorithm, what make it less flexible, but is
sufficient for most of cases.</p>
<p>These two approaches will be described more in following sub-section.</p>
<p>If user do not configure Frequency Reuse algorithm, default one
(i.e. LteFrNoOpAlgorithm) is installed in eNb. It acts as if FR
algorithm was disabled.</p>
<p>One thing that should be mentioned is that most of implemented FR algorithms work with
cell bandwidth greater or equal than 15 RBs. This limitation is caused by requirement
that at least three continuous RBs have to be assigned to UE for transmission.</p>
<section id="manual-configuration">
<h3><span class="section-number">20.2.20.1. </span>Manual configuration<a class="headerlink" href="#manual-configuration" title="Link to this heading">¶</a></h3>
<p>Frequency reuse algorithm can be configured “manually” within the simulation
program by setting type of FR algorithm and all its attributes. Currently,
seven FR algorithms are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrNoOpAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrHardAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrStrictAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrEnhancedAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrDistributedAlgorithm</span></code></p></li>
</ul>
</div></blockquote>
<p>Selecting a FR algorithm is done via the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object and
its <code class="docutils literal notranslate"><span class="pre">SetFfrAlgorithmType</span></code> method as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrHardAlgorithm&quot;);
</pre></div>
</div>
<p>Each implemented FR algorithm provide several configurable attributes. Users do
not have to care about UL and DL bandwidth configuration, because it is done
automatically during cell configuration. To change bandwidth for FR algorithm,
configure required values for <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>uint8_t bandwidth = 100;
lteHelper-&gt;SetEnbDeviceAttribute(&quot;DlBandwidth&quot;, UintegerValue(bandwidth));
lteHelper-&gt;SetEnbDeviceAttribute(&quot;UlBandwidth&quot;, UintegerValue(bandwidth));
</pre></div>
</div>
<p>Now, each FR algorithms configuration will be described.</p>
<section id="hard-frequency-reuse-algorithm">
<h4><span class="section-number">20.2.20.1.1. </span>Hard Frequency Reuse Algorithm<a class="headerlink" href="#hard-frequency-reuse-algorithm" title="Link to this heading">¶</a></h4>
<p>As described in Section <a class="reference internal" href="lte-design.html#sec-fr-hard-algorithm"><span class="std std-ref">Hard Frequency Reuse</span></a> of the Design Documentation
<code class="docutils literal notranslate"><span class="pre">ns3::LteFrHardAlgorithm</span></code> uses one sub-band. To configure this sub-band user need
to specify offset and bandwidth for DL and UL in number of RBs.</p>
<p>Hard Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DlSubBandOffset</span></code>: Downlink Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlSubBandwidth</span></code>: Downlink Transmission SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlSubBandOffset</span></code>: Uplink Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlSubBandwidth</span></code>: Uplink Transmission SubBandwidth Configuration in number of Resource Block Groups</p></li>
</ul>
</div></blockquote>
<p>Example configuration of LteFrHardAlgorithm can be done in following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrHardAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlSubBandwidth&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlSubBandwidth&quot;, UintegerValue(8));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
<p>Above example allow eNB to use only RBs from 8 to 16 in DL and UL, while entire cell
bandwidth is 25.</p>
</section>
<section id="strict-frequency-reuse-algorithm">
<h4><span class="section-number">20.2.20.1.2. </span>Strict Frequency Reuse Algorithm<a class="headerlink" href="#strict-frequency-reuse-algorithm" title="Link to this heading">¶</a></h4>
<p>Strict Frequency Reuse Algorithm uses two sub-bands: one common for each cell and one
private. There is also RSRQ threshold, which is needed to decide within which sub-band
UE should be served. Moreover the power transmission in these sub-bands can be different.</p>
<p>Strict Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlCommonSubBandwidth</span></code>: Uplink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandOffset</span></code>: Uplink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandwidth</span></code>: Uplink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlCommonSubBandwidth</span></code>: Downlink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandOffset</span></code>: Downlink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandwidth</span></code>: Downlink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgePowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>Example below allow eNB to use RBs from 0 to 6 as common sub-band and from 12 to 18 as
private sub-band in DL and UL, RSRQ threshold is 20 dB, power in center area equals
<code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">3dB</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrStrictAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandOffset&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandOffset&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(20));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB_3));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgePowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterAreaTpc&quot;, UintegerValue(1));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeAreaTpc&quot;, UintegerValue(2));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
<section id="soft-frequency-reuse-algorithm">
<h4><span class="section-number">20.2.20.1.3. </span>Soft Frequency Reuse Algorithm<a class="headerlink" href="#soft-frequency-reuse-algorithm" title="Link to this heading">¶</a></h4>
<p>With Soft Frequency Reuse Algorithm, eNb uses entire cell bandwidth, but there are two
sub-bands, within UEs are served with different power level.</p>
<p>Soft Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandOffset</span></code>: Uplink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandwidth</span></code>: Uplink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandOffset</span></code>: Downlink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandwidth</span></code>: Downlink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AllowCenterUeUseEdgeSubBand</span></code>: If true center UEs can receive on edge sub-band RBGs, otherwise
edge sub-band is allowed only for edge UEs, default value is true</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgePowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>Example below configures RBs from 8 to 16 to be used by cell edge UEs and this sub-band
is not available for cell center users. RSRQ threshold is 20 dB, power in center area
equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrSoftAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandwidth&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandwidth&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;AllowCenterUeUseEdgeSubBand&quot;, BooleanValue(false));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(20));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgePowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
<section id="soft-fractional-frequency-reuse-algorithm">
<h4><span class="section-number">20.2.20.1.4. </span>Soft Fractional Frequency Reuse Algorithm<a class="headerlink" href="#soft-fractional-frequency-reuse-algorithm" title="Link to this heading">¶</a></h4>
<p>Soft Fractional Frequency Reuse (SFFR) uses three sub-bands: center, medium (common)
and edge. User have to configure only two of them: common and edge. Center sub-band
will be composed from the remaining bandwidth. Each sub-band can be served with
different transmission power. Since there are three sub-bands, two RSRQ thresholds needs to
be configured.</p>
<p>Soft Fractional Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlCommonSubBandwidth</span></code>: Uplink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandOffset</span></code>: Uplink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandwidth</span></code>: Uplink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlCommonSubBandwidth</span></code>: Downlink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandOffset</span></code>: Downlink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandwidth</span></code>: Downlink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterRsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in medium sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeRsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MediumAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for medium sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MediumAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in medium area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>In example below RBs from 0 to 6 will be used as common (medium) sub-band,
RBs from 6 to 12 will be used as edge sub-band and RBs from 12 to 24 will be used as
center sub-band (it is composed with remaining RBs). RSRQ threshold between center
and medium area is 28 dB, RSRQ threshold between medium and edge area is 18 dB.
Power in center area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">3dB</span></code>, power in medium area equals
<code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrSoftAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterRsrqThreshold&quot;, UintegerValue(28));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeRsrqThreshold&quot;, UintegerValue(18));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB_3));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;MediumAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
<section id="enhanced-fractional-frequency-reuse-algorithm">
<h4><span class="section-number">20.2.20.1.5. </span>Enhanced Fractional Frequency Reuse Algorithm<a class="headerlink" href="#enhanced-fractional-frequency-reuse-algorithm" title="Link to this heading">¶</a></h4>
<p>Enhanced Fractional Frequency Reuse (EFFR) reserve part of system bandwidth for each cell
(typically there are 3 cell types and each one gets 1/3 of system bandwidth). Then part of
this subbandwidth it used as <cite>Primary Segment</cite> with reuse factor 3 and as <cite>Secondary Segment</cite>
with reuse factor 1. User has to configure (for DL and UL) offset of the cell subbandwidth
in number of RB, number of RB which will be used as <cite>Primary Segment</cite> and number of RB which
will be used as <cite>Secondary Segment</cite>. <cite>Primary Segment</cite> is used by cell at will, but RBs from
<cite>Secondary Segment</cite> can be assigned to UE only is CQI feedback from this UE have higher value
than configured CQI threshold. UE is considered as edge UE when its RSRQ is lower than <code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>.</p>
<p>Since each eNb needs to know where are Primary and Secondary of other cell types,
it will calculate them assuming configuration is the same for each cell and only subbandwidth offsets
are different. So it is important to divide available system bandwidth equally to each cell and apply
the same configuration of Primary and Secondary Segments to them.</p>
<p>Enhanced Fractional Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlSubBandOffset</span></code>: Uplink SubBand Offset for this cell in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlReuse3SubBandwidth</span></code>: Uplink Reuse 3 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlReuse1SubBandwidth</span></code>: Uplink Reuse 1 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlSubBandOffset</span></code>: Downlink SubBand Offset for this cell in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlReuse3SubBandwidth</span></code>: Downlink Reuse 3 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlReuse1SubBandwidth</span></code>: Downlink Reuse 1 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlCqiThreshold</span></code>: If the DL-CQI for RBG of is higher than this threshold, transmission on RBG is possible</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlCqiThreshold</span></code>: If the UL-CQI for RBG of is higher than this threshold, transmission on RBG is possible</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>In example below offset in DL and UL is 0 RB, 4 RB will be used in <cite>Primary Segment</cite> and
<cite>Secondary Segment</cite>. RSRQ threshold between center and edge area is 25 dB. DL and UL CQI
thresholds are set to value of 10. Power in center area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">6dB</span></code>,
power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">0dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrEnhancedAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(25));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlCqiThreshold&quot;, UintegerValue(10));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlCqiThreshold&quot;, UintegerValue(10));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB_6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlReuse3SubBandwidth&quot;, UintegerValue(4));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlReuse1SubBandwidth&quot;, UintegerValue(4));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlReuse3SubBandwidth&quot;, UintegerValue(4));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlReuse1SubBandwidth&quot;, UintegerValue(4));
</pre></div>
</div>
</section>
<section id="distributed-fractional-frequency-reuse-algorithm">
<h4><span class="section-number">20.2.20.1.6. </span>Distributed Fractional Frequency Reuse Algorithm<a class="headerlink" href="#distributed-fractional-frequency-reuse-algorithm" title="Link to this heading">¶</a></h4>
<p>Distributed Fractional Frequency Reuse requires X2 interface between all eNB to be installed.
X2 interfaces can be installed only when EPC is configured, so this FFR scheme can be used only with
EPC scenarios.</p>
<p>With Distributed Fractional Frequency Reuse  Algorithm, eNb uses entire cell bandwidth and there can
be two sub-bands: center sub-band and edge sub-band . Within these sub-bands UEs can be served with
different power level. Algorithm adaptively selects RBs for cell-edge sub-band on basis of
coordination information (i.e. RNTP) from adjacent cells and notifies the base stations of the adjacent cells,
which RBs it selected to use in edge sub-band. If there are no UE classified as edge UE in cell,
eNB will not use any RBs as edge sub-band.</p>
<p>Distributed Fractional Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CalculationInterval</span></code>: Time interval between calculation of Edge sub-band, Default value 1 second</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrpDifferenceThreshold</span></code>: If the difference between the power of the signal received by UE from
the serving cell and the power of the signal received from the adjacent cell is less than a
RsrpDifferenceThreshold value, the cell weight is incremented</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterPowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgePowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeRbNum</span></code>: Number of RB that can be used in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>In example below calculation interval is 500 ms. RSRQ threshold between center and edge area is 25.
RSRP Difference Threshold is set to be 5. In DL and UL 6 RB will be used by each cell in edge sub-band.
Power in center area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">0dB</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrDistributedAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CalculationInterval&quot;, TimeValue(MilliSeconds(500)));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(25));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrpDifferenceThreshold&quot;, UintegerValue(5));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeRbNum&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterPowerOffset&quot;,
                                     UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgePowerOffset&quot;,
                                     UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
</pre></div>
</div>
</section>
</section>
<section id="automatic-configuration">
<h3><span class="section-number">20.2.20.2. </span>Automatic configuration<a class="headerlink" href="#automatic-configuration" title="Link to this heading">¶</a></h3>
<p>Frequency Reuse algorithms can also be configured in more “automatic” way by setting
only the bandwidth and FrCellTypeId. During initialization of FR instance, configuration
for set bandwidth and FrCellTypeId will be taken from configuration table. It is important
that only sub-bands will be configured, thresholds and transmission power will be set
to default values. If one wants, he/she can change thresholds and transmission power
as show in previous sub-section.</p>
<p>There are three FrCellTypeId : <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3</span></code>, which correspond to three different
configurations for each bandwidth. Three configurations allow to have different
configurations in neighbouring cells in hexagonal eNB layout. If user needs to have
more different configuration for neighbouring cells, he/she need to use manual
configuration.</p>
<p>Example below show automatic FR algorithm configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrSoftAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;FrCellTypeId&quot;, UintegerValue(1));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
</section>
<section id="uplink-power-control">
<h2><span class="section-number">20.2.21. </span>Uplink Power Control<a class="headerlink" href="#uplink-power-control" title="Link to this heading">¶</a></h2>
<p>Uplink Power Control functionality is enabled by default. User can disable it by setting
the boolean attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteUePhy::EnableUplinkPowerControl</span></code> to true.</p>
<p>User can switch between Open Loop Power Control and Closed Loop Power Control mechanisms
by setting the boolean attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteUePowerControl::ClosedLoop</span></code>.
By default Closed Loop Power Control with Accumulation Mode is enabled.</p>
<p>Path-loss is key component of Uplink Power Control. It is computed as difference between
filtered RSRP and ReferenceSignalPower parameter. ReferenceSignalPower is
sent with SIB2.</p>
<p>Attributes available in Uplink Power Control:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ClosedLoop</span></code>: if true Closed Loop Uplink Power Control mode is enabled and Open Loop
Power Control otherwise, default value is false</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AccumulationEnabled</span></code>: if true Accumulation Mode is enabled and Absolute mode otherwise,
default value is false</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Alpha</span></code>: the path loss compensation factor, default value is 1.0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pcmin</span></code>: minimal UE TxPower, default value is -40 dBm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pcmax</span></code>: maximal UE TxPower, default value is 23 dBm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PoNominalPusch</span></code>: this parameter should be set by higher layers, but currently
it needs to be configured by attribute system, possible values are
integers in range (-126 … 24), Default value is -80</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PoUePusch</span></code>: this parameter should be set by higher layers, but currently
it needs to be configured by attribute system, possible values are
integers in range (-8 … 7), Default value is 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PsrsOffset</span></code>: this parameter should be set by higher layers, but currently
it needs to be configured by attribute system, possible values are
integers in range (0 … 15), Default value is 7, what gives P_Srs_Offset_Value = 0</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Traced values in Uplink Power Control:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ReportPuschTxPower</span></code>: Current UE TxPower for PUSCH</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReportPucchTxPower</span></code>: Current UE TxPower for PUCCH</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReportSrsTxPower</span></code>: Current UE TxPower for SRS</p></li>
</ul>
</dd>
</dl>
<p>Example configuration is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteUePhy::EnableUplinkPowerControl&quot;, BooleanValue(true));
Config::SetDefault(&quot;ns3::LteEnbPhy::TxPower&quot;, DoubleValue(30));
Config::SetDefault(&quot;ns3::LteUePowerControl::ClosedLoop&quot;, BooleanValue(true));
Config::SetDefault(&quot;ns3::LteUePowerControl::AccumulationEnabled&quot;, BooleanValue(true));
</pre></div>
</div>
<p>As an example, user can take a look and run the lena-uplink-power-control program.</p>
</section>
<section id="examples-programs">
<h2><span class="section-number">20.2.22. </span>Examples Programs<a class="headerlink" href="#examples-programs" title="Link to this heading">¶</a></h2>
<p>The directory <code class="docutils literal notranslate"><span class="pre">src/lte/examples/</span></code> contains some example simulation programs that
show how to simulate different LTE scenarios.</p>
</section>
<section id="reference-scenarios">
<h2><span class="section-number">20.2.23. </span>Reference scenarios<a class="headerlink" href="#reference-scenarios" title="Link to this heading">¶</a></h2>
<p>There is a vast amount of reference LTE simulation scenarios which can
be found in the literature. Here we list some of them:</p>
<blockquote>
<div><ul>
<li><p>The system simulation scenarios mentioned in section A.2 of <a class="reference internal" href="lte-references.html#tr36814" id="id14"><span>[TR36814]</span></a>.</p></li>
<li><p>The dual stripe model <a class="reference internal" href="lte-references.html#r4-092042" id="id15"><span>[R4-092042]</span></a>, which is partially implemented in the
example program <code class="docutils literal notranslate"><span class="pre">src/lte/examples/lena-dual-stripe.cc</span></code>. This example
program features a lot of configurable parameters which can be customized by
changing the corresponding global variables. To get a list of all these
global variables, you can run this command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-dual-stripe --command-template=&quot;%s --PrintGlobals&quot;
</pre></div>
</div>
<p>The following subsection presents an example of running a simulation
campaign using this example program.</p>
</li>
</ul>
</div></blockquote>
<section id="handover-simulation-campaign">
<h3><span class="section-number">20.2.23.1. </span>Handover simulation campaign<a class="headerlink" href="#handover-simulation-campaign" title="Link to this heading">¶</a></h3>
<p>In this subsection, we will demonstrate an example of running a simulation
campaign using the LTE module of <em>ns-3</em>. The objective of the campaign is to
compare the effect of each built-in handover algorithm of the LTE module.</p>
<p>The campaign will use the <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> example program. First, we have
to modify the example program to produce the output that we need. In this
occasion, we want to produce the number of handovers, user average throughput,
and average SINR.</p>
<p>The number of handovers can be obtained by counting the number of times the
<cite>HandoverEndOk</cite> <a class="reference internal" href="#sec-handover-traces"><span class="std std-ref">Handover traces</span></a> is fired. Then the user average
throughput can be obtained by enabling the RLC <a class="reference internal" href="#sec-simulation-output"><span class="std std-ref">Simulation Output</span></a>.
Finally, SINR can be obtained by enabling the PHY simulation output. The
following sample code snippet shows one possible way to obtain the above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
NotifyHandoverEndOkUe(std::string context, uint64_t imsi,
                      uint16_t cellId, uint16_t rnti)
{
  std::cout &lt;&lt; &quot;Handover IMSI &quot; &lt;&lt; imsi &lt;&lt; std::endl;
}

int
main(int argc, char *argv[])
{
  /*** SNIP ***/

  Config::Connect(&quot;/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk&quot;,
                  MakeCallback(&amp;NotifyHandoverEndOkUe));

  lteHelper-&gt;EnablePhyTraces();
  lteHelper-&gt;EnableRlcTraces();
  Ptr&lt;RadioBearerStatsCalculator&gt; rlcStats = lteHelper-&gt;GetRlcStats();
  rlcStats-&gt;SetAttribute(&quot;StartTime&quot;, TimeValue(Seconds(0)));
  rlcStats-&gt;SetAttribute(&quot;EpochDuration&quot;, TimeValue(Seconds(simTime)));

  Simulator::Run();
  Simulator::Destroy();
  return 0;
}
</pre></div>
</div>
<p>Then we have to configure the parameters of the program to suit our simulation
needs. We are looking for the following assumptions in our simulation:</p>
<blockquote>
<div><ul class="simple">
<li><p>7 sites of tri-sectored macro eNodeBs (i.e. 21 macrocells) deployed in
hexagonal layout with 500 m inter-site distance.</p></li>
<li><p>Although <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> is originally intended for a two-tier
(macrocell and femtocell) simulation, we will simplify our simulation to
one-tier (macrocell) simulation only.</p></li>
<li><p>UEs are randomly distributed around the sites and attach to the network
automatically using Idle mode cell selection. After that, UE will roam the
simulation environment with 60 kmph movement speed.</p></li>
<li><p>50 seconds simulation duration, so UEs would have traveled far enough to
trigger some handovers.</p></li>
<li><p>46 dBm macrocell Tx power and 10 dBm UE Tx power.</p></li>
<li><p>EPC mode will be used because the X2 handover procedure requires it to be
enabled.</p></li>
<li><p>Full-buffer downlink and uplink traffic, both in 5 MHz bandwidth, using TCP
protocol and Proportional Fair scheduler.</p></li>
<li><p>Ideal RRC protocol.</p></li>
</ul>
</div></blockquote>
<p>Table <a class="reference internal" href="#tab-handover-campaign-program-parameter"><span class="std std-ref">lena-dual-stripe parameter configuration for handover campaign</span></a> below shows how we
configure the parameters of <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> to achieve the above
assumptions.</p>
<span id="tab-handover-campaign-program-parameter"></span><table class="docutils align-default" id="id20">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> parameter configuration for handover campaign</span><a class="headerlink" href="#id20" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>simTime</p></td>
<td><p>50</p></td>
<td><p>50 seconds simulation duration</p></td>
</tr>
<tr class="row-odd"><td><p>nBlocks</p></td>
<td><p>0</p></td>
<td><p>Disabling apartment buildings and femtocells</p></td>
</tr>
<tr class="row-even"><td><p>nMacroEnbSites</p></td>
<td><p>7</p></td>
<td><p>Number of macrocell sites (each site has 3
cells)</p></td>
</tr>
<tr class="row-odd"><td><p>nMacroEnbSitesX</p></td>
<td><p>2</p></td>
<td><p>The macrocell sites will be positioned in a
2-3-2 formation</p></td>
</tr>
<tr class="row-even"><td><p>interSiteDistance</p></td>
<td><p>500</p></td>
<td><p>500 m distance between adjacent macrocell sites</p></td>
</tr>
<tr class="row-odd"><td><p>macroEnbTxPowerDbm</p></td>
<td><p>46</p></td>
<td><p>46 dBm Tx power for each macrocell</p></td>
</tr>
<tr class="row-even"><td><p>epc</p></td>
<td><p>1</p></td>
<td><p>Enable EPC mode</p></td>
</tr>
<tr class="row-odd"><td><p>epcDl</p></td>
<td><p>1</p></td>
<td><p>Enable full-buffer DL traffic</p></td>
</tr>
<tr class="row-even"><td><p>epcUl</p></td>
<td><p>1</p></td>
<td><p>Enable full-buffer UL traffic</p></td>
</tr>
<tr class="row-odd"><td><p>useUdp</p></td>
<td><p>0</p></td>
<td><p>Disable UDP traffic and enable TCP instead</p></td>
</tr>
<tr class="row-even"><td><p>macroUeDensity</p></td>
<td><p>0.00002</p></td>
<td><p>Determines number of UEs (translates to 48 UEs
in our simulation)</p></td>
</tr>
<tr class="row-odd"><td><p>outdoorUeMinSpeed</p></td>
<td><p>16.6667</p></td>
<td><p>Minimum UE movement speed in m/s (60 kmph)</p></td>
</tr>
<tr class="row-even"><td><p>outdoorUeMaxSpeed</p></td>
<td><p>16.6667</p></td>
<td><p>Maximum UE movement speed in m/s (60 kmph)</p></td>
</tr>
<tr class="row-odd"><td><p>macroEnbBandwidth</p></td>
<td><p>25</p></td>
<td><p>5 MHz DL and UL bandwidth</p></td>
</tr>
<tr class="row-even"><td><p>generateRem</p></td>
<td><p>1</p></td>
<td><p>(Optional) For plotting the Radio Environment
Map</p></td>
</tr>
</tbody>
</table>
<p>Some of the required assumptions are not available as parameters of
<code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code>. In this case, we override the default attributes, as
shown in Table <a class="reference internal" href="#tab-handover-campaign-default-values"><span class="std std-ref">Overriding default attributes for handover campaign</span></a> below.</p>
<span id="tab-handover-campaign-default-values"></span><table class="docutils align-default" id="id21">
<caption><span class="caption-text">Overriding default attributes for handover campaign</span><a class="headerlink" href="#id21" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Default value name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ns3::LteHelper::HandoverAlgorithm</p></td>
<td><p><cite>ns3::NoOpHandoverAlgorithm</cite>,
<cite>ns3::A3RsrpHandoverAlgorithm</cite>, or
<cite>ns3::A2A4RsrqHandoverAlgorithm</cite></p></td>
<td><p>Choice of handover algorithm</p></td>
</tr>
<tr class="row-odd"><td><p>ns3::LteHelper::Scheduler</p></td>
<td><p><cite>ns3::PfFfMacScheduler</cite></p></td>
<td><p>Proportional Fair scheduler</p></td>
</tr>
<tr class="row-even"><td><p>ns3::LteHelper::UseIdealRrc</p></td>
<td><p>1</p></td>
<td><p>Ideal RRC protocol</p></td>
</tr>
<tr class="row-odd"><td><p>ns3::RadioBearerStatsCalculator::DlRlcOutputFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-DlRlcStats.txt</p></td>
<td><p>File name for DL RLC trace output</p></td>
</tr>
<tr class="row-even"><td><p>ns3::RadioBearerStatsCalculator::UlRlcOutputFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-UlRlcStats.txt</p></td>
<td><p>File name for UL RLC trace output</p></td>
</tr>
<tr class="row-odd"><td><p>ns3::PhyStatsCalculator::DlRsrpSinrFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-DlRsrpSinrStats.txt</p></td>
<td><p>File name for DL PHY RSRP/SINR trace output</p></td>
</tr>
<tr class="row-even"><td><p>ns3::PhyStatsCalculator::UlSinrFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-UlSinrStats.txt</p></td>
<td><p>File name for UL PHY SINR trace output</p></td>
</tr>
</tbody>
</table>
<p><em>ns-3</em> provides many ways for passing configuration values into a simulation. In
this example, we will use the command line arguments. It is basically done by
appending the parameters and their values to the <code class="docutils literal notranslate"><span class="pre">ns3</span></code> call when starting each
individual simulation. So the <code class="docutils literal notranslate"><span class="pre">ns3</span></code> calls for invoking our 3 simulations would
look as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::NoOpHandoverAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=no-op-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=no-op-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=no-op-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=no-op-UlSinrStats.txt
  --RngRun=1&quot; &gt; no-op.txt

$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::A3RsrpHandoverAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=a3-rsrp-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=a3-rsrp-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=a3-rsrp-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=a3-rsrp-UlSinrStats.txt
  --RngRun=1&quot; &gt; a3-rsrp.txt

$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::A2A4RsrqHandoverAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=a2-a4-rsrq-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=a2-a4-rsrq-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=a2-a4-rsrq-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=a2-a4-rsrq-UlSinrStats.txt
  --RngRun=1&quot; &gt; a2-a4-rsrq.txt
</pre></div>
</div>
<p>Some notes on the execution:</p>
<blockquote>
<div><ul class="simple">
<li><p>Notice that some arguments are not specified because they are already the
same as the default values. We also keep the handover algorithms on each own
default settings.</p></li>
<li><p>Note the file names of simulation output, e.g. RLC traces and PHY traces,
because we have to make sure that they are not overwritten by the next
simulation run. In this example, we specify the names one by one using the
command line arguments.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">--RngRun=1</span></code> argument at the end is used for setting the run number
used by the random number generator used in the simulation. We re-run the
same simulations with different <cite>RngRun</cite> values, hence creating several
independent replications of the same simulations. Then we average the
results obtained from these replications to achieve some statistical
confidence.</p></li>
<li><p>We can add a <code class="docutils literal notranslate"><span class="pre">--generateRem=1</span></code> argument to generate the files necessary for
generating the Radio Environment Map (REM) of the simulation. The result is
Figure <a class="reference internal" href="#fig-lte-handover-campaign-rem"><span class="std std-ref">REM obtained from a simulation in handover campaign</span></a> below, which can be produced by
following the steps described in Section <a class="reference internal" href="#sec-radio-environment-maps"><span class="std std-ref">Radio Environment Maps</span></a>.
This figure also shows the position of eNodeBs and UEs at the beginning of a
simulation using <code class="docutils literal notranslate"><span class="pre">RngRun</span> <span class="pre">=</span> <span class="pre">1</span></code>. Other values of <cite>RngRun</cite> may produce
different UE position.</p></li>
</ul>
</div></blockquote>
<figure class="align-center" id="id22">
<span id="fig-lte-handover-campaign-rem"></span><img alt="_images/lte-handover-campaign-rem.png" src="_images/lte-handover-campaign-rem.png" />
<figcaption>
<p><span class="caption-text">REM obtained from a simulation in handover campaign</span><a class="headerlink" href="#id22" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>After hours of running, the simulation campaign will eventually end. Next we
will perform some post-processing on the produced simulation output to obtain
meaningful information out of it.</p>
<p>In this example, we use GNU Octave to assist the processing of throughput and
SINR data, as demonstrated in a sample GNU Octave script below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% RxBytes is the 10th column
DlRxBytes = load (&quot;no-op-DlRlcStats.txt&quot;) (:,10);
DlAverageThroughputKbps = sum (DlRxBytes) * 8 / 1000 / 50

% RxBytes is the 10th column
UlRxBytes = load (&quot;no-op-UlRlcStats.txt&quot;) (:,10);
UlAverageThroughputKbps = sum (UlRxBytes) * 8 / 1000 / 50

% Sinr is the 6th column
DlSinr = load (&quot;no-op-DlRsrpSinrStats.txt&quot;) (:,6);
% eliminate NaN values
idx = isnan (DlSinr);
DlSinr (idx) = 0;
DlAverageSinrDb = 10 * log10 (mean (DlSinr)) % convert to dB

% Sinr is the 5th column
UlSinr = load (&quot;no-op-UlSinrStats.txt&quot;) (:,5);
% eliminate NaN values
idx = isnan (UlSinr);
UlSinr (idx) = 0;
UlAverageSinrDb = 10 * log10 (mean (UlSinr)) % convert to dB
</pre></div>
</div>
<p>As for the number of handovers, we can use simple shell scripting to count the
number of occurrences of string “Handover” in the log file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ grep &quot;Handover&quot; no-op.txt | wc -l
</pre></div>
</div>
<p>Table <a class="reference internal" href="#tab-handover-campaign-results"><span class="std std-ref">Results of handover campaign</span></a> below shows the complete statistics
after we are done with post-processing on every individual simulation run. The
values shown are the average of the results obtained from <code class="docutils literal notranslate"><span class="pre">RngRun</span></code> of 1, 2, 3,
and 4.</p>
<span id="tab-handover-campaign-results"></span><table class="docutils align-default" id="id23">
<caption><span class="caption-text">Results of handover campaign</span><a class="headerlink" href="#id23" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Statistics</p></th>
<th class="head"><p>No-op</p></th>
<th class="head"><p>A2-A4-RSRQ</p></th>
<th class="head"><p>Strongest cell</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Average DL system throughput</p></td>
<td><p>6 615 kbps</p></td>
<td><p>20 509 kbps</p></td>
<td><p>19 709 kbps</p></td>
</tr>
<tr class="row-odd"><td><p>Average UL system throughput</p></td>
<td><p>4 095 kbps</p></td>
<td><p>5 705 kbps</p></td>
<td><p>6 627 kbps</p></td>
</tr>
<tr class="row-even"><td><p>Average DL SINR</p></td>
<td><p>-0.10 dB</p></td>
<td><p>5.19 dB</p></td>
<td><p>5.24 dB</p></td>
</tr>
<tr class="row-odd"><td><p>Average UL SINR</p></td>
<td><p>9.54 dB</p></td>
<td><p>81.57 dB</p></td>
<td><p>79.65 dB</p></td>
</tr>
<tr class="row-even"><td><p>Number of handovers per UE per second</p></td>
<td><p>0</p></td>
<td><p>0.05694</p></td>
<td><p>0.04771</p></td>
</tr>
</tbody>
</table>
<p>The results show that having a handover algorithm in a mobility simulation
improves both user throughput and SINR significantly. There is little difference
between the two handover algorithms in this campaign scenario. It would be
interesting to see their performance in different scenarios, such as scenarios
with home eNodeBs deployment.</p>
</section>
<section id="frequency-reuse-examples">
<h3><span class="section-number">20.2.23.2. </span>Frequency Reuse examples<a class="headerlink" href="#frequency-reuse-examples" title="Link to this heading">¶</a></h3>
<p>There are two examples showing Frequency Reuse Algorithms functionality.</p>
<p><code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> is simple example with 3 eNBs in triangle layout.
There are 3 cell edge UEs, which are located in the center of this triangle and
3 cell center UEs (one near each eNB). User can also specify the number of randomly
located UEs. FR algorithm is installed in eNBs and each eNB has different FrCellTypeId,
what means each eNB uses different FR configuration. User can run <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code>
with 6 different FR algorithms: NoOp, Hard FR, Strict FR, Soft FR, Soft FFR and Enhanced FFR.
To run scenario with Distributed FFR algorithm, user should use <code class="docutils literal notranslate"><span class="pre">lena-distributed-ffr</span></code>.
These two examples are very similar, but they were split because Distributed FFR requires
EPC to be used, and other algorithms do not.</p>
<p>To run <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> with different Frequency Reuse algorithms, user needs to specify
FR algorithm by overriding the default attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::FfrAlgorithm</span></code>.
Example command to run <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> with Soft FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-frequency-reuse --ns3::LteHelper::FfrAlgorithm=ns3::LteFrSoftAlgorithm&quot;
</pre></div>
</div>
<p>In these examples functionality to generate REM and spectrum analyzer trace was added.
User can enable generation of it by setting <code class="docutils literal notranslate"><span class="pre">generateRem</span></code> and <code class="docutils literal notranslate"><span class="pre">generateSpectrumTrace</span></code>
attributes.</p>
<p>Command to generate REM for RB 1 in data channel from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> scenario
with Soft FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-frequency-reuse --ns3::LteHelper::FfrAlgorithm=ns3::LteFrSoftAlgorithm
  --generateRem=true --remRbId=1&quot;
</pre></div>
</div>
<p>Radio Environment Map for Soft FR is presented in Figure <a class="reference internal" href="#fig-lte-soft-fr-1-rem"><span class="std std-ref">REM for RB 1 obtained from lena-frequency-reuse example with Soft FR
algorithm enabled</span></a>.</p>
<figure class="align-center" id="id24">
<span id="fig-lte-soft-fr-1-rem"></span><img alt="_images/lte-fr-soft-1-rem.png" src="_images/lte-fr-soft-1-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 1 obtained from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> example with Soft FR
algorithm enabled</span><a class="headerlink" href="#id24" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Command to generate spectrum trace from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> scenario
with Soft FFR algorithm is presented below (Spectrum Analyzer position needs to be configured
inside script):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-frequency-reuse --ns3::LteHelper::FfrAlgorithm=ns3::LteFfrSoftAlgorithm
  --generateSpectrumTrace=true&quot;
</pre></div>
</div>
<p>Example spectrum analyzer trace is presented in figure <a class="reference internal" href="#fig-lte-soft-ffr-2-spectrum-trace"><span class="std std-ref">Spectrum Analyzer trace obtained from lena-frequency-reuse example
with Soft FFR algorithm enabled. Spectrum Analyzer was located need eNB
with FrCellTypeId 2.</span></a>.
As can be seen, different data channel subbands are sent with different power level
(according to configuration), while control channel is transmitted with uniform power
along entire system bandwidth.</p>
<figure class="align-center" id="id25">
<span id="fig-lte-soft-ffr-2-spectrum-trace"></span><img alt="_images/lte-ffr-soft-2-spectrum-trace.png" src="_images/lte-ffr-soft-2-spectrum-trace.png" />
<figcaption>
<p><span class="caption-text">Spectrum Analyzer trace obtained from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> example
with Soft FFR algorithm enabled. Spectrum Analyzer was located need eNB
with FrCellTypeId 2.</span><a class="headerlink" href="#id25" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> can be also run with Frequency Reuse algorithms installed in all macro eNB.
User needs to specify FR algorithm by overriding the default attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::FfrAlgorithm</span></code>.
Example command to run <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> with Hard FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::NoOpHandoverAlgorithm
  --ns3::LteHelper::FfrAlgorithm=ns3::LteFrHardAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=no-op-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=no-op-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=no-op-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=no-op-UlSinrStats.txt
  --RngRun=1&quot; &gt; no-op.txt
</pre></div>
</div>
<p>Example command to generate REM for RB 1 in data channel from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> scenario
with Hard FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=0 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::NoOpHandoverAlgorithm
  --ns3::LteHelper::FfrAlgorithm=ns3::LteFrHardAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=no-op-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=no-op-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=no-op-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=no-op-UlSinrStats.txt
  --RngRun=1 --generateRem=true --remRbId=1&quot; &gt; no-op.txt
</pre></div>
</div>
<p>Radio Environment Maps for RB 1, 10 and 20 generated from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code>
scenario with Hard Frequency Reuse algorithm are presented in the figures
below. These RB were selected because each one is used by different FR cell type.</p>
<figure class="align-center" id="id26">
<span id="fig-lte-hard-fr-1-rem"></span><img alt="_images/lte-fr-hard-1-rem.png" src="_images/lte-fr-hard-1-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 1 obtained from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> simulation with Hard FR algorithm enabled</span><a class="headerlink" href="#id26" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id27">
<span id="fig-lte-hard-fr-2-rem"></span><img alt="_images/lte-fr-hard-2-rem.png" src="_images/lte-fr-hard-2-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 10 obtained from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> simulation with Hard FR algorithm enabled</span><a class="headerlink" href="#id27" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id28">
<span id="fig-lte-hard-fr-3-rem"></span><img alt="_images/lte-fr-hard-3-rem.png" src="_images/lte-fr-hard-3-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 20 obtained from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> simulation with Hard FR algorithm enabled</span><a class="headerlink" href="#id28" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="carrier-aggregation-examples">
<h2><span class="section-number">20.2.24. </span>Carrier aggregation examples<a class="headerlink" href="#carrier-aggregation-examples" title="Link to this heading">¶</a></h2>
<p>The carrier aggregation feature is not enabled by default. The user can enable it by setting the boolean attribute
<code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::UseCa</span></code> to true. The number of component carriers to be used in carrier aggregation can
be configured by setting the attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::NumberOfComponentCarriers</span></code>. Currently the
maximum number is 5. Additionally, the component carrier manager needs to be configured. By default
the <code class="docutils literal notranslate"><span class="pre">NoOpComponentCarrierManager</span></code> is selected, which means that only the primary carrier is enabled. The Component
carrier manager (CCM) implementation that uses all the available carriers is <code class="docutils literal notranslate"><span class="pre">RrComponentCarrierManager</span></code>.
The CCM can be configured by using the attribute <code class="docutils literal notranslate"><span class="pre">LteHelper::EnbComponentCarrierManager</span></code>.</p>
<p>An example configuration is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteHelper::UseCa&quot;, BooleanValue(useCa));
Config::SetDefault(&quot;ns3::LteHelper::NumberOfComponentCarriers&quot;, UintegerValue(2));
Config::SetDefault(&quot;ns3::LteHelper::EnbComponentCarrierManager&quot;, StringValue(&quot;ns3::RrComponentCarrierManager&quot;));
</pre></div>
</div>
<p>As an example, the user can take a look and run the <code class="docutils literal notranslate"><span class="pre">lena-simple</span></code> and <code class="docutils literal notranslate"><span class="pre">lena-simple-epc</span></code> programs and enable LTE traces
to check the performance. A new column is added to PHY and MAC traces to indicate the component carrier.</p>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-carrier-aggregation</span></code> is also a test program that can be used as an example as it can be run in a mode to write results
to output files by setting the <code class="docutils literal notranslate"><span class="pre">s_writeResults</span></code> boolean static variable to true. The test can be run by using a <cite>test-runner</cite>:</p>
<blockquote>
<div><p>./ns3 run ‘test-runner –suite=lte-carrier-aggregation’</p>
</div></blockquote>
<p>To plot the test results, a file has to be created in the root folder of the ns-3 repository, and added to it with the following content :</p>
<blockquote>
<div><p>set terminal png
set xlabel “Number of users”
set ylabel “Throughput per UE [Mbps]”
set key top right</p>
<p>downlink_results=”carrier_aggregation_results_dl.txt”
uplink_results=”carrier_aggregation_results_ul.txt”</p>
<p>set output “ca-test-example-dl.png”
set title “Downlink performance”</p>
<dl class="simple">
<dt>plot downlink_results using 1:($2==1 ? $3/1000000<span class="classifier">1/0) w lp t ‘NO SDL’, </span></dt><dd><p>downlink_results using 1:($2==2 ? $3/1000000 : 1/0) w lp t ‘RR SDL 1’, downlink_results using 1:($2==3 ? $3/1000000 : 1/0) w lp t ‘RR SDL 2’</p>
</dd>
</dl>
<p>set output “ca-test-example-ul.png”
set title “Uplink performance”</p>
<dl class="simple">
<dt>plot uplink_results using 1:($2==1 ? $3/1000000<span class="classifier">1/0) w lp t ‘NO SDL’, </span></dt><dd><p>uplink_results using 1:($2==2 ? $3/1000000 : 1/0) w lp t ‘RR SDL 1’, uplink_results using 1:($2==3 ? $3/1000000 : 1/0) w lp t ‘RR SDL 2’</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">gnuplot</span></code> can be run by providing the file name, so that in the ns-3 root directory
figures are generated. An example to run this test suite is shown in figures:
<cite>fig-ca-test-example-ul</cite> and <cite>fig-ca-test-example-dl</cite>.</p>
<figure class="align-center" id="id29">
<span id="fig-ca-test-example-ul"></span><a class="reference internal image-reference" href="_images/ca-test-example-ul.png"><img alt="_images/ca-test-example-ul.png" src="_images/ca-test-example-ul.png" style="width: 384.0px; height: 288.0px;" /></a>
<figcaption>
<p><span class="caption-text">Example of CA test performance in the uplink</span><a class="headerlink" href="#id29" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id30">
<span id="fig-ca-test-example-dl"></span><a class="reference internal image-reference" href="_images/ca-test-example-dl.png"><img alt="_images/ca-test-example-dl.png" src="_images/ca-test-example-dl.png" style="width: 384.0px; height: 288.0px;" /></a>
<figcaption>
<p><span class="caption-text">Example of CA test performance in the downlink</span><a class="headerlink" href="#id30" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="radio-link-failure-example">
<h2><span class="section-number">20.2.25. </span>Radio link failure example<a class="headerlink" href="#radio-link-failure-example" title="Link to this heading">¶</a></h2>
<p>The example <em>lena-radio-link-failure.cc</em> is an example to simulate the RLF
functionality. In particular, it simulates only one moving UE using <em>Ideal</em> or <em>Real</em>
RRC protocol with EPC performing downlink and uplink communication in two
scenarios shown in <a class="reference internal" href="#lena-radio-link-failure-one-enb"><span class="std std-ref">Scenario A: Radio link failure example with one eNB</span></a> and
<a class="reference internal" href="#lena-radio-link-failure-two-enb"><span class="std std-ref">Scenario B: Radio link failure example with two eNBs</span></a></p>
<figure class="align-center" id="id31">
<span id="lena-radio-link-failure-one-enb"></span><img alt="_images/lena-radio-link-failure-one-enb.png" src="_images/lena-radio-link-failure-one-enb.png" />
<figcaption>
<p><span class="caption-text">Scenario A: Radio link failure example with one eNB</span><a class="headerlink" href="#id31" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We note that, the RLF detection is enabled by default, which can be disabled by
configuring the <code class="docutils literal notranslate"><span class="pre">LteUePhy::EnableRlfDetection</span></code> to false, e.g.,:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteUePhy::EnableRlfDetection&quot;, BooleanValue(false));
</pre></div>
</div>
<p>In this example, to study the impact of a RLF on the user’s quality of experience,
we compute an instantaneous (i.e., every 200 ms) DL throughput of the UE, and
writes it into a file for plotting purposes. For example, to simulate the “Scenario
A” with <em>Ideal</em> and <em>Real</em> RRC protocol a user can use the following commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ideal RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=1 --useIdealRrc=1
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;

Real RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=1 --useIdealRrc=0
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;
</pre></div>
</div>
<p>After running the above two commands, we can use a simple gnuplot script to plot
the throughput as shown in the Figure <a class="reference internal" href="#fig-lena-radio-link-failure-one-enb-thrput"><span class="std std-ref">Downlink instantaneous throughput of UE in scenario A</span></a>
, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set terminal png
set output  &quot;lena-radio-link-failure-one-enb-thrput.png&quot;
set multiplot
set xlabel &quot;Time [s]&quot;
set ylabel &quot;Instantaneous throughput UE [Mbps]&quot;
set grid
set title &quot;LTE RLF example 1 eNB DL instantaneous throughput&quot;
plot &quot;rlf_dl_thrput_1_eNB_ideal_rrc&quot; using ($1):($2) with linespoints
title &#39;Ideal RRC&#39; linestyle 1 lw 2 lc rgb &#39;blue&#39;, &quot;rlf_dl_thrput_1_eNB_real_rrc&quot;
using ($1):($2) with linespoints title &#39;Real RRC&#39; linestyle 2 lw 2 lc rgb &#39;red&#39;

unset multiplot
</pre></div>
</div>
<figure class="align-center" id="id32">
<span id="fig-lena-radio-link-failure-one-enb-thrput"></span><img alt="_images/lena-radio-link-failure-one-enb-thrput.png" src="_images/lena-radio-link-failure-one-enb-thrput.png" />
<figcaption>
<p><span class="caption-text">Downlink instantaneous throughput of UE in scenario A</span><a class="headerlink" href="#id32" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In the simulator, a UE can synchronize (i.e., start reading system information)
with an eNB at a low RSRP level, which defaults to -140 dBm (see QRxLevMin attribute of eNB RRC).
It enables the UE to start the random access procedure with the eNB. In this scenario,
when using the <em>Ideal</em> RRC the UE after the RLF will connect and disconnect from
the eNB several times. This is because in the <em>Ideal</em> RRC mode, once the UE is
able to receive Random Access Response (RAR) from the eNB, it can complete the
RRC connection establishment procedure
(<a class="reference internal" href="lte-design.html#sec-rrc-connection-establishment"><span class="std std-ref">RRC connection establishment</span></a>) without any
errors, since all the RRC messages are exchanged ideally between the eNB and the UE.
However, soon after the connection establishment, it ends up in RLF due to the
poor channel quality. On the other hand, with the <em>Real</em> RRC the UE after the RLF
will not be able to complete the RRC connection establishment procedure due to
the loss of RRC messages. Thus, it will not be able to establish the connection
with the eNB. Therefore, in both the cases the UE throughput drops to zero as shown in the
Figure <a class="reference internal" href="#fig-lena-radio-link-failure-one-enb-thrput"><span class="std std-ref">Downlink instantaneous throughput of UE in scenario A</span></a>. It is also worthwhile
to mention that towards the end of the simulation (using <em>Ideal</em> or <em>Real</em> RRC)
there are occasions where RAR timer at the UE MAC would timeout due to the
increased distance between the eNB and the UE, which causes errors while decoding
this message at the UE (Note: the downlink control error model is enabled by default).</p>
<figure class="align-center" id="id33">
<span id="lena-radio-link-failure-two-enb"></span><img alt="_images/lena-radio-link-failure-two-enb.png" src="_images/lena-radio-link-failure-two-enb.png" />
<figcaption>
<p><span class="caption-text">Scenario B: Radio link failure example with two eNBs</span><a class="headerlink" href="#id33" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Similarly, to simulate the “Scenario B” with <em>Ideal</em> and <em>Real</em> RRC protocol
following commands can be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ideal RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=2 --useIdealRrc=1
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;

Real RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=2 --useIdealRrc=0
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fig-lena-radio-link-failure-two-enb-thrput"><span class="std std-ref">Downlink instantaneous throughput of UE in scenario B</span></a>, shows the throughput
in “Scenario B”. We note that in this scenario the handover algorithm is not used.
As expected, with <em>Ideal</em> RRC protocol the UE after the RLF can complete
the random access procedure with the second eNB. Interestingly, the DL SINR after
the connection establishment is not low enough to trigger the RLF, but it is
low enough to impact the DL control reception for some TBs, which in turn causes
loss of data. It can be observed from the slightly unstable throughput of the UE
after connecting to the second eNB. On the other hand, with <em>Real</em> RRC the UE faces
problems in connection establishment phase due to the loss of RRC messages, in
particular, the RRC connection request from the UE. This is the reason why the
UE throughput after the RLF remains zero for a more extended period as compared
to the <em>ideal</em> RRC protocol.</p>
<figure class="align-center" id="id34">
<span id="fig-lena-radio-link-failure-two-enb-thrput"></span><img alt="_images/lena-radio-link-failure-two-enb-thrput.png" src="_images/lena-radio-link-failure-two-enb-thrput.png" />
<figcaption>
<p><span class="caption-text">Downlink instantaneous throughput of UE in scenario B</span><a class="headerlink" href="#id34" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="troubleshooting-and-debugging-tips">
<h2><span class="section-number">20.2.26. </span>Troubleshooting and debugging tips<a class="headerlink" href="#troubleshooting-and-debugging-tips" title="Link to this heading">¶</a></h2>
<p>Many users post on the ns-3-users mailing list asking, for example,
why they do not get any traffic in their simulation, or maybe only
uplink but no downlink traffic is generated, etc. In most of the cases,
this is a bug in the user simulation program. Here the reader can find some
tips to debug the program and find out the cause of the problem.</p>
<p>The general approach is to selectively and incrementally enable the logging
of relevant LTE module components, verifying upon each activation that the
output is as expected. In detail:</p>
<blockquote>
<div><ul class="simple">
<li><p>first check the control plane, in particular the RRC connection
establishment procedure, by enabling the log components LteUeRrc and LteEnbRrc</p></li>
<li><p>then check packet transmissions on the data plane, starting by
enabling the log components LteUeNetDevice and the
EpcSgwApplication, EpcPgwApplication and EpcEnbApplication, then moving down the
LTE radio stack (PDCP, RLC, MAC, and finally PHY). All this until
you find where packets stop being processed / forwarded.</p></li>
</ul>
</div></blockquote>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">20.2. User Documentation</a><ul>
<li><a class="reference internal" href="#background">20.2.1. Background</a></li>
<li><a class="reference internal" href="#usage-overview">20.2.2. Usage Overview</a></li>
<li><a class="reference internal" href="#basic-simulation-program">20.2.3. Basic simulation program</a></li>
<li><a class="reference internal" href="#configuration-of-lte-model-parameters">20.2.4. Configuration of LTE model parameters</a></li>
<li><a class="reference internal" href="#configure-lte-mac-scheduler">20.2.5. Configure LTE MAC Scheduler</a></li>
<li><a class="reference internal" href="#simulation-output">20.2.6. Simulation Output</a></li>
<li><a class="reference internal" href="#fading-trace-usage">20.2.7. Fading Trace Usage</a><ul>
<li><a class="reference internal" href="#fading-traces-generation">20.2.7.1. Fading Traces Generation</a></li>
<li><a class="reference internal" href="#fading-traces-usage">20.2.7.2. Fading Traces Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mobility-model-with-buildings">20.2.8. Mobility Model with Buildings</a></li>
<li><a class="reference internal" href="#phy-error-model">20.2.9. PHY Error Model</a></li>
<li><a class="reference internal" href="#mimo-model">20.2.10. MIMO Model</a></li>
<li><a class="reference internal" href="#use-of-antennamodel">20.2.11. Use of AntennaModel</a></li>
<li><a class="reference internal" href="#radio-environment-maps">20.2.12. Radio Environment Maps</a></li>
<li><a class="reference internal" href="#amc-model-and-cqi-calculation">20.2.13. AMC Model and CQI Calculation</a></li>
<li><a class="reference internal" href="#evolved-packet-core-epc">20.2.14. Evolved Packet Core (EPC)</a></li>
<li><a class="reference internal" href="#using-the-epc-with-emulation-mode">20.2.15. Using the EPC with emulation mode</a></li>
<li><a class="reference internal" href="#custom-backhaul">20.2.16. Custom Backhaul</a></li>
<li><a class="reference internal" href="#network-attachment">20.2.17. Network Attachment</a><ul>
<li><a class="reference internal" href="#manual-attachment">20.2.17.1. Manual attachment</a></li>
<li><a class="reference internal" href="#automatic-attachment-using-idle-mode-cell-selection-procedure">20.2.17.2. Automatic attachment using Idle mode cell selection procedure</a></li>
<li><a class="reference internal" href="#closed-subscriber-group">20.2.17.3. Closed Subscriber Group</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configure-ue-measurements">20.2.18. Configure UE measurements</a></li>
<li><a class="reference internal" href="#x2-based-handover">20.2.19. X2-based handover</a><ul>
<li><a class="reference internal" href="#manual-handover-trigger">20.2.19.1. Manual handover trigger</a></li>
<li><a class="reference internal" href="#automatic-handover-trigger">20.2.19.2. Automatic handover trigger</a></li>
<li><a class="reference internal" href="#tuning-simulation-with-handover">20.2.19.3. Tuning simulation with handover</a></li>
<li><a class="reference internal" href="#handover-traces">20.2.19.4. Handover traces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frequency-reuse-algorithms">20.2.20. Frequency Reuse Algorithms</a><ul>
<li><a class="reference internal" href="#manual-configuration">20.2.20.1. Manual configuration</a><ul>
<li><a class="reference internal" href="#hard-frequency-reuse-algorithm">20.2.20.1.1. Hard Frequency Reuse Algorithm</a></li>
<li><a class="reference internal" href="#strict-frequency-reuse-algorithm">20.2.20.1.2. Strict Frequency Reuse Algorithm</a></li>
<li><a class="reference internal" href="#soft-frequency-reuse-algorithm">20.2.20.1.3. Soft Frequency Reuse Algorithm</a></li>
<li><a class="reference internal" href="#soft-fractional-frequency-reuse-algorithm">20.2.20.1.4. Soft Fractional Frequency Reuse Algorithm</a></li>
<li><a class="reference internal" href="#enhanced-fractional-frequency-reuse-algorithm">20.2.20.1.5. Enhanced Fractional Frequency Reuse Algorithm</a></li>
<li><a class="reference internal" href="#distributed-fractional-frequency-reuse-algorithm">20.2.20.1.6. Distributed Fractional Frequency Reuse Algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#automatic-configuration">20.2.20.2. Automatic configuration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uplink-power-control">20.2.21. Uplink Power Control</a></li>
<li><a class="reference internal" href="#examples-programs">20.2.22. Examples Programs</a></li>
<li><a class="reference internal" href="#reference-scenarios">20.2.23. Reference scenarios</a><ul>
<li><a class="reference internal" href="#handover-simulation-campaign">20.2.23.1. Handover simulation campaign</a></li>
<li><a class="reference internal" href="#frequency-reuse-examples">20.2.23.2. Frequency Reuse examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#carrier-aggregation-examples">20.2.24. Carrier aggregation examples</a></li>
<li><a class="reference internal" href="#radio-link-failure-example">20.2.25. Radio link failure example</a></li>
<li><a class="reference internal" href="#troubleshooting-and-debugging-tips">20.2.26. Troubleshooting and debugging tips</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="lte-design.html"
                          title="previous chapter"><span class="section-number">20.1. </span>Design Documentation</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="lte-testing.html"
                          title="next chapter"><span class="section-number">20.3. </span>Testing Documentation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/lte-user.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="lte-testing.html" title="20.3. Testing Documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="lte-design.html" title="20.1. Design Documentation"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="lte.html" ><span class="section-number">20. </span>LTE Module</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">20.2. </span>User Documentation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006-2019.
      Last updated on Nov 10, 2023 15:56.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>