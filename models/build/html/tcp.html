
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>16.5. TCP models in ns-3 &#8212; Model Library</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/default.css?v=bb97339c" />
    <script src="_static/documentation_options.js?v=316584e3"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="16.6. UDP model in ns-3" href="udp.html" />
    <link rel="prev" title="16.4. Routing overview" href="routing-overview.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico"
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>


  </head><body>
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" width="100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo">
              <a id="ns3_home1"
                 href="http://www.nsnam.org/">
                 <img alt="ns-3 Logo" style="background-color: unset;"
                      src="_static/ns-3-inverted-notext-small.png"/>
              </a>
            </td>
            <td id="projecttext">
              <div id="projectbrief">A Discrete-Event Network Simulator</div>
              <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
            </td>

            <td id="ns3-menu">
              <div class="menu">
                <ul >
                  <li style="background-image:none">
                    <a id="ns3_home2"
                         href="http://www.nsnam.org/"
                         >&nbsp;&nbsp;Home</a>
                  </li>
                  <li><span
                        onmouseover="mopen('mTuts')"
                        onmouseout="mclosetime()"
                          >Tutorials &nbsp;&#x25BC;</span>
                      <div id="mTuts"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_tut"
                           href="/docs/tutorial/html/index.html"
                            >English</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDocs')"
                        onmouseout="mclosetime()"
                          >Documentation &nbsp;&#x25BC;</span>
                      <div id="mDocs"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_ins"
                           href="/docs/installation/html/index.html"
                           >Installation</a><br/>
                        <a id="ns3_man"
                           href="/docs/manual/html/index.html"
                           >Manual</a><br/>
                        <a id="ns3_mod"
                           href="/docs/models/html/index.html"
                           >Models</a><br/>
                        <a id="ns3_con"
                           href="/docs/contributing/html/index.html"
                           >Contributing</a><br/>
                        <a id="ns3_wiki"
                           href="http://www.nsnam.org/wiki"
                           >Wiki</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDev')"
                        onmouseout="mclosetime()"
                          >Development &nbsp;&#x25BC;</span>
                      <div id="mDev"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_api"
                           href="/docs/doxygen/html/index.html"
                           >API Docs</a><br/>
                        <a id="ns3_bugs"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/issues"
                           >Issue Tracker</a><br/>
                        <a id="ns3_merge"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests"
                           >Merge Requests</a><br/>
                      </div>
                  </li>
                </ul>
              </div>
            </td>

            <td id="projectsection">
              <span style="margin-right:10px">Models</span>
            </td>
          </tr>
        </tbody>
      </table>
      <script  type="text/javascript">ns3_write_links()</script>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="udp.html" title="16.6. UDP model in ns-3"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="routing-overview.html" title="16.4. Routing overview"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="internet-models.html" accesskey="U"><span class="section-number">16. </span>Internet Models (IP, TCP, Routing, UDP)</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">16.5. </span>TCP models in ns-3</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="tcp-models-in-ns-3">
<h1><span class="section-number">16.5. </span>TCP models in ns-3<a class="headerlink" href="#tcp-models-in-ns-3" title="Link to this heading">¶</a></h1>
<p>This chapter describes the TCP models available in <em>ns-3</em>.</p>
<section id="overview-of-support-for-tcp">
<h2><span class="section-number">16.5.1. </span>Overview of support for TCP<a class="headerlink" href="#overview-of-support-for-tcp" title="Link to this heading">¶</a></h2>
<p><em>ns-3</em> was written to support multiple TCP implementations. The implementations
inherit from a few common header classes in the <code class="docutils literal notranslate"><span class="pre">src/network</span></code> directory, so that
user code can swap out implementations with minimal changes to the scripts.</p>
<p>There are three important abstract base classes:</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocket</span></code>: This is defined in
<code class="docutils literal notranslate"><span class="pre">src/internet/model/tcp-socket.{cc,h}</span></code>. This class exists for hosting TcpSocket
attributes that can be reused across different implementations. For instance,
the attribute <code class="docutils literal notranslate"><span class="pre">InitialCwnd</span></code> can be used for any of the implementations
that derive from class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocket</span></code>.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocketFactory</span></code>: This is used by the layer-4 protocol
instance to create TCP sockets of the right type.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpCongestionOps</span></code>: This supports different variants of
congestion control– a key topic of simulation-based TCP research.</p></li>
</ul>
<p>There are presently two active implementations of TCP available for <em>ns-3</em>.</p>
<ul class="simple">
<li><p>a natively implemented TCP for ns-3</p></li>
<li><p>support for kernel implementations via <a class="reference external" href="https://www.nsnam.org/overview/projects/direct-code-execution/">Direct Code Execution (DCE)</a></p></li>
</ul>
<p>Direct Code Execution is limited in its support for newer kernels; at
present, only Linux kernel 4.4 is supported.  However, the TCP implementations
in kernel 4.4 can still be used for ns-3 validation or for specialized
simulation use cases.</p>
<p>It should also be mentioned that various ways of combining virtual machines
with <em>ns-3</em> makes available also some additional TCP implementations, but
those are out of scope for this chapter.</p>
</section>
<section id="ns-3-tcp">
<h2><span class="section-number">16.5.2. </span>ns-3 TCP<a class="headerlink" href="#ns-3-tcp" title="Link to this heading">¶</a></h2>
<p>In brief, the native <em>ns-3</em> TCP model supports a full bidirectional TCP with
connection setup and close logic. Several congestion control algorithms
are supported, with CUBIC the default, and NewReno, Westwood, Hybla, HighSpeed,
Vegas, Scalable, Veno, Binary Increase Congestion Control (BIC), Yet Another
HighSpeed TCP (YeAH), Illinois, H-TCP, Low Extra Delay Background Transport
(LEDBAT), TCP Low Priority (TCP-LP), Data Center TCP (DCTCP) and Bottleneck
Bandwidth and RTT (BBR) also supported. The model also supports Selective
Acknowledgements (SACK), Proportional Rate Reduction (PRR) and Explicit
Congestion Notification (ECN). Multipath-TCP is not yet supported in the <em>ns-3</em>
releases.</p>
<section id="model-history">
<h3><span class="section-number">16.5.2.1. </span>Model history<a class="headerlink" href="#model-history" title="Link to this heading">¶</a></h3>
<p>Until the ns-3.10 release, <em>ns-3</em> contained a port of the TCP model from <a class="reference external" href="http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/index.html">GTNetS</a>,
developed initially by George Riley and ported to <em>ns-3</em> by Raj Bhattacharjea.
This implementation was substantially rewritten by Adriam Tam for ns-3.10.
In 2015, the TCP module was redesigned in order to create a better
environment for creating and carrying out automated tests. One of the main
changes involves congestion control algorithms, and how they are implemented.</p>
<p>Before the ns-3.25 release, a congestion control was considered as a stand-alone TCP
through an inheritance relation: each congestion control (e.g. TcpNewReno) was
a subclass of TcpSocketBase, reimplementing some inherited methods. The
architecture was redone to avoid this inheritance,
by making each congestion control a separate class, and defining an interface
to exchange important data between TcpSocketBase and the congestion modules.
The Linux <code class="docutils literal notranslate"><span class="pre">tcp_congestion_ops</span></code> interface was used as the design reference.</p>
<p>Along with congestion control, Fast Retransmit and Fast Recovery algorithms
have been modified; in previous releases, these algorithms were delegated to
TcpSocketBase subclasses. Starting from ns-3.25, they have been merged inside
TcpSocketBase. In future releases, they can be extracted as separate modules,
following the congestion control design.</p>
<p>As of the ns-3.31 release, the default initial window was set to 10 segments
(in previous releases, it was set to 1 segment).  This aligns with current
Linux default, and is discussed further in <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6928.html"><strong>RFC 6928</strong></a>.</p>
<p>In the ns-3.32 release, the default recovery algorithm was set to
Proportional Rate Reduction (PRR) from the classic ack-clocked Fast
Recovery algorithm.</p>
<p>In the ns-3.34 release, the default congestion control algorithm was set
to CUBIC from NewReno.</p>
</section>
<section id="acknowledgments">
<h3><span class="section-number">16.5.2.2. </span>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Link to this heading">¶</a></h3>
<p>As mentioned above, <em>ns-3</em> TCP has had multiple authors and maintainers over
the years. Several publications exist on aspects of <em>ns-3</em> TCP, and users
of <em>ns-3</em> TCP are requested to cite one of the applicable papers when
publishing new work.</p>
<p>A general reference on the current architecture is found in the following paper:</p>
<ul class="simple">
<li><p>Maurizio Casoni, Natale Patriciello, Next-generation TCP for ns-3 simulator, Simulation Modelling Practice and Theory, Volume 66, 2016, Pages 81-93. (<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1569190X15300939">http://www.sciencedirect.com/science/article/pii/S1569190X15300939</a>)</p></li>
</ul>
<p>For an academic peer-reviewed paper on the SACK implementation in ns-3,
please refer to:</p>
<ul class="simple">
<li><p>Natale Patriciello. 2017. A SACK-based Conservative Loss Recovery Algorithm for ns-3 TCP: a Linux-inspired Proposal. In Proceedings of the Workshop on ns-3 (WNS3 ‘17). ACM, New York, NY, USA, 1-8. (<a class="reference external" href="https://dl.acm.org/citation.cfm?id=3067666">https://dl.acm.org/citation.cfm?id=3067666</a>)</p></li>
</ul>
</section>
<section id="usage">
<h3><span class="section-number">16.5.2.3. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>In many cases, usage of TCP is set at the application layer by telling
the <em>ns-3</em> application which kind of socket factory to use.</p>
<p>Using the helper functions defined in <code class="docutils literal notranslate"><span class="pre">src/applications/helper</span></code> and
<code class="docutils literal notranslate"><span class="pre">src/network/helper</span></code>, here is how one would create a TCP receiver:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a packet sink on the star &quot;hub&quot; to receive these packets</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50000</span><span class="p">;</span>
<span class="n">Address</span><span class="w"> </span><span class="nf">sinkLocalAddress</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="n">port</span><span class="p">));</span>
<span class="n">PacketSinkHelper</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sinkLocalAddress</span><span class="p">);</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">sinkApp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">serverNode</span><span class="p">);</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Similarly, the below snippet configures OnOffApplication traffic source to use
TCP:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the OnOff applications to send TCP to the server</span>
<span class="n">OnOffHelper</span><span class="w"> </span><span class="n">clientHelper</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="p">());</span>
</pre></div>
</div>
<p>The careful reader will note above that we have specified the TypeId of an
abstract base class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocketFactory</span></code>. How does the script tell
<em>ns-3</em> that it wants the native <em>ns-3</em> TCP vs. some other one? Well, when
internet stacks are added to the node, the default TCP implementation that is
aggregated to the node is the <em>ns-3</em> TCP.  So, by default, when using the <em>ns-3</em>
helper API, the TCP that is aggregated to nodes with an Internet stack is the
native <em>ns-3</em> TCP.</p>
<p>To configure behavior of TCP, a number of parameters are exported through the
<em>ns-3</em> attribute system. These are documented in the <a class="reference external" href="https://www.nsnam.org/docs/doxygen/d3/dea/classns3_1_1_tcp_socket.html">Doxygen</a> for class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocket</span></code>. For example, the maximum segment size is a
settable attribute.</p>
<p>To set the default socket type before any internet stack-related objects are
created, one may put the following statement at the top of the simulation
program:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>For users who wish to have a pointer to the actual socket (so that
socket operations like Bind(), setting socket options, etc. can be
done on a per-socket basis), Tcp sockets can be created by using the
<code class="docutils literal notranslate"><span class="pre">Socket::CreateSocket()</span></code> method. The TypeId passed to CreateSocket()
must be of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::SocketFactory</span></code>, so configuring the underlying
socket type must be done by twiddling the attribute associated with the
underlying TcpL4Protocol object. The easiest way to get at this would be
through the attribute configuration system. In the below example,
the Node container “n0n1” is accessed to get the zeroth element, and a socket is
created on this node:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create and bind the socket...</span>
<span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeId</span><span class="o">::</span><span class="n">LookupByName</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">);</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/*/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">tid</span><span class="p">));</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">localSocket</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">Socket</span><span class="o">::</span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">n0n1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TcpSocketFactory</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">());</span>
</pre></div>
</div>
<p>Above, the “*” wild card for node number is passed to the attribute
configuration system, so that all future sockets on all nodes are set to
NewReno, not just on node ‘n0n1.Get (0)’. If one wants to limit it to just
the specified node, one would have to do something like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create and bind the socket...</span>
<span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeId</span><span class="o">::</span><span class="n">LookupByName</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span>
<span class="n">nodeId</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n0n1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetId</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">specificNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;/NodeList/&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nodeId</span><span class="p">.</span><span class="n">str</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">;</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="n">specificNode</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">tid</span><span class="p">));</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">localSocket</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">Socket</span><span class="o">::</span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">n0n1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TcpSocketFactory</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">());</span>
</pre></div>
</div>
<p>Once a TCP socket is created, one will want to follow conventional socket logic
and either connect() and send() (for a TCP client) or bind(), listen(), and
accept() (for a TCP server).
Please note that applications usually create the sockets they use automatically,
and so is not straightforward to connect directly to them using pointers. Please
refer to the source code of your preferred application to discover how and when
it creates the socket.</p>
<section id="tcp-socket-interaction-and-interface-with-application-layer">
<h4><span class="section-number">16.5.2.3.1. </span>TCP Socket interaction and interface with Application layer<a class="headerlink" href="#tcp-socket-interaction-and-interface-with-application-layer" title="Link to this heading">¶</a></h4>
<p>In the following there is an analysis on the public interface of the TCP socket,
and how it can be used to interact with the socket itself. An analysis of the
callback fired by the socket is also carried out. Please note that, for
the sake of clarity, we will use the terminology “Sender” and “Receiver” to clearly
divide the functionality of the socket. However, in TCP these two roles can be
applied at the same time (i.e. a socket could be a sender and a receiver at the
same time): our distinction does not lose generality, since the following
definition can be applied to both sockets in case of full-duplex mode.</p>
<hr class="docutils" />
<p><strong>TCP state machine (for commodity use)</strong></p>
<figure class="align-center" id="id5">
<span id="fig-tcp-state-machine"></span><img alt="_images/tcp-state-machine.png" src="_images/tcp-state-machine.png" />
<figcaption>
<p><span class="caption-text">TCP State machine</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In ns-3 we are fully compliant with the state machine depicted in
Figure <a class="reference internal" href="#fig-tcp-state-machine"><span class="std std-ref">TCP State machine</span></a>.</p>
<hr class="docutils" />
<p><strong>Public interface for receivers (e.g. servers receiving data)</strong></p>
<dl class="simple">
<dt><em>Bind()</em></dt><dd><p>Bind the socket to an address, or to a general endpoint. A general endpoint
is an endpoint with an ephemeral port allocation (that is, a random port
allocation) on the 0.0.0.0 IP address. For instance, in current applications,
data senders usually binds automatically after a <em>Connect()</em> over a random
port. Consequently, the connection will start from this random port towards
the well-defined port of the receiver. The IP 0.0.0.0 is then translated by
lower layers into the real IP of the device.</p>
</dd>
<dt><em>Bind6()</em></dt><dd><p>Same as <em>Bind()</em>, but for IPv6.</p>
</dd>
<dt><em>BindToNetDevice()</em></dt><dd><p>Bind the socket to the specified NetDevice, creating a general endpoint.</p>
</dd>
<dt><em>Listen()</em></dt><dd><p>Listen on the endpoint for an incoming connection. Please note that this
function can be called only in the TCP CLOSED state, and transit in the
LISTEN state. When an incoming request for connection is detected (i.e. the
other peer invoked <em>Connect()</em>) the application will be signaled with the
callback <em>NotifyConnectionRequest</em> (set in <em>SetAcceptCallback()</em> beforehand).
If the connection is accepted (the default behavior, when the associated
callback is a null one) the Socket will fork itself, i.e. a new socket is
created to handle the incoming data/connection, in the state SYN_RCVD. Please
note that this newly created socket is not connected anymore to the callbacks
on the “father” socket (e.g. DataSent, Recv); the pointer of the newly
created socket is provided in the Callback <em>NotifyNewConnectionCreated</em> (set
beforehand in <em>SetAcceptCallback</em>), and should be used to connect new
callbacks to interesting events (e.g. Recv callback). After receiving the ACK
of the SYN-ACK, the socket will set the congestion control, move into
ESTABLISHED state, and then notify the application with
<em>NotifyNewConnectionCreated</em>.</p>
</dd>
<dt><em>ShutdownSend()</em></dt><dd><p>Signal a termination of send, or in other words prevents data from being added
to the buffer. After this call, if buffer is already empty, the socket
will send a FIN, otherwise FIN will go when buffer empties. Please note
that this is useful only for modeling “Sink” applications. If you have
data to transmit, please refer to the <em>Send()</em> / <em>Close()</em> combination of
API.</p>
</dd>
<dt><em>GetRxAvailable()</em></dt><dd><p>Get the amount of data that could be returned by the Socket in one or multiple
call to Recv or RecvFrom. Please use the Attribute system to configure the
maximum available space on the receiver buffer (property “RcvBufSize”).</p>
</dd>
<dt><em>Recv()</em></dt><dd><p>Grab data from the TCP socket. Please remember that TCP is a stream socket,
and it is allowed to concatenate multiple packets into bigger ones. If no data
is present (i.e. <em>GetRxAvailable</em> returns 0) an empty packet is returned.
Set the callback <em>RecvCallback</em> through <em>SetRecvCallback()</em> in order to have
the application automatically notified when some data is ready to be read.
It’s important to connect that callback to the newly created socket in case
of forks.</p>
</dd>
<dt><em>RecvFrom()</em></dt><dd><p>Same as Recv, but with the source address as parameter.</p>
</dd>
</dl>
<hr class="docutils" />
<p><strong>Public interface for senders (e.g. clients uploading data)</strong></p>
<dl class="simple">
<dt><em>Connect()</em></dt><dd><p>Set the remote endpoint, and try to connect to it. The local endpoint should
be set before this call, or otherwise an ephemeral one will be created. The
TCP then will be in the SYN_SENT state. If a SYN-ACK is received, the TCP will
setup the congestion control, and then call the callback
<em>ConnectionSucceeded</em>.</p>
</dd>
<dt><em>GetTxAvailable()</em></dt><dd><p>Return the amount of data that can be stored in the TCP Tx buffer. Set this
property through the Attribute system (“SndBufSize”).</p>
</dd>
<dt><em>Send()</em></dt><dd><p>Send the data into the TCP Tx buffer. From there, the TCP rules will decide
if, and when, this data will be transmitted. Please note that, if the tx
buffer has enough data to fill the congestion (or the receiver) window, dynamically
varying the rate at which data is injected in the TCP buffer does not have any
noticeable effect on the amount of data transmitted on the wire, that will
continue to be decided by the TCP rules.</p>
</dd>
<dt><em>SendTo()</em></dt><dd><p>Same as <em>Send()</em>.</p>
</dd>
<dt><em>Close()</em></dt><dd><p>Terminate the local side of the connection, by sending a FIN (after all data
in the tx buffer has been transmitted). This does not prevent the socket in
receiving data, and employing retransmit mechanism if losses are detected. If
the application calls <em>Close()</em> with unread data in its rx buffer, the socket
will send a reset. If the socket is in the state SYN_SENT, CLOSING, LISTEN,
FIN_WAIT_2, or LAST_ACK, after that call the application will be notified with
<em>NotifyNormalClose()</em>. In other cases, the notification is delayed
(see <em>NotifyNormalClose()</em>).</p>
</dd>
</dl>
<hr class="docutils" />
<p><strong>Public callbacks</strong></p>
<p>These callbacks are called by the TCP socket to notify the application of
interesting events. We will refer to these with the protected name used in
socket.h, but we will provide the API function to set the pointers to these
callback as well.</p>
<dl class="simple">
<dt><em>NotifyConnectionSucceeded</em>: <em>SetConnectCallback</em>, 1st argument</dt><dd><p>Called in the SYN_SENT state, before moving to ESTABLISHED. In other words, we
have sent the SYN, and we received the SYN-ACK: the socket prepares the
sequence numbers, sends the ACK for the SYN-ACK, tries to send out more data (in
another segment) and then invokes this callback. After this callback, it
invokes the NotifySend callback.</p>
</dd>
<dt><em>NotifyConnectionFailed</em>: <em>SetConnectCallback</em>, 2nd argument</dt><dd><p>Called after the SYN retransmission count goes to 0. SYN packet is lost
multiple times, and the socket gives up.</p>
</dd>
<dt><em>NotifyNormalClose</em>: <em>SetCloseCallbacks</em>, 1st argument</dt><dd><p>A normal close is invoked. A rare case is when we receive an RST segment (or a
segment with bad flags) in normal states. All other cases are:
- The application tries to <em>Connect()</em> over an already connected socket
- Received an ACK for the FIN sent, with or without the FIN bit set (we are in LAST_ACK)
- The socket reaches the maximum amount of retries in retransmitting the SYN (*)
- We receive a timeout in the LAST_ACK state
- Upon entering the TIME_WAIT state, before waiting the 2*Maximum Segment Lifetime seconds to finally deallocate the socket.</p>
</dd>
<dt><em>NotifyErrorClose</em>: <em>SetCloseCallbacks</em>, 2nd argument</dt><dd><p>Invoked when we send an RST segment (for whatever reason) or we reached the
maximum amount of data retries.</p>
</dd>
<dt><em>NotifyConnectionRequest</em>: <em>SetAcceptCallback</em>, 1st argument</dt><dd><p>Invoked in the LISTEN state, when we receive a SYN. The return value indicates
if the socket should accept the connection (return true) or should ignore it
(return false).</p>
</dd>
<dt><em>NotifyNewConnectionCreated</em>: <em>SetAcceptCallback</em>, 2nd argument</dt><dd><p>Invoked when from SYN_RCVD the socket passes to ESTABLISHED, and after setting
up the congestion control, the sequence numbers, and processing the incoming
ACK. If there is some space in the buffer, <em>NotifySend</em> is called shortly
after this callback. The Socket pointer, passed with this callback, is the
newly created socket, after a Fork().</p>
</dd>
<dt><em>NotifyDataSent</em>: <em>SetDataSentCallback</em></dt><dd><p>The Socket notifies the application that some bytes have been transmitted on
the IP level. These bytes could still be lost in the node (traffic control
layer) or in the network.</p>
</dd>
<dt><em>NotifySend</em>: <em>SetSendCallback</em></dt><dd><p>Invoked if there is some space in the tx buffer when entering the ESTABLISHED
state (e.g. after the ACK for SYN-ACK is received), after the connection
succeeds (e.g. after the SYN-ACK is received) and after each new ACK (i.e.
that advances SND.UNA).</p>
</dd>
<dt><em>NotifyDataRecv</em>: <em>SetRecvCallback</em></dt><dd><p>Called when in the receiver buffer there are in-order bytes, and when in
FIN_WAIT_1 or FIN_WAIT_2 the socket receive a in-sequence FIN (that can carry
data).</p>
</dd>
</dl>
</section>
</section>
<section id="congestion-control-algorithms">
<h3><span class="section-number">16.5.2.4. </span>Congestion Control Algorithms<a class="headerlink" href="#congestion-control-algorithms" title="Link to this heading">¶</a></h3>
<p>Here follows a list of supported TCP congestion control algorithms. For an
academic paper on many of these congestion control algorithms, see
<a class="reference external" href="http://dl.acm.org/citation.cfm?id=2756518">http://dl.acm.org/citation.cfm?id=2756518</a> .</p>
<section id="newreno">
<h4><span class="section-number">16.5.2.4.1. </span>NewReno<a class="headerlink" href="#newreno" title="Link to this heading">¶</a></h4>
<p>NewReno algorithm introduces partial ACKs inside the well-established Reno
algorithm. This and other modifications are described in RFC 6582. We have two
possible congestion window increment strategy: slow start and congestion
avoidance. Taken from RFC 5681:</p>
<blockquote>
<div><p>During slow start, a TCP increments cwnd by at most SMSS bytes for
each ACK received that cumulatively acknowledges new data. Slow
start ends when cwnd exceeds ssthresh (or, optionally, when it
reaches it, as noted above) or when congestion is observed. While
traditionally TCP implementations have increased cwnd by precisely
SMSS bytes upon receipt of an ACK covering new data, we RECOMMEND
that TCP implementations increase cwnd, per Equation <a class="reference internal" href="#equation-newrenocongavoid">(1)</a>,
where N is the number of previously unacknowledged bytes acknowledged
in the incoming ACK.</p>
</div></blockquote>
<div class="math" id="equation-newrenocongavoid">
<p><span class="eqno">(1)<a class="headerlink" href="#equation-newrenocongavoid" title="Link to this equation">¶</a></span><img src="_images/math/e090bca2a574182b62f610602f2023f40aa4aa1b.png" alt="cwnd += min (N, SMSS)"/></p>
</div><p>During congestion avoidance, cwnd is incremented by roughly 1 full-sized
segment per round-trip time (RTT), and for each congestion event, the slow
start threshold is halved.</p>
</section>
<section id="cubic">
<h4><span class="section-number">16.5.2.4.2. </span>CUBIC<a class="headerlink" href="#cubic" title="Link to this heading">¶</a></h4>
<p>CUBIC (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpCubic</span></code>) is the default TCP congestion control
in Linux, macOS (since 2014), and Microsoft Windows (since 2017).
CUBIC has two main differences with respect to
a more classic TCP congestion control such as NewReno.  First, during the
congestion avoidance phase, the window size grows according to a cubic
function (concave, then convex) with the latter convex portion designed
to allow for bandwidth probing.  Second, a hybrid slow start (HyStart)
algorithm uses observations of delay increases in the slow start
phase of window growth to try to exit slow start before window growth
causes queue overflow.</p>
<p>CUBIC is documented in <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8312.html"><strong>RFC 8312</strong></a>, and the <em>ns-3</em> implementation is based
on the RFC more so than the Linux implementation, although the Linux 4.4
kernel implementation (through the Direct Code Execution environment) has
been used to validate the behavior and is fairly well aligned (see below
section on validation).</p>
</section>
<section id="linux-reno">
<h4><span class="section-number">16.5.2.4.3. </span>Linux Reno<a class="headerlink" href="#linux-reno" title="Link to this heading">¶</a></h4>
<p>TCP Linux Reno (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpLinuxReno</span></code>) is designed to provide a
Linux-like implementation of
TCP NewReno. The implementation of class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpNewReno</span></code> in ns-3
follows RFC standards, and increases cwnd more conservatively than does Linux Reno.
Linux Reno modifies slow start and congestion avoidance algorithms to
increase cwnd based on the number of bytes being acknowledged by each
arriving ACK, rather than by the number of ACKs that arrive.  Another major
difference in implementation is that Linux maintains the congestion window
in units of segments, while the RFCs define the congestion window in units of
bytes.</p>
<p>In slow start phase, on each incoming ACK at the TCP sender side cwnd
is increased by the number of previously unacknowledged bytes ACKed by the
incoming acknowledgment. In contrast, in ns-3 NewReno, cwnd is increased
by one segment per acknowledgment.  In standards terminology, this
difference is referred to as Appropriate Byte Counting (RFC 3465); Linux
follows Appropriate Byte Counting while ns-3 NewReno does not.</p>
<div class="math" id="equation-linuxrenoslowstart">
<p><span class="eqno">(2)<a class="headerlink" href="#equation-linuxrenoslowstart" title="Link to this equation">¶</a></span><img src="_images/math/cbeaede37c37a58a465004520beda7057a7edf79.png" alt="cwnd += segAcked * segmentSize"/></p>
</div><div class="math" id="equation-newrenoslowstart">
<p><span class="eqno">(3)<a class="headerlink" href="#equation-newrenoslowstart" title="Link to this equation">¶</a></span><img src="_images/math/67689f3a602dea7bd4a43581b48853408d6dba45.png" alt="cwnd += segmentSize"/></p>
</div><p>In congestion avoidance phase, the number of bytes that have been ACKed at
the TCP sender side are stored in a ‘bytes_acked’ variable in the TCP control
block. When ‘bytes_acked’ becomes greater than or equal to the value of the
cwnd, ‘bytes_acked’ is reduced by the value of cwnd. Next, cwnd is incremented
by a full-sized segment (SMSS).  In contrast, in ns-3 NewReno, cwnd is increased
by (1/cwnd) with a rounding off due to type casting into int.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Linux Reno <cite>cwnd</cite> update</span><a class="headerlink" href="#id6" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_cWndCnt</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_cWndCnt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>

<span class="w">   </span><span class="n">m_cWndCnt</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">   </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_segmentSize</span><span class="p">;</span>
<span class="w">   </span><span class="n">NS_LOG_DEBUG</span><span class="p">(</span><span class="s">&quot;Subtracting delta * w from m_cWndCnt &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">New Reno <cite>cwnd</cite> update</span><a class="headerlink" href="#id7" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">segmentsAcked</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_segmentSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_segmentSize</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>
<span class="w">   </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">adder</span><span class="p">);</span>
<span class="w">   </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">adder</span><span class="p">);</span>
<span class="w">   </span><span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;In CongAvoid, updated to cwnd &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">                </span><span class="s">&quot; ssthresh &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_ssThresh</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>So, there are two main difference between the TCP Linux Reno and TCP NewReno
in ns-3:
1) In TCP Linux Reno, delayed acknowledgement configuration does not affect
congestion window growth, while in TCP NewReno, delayed acknowledgments cause
a slower congestion window growth.
2) In congestion avoidance phase, the arithmetic for counting the number of
segments acked and deciding when to increment the cwnd is different for TCP
Linux Reno and TCP NewReno.</p>
<p>Following graphs shows the behavior of window growth in TCP Linux Reno and
TCP NewReno with delayed acknowledgement of 2 segments:</p>
<figure class="align-center" id="id8">
<span id="fig-ns3-new-reno-vs-ns3-linux-reno"></span><a class="reference internal image-reference" href="_images/ns3-new-reno-vs-ns3-linux-reno.png"><img alt="_images/ns3-new-reno-vs-ns3-linux-reno.png" src="_images/ns3-new-reno-vs-ns3-linux-reno.png" style="width: 560.0px; height: 420.0px;" /></a>
<figcaption>
<p><span class="caption-text">ns-3 TCP NewReno vs. ns-3 TCP Linux Reno</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="highspeed">
<h4><span class="section-number">16.5.2.4.4. </span>HighSpeed<a class="headerlink" href="#highspeed" title="Link to this heading">¶</a></h4>
<p>TCP HighSpeed is designed for high-capacity channels or, in general, for
TCP connections with large congestion windows.
Conceptually, with respect to the standard TCP, HighSpeed makes the
cWnd grow faster during the probing phases and accelerates the
cWnd recovery from losses.
This behavior is executed only when the window grows beyond a
certain threshold, which allows TCP HighSpeed to be friendly with standard
TCP in environments with heavy congestion, without introducing new dangers
of congestion collapse.</p>
<p>Mathematically:</p>
<div class="math" id="equation-highspeedcwndincrement">
<p><span class="eqno">(4)<a class="headerlink" href="#equation-highspeedcwndincrement" title="Link to this equation">¶</a></span><img src="_images/math/b4c10b6ae1eda1878aa0f738e3caddede323f59d.png" alt="cWnd = cWnd + \frac{a(cWnd)}{cWnd}"/></p>
</div><p>The function a() is calculated using a fixed RTT the value 100 ms (the
lookup table for this function is taken from RFC 3649). For each congestion
event, the slow start threshold is decreased by a value that depends on the
size of the slow start threshold itself. Then, the congestion window is set
to such value.</p>
<div class="math" id="equation-highspeedcwnddecrement">
<p><span class="eqno">(5)<a class="headerlink" href="#equation-highspeedcwnddecrement" title="Link to this equation">¶</a></span><img src="_images/math/4e6a6fae0ae7fc738227a941fdf617b9ddaa2908.png" alt="cWnd = (1 - b(cWnd)) \cdot cWnd"/></p>
</div><p>The lookup table for the function b() is taken from the same RFC.
More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=2756518">http://dl.acm.org/citation.cfm?id=2756518</a></p>
</section>
<section id="hybla">
<h4><span class="section-number">16.5.2.4.5. </span>Hybla<a class="headerlink" href="#hybla" title="Link to this heading">¶</a></h4>
<p>The key idea behind TCP Hybla is to obtain for long RTT connections the same
instantaneous transmission rate of a reference TCP connection with lower RTT.
With analytical steps, it is shown that this goal can be achieved by
modifying the time scale, in order for the throughput to be independent from
the RTT. This independence is obtained through the use of a coefficient rho.</p>
<p>This coefficient is used to calculate both the slow start threshold
and the congestion window when in slow start and in congestion avoidance,
respectively.</p>
<p>More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=2756518">http://dl.acm.org/citation.cfm?id=2756518</a></p>
</section>
<section id="westwood">
<h4><span class="section-number">16.5.2.4.6. </span>Westwood<a class="headerlink" href="#westwood" title="Link to this heading">¶</a></h4>
<p>Westwood and Westwood+ employ the AIAD (Additive Increase/Adaptive Decrease)
congestion control paradigm. When a congestion episode happens,
instead of halving the cwnd, these protocols try to estimate the network’s
bandwidth and use the estimated value to adjust the cwnd.
While Westwood performs the bandwidth sampling every ACK reception,
Westwood+ samples the bandwidth every RTT.</p>
<p>The TCP Westwood model has been removed in ns-3.38 due to bugs that are impossible
to fix without modifying the original Westwood model as presented in the published papers.
For further info refer to <a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/579">https://gitlab.com/nsnam/ns-3-dev/-/issues/579</a></p>
<p>The Westwood+ model does not have such issues, and is still available.</p>
<p>WARNING: this TCP model lacks validation and regression tests; use with caution.</p>
<p>More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=381704">http://dl.acm.org/citation.cfm?id=381704</a> and
<a class="reference external" href="http://dl.acm.org/citation.cfm?id=2512757">http://dl.acm.org/citation.cfm?id=2512757</a></p>
</section>
<section id="vegas">
<h4><span class="section-number">16.5.2.4.7. </span>Vegas<a class="headerlink" href="#vegas" title="Link to this heading">¶</a></h4>
<p>TCP Vegas is a pure delay-based congestion control algorithm implementing a
proactive scheme that tries to prevent packet drops by maintaining a small
backlog at the bottleneck queue. Vegas continuously samples the RTT and computes
the actual throughput a connection achieves using Equation <a class="reference internal" href="#equation-vegasactual">(6)</a> and compares it
with the expected throughput calculated in Equation <a class="reference internal" href="#equation-vegasexpected">(7)</a>. The difference between
these 2 sending rates in Equation <a class="reference internal" href="#equation-vegasdiff">(8)</a> reflects the amount of extra packets being
queued at the bottleneck.</p>
<div class="math" id="equation-vegasactual">
<p><span class="eqno">(6)<a class="headerlink" href="#equation-vegasactual" title="Link to this equation">¶</a></span><img src="_images/math/8b29760ba8889dec84ff7f4ffcf262f62a7e7e3a.png" alt="actual &amp;= \frac{cWnd}{RTT}"/></p>
</div><div class="math" id="equation-vegasexpected">
<p><span class="eqno">(7)<a class="headerlink" href="#equation-vegasexpected" title="Link to this equation">¶</a></span><img src="_images/math/bf06f1681b7d351b89ab3ab6b1408250cb7995c9.png" alt="expected &amp;= \frac{cWnd}{BaseRTT}"/></p>
</div><div class="math" id="equation-vegasdiff">
<p><span class="eqno">(8)<a class="headerlink" href="#equation-vegasdiff" title="Link to this equation">¶</a></span><img src="_images/math/170f36671c6f7f789a46bc098bd6ac941a182771.png" alt="diff &amp;= expected - actual"/></p>
</div><p>To avoid congestion, Vegas linearly increases/decreases its congestion window
to ensure the diff value falls between the two predefined thresholds, alpha and
beta. diff and another threshold, gamma, are used to determine when Vegas
should change from its slow-start mode to linear increase/decrease mode.
Following the implementation of Vegas in Linux, we use 2, 4, and 1 as the
default values of alpha, beta, and gamma, respectively, but they can be
modified through the Attribute system.</p>
<p>More information at: <a class="reference external" href="http://dx.doi.org/10.1109/49.464716">http://dx.doi.org/10.1109/49.464716</a></p>
</section>
<section id="scalable">
<h4><span class="section-number">16.5.2.4.8. </span>Scalable<a class="headerlink" href="#scalable" title="Link to this heading">¶</a></h4>
<p>Scalable improves TCP performance to better utilize the available bandwidth of
a highspeed wide area network by altering NewReno congestion window adjustment
algorithm. When congestion has not been detected, for each ACK received in an
RTT, Scalable increases its cwnd per:</p>
<div class="math" id="equation-scalablecwndincrement">
<p><span class="eqno">(9)<a class="headerlink" href="#equation-scalablecwndincrement" title="Link to this equation">¶</a></span><img src="_images/math/1d34609834fb8d613c00ccf858b6076db5889661.png" alt="cwnd = cwnd + 0.01"/></p>
</div><p>Following Linux implementation of Scalable, we use 50 instead of 100 to account
for delayed ACK.</p>
<p>On the first detection of congestion in a given RTT, cwnd is reduced based on
the following equation:</p>
<div class="math" id="equation-scalablecwnddecrement">
<p><span class="eqno">(10)<a class="headerlink" href="#equation-scalablecwnddecrement" title="Link to this equation">¶</a></span><img src="_images/math/71f3cfa2d94c13a419d51466fce33c13b49764a5.png" alt="cwnd = cwnd - ceil(0.125 \cdot cwnd)"/></p>
</div><p>More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=956989">http://dl.acm.org/citation.cfm?id=956989</a></p>
</section>
<section id="veno">
<h4><span class="section-number">16.5.2.4.9. </span>Veno<a class="headerlink" href="#veno" title="Link to this heading">¶</a></h4>
<p>TCP Veno enhances Reno algorithm for more effectively dealing with random
packet loss in wireless access networks by employing Vegas’s method in
estimating the backlog at the bottleneck queue to distinguish between
congestive and non-congestive states.</p>
<p>The backlog (the number of packets accumulated at the bottleneck queue) is
calculated using Equation <a class="reference internal" href="#equation-venon">(11)</a>:</p>
<div class="math" id="equation-venon">
<p><span class="eqno">(11)<a class="headerlink" href="#equation-venon" title="Link to this equation">¶</a></span><img src="_images/math/a5e35f9d7217bc23dfaef6ecb5f82237ca3f9a09.png" alt="N &amp;= Actual \cdot (RTT - BaseRTT) \\
  &amp;= Diff \cdot BaseRTT"/></p>
</div><p>where:</p>
<div class="math" id="equation-venodiff">
<p><span class="eqno">(12)<a class="headerlink" href="#equation-venodiff" title="Link to this equation">¶</a></span><img src="_images/math/504b7638197b5c209fb7b2b13bffe494740a07c3.png" alt="Diff &amp;= Expected - Actual \\
     &amp;= \frac{cWnd}{BaseRTT} - \frac{cWnd}{RTT}"/></p>
</div><p>Veno makes decision on cwnd modification based on the calculated N and its
predefined threshold beta.</p>
<p>Specifically, it refines the additive increase algorithm of Reno so that the
connection can stay longer in the stable state by incrementing cwnd by
1/cwnd for every other new ACK received after the available bandwidth has
been fully utilized, i.e. when N exceeds beta. Otherwise, Veno increases
its cwnd by 1/cwnd upon every new ACK receipt as in Reno.</p>
<p>In the multiplicative decrease algorithm, when Veno is in the non-congestive
state, i.e. when N is less than beta, Veno decrements its cwnd by only 1/5
because the loss encountered is more likely a corruption-based loss than a
congestion-based. Only when N is greater than beta, Veno halves its sending
rate as in Reno.</p>
<p>More information at: <a class="reference external" href="http://dx.doi.org/10.1109/JSAC.2002.807336">http://dx.doi.org/10.1109/JSAC.2002.807336</a></p>
</section>
<section id="bic">
<h4><span class="section-number">16.5.2.4.10. </span>BIC<a class="headerlink" href="#bic" title="Link to this heading">¶</a></h4>
<p>BIC (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpBic</span></code>) is a predecessor of TCP CUBIC.
In TCP BIC the congestion control problem is viewed as a search
problem. Taking as a starting point the current window value
and as a target point the last maximum window value
(i.e. the cWnd value just before the loss event) a binary search
technique can be used to update the cWnd value at the midpoint between
the two, directly or using an additive increase strategy if the distance from
the current window is too large.</p>
<p>This way, assuming a no-loss period, the congestion window logarithmically
approaches the maximum value of cWnd until the difference between it and cWnd
falls below a preset threshold. After reaching such a value (or the maximum
window is unknown, i.e. the binary search does not start at all) the algorithm
switches to probing the new maximum window with a ‘slow start’ strategy.</p>
<p>If a loss occur in either these phases, the current window (before the loss)
can be treated as the new maximum, and the reduced (with a multiplicative
decrease factor Beta) window size can be used as the new minimum.</p>
<p>More information at: <a class="reference external" href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672</a></p>
</section>
<section id="yeah">
<h4><span class="section-number">16.5.2.4.11. </span>YeAH<a class="headerlink" href="#yeah" title="Link to this heading">¶</a></h4>
<p>YeAH-TCP (Yet Another HighSpeed TCP) is a heuristic designed to balance various
requirements of a state-of-the-art congestion control algorithm:</p>
<ol class="arabic simple">
<li><p>fully exploit the link capacity of high BDP networks while inducing a small number of congestion events</p></li>
<li><p>compete friendly with Reno flows</p></li>
<li><p>achieve intra and RTT fairness</p></li>
<li><p>robust to random losses</p></li>
<li><p>achieve high performance regardless of buffer size</p></li>
</ol>
<p>YeAH operates between 2 modes: Fast and Slow mode. In the Fast mode when the queue
occupancy is small and the network congestion level is low, YeAH increments
its congestion window according to the aggressive HSTCP rule. When the number of packets
in the queue grows beyond a threshold and the network congestion level is high, YeAH enters
its Slow mode, acting as Reno with a decongestion algorithm. YeAH employs Vegas’ mechanism
for calculating the backlog as in Equation <a class="reference internal" href="#equation-q-yeah">(13)</a>. The estimation of the network congestion
level is shown in Equation <a class="reference internal" href="#equation-l-yeah">(14)</a>.</p>
<div class="math" id="equation-q-yeah">
<p><span class="eqno">(13)<a class="headerlink" href="#equation-q-yeah" title="Link to this equation">¶</a></span><img src="_images/math/e4932613eb31adb0529ed55839362d0819ba6b9a.png" alt="Q = (RTT - BaseRTT) \cdot \frac{cWnd}{RTT}"/></p>
</div><div class="math" id="equation-l-yeah">
<p><span class="eqno">(14)<a class="headerlink" href="#equation-l-yeah" title="Link to this equation">¶</a></span><img src="_images/math/bd11d8b588af30b71a574a0bbe61cc5ee281a46b.png" alt="L = \frac{RTT - BaseRTT}{BaseRTT}"/></p>
</div><p>To ensure TCP friendliness, YeAH also implements an algorithm to detect the presence of legacy
Reno flows. Upon the receipt of 3 duplicate ACKs, YeAH decreases its slow start threshold
according to Equation <a class="reference internal" href="#equation-yeahssthresh">(15)</a> if it’s not competing with Reno flows. Otherwise, the ssthresh is
halved as in Reno:</p>
<div class="math" id="equation-yeahssthresh">
<p><span class="eqno">(15)<a class="headerlink" href="#equation-yeahssthresh" title="Link to this equation">¶</a></span><img src="_images/math/1547db882efefba10a5b5478296da38c6cee0774.png" alt="ssthresh = min(max(\frac{cWnd}{8}, Q), \frac{cWnd}{2})"/></p>
</div><p>More information: <a class="reference external" href="http://www.csc.lsu.edu/~sjpark/cs7601/4-YeAH_TCP.pdf">http://www.csc.lsu.edu/~sjpark/cs7601/4-YeAH_TCP.pdf</a></p>
</section>
<section id="illinois">
<h4><span class="section-number">16.5.2.4.12. </span>Illinois<a class="headerlink" href="#illinois" title="Link to this heading">¶</a></h4>
<p>TCP Illinois is a hybrid congestion control algorithm designed for
high-speed networks. Illinois implements a Concave-AIMD (or C-AIMD)
algorithm that uses packet loss as the primary congestion signal to
determine the direction of window update and queueing delay as the
secondary congestion signal to determine the amount of change.</p>
<p>The additive increase and multiplicative decrease factors (denoted as
alpha and beta, respectively) are functions of the current average queueing
delay da as shown in Equations <a class="reference internal" href="#equation-illinoisalpha">(16)</a> and <a class="reference internal" href="#equation-illinoisbeta">(17)</a>. To improve the protocol
robustness against sudden fluctuations in its delay sampling,
Illinois allows the increment of alpha to alphaMax
only if da stays below d1 for a some (theta) amount of time.</p>
<div class="math" id="equation-illinoisalpha">
<p><span class="eqno">(16)<a class="headerlink" href="#equation-illinoisalpha" title="Link to this equation">¶</a></span><img src="_images/math/8f205d4ecda4891fb1c9b94fc106d8c272c0ec00.png" alt="alpha &amp;=
\begin{cases}
   \quad alphaMax              &amp; \quad \text{if } da &lt;= d1 \\
   \quad k1 / (k2 + da)        &amp; \quad \text{otherwise} \\
\end{cases}"/></p>
</div><div class="math" id="equation-illinoisbeta">
<p><span class="eqno">(17)<a class="headerlink" href="#equation-illinoisbeta" title="Link to this equation">¶</a></span><img src="_images/math/f08c85ef621a3445a318c7f3e0be863acd615b2e.png" alt="beta &amp;=
\begin{cases}
   \quad betaMin               &amp; \quad \text{if } da &lt;= d2 \\
   \quad k3 + k4 \, da         &amp; \quad \text{if } d2 &lt; da &lt; d3 \\
   \quad betaMax               &amp; \quad \text{otherwise}
\end{cases}"/></p>
</div><p>where the calculations of k1, k2, k3, and k4 are shown in the following:</p>
<div class="math" id="equation-illinoisk1">
<p><span class="eqno">(18)<a class="headerlink" href="#equation-illinoisk1" title="Link to this equation">¶</a></span><img src="_images/math/44f928900c289fcfc50cc42aa67fb3a507f5dfd6.png" alt="k1 &amp;= \frac{(dm - d1) \cdot alphaMin \cdot alphaMax}{alphaMax - alphaMin}"/></p>
</div><div class="math" id="equation-illinoisk2">
<p><span class="eqno">(19)<a class="headerlink" href="#equation-illinoisk2" title="Link to this equation">¶</a></span><img src="_images/math/f0fe5722801ec37ae27818d45c186961b8718e52.png" alt="k2 &amp;= \frac{(dm - d1) \cdot alphaMin}{alphaMax - alphaMin} - d1"/></p>
</div><div class="math" id="equation-illinoisk3">
<p><span class="eqno">(20)<a class="headerlink" href="#equation-illinoisk3" title="Link to this equation">¶</a></span><img src="_images/math/fbcef6da880f984cf7d047c82d4b848df197e875.png" alt="k3 &amp;= \frac{alphaMin \cdot d3 - alphaMax \cdot d2}{d3 - d2}"/></p>
</div><div class="math" id="equation-illinoisk4">
<p><span class="eqno">(21)<a class="headerlink" href="#equation-illinoisk4" title="Link to this equation">¶</a></span><img src="_images/math/bcbcc4a406bb181759111343bfeebdc481447c1a.png" alt="k4 &amp;= \frac{alphaMax - alphaMin}{d3 - d2}"/></p>
</div><p>Other parameters include da (the current average queueing delay), and
Ta (the average RTT, calculated as sumRtt / cntRtt in the implementation) and
Tmin (baseRtt in the implementation) which is the minimum RTT ever seen.
dm is the maximum (average) queueing delay, and Tmax (maxRtt in the
implementation) is the maximum RTT ever seen.</p>
<div class="math" id="equation-illinoisda">
<p><span class="eqno">(22)<a class="headerlink" href="#equation-illinoisda" title="Link to this equation">¶</a></span><img src="_images/math/aad2cfcefe704282e534e940f672723c3f2e56ac.png" alt="da &amp;= Ta - Tmin"/></p>
</div><div class="math" id="equation-illinoisdm">
<p><span class="eqno">(23)<a class="headerlink" href="#equation-illinoisdm" title="Link to this equation">¶</a></span><img src="_images/math/73ac4dd7e67448cc9688add2fc1dadfcdbc79e33.png" alt="dm &amp;= Tmax - Tmin"/></p>
</div><div class="math" id="equation-illinoisdi">
<p><span class="eqno">(24)<a class="headerlink" href="#equation-illinoisdi" title="Link to this equation">¶</a></span><img src="_images/math/a29fa246d3629a41507aea5e1e538db406a963bc.png" alt="d_i &amp;= eta_i \cdot dm"/></p>
</div><p>Illinois only executes its adaptation of alpha and beta when cwnd exceeds a threshold
called winThresh. Otherwise, it sets alpha and beta to the base values of 1 and 0.5,
respectively.</p>
<p>Following the implementation of Illinois in the Linux kernel, we use the following
default parameter settings:</p>
<ul class="simple">
<li><p>alphaMin = 0.3      (0.1 in the Illinois paper)</p></li>
<li><p>alphaMax = 10.0</p></li>
<li><p>betaMin = 0.125</p></li>
<li><p>betaMax = 0.5</p></li>
<li><p>winThresh = 15      (10 in the Illinois paper)</p></li>
<li><p>theta = 5</p></li>
<li><p>eta1 = 0.01</p></li>
<li><p>eta2 = 0.1</p></li>
<li><p>eta3 = 0.8</p></li>
</ul>
<p>More information: <a class="reference external" href="http://www.doi.org/10.1145/1190095.1190166">http://www.doi.org/10.1145/1190095.1190166</a></p>
</section>
<section id="h-tcp">
<h4><span class="section-number">16.5.2.4.13. </span>H-TCP<a class="headerlink" href="#h-tcp" title="Link to this heading">¶</a></h4>
<p>H-TCP has been designed for high BDP (Bandwidth-Delay Product) paths. It is
a dual mode protocol. In normal conditions, it works like traditional TCP
with the same rate of increment and decrement for the congestion window.
However, in high BDP networks, when it finds no congestion on the path
after <code class="docutils literal notranslate"><span class="pre">deltal</span></code> seconds, it increases the window size based on the alpha
function in the following:</p>
<div class="math" id="equation-htcpalpha">
<p><span class="eqno">(25)<a class="headerlink" href="#equation-htcpalpha" title="Link to this equation">¶</a></span><img src="_images/math/1ceda851ee1572f05925c3c5d43a3dd30edee4c3.png" alt="alpha(delta)=1+10(delta-deltal)+0.5(delta-deltal)^2"/></p>
</div><p>where <code class="docutils literal notranslate"><span class="pre">deltal</span></code> is a threshold in seconds for switching between the modes and
<code class="docutils literal notranslate"><span class="pre">delta</span></code> is the elapsed time from the last congestion. During congestion,
it reduces the window size by multiplying by beta function provided
in the reference paper. The calculated throughput between the last two
consecutive congestion events is considered for beta calculation.</p>
<p>The transport <code class="docutils literal notranslate"><span class="pre">TcpHtcp</span></code> can be selected in the program
<code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-variants-comparison.cc</span></code> to perform an experiment with H-TCP,
although it is useful to increase the bandwidth in this example (e.g.
to 20 Mb/s) to create a higher BDP link, such as</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">ns3</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="s">&quot;tcp-variants-comparison --transport_prot=TcpHtcp --bandwidth=20Mbps --duration=10&quot;</span>
</pre></div>
</div>
<p>More information (paper): <a class="reference external" href="http://www.hamilton.ie/net/htcp3.pdf">http://www.hamilton.ie/net/htcp3.pdf</a></p>
<p>More information (Internet Draft): <a class="reference external" href="https://tools.ietf.org/html/draft-leith-tcp-htcp-06">https://tools.ietf.org/html/draft-leith-tcp-htcp-06</a></p>
</section>
<section id="ledbat">
<h4><span class="section-number">16.5.2.4.14. </span>LEDBAT<a class="headerlink" href="#ledbat" title="Link to this heading">¶</a></h4>
<p>Low Extra Delay Background Transport (LEDBAT) is an experimental delay-based
congestion control algorithm that seeks to utilize the available bandwidth on
an end-to-end path while limiting the consequent increase in queueing delay
on that path. LEDBAT uses changes in one-way delay measurements to limit
congestion that the flow itself induces in the network.</p>
<p>As a first approximation, the LEDBAT sender operates as shown below:</p>
<p>On receipt of an ACK:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">currentdelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">acknowledgement</span><span class="p">.</span><span class="n">delay</span>
<span class="n">basedelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">basedelay</span><span class="p">,</span><span class="w"> </span><span class="n">currentdelay</span><span class="p">)</span>
<span class="n">queuingdelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentdelay</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">basedelay</span>
<span class="n">offtarget</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="n">TARGET</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">queuingdelay</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">TARGET</span>
<span class="n">cWnd</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">GAIN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offtarget</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bytesnewlyacked</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MSS</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cWnd</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TARGET</span></code> is the maximum queueing delay that LEDBAT itself may introduce in the
network, and <code class="docutils literal notranslate"><span class="pre">GAIN</span></code> determines the rate at which the cwnd responds to changes in
queueing delay; <code class="docutils literal notranslate"><span class="pre">offtarget</span></code> is a normalized value representing the difference between
the measured current queueing delay and the predetermined TARGET delay. offtarget can
be positive or negative; consequently, cwnd increases or decreases in proportion to
offtarget.</p>
<p>Following the recommendation of RFC 6817, the default values of the parameters are:</p>
<ul class="simple">
<li><p>TargetDelay = 100</p></li>
<li><p>baseHistoryLen = 10</p></li>
<li><p>noiseFilterLen = 4</p></li>
<li><p>Gain = 1</p></li>
</ul>
<p>To enable LEDBAT on all TCP sockets, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpLedbat</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>To enable LEDBAT on a chosen TCP socket, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpLedbat</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>The following unit tests have been written to validate the implementation of LEDBAT:</p>
<ul class="simple">
<li><p>LEDBAT should operate same as NewReno during slow start</p></li>
<li><p>LEDBAT should operate same as NewReno if timestamps are disabled</p></li>
<li><p>Test to validate cwnd increment in LEDBAT</p></li>
</ul>
<p>In comparison to RFC 6817, the scope and limitations of the current LEDBAT
implementation are:</p>
<ul class="simple">
<li><p>It assumes that the clocks on the sender side and receiver side are synchronised</p></li>
<li><p>In line with Linux implementation, the one-way delay is calculated at the sender side by using the timestamps option in TCP header</p></li>
<li><p>Only the MIN function is used for noise filtering</p></li>
</ul>
<p>More information about LEDBAT is available in RFC 6817: <a class="reference external" href="https://tools.ietf.org/html/rfc6817">https://tools.ietf.org/html/rfc6817</a></p>
</section>
<section id="tcp-lp">
<h4><span class="section-number">16.5.2.4.15. </span>TCP-LP<a class="headerlink" href="#tcp-lp" title="Link to this heading">¶</a></h4>
<p>TCP-Low Priority (TCP-LP) is a delay based congestion control protocol in which the low
priority data utilizes only the excess bandwidth available on an end-to-end path.
TCP-LP uses one way delay measurements as an indicator of congestion as it does
not influence cross-traffic in the reverse direction.</p>
<p>On receipt of an ACK:</p>
<div class="math">
<p><img src="_images/math/64405a2f4e1fc124d0b06e41d4c6660aee9d9953.png" alt="One way delay = Receiver timestamp - Receiver timestamp echo reply
Smoothed one way delay = 7/8 * Old Smoothed one way delay + 1/8 * one way delay
If smoothed one way delay &gt; owdMin + 15 * (owdMax - owdMin) / 100
  if LP_WITHIN_INF
    cwnd = 1
  else
    cwnd = cwnd / 2
  Inference timer is set"/></p>
</div><p>where owdMin and owdMax are the minimum and maximum one way delays experienced
throughout the connection, LP_WITHIN_INF indicates if TCP-LP is in inference
phase or not</p>
<p>More information (paper): <a class="reference external" href="http://cs.northwestern.edu/~akuzma/rice/doc/TCP-LP.pdf">http://cs.northwestern.edu/~akuzma/rice/doc/TCP-LP.pdf</a></p>
</section>
<section id="data-center-tcp-dctcp">
<h4><span class="section-number">16.5.2.4.16. </span>Data Center TCP (DCTCP)<a class="headerlink" href="#data-center-tcp-dctcp" title="Link to this heading">¶</a></h4>
<p>DCTCP, specified in RFC 8257 and implemented in Linux, is a TCP congestion
control algorithm for data center networks.  It leverages Explicit Congestion
Notification (ECN) to provide more fine-grained congestion
feedback to the end hosts, and is intended to work with routers that
implement a shallow congestion marking threshold (on the order of a
few milliseconds) to achieve high throughput and low latency in the
datacenter.  However, because DCTCP does not react in the same way to
notification of congestion experienced, there are coexistence (fairness)
issues between it and legacy TCP congestion controllers, which is why it
is recommended to only be used in controlled networking environments such
as within data centers.</p>
<p>DCTCP extends the Explicit Congestion Notification signal
to estimate the fraction of bytes that encounter congestion, rather than simply
detecting that the congestion has occurred. DCTCP then scales the congestion
window based on this estimate. This approach achieves high burst tolerance, low
latency, and high throughput with shallow-buffered switches.</p>
<ul class="simple">
<li><p><em>Receiver functionality:</em> If CE is observed in the IP header of an incoming
packet at the TCP receiver, the receiver sends congestion notification to
the sender by setting ECE in TCP header. This processing is different
from standard receiver ECN processing which sets and holds the ECE bit
for every ACK until it observes a CWR signal from the TCP sender.</p></li>
<li><p><em>Sender functionality:</em> The sender makes use of the modified receiver
ECE semantics to maintain an estimate of the fraction of packets marked
(<img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/>) by using the exponential weighted moving average (EWMA) as
shown below:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/8b5026eab360e4cdc72d8a71db4490c352d741df.png" alt="\alpha = (1 - g) * \alpha + g * F"/></p>
</div><p>In the above EWMA:</p>
<ul class="simple">
<li><p><em>g</em> is the estimation gain (between 0 and 1)</p></li>
<li><p><em>F</em> is the fraction of packets marked in current RTT.</p></li>
</ul>
<p>For send windows in which at least one ACK was received with ECE set,
the sender should respond by reducing the congestion
window as follows, once for every window of data:</p>
<div class="math">
<p><img src="_images/math/c07d5a2b0d23280b2dbf48992f7e476633398869.png" alt="cwnd = cwnd * (1 - \alpha / 2)"/></p>
</div><p>Following the recommendation of RFC 8257, the default values of the parameters are:</p>
<div class="math">
<p><img src="_images/math/00962736150bbfc10cf5f7127c273a83c252a671.png" alt="g = 0.0625 (i.e., 1/16)

initial alpha (\alpha) = 1"/></p>
</div><p>To enable DCTCP on all TCP sockets, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpDctcp</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>To enable DCTCP on a selected node, one can set the “SocketType” attribute
on the TcpL4Protocol object of that node to the TcpDctcp TypeId.</p>
<p>The ECN is enabled automatically when DCTCP is used, even if the user
has not explicitly enabled it.</p>
<p>DCTCP depends on a simple queue management algorithm in routers / switches to
mark packets. The current implementation of DCTCP in ns-3 can use RED with
a simple
configuration to achieve the behavior of desired queue management algorithm.</p>
<p>To configure RED router for DCTCP:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::UseEcn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::QW&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::MinTh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::MaxTh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
</pre></div>
</div>
<p>There is also the option, when running CoDel or FqCoDel, to enable ECN
on the queue and to set the “CeThreshold” value to a low value such as 1ms.
The following example uses CoDel:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::CoDelQueueDisc::UseEcn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::CoDelQueueDisc::CeThreshold&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">MilliSeconds</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
</pre></div>
</div>
<p>The following unit tests have been written to validate the implementation of DCTCP:</p>
<ul class="simple">
<li><p>ECT flags should be set for SYN, SYN+ACK, ACK and data packets for DCTCP traffic</p></li>
<li><p>ECT flags should not be set for SYN, SYN+ACK and pure ACK packets, but should be set on data packets for ECN enabled traditional TCP flows</p></li>
<li><p>ECE should be set only when CE flags are received at receiver and even if sender doesn’t send CWR, receiver should not send ECE if it doesn’t receive packets with CE flags</p></li>
</ul>
<p>An example program, <code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-validation.cc</span></code>, can be used to
experiment with DCTCP for long-running flows with different bottleneck
link bandwidth, base RTTs, and queuing disciplines.  A variant of this
program has also been run using the <em>ns-3</em> Direct Code Execution
environment using DCTCP from Linux kernel 4.4, and the results were
compared against <em>ns-3</em> results.</p>
<p>An example program based on an experimental topology found in the original
DCTCP SIGCOMM paper is provided in <code class="docutils literal notranslate"><span class="pre">examples/tcp/dctcp-example.cc</span></code>.
This example uses a simple topology consisting of forty DCTCP senders
and receivers and two ECN-enabled switches to examine throughput,
fairness, and queue delay properties of the network.</p>
<p>This implementation was tested extensively against a version of DCTCP in
the Linux kernel version 4.4 using the ns-3 direct code execution (DCE)
environment. Some differences were noted:</p>
<ul class="simple">
<li><p>Linux maintains its congestion window in segments and not bytes, and
the arithmetic is not floating point, so small differences in the
evolution of congestion window have been observed.</p></li>
<li><p>Linux uses pacing, where packets to be sent are paced out at regular
intervals. However, if at any instant the number of segments that can
be sent are less than two, Linux does not pace them and instead sends
them back-to-back. Currently, ns-3 paces out all packets eligible to
be sent in the same manner.</p></li>
</ul>
<p>More information about DCTCP is available in the RFC 8257:
<a class="reference external" href="https://tools.ietf.org/html/rfc8257">https://tools.ietf.org/html/rfc8257</a></p>
</section>
<section id="bbr">
<h4><span class="section-number">16.5.2.4.17. </span>BBR<a class="headerlink" href="#bbr" title="Link to this heading">¶</a></h4>
<p>BBR (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpBbr</span></code>) is a congestion control algorithm that
regulates the sending rate by deriving an estimate of the bottleneck’s
available bandwidth and RTT of the path. It seeks to operate at an optimal
point where sender experiences maximum delivery rate with minimum RTT. It
creates a network model comprising maximum delivery rate with minimum RTT
observed so far, and then estimates BDP (maximum bandwidth * minimum RTT)
to control the maximum amount of inflight data. BBR controls congestion by
limiting the rate at which packets are sent. It caps the cwnd to one BDP
and paces out packets at a rate which is adjusted based on the latest estimate
of delivery rate. BBR algorithm is agnostic to packet losses and ECN marks.</p>
<p>pacing_gain controls the rate of sending data and cwnd_gain controls the amount
of data to send.</p>
<p>The following is a high level overview of BBR congestion control algorithm:</p>
<p>On receiving an ACK:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">rtt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">packet</span><span class="p">.</span><span class="n">sent_time</span>
<span class="n">update_minimum_rtt</span><span class="p">(</span><span class="n">rtt</span><span class="p">)</span>
<span class="n">delivery_rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_delivery_rate</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="n">update_maximum_bandwidth</span><span class="p">(</span><span class="n">delivery_rate</span><span class="p">)</span>
</pre></div>
</div>
<p>After transmitting a data packet:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">bdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_bandwidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">min_rtt</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cwnd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bdp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inflight</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nextSendTime</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">transmit</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="w">    </span><span class="n">nextSendTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">packet</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="p">(</span><span class="n">pacing_gain</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">max_bandwidth</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="k">return</span>
<span class="n">Schedule</span><span class="p">(</span><span class="n">nextSendTime</span><span class="p">,</span><span class="w"> </span><span class="n">Send</span><span class="p">)</span>
</pre></div>
</div>
<p>To enable BBR on all TCP sockets, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpBbr</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>To enable BBR on a chosen TCP socket, the following configuration can be used
(note that an appropriate Node ID must be used instead of 1):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpBbr</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>The ns-3 implementation of BBR is based on its Linux implementation. Linux 5.4
kernel implementation has been used to validate the behavior of ns-3
implementation of BBR (See below section on Validation).</p>
<p>In addition, the following unit tests have been written to validate the
implementation of BBR in ns-3:</p>
<ul class="simple">
<li><p>BBR should enable (if not already done) TCP pacing feature.</p></li>
<li><p>Test to validate the values of pacing_gain and cwnd_gain in different phases
of BBR.</p></li>
</ul>
<p>An example program, examples/tcp/tcp-bbr-example.cc, is provided to experiment
with BBR for one long running flow. This example uses a simple topology
consisting of one sender, one receiver and two routers to examine congestion
window, throughput and queue control. A program similar to this has been run
using the Network Stack Tester (NeST) using BBR from Linux kernel 5.4, and the
results were compared against ns-3 results.</p>
<p>More information about BBR is available in the following Internet Draft:
<a class="reference external" href="https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00">https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00</a></p>
<p>More information about Delivery Rate Estimation is in the following draft:
<a class="reference external" href="https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00">https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00</a></p>
<p>For an academic peer-reviewed paper on the BBR implementation in ns-3,
please refer to:</p>
<ul class="simple">
<li><p>Vivek Jain, Viyom Mittal and Mohit P. Tahiliani. “Design and Implementation of TCP BBR in ns-3.” In Proceedings of the 10th Workshop on ns-3, pp. 16-22. 2018. (<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3199902.3199911">https://dl.acm.org/doi/abs/10.1145/3199902.3199911</a>)</p></li>
</ul>
</section>
</section>
<section id="support-for-explicit-congestion-notification-ecn">
<h3><span class="section-number">16.5.2.5. </span>Support for Explicit Congestion Notification (ECN)<a class="headerlink" href="#support-for-explicit-congestion-notification-ecn" title="Link to this heading">¶</a></h3>
<p>ECN provides end-to-end notification of network congestion without dropping
packets. It uses two bits in the IP header: ECN Capable Transport (ECT bit)
and Congestion Experienced (CE bit), and two bits in the TCP header: Congestion
Window Reduced (CWR) and ECN Echo (ECE).</p>
<p>More information is available in RFC 3168: <a class="reference external" href="https://tools.ietf.org/html/rfc3168">https://tools.ietf.org/html/rfc3168</a></p>
<p>The following ECN states are declared in <code class="docutils literal notranslate"><span class="pre">src/internet/model/tcp-socket-state.h</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ECN_DISABLED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">//!&lt; ECN disabled traffic</span>
<span class="w">    </span><span class="n">ECN_IDLE</span><span class="p">,</span><span class="w">         </span><span class="c1">//!&lt; ECN is enabled but currently there is no action pertaining to ECE or CWR to be taken</span>
<span class="w">    </span><span class="n">ECN_CE_RCVD</span><span class="p">,</span><span class="w">      </span><span class="c1">//!&lt; Last packet received had CE bit set in IP header</span>
<span class="w">    </span><span class="n">ECN_SENDING_ECE</span><span class="p">,</span><span class="w">  </span><span class="c1">//!&lt; Receiver sends an ACK with ECE bit set in TCP header</span>
<span class="w">    </span><span class="n">ECN_ECE_RCVD</span><span class="p">,</span><span class="w">     </span><span class="c1">//!&lt; Last ACK received had ECE bit set in TCP header</span>
<span class="w">    </span><span class="n">ECN_CWR_SENT</span><span class="w">      </span><span class="c1">//!&lt; Sender has reduced the congestion window, and sent a packet with CWR bit set in TCP header. This is used for tracing.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">EcnStates_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Current implementation of ECN is based on RFC 3168 and is referred as Classic ECN.</p>
<p>The following enum represents the mode of ECN:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ClassicEcn</span><span class="p">,</span><span class="w">  </span><span class="c1">//!&lt; ECN functionality as described in RFC 3168.</span>
<span class="w">    </span><span class="n">DctcpEcn</span><span class="p">,</span><span class="w">    </span><span class="c1">//!&lt; ECN functionality as described in RFC 8257. Note: this mode is specific to DCTCP.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">EcnMode_t</span><span class="p">;</span>
</pre></div>
</div>
<p>The following are some important ECN parameters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ECN parameters</span>
<span class="n">EcnMode_t</span><span class="w">              </span><span class="n">m_ecnMode</span><span class="w"> </span><span class="p">{</span><span class="n">ClassicEcn</span><span class="p">};</span><span class="w"> </span><span class="c1">//!&lt; ECN mode</span>
<span class="n">UseEcn_t</span><span class="w">               </span><span class="n">m_useEcn</span><span class="w"> </span><span class="p">{</span><span class="n">Off</span><span class="p">};</span><span class="w">         </span><span class="c1">//!&lt; Socket ECN capability</span>
</pre></div>
</div>
<section id="enabling-ecn">
<h4><span class="section-number">16.5.2.5.1. </span>Enabling ECN<a class="headerlink" href="#enabling-ecn" title="Link to this heading">¶</a></h4>
<p>By default, support for ECN is disabled in TCP sockets. To enable, change
the value of the attribute <code class="docutils literal notranslate"><span class="pre">ns3::TcpSocketBase::UseEcn</span></code> to <code class="docutils literal notranslate"><span class="pre">On</span></code>.
Following are supported values for the same, this functionality is aligned with
Linux: <a class="reference external" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt</a></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">Off</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="c1">//!&lt; Disable</span>
<span class="w">    </span><span class="n">On</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="c1">//!&lt; Enable</span>
<span class="w">    </span><span class="n">AcceptOnly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="c1">//!&lt; Enable only when the peer endpoint is ECN capable</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="p">;</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketBase::UseEcn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;On&quot;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="ecn-negotiation">
<h4><span class="section-number">16.5.2.5.2. </span>ECN negotiation<a class="headerlink" href="#ecn-negotiation" title="Link to this heading">¶</a></h4>
<p>ECN capability is negotiated during the three-way TCP handshake:</p>
<ol class="arabic simple">
<li><p>Sender sends SYN + CWR + ECE</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_useEcn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="o">::</span><span class="n">On</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_DISABLED</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Receiver sends SYN + ACK + ECE</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_useEcn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="o">::</span><span class="n">Off</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">tcpHeader</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ACK</span><span class="w"> </span><span class="o">|</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_IDLE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ACK</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_DISABLED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Sender sends ACK</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_useEcn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="o">::</span><span class="n">Off</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">tcpHeader</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_IDLE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_DISABLED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Once the ECN-negotiation is successful, the sender sends data packets with ECT
bits set in the IP header.</p>
<p>Note: As mentioned in <a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.1">Section 6.1.1 of RFC 3168</a>, ECT bits should not be set
during ECN negotiation. The ECN negotiation implemented in <em>ns-3</em> follows
this guideline.</p>
</section>
<section id="ecn-state-transitions">
<h4><span class="section-number">16.5.2.5.3. </span>ECN State Transitions<a class="headerlink" href="#ecn-state-transitions" title="Link to this heading">¶</a></h4>
<ol class="arabic simple">
<li><p>Initially both sender and receiver have their m_ecnState set as ECN_DISABLED</p></li>
<li><p>Once the ECN negotiation is successful, their states are set to ECN_IDLE</p></li>
<li><p>The receiver’s state changes to ECN_CE_RCVD when it receives a packet with
CE bit set. The state then moves to ECN_SENDING_ECE when the receiver sends
an ACK with ECE set. This state is retained until a CWR is received
, following which, the state changes to ECN_IDLE.</p></li>
<li><p>When the sender receives an ACK with ECE bit set from receiver, its state
is set as ECN_ECE_RCVD</p></li>
<li><p>The sender’s state changes to ECN_CWR_SENT when it sends a packet with
CWR bit set. It remains in this state until an ACK with valid ECE is received
(i.e., ECE is received for a packet that belongs to a new window),
following which, its state changes to ECN_ECE_RCVD.</p></li>
</ol>
</section>
<section id="rfc-3168-compliance">
<h4><span class="section-number">16.5.2.5.4. </span>RFC 3168 compliance<a class="headerlink" href="#rfc-3168-compliance" title="Link to this heading">¶</a></h4>
<p>Based on the suggestions provided in RFC 3168, the following behavior has
been implemented:</p>
<ol class="arabic simple">
<li><p>Pure ACK packets should not have the ECT bit set (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.4">Section 6.1.4</a>).</p></li>
<li><p>In the current implementation, the sender only sends ECT(0) in the IP header.</p></li>
<li><p>The sender should should reduce the congestion window only once in each
window (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.2">Section 6.1.2</a>).</p></li>
<li><p>The receiver should ignore the CE bits set in a packet arriving out of
window (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.5">Section 6.1.5</a>).</p></li>
<li><p>The sender should ignore the ECE bits set in the packet arriving out of
window (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.2">Section 6.1.2</a>).</p></li>
</ol>
</section>
<section id="open-issues">
<h4><span class="section-number">16.5.2.5.5. </span>Open issues<a class="headerlink" href="#open-issues" title="Link to this heading">¶</a></h4>
<p>The following issues are yet to be addressed:</p>
<ol class="arabic simple">
<li><p>Retransmitted packets should not have the CWR bit set (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.5">Section 6.1.5</a>).</p></li>
<li><p>Despite the congestion window size being 1 MSS, the sender should reduce its
congestion window by half when it receives a packet with the ECE bit set. The
sender must reset the retransmit timer on receiving the ECN-Echo packet when
the congestion window is one. The sending TCP will then be able to send a
new packet only when the retransmit timer expires (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.2">Section 6.1.2</a>).</p></li>
<li><p>Support for separately handling the enabling of ECN on the incoming and
outgoing TCP sessions (e.g. a TCP may perform ECN echoing but not set the
ECT codepoints on its outbound data segments).</p></li>
</ol>
</section>
</section>
<section id="support-for-dynamic-pacing">
<h3><span class="section-number">16.5.2.6. </span>Support for Dynamic Pacing<a class="headerlink" href="#support-for-dynamic-pacing" title="Link to this heading">¶</a></h3>
<p>TCP pacing refers to the sender-side practice of scheduling the transmission
of a burst of eligible TCP segments across a time interval such as
a TCP RTT, to avoid or reduce bursts.  Historically,
TCP used the natural ACK clocking mechanism to pace segments, but some
network paths introduce aggregation (bursts of ACKs arriving) or ACK
thinning, either of which disrupts ACK clocking.
Some latency-sensitive congestion controls under development (Prague, BBR)
require pacing to operate effectively.</p>
<p>Until recently, the state of the art in Linux was to support pacing in one
of two ways:</p>
<ol class="arabic simple">
<li><p>fq/pacing with sch_fq</p></li>
<li><p>TCP internal pacing</p></li>
</ol>
<p>The presentation by Dumazet and Cheng at IETF 88 summarizes:
<a class="reference external" href="https://www.ietf.org/proceedings/88/slides/slides-88-tcpm-9.pdf">https://www.ietf.org/proceedings/88/slides/slides-88-tcpm-9.pdf</a></p>
<p>The first option was most often used when offloading (TSO) was enabled and
when the sch_fq scheduler was used at the traffic control (qdisc) sublayer.  In
this case, TCP was responsible for setting the socket pacing rate, but
the qdisc sublayer would enforce it.  When TSO was enabled, the kernel
would break a large burst into smaller chunks, with dynamic sizing based
on the pacing rate, and hand off the segments to the fq qdisc for
pacing.</p>
<p>The second option was used if sch_fq was not enabled; TCP would be
responsible for internally pacing.</p>
<p>In 2018, Linux switched to an Early Departure Model (EDM): <a class="reference external" href="https://lwn.net/Articles/766564/">https://lwn.net/Articles/766564/</a>.</p>
<p>TCP pacing in Linux was added in kernel 3.12, and authors chose to allow
a pacing rate of 200% against the current rate, to allow probing for
optimal throughput even during slow start phase.  Some refinements were
added in <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=43e122b014c9">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=43e122b014c9</a>,
in which Google reported that it was better to apply
a different ratio (120%) in Congestion Avoidance phase.  Furthermore,
authors found that after cwnd reduction, it was helpful to become more
conservative and switch to the conservative ratio (120%) as soon as
cwnd &gt;= ssthresh/2, as the initial ramp up (when ssthresh is infinite) still
allows doubling cwnd every other RTT.  Linux also does not pace the initial
window (IW), typically 10 segments in practice.</p>
<p>Linux has also been observed to not pace if the number of eligible segments
to be sent is exactly two; they will be sent back to back.  If three or
more, the first two are sent immediately, and additional segments are paced
at the current pacing rate.</p>
<p>In ns-3, the model is as follows.  There is no TSO/sch_fq model; only
internal pacing according to current Linux policy.</p>
<p>Pacing may be enabled for any TCP congestion control, and a maximum
pacing rate can be set.  Furthermore, dynamic pacing is enabled for
all TCP variants, according to the following guidelines.</p>
<ul class="simple">
<li><p>Pacing of the initial window (IW) is not done by default but can be
separately enabled.</p></li>
<li><p>Pacing of the initial slow start, after IW, is done according to the
pacing rate of 200% of the current rate, to allow for window growth
This pacing rate can be configured to a different value than 200%.</p></li>
<li><p>Pacing of congestion avoidance phase is done at a pacing rate of 120% of
current rate.  This can be configured to a different value than 120%.</p></li>
<li><p>Pacing of subsequent slow start is done according to the following
heuristic.  If cwnd &lt; ssthresh/2, such as after a timeout or idle period,
pace at the slow start rate (200%).  Otherwise, pace at the congestion
avoidance rate.</p></li>
</ul>
<p>Dynamic pacing is demonstrated by the example program <code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-pacing.cc</span></code>.</p>
</section>
<section id="validation">
<h3><span class="section-number">16.5.2.7. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The following tests are found in the <code class="docutils literal notranslate"><span class="pre">src/internet/test</span></code> directory. In
general, TCP tests inherit from a class called <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpGeneralTest</span></code>,
which provides common operations to set up test scenarios involving TCP
objects. For more information on how to write new tests, see the
section below on <a class="reference internal" href="#writing-tcp-tests"><span class="std std-ref">Writing TCP tests</span></a>.</p>
<ul class="simple">
<li><p><strong>tcp:</strong> Basic transmission of string of data from client to server</p></li>
<li><p><strong>tcp-bytes-in-flight-test:</strong> TCP correctly estimates bytes in flight under loss conditions</p></li>
<li><p><strong>tcp-cong-avoid-test:</strong> TCP congestion avoidance for different packet sizes</p></li>
<li><p><strong>tcp-datasentcb:</strong> Check TCP’s ‘data sent’ callback</p></li>
<li><p><strong>tcp-endpoint-bug2211-test:</strong> A test for an issue that was causing stack overflow</p></li>
<li><p><strong>tcp-fast-retr-test:</strong> Fast Retransmit testing</p></li>
<li><p><strong>tcp-header:</strong> Unit tests on the TCP header</p></li>
<li><p><strong>tcp-highspeed-test:</strong> Unit tests on the HighSpeed congestion control</p></li>
<li><p><strong>tcp-htcp-test:</strong> Unit tests on the H-TCP congestion control</p></li>
<li><p><strong>tcp-hybla-test:</strong> Unit tests on the Hybla congestion control</p></li>
<li><p><strong>tcp-vegas-test:</strong> Unit tests on the Vegas congestion control</p></li>
<li><p><strong>tcp-veno-test:</strong> Unit tests on the Veno congestion control</p></li>
<li><p><strong>tcp-scalable-test:</strong> Unit tests on the Scalable congestion control</p></li>
<li><p><strong>tcp-bic-test:</strong> Unit tests on the BIC congestion control</p></li>
<li><p><strong>tcp-yeah-test:</strong> Unit tests on the YeAH congestion control</p></li>
<li><p><strong>tcp-illinois-test:</strong> Unit tests on the Illinois congestion control</p></li>
<li><p><strong>tcp-ledbat-test:</strong> Unit tests on the LEDBAT congestion control</p></li>
<li><p><strong>tcp-lp-test:</strong> Unit tests on the TCP-LP congestion control</p></li>
<li><p><strong>tcp-dctcp-test:</strong> Unit tests on the DCTCP congestion control</p></li>
<li><p><strong>tcp-bbr-test:</strong> Unit tests on the BBR congestion control</p></li>
<li><p><strong>tcp-option:</strong> Unit tests on TCP options</p></li>
<li><p><strong>tcp-pkts-acked-test:</strong> Unit test the number of time that PktsAcked is called</p></li>
<li><p><strong>tcp-rto-test:</strong> Unit test behavior after a RTO occurs</p></li>
<li><p><strong>tcp-rtt-estimation-test:</strong> Check RTT calculations, including retransmission cases</p></li>
<li><p><strong>tcp-slow-start-test:</strong> Check behavior of slow start</p></li>
<li><p><strong>tcp-timestamp:</strong> Unit test on the timestamp option</p></li>
<li><p><strong>tcp-wscaling:</strong> Unit test on the window scaling option</p></li>
<li><p><strong>tcp-zero-window-test:</strong> Unit test persist behavior for zero window conditions</p></li>
<li><p><strong>tcp-close-test:</strong> Unit test on the socket closing: both receiver and sender have to close their socket when all bytes are transferred</p></li>
<li><p><strong>tcp-ecn-test:</strong> Unit tests on Explicit Congestion Notification</p></li>
<li><p><strong>tcp-pacing-test:</strong> Unit tests on dynamic TCP pacing rate</p></li>
</ul>
<p>Several tests have dependencies outside of the <code class="docutils literal notranslate"><span class="pre">internet</span></code> module, so they
are located in a system test directory called <code class="docutils literal notranslate"><span class="pre">src/test/ns3tcp</span></code>.</p>
<ul class="simple">
<li><p><strong>ns3-tcp-loss:</strong> Check behavior of ns-3 TCP upon packet losses</p></li>
<li><p><strong>ns3-tcp-no-delay:</strong> Check that ns-3 TCP Nagle’s algorithm works correctly and that it can be disabled</p></li>
<li><p><strong>ns3-tcp-socket:</strong> Check that ns-3 TCP successfully transfers an application data write of various sizes</p></li>
<li><p><strong>ns3-tcp-state:</strong> Check the operation of the TCP state machine for several cases</p></li>
</ul>
<p>Several TCP validation test results can also be found in the
<a class="reference external" href="http://www.nsnam.org/wiki/New_TCP_Socket_Architecture">wiki page</a>
describing this implementation.</p>
<p>The ns-3 implementation of TCP Linux Reno was validated against the NewReno
implementation of Linux kernel 4.4.0 using ns-3 Direct Code Execution (DCE).
DCE is a framework which allows the users to run kernel space protocol inside
ns-3 without changing the source code.</p>
<p>In this validation, cwnd traces of DCE Linux <code class="docutils literal notranslate"><span class="pre">reno</span></code> were compared to those of
ns-3 Linux Reno and NewReno for a delayed acknowledgement configuration of 1
segment (in the ns-3 implementation; Linux does not allow direct configuration
of this setting). It can be observed that cwnd traces for ns-3 Linux Reno are
closely overlapping with DCE <code class="docutils literal notranslate"><span class="pre">reno</span></code>, while
for ns-3 NewReno there was deviation in the congestion avoidance phase.</p>
<figure class="align-center" id="id9">
<span id="fig-dce-linux-reno-vs-ns3-linux-reno"></span><a class="reference internal image-reference" href="_images/dce-linux-reno-vs-ns3-linux-reno.png"><img alt="_images/dce-linux-reno-vs-ns3-linux-reno.png" src="_images/dce-linux-reno-vs-ns3-linux-reno.png" style="width: 560.0px; height: 420.0px;" /></a>
<figcaption>
<p><span class="caption-text">DCE Linux Reno vs. ns-3 Linux Reno</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id10">
<span id="fig-dce-linux-reno-vs-ns3-new-reno"></span><a class="reference internal image-reference" href="_images/dce-linux-reno-vs-ns3-new-reno.png"><img alt="_images/dce-linux-reno-vs-ns3-new-reno.png" src="_images/dce-linux-reno-vs-ns3-new-reno.png" style="width: 560.0px; height: 420.0px;" /></a>
<figcaption>
<p><span class="caption-text">DCE Linux Reno vs. ns-3 NewReno</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The difference in the cwnd in the early stage of this flow is because of the
way cwnd is plotted.  As ns-3 provides a trace source for cwnd, an ns-3 Linux
Reno cwnd simple is obtained every time the cwnd value changes, whereas for
DCE Linux Reno, the kernel does not have a corresponding trace source.
Instead, we use the “ss” command of the Linux kernel to obtain
cwnd values. The “ss” samples cwnd at an interval of 0.5 seconds.</p>
<p>Figure <a class="reference internal" href="#fig-dctcp-10ms-50mbps-tcp-throughput"><span class="std std-ref">DCTCP throughput for 10ms/50Mbps bottleneck, 1ms CE threshold</span></a> shows a long-running
file transfer using DCTCP over a 50 Mbps bottleneck (running CoDel queue
disc with a 1ms CE threshold setting) with a 10 ms base RTT.  The figure
shows that DCTCP reaches link capacity very quickly and stays there for
the duration with minimal change in throughput.  In contrast, Figure
<a class="reference internal" href="#fig-dctcp-80ms-50mbps-tcp-throughput"><span class="std std-ref">DCTCP throughput for 80ms/50Mbps bottleneck, 1ms CE threshold</span></a> plots the throughput for
the same configuration except with an 80 ms base RTT.  In this case,
the DCTCP exits slow start early and takes a long time to build the
flow throughput to the bottleneck link capacity.  DCTCP is not intended
to be used at such a large base RTT, but this figure highlights the
sensitivity to RTT (and can be reproduced using the Linux implementation).</p>
<figure class="align-center" id="id11">
<span id="fig-dctcp-10ms-50mbps-tcp-throughput"></span><a class="reference internal image-reference" href="_images/dctcp-10ms-50mbps-tcp-throughput.png"><img alt="_images/dctcp-10ms-50mbps-tcp-throughput.png" src="_images/dctcp-10ms-50mbps-tcp-throughput.png" style="width: 460.8px; height: 345.6px;" /></a>
<figcaption>
<p><span class="caption-text">DCTCP throughput for 10ms/50Mbps bottleneck, 1ms CE threshold</span><a class="headerlink" href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id12">
<span id="fig-dctcp-80ms-50mbps-tcp-throughput"></span><a class="reference internal image-reference" href="_images/dctcp-80ms-50mbps-tcp-throughput.png"><img alt="_images/dctcp-80ms-50mbps-tcp-throughput.png" src="_images/dctcp-80ms-50mbps-tcp-throughput.png" style="width: 460.8px; height: 345.6px;" /></a>
<figcaption>
<p><span class="caption-text">DCTCP throughput for 80ms/50Mbps bottleneck, 1ms CE threshold</span><a class="headerlink" href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Similar to DCTCP, TCP CUBIC has been tested against the Linux kernel version
4.4 implementation.  Figure <a class="reference internal" href="#fig-cubic-50ms-50mbps-tcp-cwnd-no-ecn"><span class="std std-ref">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, no ECN</span></a>
compares the congestion window evolution between ns-3 and Linux for a single
flow operating over a 50 Mbps link with 50 ms base RTT and the CoDel AQM.
Some differences can be observed between the peak of slow start window
growth (ns-3 exits slow start earlier due to its HyStart implementation),
and the window growth is a bit out-of-sync (likely due to different
implementations of the algorithm), but the cubic concave/convex window
pattern, and the signs of TCP CUBIC fast convergence algorithm
(alternating patterns of cubic and concave window growth) can be observed.
The <em>ns-3</em> congestion window is maintained in bytes (unlike Linux which uses
segments) but has been normalized to segments for these plots.
Figure <a class="reference internal" href="#fig-cubic-50ms-50mbps-tcp-cwnd-ecn"><span class="std std-ref">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, with ECN</span></a> displays the outcome of
a similar scenario but with ECN enabled throughout.</p>
<figure class="align-center" id="id13">
<span id="fig-cubic-50ms-50mbps-tcp-cwnd-no-ecn"></span><a class="reference internal image-reference" href="_images/cubic-50ms-50mbps-tcp-cwnd-no-ecn.png"><img alt="_images/cubic-50ms-50mbps-tcp-cwnd-no-ecn.png" src="_images/cubic-50ms-50mbps-tcp-cwnd-no-ecn.png" style="width: 368.8px; height: 276.8px;" /></a>
<figcaption>
<p><span class="caption-text">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, no ECN</span><a class="headerlink" href="#id13" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id14">
<span id="fig-cubic-50ms-50mbps-tcp-cwnd-ecn"></span><a class="reference internal image-reference" href="_images/cubic-50ms-50mbps-tcp-cwnd-ecn.png"><img alt="_images/cubic-50ms-50mbps-tcp-cwnd-ecn.png" src="_images/cubic-50ms-50mbps-tcp-cwnd-ecn.png" style="width: 368.8px; height: 276.8px;" /></a>
<figcaption>
<p><span class="caption-text">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, with ECN</span><a class="headerlink" href="#id14" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>TCP ECN operation is tested in the ARED and RED tests that are documented in the traffic-control
module documentation.</p>
<p>Like DCTCP and TCP CUBIC, the ns-3 implementation of TCP BBR was validated
against the BBR implementation of Linux kernel 5.4 using Network Stack Tester
(NeST). NeST is a python package which allows the users to emulate kernel space
protocols using Linux network namespaces. Figure <a class="reference internal" href="#fig-ns3-bbr-vs-linux-bbr"><span class="std std-ref">Congestion window evolution: ns-3 BBR vs. Linux BBR (using NeST)</span></a>
compares the congestion window evolution between ns-3 and Linux for a single
flow operating over a 10 Mbps link with 10 ms base RTT and FIFO queue
discipline.</p>
<figure class="align-center" id="id15">
<span id="fig-ns3-bbr-vs-linux-bbr"></span><a class="reference internal image-reference" href="_images/ns3-bbr-vs-linux-bbr.png"><img alt="_images/ns3-bbr-vs-linux-bbr.png" src="_images/ns3-bbr-vs-linux-bbr.png" style="width: 512.0px; height: 384.0px;" /></a>
<figcaption>
<p><span class="caption-text">Congestion window evolution: ns-3 BBR vs. Linux BBR (using NeST)</span><a class="headerlink" href="#id15" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>It can be observed that the congestion window traces for ns-3 BBR closely
overlap with Linux BBR. The periodic drops in congestion window every 10
seconds depict the PROBE_RTT phase of the BBR algorithm. In this phase, BBR
algorithm keeps the congestion window fixed to 4 segments.</p>
<p>The example program, examples/tcp-bbr-example.cc has been used to obtain the
congestion window curve shown in Figure <a class="reference internal" href="#fig-ns3-bbr-vs-linux-bbr"><span class="std std-ref">Congestion window evolution: ns-3 BBR vs. Linux BBR (using NeST)</span></a>. The
detailed instructions to reproduce ns-3 plot and NeST plot can be found at:
<a class="reference external" href="https://github.com/mohittahiliani/BBR-Validation">https://github.com/mohittahiliani/BBR-Validation</a></p>
</section>
<section id="writing-a-new-congestion-control-algorithm">
<h3><span class="section-number">16.5.2.8. </span>Writing a new congestion control algorithm<a class="headerlink" href="#writing-a-new-congestion-control-algorithm" title="Link to this heading">¶</a></h3>
<p>Writing (or porting) a congestion control algorithms from scratch (or from
other systems) is a process completely separated from the internals of
TcpSocketBase.</p>
<p>All operations that are delegated to a congestion control are contained in
the class TcpCongestionOps. It mimics the structure tcp_congestion_ops of
Linux, and the following operations are defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">GetName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">GetSsThresh</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">IncreaseWindow</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">segmentsAcked</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">PktsAcked</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">segmentsAcked</span><span class="p">,</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rtt</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpCongestionOps</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Fork</span><span class="p">();</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">CwndEvent</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">::</span><span class="n">TcpCaEvent_t</span><span class="w"> </span><span class="n">event</span><span class="p">);</span>
</pre></div>
</div>
<p>The most interesting methods to write are GetSsThresh and IncreaseWindow.
The latter is called when TcpSocketBase decides that it is time to increase
the congestion window. Much information is available in the Transmission
Control Block, and the method should increase cWnd and/or ssThresh based
on the number of segments acked.</p>
<p>GetSsThresh is called whenever the socket needs an updated value of the
slow start threshold. This happens after a loss; congestion control algorithms
are then asked to lower such value, and to return it.</p>
<p>PktsAcked is used in case the algorithm needs timing information (such as
RTT), and it is called each time an ACK is received.</p>
<p>CwndEvent is used in case the algorithm needs the state of socket during different
congestion window event.</p>
</section>
<section id="tcp-sack-and-non-sack">
<h3><span class="section-number">16.5.2.9. </span>TCP SACK and non-SACK<a class="headerlink" href="#tcp-sack-and-non-sack" title="Link to this heading">¶</a></h3>
<p>To avoid code duplication and the effort of maintaining two different versions
of the TCP core, namely RFC 6675 (TCP-SACK) and RFC 5681 (TCP congestion control),
we have merged RFC 6675 in the current code base. If the receiver supports the
option, the sender bases its retransmissions over the received SACK information.
However, in the absence of that option, the best it can do is to follow the RFC
5681 specification (on Fast Retransmit/Recovery) and employing NewReno
modifications in case of partial ACKs.</p>
<p>A similar concept is used in Linux with the function tcp_add_reno_sack.
Our implementation resides in the TcpTxBuffer class that implements a scoreboard
through two different lists of segments. TcpSocketBase actively uses the API
provided by TcpTxBuffer to query the scoreboard; please refer to the Doxygen
documentation (and to in-code comments) if you want to learn more about this
implementation.</p>
<p>For an academic peer-reviewed paper on the SACK implementation in ns-3,
please refer to <a class="reference external" href="https://dl.acm.org/citation.cfm?id=3067666">https://dl.acm.org/citation.cfm?id=3067666</a>.</p>
</section>
<section id="loss-recovery-algorithms">
<h3><span class="section-number">16.5.2.10. </span>Loss Recovery Algorithms<a class="headerlink" href="#loss-recovery-algorithms" title="Link to this heading">¶</a></h3>
<p>The following loss recovery algorithms are supported in ns-3 TCP.  The current
default (as of ns-3.32 release) is Proportional Rate Reduction (PRR), while
the default for ns-3.31 and earlier was Classic Recovery.</p>
<section id="classic-recovery">
<h4><span class="section-number">16.5.2.10.1. </span>Classic Recovery<a class="headerlink" href="#classic-recovery" title="Link to this heading">¶</a></h4>
<p>Classic Recovery refers to the combination of NewReno algorithm described in
RFC 6582 along with SACK based loss recovery algorithm mentioned in RFC 6675.
SACK based loss recovery is used when sender and receiver support SACK options.
In the case when SACK options are disabled, the NewReno modification handles
the recovery.</p>
<p>At the start of recovery phase the congestion window is reduced diffently for
NewReno and SACK based recovery. For NewReno the reduction is done as given below:</p>
<div class="math">
<p><img src="_images/math/373e3e96ffe78616f0be7b8f850cb0aab389a575.png" alt="cWnd = ssThresh"/></p>
</div><p>For SACK based recovery, this is done as follows:</p>
<div class="math">
<p><img src="_images/math/b03b1d0d3702d0b132fc8c5069257ee011cf3a76.png" alt="cWnd = ssThresh + (dupAckCount * segmentSize)"/></p>
</div><p>While in the recovery phase, the congestion window is inflated by segmentSize
on arrival of every ACK when NewReno is used. The congestion window is kept
same when SACK based loss recovery is used.</p>
</section>
<section id="proportional-rate-reduction">
<h4><span class="section-number">16.5.2.10.2. </span>Proportional Rate Reduction<a class="headerlink" href="#proportional-rate-reduction" title="Link to this heading">¶</a></h4>
<p>Proportional Rate Reduction (PRR) is a loss recovery algorithm described in
RFC 6937 and currently used in Linux. The design of PRR helps in avoiding
excess window adjustments and aims to keep the congestion window as close as
possible to ssThresh.</p>
<p>PRR updates the congestion window by comparing the values of bytesInFlight and
ssThresh. If the value of bytesInFlight is greater than ssThresh, congestion window
is updated as shown below:</p>
<div class="math">
<p><img src="_images/math/24b0a7d5c50f3b631649b066bb146be623028e07.png" alt="sndcnt = CEIL(prrDelivered * ssThresh / RecoverFS) - prrOut"/></p>
</div><div class="math">
<p><img src="_images/math/6dc20e3e199e3bd8ad3079d594497d37c9438a2f.png" alt="cWnd = pipe + sndcnt"/></p>
</div><p>where <code class="docutils literal notranslate"><span class="pre">RecoverFS</span></code> is the value of bytesInFlight at the start of recovery phase,
<code class="docutils literal notranslate"><span class="pre">prrDelivered</span></code> is the total bytes delivered during recovery phase,
<code class="docutils literal notranslate"><span class="pre">prrOut</span></code> is the total bytes sent during recovery phase and
<code class="docutils literal notranslate"><span class="pre">sndcnt</span></code> represents the number of bytes to be sent in response to each ACK.</p>
<p>Otherwise, the congestion window is updated by either using Conservative Reduction
Bound (CRB) or Slow Start Reduction Bound (SSRB) with SSRB being the default
Reduction Bound. Each Reduction Bound calculates a maximum data sending limit.
For CRB, the limit is calculated as shown below:</p>
<div class="math">
<p><img src="_images/math/94f0ecd5a3d49bd6ac2705c7a43cbbb89f8f4a8e.png" alt="limit = prrDelivered - prr out"/></p>
</div><p>For SSRB, it is calculated as:</p>
<div class="math">
<p><img src="_images/math/0239723cb98b74a08a1f279edf6d074749e623a3.png" alt="limit = MAX(prrDelivered - prrOut, DeliveredData) + MSS"/></p>
</div><p>where <code class="docutils literal notranslate"><span class="pre">DeliveredData</span></code> represents the total number of bytes delivered to the
receiver as indicated by the current ACK and <code class="docutils literal notranslate"><span class="pre">MSS</span></code> is the maximum segment size.</p>
<p>After limit calculation, the cWnd is updated as given below:</p>
<div class="math">
<p><img src="_images/math/62defe9fb8e84a0fedf0187e8673a726cdac6959.png" alt="sndcnt = MIN (ssThresh - pipe, limit)"/></p>
</div><div class="math">
<p><img src="_images/math/6dc20e3e199e3bd8ad3079d594497d37c9438a2f.png" alt="cWnd = pipe + sndcnt"/></p>
</div><p>More information (paper): <a class="reference external" href="https://dl.acm.org/citation.cfm?id=2068832">https://dl.acm.org/citation.cfm?id=2068832</a></p>
<p>More information (RFC): <a class="reference external" href="https://tools.ietf.org/html/rfc6937">https://tools.ietf.org/html/rfc6937</a></p>
</section>
</section>
<section id="adding-a-new-loss-recovery-algorithm-in-ns-3">
<h3><span class="section-number">16.5.2.11. </span>Adding a new loss recovery algorithm in ns-3<a class="headerlink" href="#adding-a-new-loss-recovery-algorithm-in-ns-3" title="Link to this heading">¶</a></h3>
<p>Writing (or porting) a loss recovery algorithms from scratch (or from
other systems) is a process completely separated from the internals of
TcpSocketBase.</p>
<p>All operations that are delegated to a loss recovery are contained in
the class TcpRecoveryOps and are given below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">GetName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnterRecovery</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">unAckDataCount</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">bool</span><span class="w"> </span><span class="n">isSackEnabled</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dupAckCount</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lastDeliveredBytes</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DoRecovery</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">unAckDataCount</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">bool</span><span class="w"> </span><span class="n">isSackEnabled</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dupAckCount</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lastDeliveredBytes</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">ExitRecovery</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">UpdateBytesSent</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesSent</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpRecoveryOps</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Fork</span><span class="p">();</span>
</pre></div>
</div>
<p>EnterRecovery is called when packet loss is detected and recovery is triggered.
While in recovery phase, each time when an ACK arrives, DoRecovery is called which
performs the necessary congestion window changes as per the recovery algorithm.
ExitRecovery is called just prior to exiting recovery phase in order to perform the
required congestion window adjustments. UpdateBytesSent is used to keep track of
bytes sent and is called whenever a data packet is sent during recovery phase.</p>
</section>
<section id="delivery-rate-estimation">
<h3><span class="section-number">16.5.2.12. </span>Delivery Rate Estimation<a class="headerlink" href="#delivery-rate-estimation" title="Link to this heading">¶</a></h3>
<p>Current TCP implementation measures the approximate value of the delivery rate of
inflight data based on Delivery Rate Estimation.</p>
<p>As high level idea, keep in mind that the algorithm keeps track of 2 variables:</p>
<ol class="arabic simple">
<li><p><cite>delivered</cite>: Total amount of data delivered so far.</p></li>
<li><p><cite>deliveredStamp</cite>: Last time <cite>delivered</cite> was updated.</p></li>
</ol>
<p>When a packet is transmitted, the value of <cite>delivered (d0)</cite> and <cite>deliveredStamp (t0)</cite>
is stored in its respective TcpTxItem.</p>
<p>When an acknowledgement comes for this packet, the value of <cite>delivered</cite> and <cite>deliveredStamp</cite>
is updated to <cite>d1</cite> and <cite>t1</cite> in the same TcpTxItem.</p>
<p>After processing the acknowledgement, the rate sample is calculated and then passed
to a congestion avoidance algorithm:</p>
<div class="math">
<p><img src="_images/math/e637312558069d005426da7a12b385ca54b20742.png" alt="delivery_rate = (d1 - d0)/(t1 - t0)"/></p>
</div><p>The implementation to estimate delivery rate is a joint work between TcpTxBuffer and TcpRateOps.
For more information, please take a look at their Doxygen documentation.</p>
<p>The implementation follows the Internet draft (Delivery Rate Estimation):
<a class="reference external" href="https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00">https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00</a></p>
</section>
<section id="current-limitations">
<h3><span class="section-number">16.5.2.13. </span>Current limitations<a class="headerlink" href="#current-limitations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>TcpCongestionOps interface does not contain every possible Linux operation</p></li>
</ul>
</section>
<section id="writing-tcp-tests">
<span id="id4"></span><h3><span class="section-number">16.5.2.14. </span>Writing TCP tests<a class="headerlink" href="#writing-tcp-tests" title="Link to this heading">¶</a></h3>
<p>The TCP subsystem supports automated test
cases on both socket functions and congestion control algorithms. To show
how to write tests for TCP, here we explain the process of creating a test
case that reproduces the <a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=1571">Bug #1571</a>.</p>
<p>The bug concerns the zero window situation, which happens when the receiver
cannot handle more data. In this case, it advertises a zero window, which causes
the sender to pause transmission and wait for the receiver to increase the
window.</p>
<p>The sender has a timer to periodically check the receiver’s window: however, in
modern TCP implementations, when the receiver has freed a “significant” amount
of data, the receiver itself sends an “active” window update, meaning that
the transmission could be resumed. Nevertheless, the sender timer is still
necessary because window updates can be lost.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>During the text, we will assume some knowledge about the general design
of the TCP test infrastructure, which is explained in detail into the
Doxygen documentation. As a brief summary, the strategy is to have a class
that sets up a TCP connection, and that calls protected members of itself.
In this way, subclasses can implement the necessary members, which will
be called by the main TcpGeneralTest class when events occur. For example,
after processing an ACK, the method ProcessedAck will be invoked. Subclasses
interested in checking some particular things which must have happened during
an ACK processing, should implement the ProcessedAck method and check
the interesting values inside the method. To get a list of available methods,
please check the Doxygen documentation.</p>
</div>
<p>We describe the writing of two test cases, covering both situations: the
sender’s zero-window probing and the receiver “active” window update. Our focus
will be on dealing with the reported problems, which are:</p>
<ul class="simple">
<li><p>an ns-3 receiver does not send “active” window update when its receive buffer
is being freed;</p></li>
<li><p>even if the window update is artificially crafted, the transmission does not
resume.</p></li>
</ul>
<p>However, other things should be checked in the test:</p>
<ul class="simple">
<li><p>Persistent timer setup</p></li>
<li><p>Persistent timer teardown if rWnd increases</p></li>
</ul>
<p>To construct the test case, one first derives from the TcpGeneralTest class:</p>
<p>The code is the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TcpZeroWindowTest</span><span class="o">::</span><span class="n">TcpZeroWindowTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">)</span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">TcpGeneralTest</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, one should define the general parameters for the TCP connection, which
will be one-sided (one node is acting as SENDER, while the other is acting as
RECEIVER):</p>
<ul class="simple">
<li><p>Application packet size set to 500, and 20 packets in total (meaning a stream
of 10k bytes)</p></li>
<li><p>Segment size for both SENDER and RECEIVER set to 500 bytes</p></li>
<li><p>Initial slow start threshold set to UINT32_MAX</p></li>
<li><p>Initial congestion window for the SENDER set to 10 segments (5000 bytes)</p></li>
<li><p>Congestion control: NewReno</p></li>
</ul>
<p>We have also to define the link properties, because the above definition does
not work for every combination of propagation delay and sender application behavior.</p>
<ul class="simple">
<li><p>Link one-way propagation delay: 50 ms</p></li>
<li><p>Application packet generation interval: 10 ms</p></li>
<li><p>Application starting time: 20 s after the starting point</p></li>
</ul>
<p>To define the properties of the environment (e.g. properties which should be
set before the object creation, such as propagation delay) one next implements
the method ConfigureEnvironment:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::ConfigureEnvironment</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TcpGeneralTest</span><span class="o">::</span><span class="n">ConfigureEnvironment</span><span class="p">();</span>
<span class="w">  </span><span class="n">SetAppPktCount</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="n">SetMTU</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="w">  </span><span class="n">SetTransmitStart</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
<span class="w">  </span><span class="n">SetPropagationDelay</span><span class="p">(</span><span class="n">MilliSeconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For other properties, set after the object creation, one can use
ConfigureProperties ().
The difference is that some values, such as initial congestion window
or initial slow start threshold, are applicable only to a single instance, not
to every instance we have. Usually, methods that requires an id and a value
are meant to be called inside ConfigureProperties (). Please see the Doxygen
documentation for an exhaustive list of the tunable properties.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::ConfigureProperties</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TcpGeneralTest</span><span class="o">::</span><span class="n">ConfigureProperties</span><span class="p">();</span>
<span class="w">  </span><span class="n">SetInitialCwnd</span><span class="p">(</span><span class="n">SENDER</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To see the default value for the experiment, please see the implementation of
both methods inside TcpGeneralTest class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If some configuration parameters are missing, add a method called
“SetSomeValue” which takes as input the value only (if it is meant to be
called inside ConfigureEnvironment) or the socket and the value (if it is
meant to be called inside ConfigureProperties).</p>
</div>
<p>To define a zero-window situation, we choose (by design) to initiate the connection
with a 0-byte rx buffer. This implies that the RECEIVER, in its first SYN-ACK,
advertises a zero window. This can be accomplished by implementing the method
CreateReceiverSocket, setting an Rx buffer value of 0 bytes (at line 6 of the
following code):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketMsgBase</span><span class="o">&gt;</span>
<span class="linenos"> 2</span><span class="n">TcpZeroWindowTest</span><span class="o">::</span><span class="n">CreateReceiverSocket</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span>
<span class="linenos"> 3</span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketMsgBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpGeneralTest</span><span class="o">::</span><span class="n">CreateReceiverSocket</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="linenos"> 5</span>
<span class="hll"><span class="linenos"> 6</span><span class="w">  </span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;RcvBufSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class="hll"><span class="linenos"> 7</span><span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
</span><span class="hll"><span class="linenos"> 8</span><span class="w">                      </span><span class="o">&amp;</span><span class="n">TcpZeroWindowTest</span><span class="o">::</span><span class="n">IncreaseBufSize</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
</span><span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">socket</span><span class="p">;</span>
<span class="linenos">11</span><span class="p">}</span>
</pre></div>
</div>
<p>Even so, to check the active window update, we should schedule an increase
of the buffer size. We do this at line 7 and 8, scheduling the function
IncreaseBufSize.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::IncreaseBufSize</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">SetRcvBufSize</span><span class="p">(</span><span class="n">RECEIVER</span><span class="p">,</span><span class="w"> </span><span class="mi">2500</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Which utilizes the SetRcvBufSize method to edit the RxBuffer object of the
RECEIVER. As said before, check the Doxygen documentation for class TcpGeneralTest
to be aware of the various possibilities that it offers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By design, we choose to maintain a close relationship between TcpSocketBase
and TcpGeneralTest: they are connected by a friendship relation. Since
friendship is not passed through inheritance, if one discovers that one
needs to access or to modify a private (or protected) member of TcpSocketBase,
one can do so by adding a method in the class TcpGeneralSocket. An example
of such method is SetRcvBufSize, which allows TcpGeneralSocket subclasses
to forcefully set the RxBuffer size.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpGeneralTest::SetRcvBufSize</span><span class="p">(</span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENDER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_senderSocket</span><span class="o">-&gt;</span><span class="n">SetRcvBufSize</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RECEIVER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_receiverSocket</span><span class="o">-&gt;</span><span class="n">SetRcvBufSize</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">NS_FATAL_ERROR</span><span class="p">(</span><span class="s">&quot;Not defined&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Next, we can start to follow the TCP connection:</p>
<ol class="arabic simple">
<li><p>At time 0.0 s the connection is opened sender side, with a SYN packet sent from
SENDER to RECEIVER</p></li>
<li><p>At time 0.05 s the RECEIVER gets the SYN and replies with a SYN-ACK</p></li>
<li><p>At time 0.10 s the SENDER gets the SYN-ACK and replies with a SYN.</p></li>
</ol>
<p>While the general structure is defined, and the connection is started,
we need to define a way to check the rWnd field on the segments. To this aim,
we can implement the methods Rx and Tx in the TcpGeneralTest subclass,
checking each time the actions of the RECEIVER and the SENDER. These methods are
defined in TcpGeneralTest, and they are attached to the Rx and Tx traces in the
TcpSocketBase. One should write small tests for every detail that one wants to ensure during the
connection (it will prevent the test from changing over the time, and it ensures
that the behavior will stay consistent through releases). We start by ensuring that
the first SYN-ACK has 0 as advertised window size:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::Tx</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TcpHeader</span><span class="w"> </span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RECEIVER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">RECEIVER TX &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">GetSize</span><span class="p">());</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                </span><span class="s">&quot;RECEIVER window size is not 0 in the SYN-ACK&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">....</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Practically, we are checking that every SYN packet sent by the RECEIVER has the
advertised window set to 0. The same thing is done also by checking, in the Rx
method, that each SYN received by SENDER has the advertised window set to 0.
Thanks to the log subsystem, we can print what is happening through messages.
If we run the experiment, enabling the logging, we can see the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>shell
gdb<span class="w"> </span>--args<span class="w"> </span>./build/utils/ns3-dev-test-runner-debug<span class="w"> </span>--test-name<span class="o">=</span>tcp-zero-window-test<span class="w"> </span>--stop-on-failure<span class="w"> </span>--fullness<span class="o">=</span>QUICK<span class="w"> </span>--assert-on-failure<span class="w"> </span>--verbose
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>run

<span class="m">0</span>.00s<span class="w"> </span>TcpZeroWindowTestSuite:Tx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.00<span class="w">  </span>SENDER<span class="w"> </span>TX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>SYN<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">0</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">36</span>
<span class="m">0</span>.05s<span class="w"> </span>TcpZeroWindowTestSuite:Rx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.05<span class="w">  </span>RECEIVER<span class="w"> </span>RX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>SYN<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">0</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionEnd<span class="o">(</span>EOL<span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">0</span>
<span class="m">0</span>.05s<span class="w"> </span>TcpZeroWindowTestSuite:Tx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.05<span class="w">  </span>RECEIVER<span class="w"> </span>TX<span class="w"> </span><span class="m">4477</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">49153</span><span class="w"> </span><span class="o">[</span>SYN<span class="p">|</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">0</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">50</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">36</span>
<span class="m">0</span>.10s<span class="w"> </span>TcpZeroWindowTestSuite:Rx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.10<span class="w">  </span>SENDER<span class="w"> </span>RX<span class="w"> </span><span class="m">4477</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">49153</span><span class="w"> </span><span class="o">[</span>SYN<span class="p">|</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">0</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">50</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionEnd<span class="o">(</span>EOL<span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">0</span>
<span class="m">0</span>.10s<span class="w"> </span>TcpZeroWindowTestSuite:Tx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.10<span class="w">  </span>SENDER<span class="w"> </span>TX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">100</span><span class="p">;</span><span class="m">50</span><span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">32</span>
<span class="m">0</span>.15s<span class="w"> </span>TcpZeroWindowTestSuite:Rx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.15<span class="w">  </span>RECEIVER<span class="w"> </span>RX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">100</span><span class="p">;</span><span class="m">50</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionEnd<span class="o">(</span>EOL<span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">0</span>
<span class="o">(</span>...<span class="o">)</span>
</pre></div>
</div>
<p>The output is cut to show the threeway handshake. As we can see from the headers,
the rWnd of RECEIVER is set to 0, and thankfully our tests are not failing.
Now we need to test for the persistent timer, which should be started by
the SENDER after it receives the SYN-ACK. Since the Rx method is called before
any computation on the received packet, we should utilize another method, namely
ProcessedAck, which is the method called after each processed ACK. In the
following, we show how to check if the persistent event is running after the
processing of the SYN-ACK:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::ProcessedAck</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENDER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">EventId</span><span class="w"> </span><span class="n">persistentEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetPersistentEvent</span><span class="p">(</span><span class="n">SENDER</span><span class="p">);</span>
<span class="w">          </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">persistentEvent</span><span class="p">.</span><span class="n">IsRunning</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                                </span><span class="s">&quot;Persistent event not started&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Since we programmed the increase of the buffer size after 10 simulated seconds,
we expect the persistent timer to fire before any rWnd changes. When it fires,
the SENDER should send a window probe, and the receiver should reply reporting
again a zero window situation. At first, we investigates on what the sender sends:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="linenos"> 1</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">6.0</span><span class="p">)</span>
</span><span class="linenos"> 2</span><span class="w">  </span><span class="p">{</span>
<span class="linenos"> 3</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">GetSize</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">GetSerializedSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos"> 4</span><span class="w">                          </span><span class="s">&quot;Data packet sent anyway&quot;</span><span class="p">);</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="p">}</span>
<span class="hll"><span class="linenos"> 6</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">6.0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
</span><span class="hll"><span class="linenos"> 7</span><span class="w">         </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">7.0</span><span class="p">)</span>
</span><span class="linenos"> 8</span><span class="w">  </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_zeroWindowProbe</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Sent another probe&quot;</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="hll"><span class="linenos">11</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">m_zeroWindowProbe</span><span class="p">)</span>
</span><span class="linenos">12</span><span class="w">      </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">        </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">GetSize</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">GetSerializedSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="linenos">14</span><span class="w">                              </span><span class="s">&quot;Data packet sent instead of window probe&quot;</span><span class="p">);</span>
<span class="linenos">15</span><span class="w">        </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetSequenceNumber</span><span class="p">(),</span><span class="w"> </span><span class="n">SequenceNumber32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="linenos">16</span><span class="w">                              </span><span class="s">&quot;Data packet sent instead of window probe&quot;</span><span class="p">);</span>
<span class="linenos">17</span><span class="w">        </span><span class="n">m_zeroWindowProbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos">18</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">19</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>We divide the events by simulated time. At line 1, we check everything that
happens before the 6.0 seconds mark; for instance, that no data packets are sent,
and that the state remains OPEN for both sender and receiver.</p>
<p>Since the persist timeout is initialized at 6 seconds (exercise left for the
reader: edit the test, getting this value from the Attribute system), we need
to check (line 6) between 6.0 and 7.0 simulated seconds that the probe is sent.
Only one probe is allowed, and this is the reason for the check at line 11.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">6.0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">2</span><span class="w">    </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">7.0</span><span class="p">)</span>
<span class="linenos">3</span><span class="w">  </span><span class="p">{</span>
<span class="linenos">4</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetSequenceNumber</span><span class="p">(),</span><span class="w"> </span><span class="n">SequenceNumber32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="linenos">5</span><span class="w">                          </span><span class="s">&quot;Data packet sent instead of window probe&quot;</span><span class="p">);</span>
<span class="hll"><span class="linenos">6</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">7</span><span class="w">                          </span><span class="s">&quot;No zero window advertised by RECEIVER&quot;</span><span class="p">);</span>
</span><span class="linenos">8</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>For the RECEIVER, the interval between 6 and 7 seconds is when the zero-window
segment is sent.</p>
<p>Other checks are redundant; the safest approach is to deny any other packet
exchange between the 7 and 10 seconds mark.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">7.0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">         </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">10.0</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">NS_FATAL_ERROR</span><span class="p">(</span><span class="s">&quot;No packets should be sent before the window update&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>The state checks are performed at the end of the methods, since they are valid
in every condition:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">GetCongStateFrom</span><span class="p">(</span><span class="n">GetTcb</span><span class="p">(</span><span class="n">SENDER</span><span class="p">)),</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">::</span><span class="n">CA_OPEN</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;Sender State is not OPEN&quot;</span><span class="p">);</span>
<span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">GetCongStateFrom</span><span class="p">(</span><span class="n">GetTcb</span><span class="p">(</span><span class="n">RECEIVER</span><span class="p">)),</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">::</span><span class="n">CA_OPEN</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;Receiver State is not OPEN&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, the interesting part in the Tx method is to check that after the 10.0
seconds mark (when the RECEIVER sends the active window update) the value of
the window should be greater than zero (and precisely, set to 2500):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">2500</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;Receiver window not updated&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>To be sure that the sender receives the window update, we can use the Rx
method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">)</span>
<span class="linenos">2</span><span class="w">  </span><span class="p">{</span>
<span class="linenos">3</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">2500</span><span class="p">,</span>
<span class="linenos">4</span><span class="w">                          </span><span class="s">&quot;Receiver window not updated&quot;</span><span class="p">);</span>
<span class="hll"><span class="linenos">5</span><span class="w">    </span><span class="n">m_windowUpdated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</span><span class="linenos">6</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>We check every packet after the 10 seconds mark to see if it has the
window updated. At line 5, we also set to true a boolean variable, to check
that we effectively reach this test.</p>
<p>Last but not least, we implement also the NormalClose() method, to check that
the connection ends with a success:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::NormalClose</span><span class="p">(</span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENDER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_senderFinished</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RECEIVER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_receiverFinished</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The method is called only if all bytes are transmitted successfully. Then, in
the method FinalChecks(), we check all variables, which should be true (which
indicates that we have perfectly closed the connection).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::FinalChecks</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_zeroWindowProbe</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Zero window probe not sent&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_windowUpdated</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Window has not updated during the connection&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_senderFinished</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Connection not closed successfully(SENDER)&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_receiverFinished</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Connection not closed successfully(RECEIVER)&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To run the test, the usual way is</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./test.py<span class="w"> </span>-s<span class="w"> </span>tcp-zero-window-test

PASS:<span class="w"> </span>TestSuite<span class="w"> </span>tcp-zero-window-test
<span class="m">1</span><span class="w"> </span>of<span class="w"> </span><span class="m">1</span><span class="w"> </span>tests<span class="w"> </span>passed<span class="w"> </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>passed,<span class="w"> </span><span class="m">0</span><span class="w"> </span>skipped,<span class="w"> </span><span class="m">0</span><span class="w"> </span>failed,<span class="w"> </span><span class="m">0</span><span class="w"> </span>crashed,<span class="w"> </span><span class="m">0</span><span class="w"> </span>valgrind<span class="w"> </span>errors<span class="o">)</span>
</pre></div>
</div>
<p>To see INFO messages, use a combination of ./ns3 shell and gdb (really useful):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>shell<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>gdb<span class="w"> </span>--args<span class="w"> </span>./build/utils/ns3-dev-test-runner-debug<span class="w"> </span>--test-name<span class="o">=</span>tcp-zero-window-test<span class="w"> </span>--stop-on-failure<span class="w"> </span>--fullness<span class="o">=</span>QUICK<span class="w"> </span>--assert-on-failure<span class="w"> </span>--verbose
</pre></div>
</div>
<p>and then, hit “Run”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This code magically runs without any reported errors; however, in real cases,
when you discover a bug you should expect the existing test to fail (this
could indicate a well-written test and a bad-written model, or a bad-written
test; hopefully the first situation). Correcting bugs is an iterative
process. For instance, commits created to make this test case running without
errors are 11633:6b74df04cf44, (others to be merged).</p>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">16.5. TCP models in ns-3</a><ul>
<li><a class="reference internal" href="#overview-of-support-for-tcp">16.5.1. Overview of support for TCP</a></li>
<li><a class="reference internal" href="#ns-3-tcp">16.5.2. ns-3 TCP</a><ul>
<li><a class="reference internal" href="#model-history">16.5.2.1. Model history</a></li>
<li><a class="reference internal" href="#acknowledgments">16.5.2.2. Acknowledgments</a></li>
<li><a class="reference internal" href="#usage">16.5.2.3. Usage</a><ul>
<li><a class="reference internal" href="#tcp-socket-interaction-and-interface-with-application-layer">16.5.2.3.1. TCP Socket interaction and interface with Application layer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#congestion-control-algorithms">16.5.2.4. Congestion Control Algorithms</a><ul>
<li><a class="reference internal" href="#newreno">16.5.2.4.1. NewReno</a></li>
<li><a class="reference internal" href="#cubic">16.5.2.4.2. CUBIC</a></li>
<li><a class="reference internal" href="#linux-reno">16.5.2.4.3. Linux Reno</a></li>
<li><a class="reference internal" href="#highspeed">16.5.2.4.4. HighSpeed</a></li>
<li><a class="reference internal" href="#hybla">16.5.2.4.5. Hybla</a></li>
<li><a class="reference internal" href="#westwood">16.5.2.4.6. Westwood</a></li>
<li><a class="reference internal" href="#vegas">16.5.2.4.7. Vegas</a></li>
<li><a class="reference internal" href="#scalable">16.5.2.4.8. Scalable</a></li>
<li><a class="reference internal" href="#veno">16.5.2.4.9. Veno</a></li>
<li><a class="reference internal" href="#bic">16.5.2.4.10. BIC</a></li>
<li><a class="reference internal" href="#yeah">16.5.2.4.11. YeAH</a></li>
<li><a class="reference internal" href="#illinois">16.5.2.4.12. Illinois</a></li>
<li><a class="reference internal" href="#h-tcp">16.5.2.4.13. H-TCP</a></li>
<li><a class="reference internal" href="#ledbat">16.5.2.4.14. LEDBAT</a></li>
<li><a class="reference internal" href="#tcp-lp">16.5.2.4.15. TCP-LP</a></li>
<li><a class="reference internal" href="#data-center-tcp-dctcp">16.5.2.4.16. Data Center TCP (DCTCP)</a></li>
<li><a class="reference internal" href="#bbr">16.5.2.4.17. BBR</a></li>
</ul>
</li>
<li><a class="reference internal" href="#support-for-explicit-congestion-notification-ecn">16.5.2.5. Support for Explicit Congestion Notification (ECN)</a><ul>
<li><a class="reference internal" href="#enabling-ecn">16.5.2.5.1. Enabling ECN</a></li>
<li><a class="reference internal" href="#ecn-negotiation">16.5.2.5.2. ECN negotiation</a></li>
<li><a class="reference internal" href="#ecn-state-transitions">16.5.2.5.3. ECN State Transitions</a></li>
<li><a class="reference internal" href="#rfc-3168-compliance">16.5.2.5.4. RFC 3168 compliance</a></li>
<li><a class="reference internal" href="#open-issues">16.5.2.5.5. Open issues</a></li>
</ul>
</li>
<li><a class="reference internal" href="#support-for-dynamic-pacing">16.5.2.6. Support for Dynamic Pacing</a></li>
<li><a class="reference internal" href="#validation">16.5.2.7. Validation</a></li>
<li><a class="reference internal" href="#writing-a-new-congestion-control-algorithm">16.5.2.8. Writing a new congestion control algorithm</a></li>
<li><a class="reference internal" href="#tcp-sack-and-non-sack">16.5.2.9. TCP SACK and non-SACK</a></li>
<li><a class="reference internal" href="#loss-recovery-algorithms">16.5.2.10. Loss Recovery Algorithms</a><ul>
<li><a class="reference internal" href="#classic-recovery">16.5.2.10.1. Classic Recovery</a></li>
<li><a class="reference internal" href="#proportional-rate-reduction">16.5.2.10.2. Proportional Rate Reduction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-a-new-loss-recovery-algorithm-in-ns-3">16.5.2.11. Adding a new loss recovery algorithm in ns-3</a></li>
<li><a class="reference internal" href="#delivery-rate-estimation">16.5.2.12. Delivery Rate Estimation</a></li>
<li><a class="reference internal" href="#current-limitations">16.5.2.13. Current limitations</a></li>
<li><a class="reference internal" href="#writing-tcp-tests">16.5.2.14. Writing TCP tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="routing-overview.html"
                          title="previous chapter"><span class="section-number">16.4. </span>Routing overview</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="udp.html"
                          title="next chapter"><span class="section-number">16.6. </span>UDP model in ns-3</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tcp.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="udp.html" title="16.6. UDP model in ns-3"
             >next</a> |</li>
        <li class="right" >
          <a href="routing-overview.html" title="16.4. Routing overview"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="internet-models.html" ><span class="section-number">16. </span>Internet Models (IP, TCP, Routing, UDP)</a><span class="navelem">&nbsp;</span></li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">16.5. </span>TCP models in ns-3</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006-2019.
      Last updated on Dec 19, 2023 13:21.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>