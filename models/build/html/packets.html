

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Packets &#8212; Model Library</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Error Model" href="error-model.html" />
    <link rel="prev" title="Network Module" href="network.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico" 
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>
      

  </head><body>
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0" width="100%">
      <tbody>
	<tr style="height: 56px;">
	  <td id="projectlogo">
	    <a id="ns3_home1"
	       href="http://www.nsnam.org/">
	       <img alt="ns-3 Logo"
		    src="_static/ns-3-inverted-notext-small.png"/>
	    </a>
	  </td>
	  <td id="projecttext">
	    <div id="projectbrief">A Discrete-Event Network Simulator</div>
	      <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
	  </td>
	      
	  <td id="ns3-menu">
	    <div class="menu">
	      <ul >
	        <li><a id="ns3_home2"
		       href="http://www.nsnam.org/"
		       >&nbsp;&nbsp;Home</a>
	        </li>
	        <li><span
		      onmouseover="mopen('mTuts')" 
		      onmouseout="mclosetime()"
			>Tutorials &nbsp;&#x25BC;</span>
		    <div id="mTuts" 
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_tut"
			 href="/docs/tutorial/html/index.html"
			  >English</a><br/>
	        </li>
	        <li><span
		      onmouseover="mopen('mDocs')" 
		      onmouseout="mclosetime()"
			>Docs &nbsp;&nbsp;&nbsp;&#x25BC;</span>
		    <div id="mDocs"
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_wiki"
			 href="http://www.nsnam.org/wiki"
			 >Wiki</a><br/>
		      <a id="ns3_man"
			 href="/docs/manual/html/index.html"
			 >Manual</a><br/>
		      <a id="ns3_mod"
			 href="/docs/models/html/index.html"
			 >Models</a><br/>
	        </li>
	        <li><span
		      onmouseover="mopen('mDev')" 
		      onmouseout="mclosetime()"
			>Develop &#x25BC;</span>
		    <div id="mDev"
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_api"
			 href="/docs/doxygen/html/index.html"
			 >API</a><br/>
		      <a id="ns3_bugs"
		       href="http://www.nsnam.org/bugzilla/">Bugs</a>
	        </li>
	      </ul>
	    </div>
	  </td>
	  <td id="projectsection">
	    <span style="margin-right:10px">Models</span>
	  </td>
	</tr>
      </tbody>
    </table>
    <script  type="text/javascript">ns3_write_links()</script>
  </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="error-model.html" title="Error Model"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="network.html" title="Network Module"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="network.html" accesskey="U">Network Module</a><span class="navelem">&nbsp;</span></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="packets">
<h1>Packets<a class="headerlink" href="#packets" title="Permalink to this headline">¶</a></h1>
<p>The design of the Packet framework of <em>ns</em> was heavily guided by a few
important use-cases:</p>
<ul class="simple">
<li><p>avoid changing the core of the simulator to introduce new types of packet
headers or trailers</p></li>
<li><p>maximize the ease of integration with real-world code and systems</p></li>
<li><p>make it easy to support fragmentation, defragmentation, and, concatenation
which are important, especially in wireless systems.</p></li>
<li><p>make memory management of this object efficient</p></li>
<li><p>allow actual application data or dummy application bytes for emulated
applications</p></li>
</ul>
<p>Each network packet contains a byte buffer, a set of byte tags, a set of packet
tags, and metadata.</p>
<p>The byte buffer stores the serialized content of the headers and trailers added
to a packet. The serialized representation of these headers is expected to match
that of real network packets bit for bit (although nothing forces you to do
this) which means that the content of a packet buffer is expected to be that of
a real packet.</p>
<p>Fragmentation and defragmentation are quite natural to implement within this
context: since we have a buffer of real bytes, we can split it in multiple
fragments and re-assemble these fragments. We expect that this choice will make
it really easy to wrap our Packet data structure within Linux-style skb or
BSD-style mbuf to integrate real-world kernel code in the simulator. We also
expect that performing a real-time plug of the simulator to a real-world network
will be easy.</p>
<p>One problem that this design choice raises is that it is difficult to
pretty-print the packet headers without context. The packet metadata describes
the type of the headers and trailers which were serialized in the byte buffer.
The maintenance of metadata is optional and disabled by default. To enable it,
you must call Packet::EnablePrinting() and this will allow you to get non-empty
output from Packet::Print and Packet::Print.</p>
<p>Also, developers often want to store data in packet objects that is not found
in the real packets (such as timestamps or flow-ids). The Packet class
deals with this requirement by storing a set of tags (class Tag).
We have found two classes of use cases for these tags, which leads to
two different types of tags. So-called ‘byte’ tags are used to tag a subset of
the bytes in the packet byte buffer while ‘packet’ tags are used to tag the
packet itself. The main difference between these two kinds of tags is what
happens when packets are copied, fragmented, and reassembled: ‘byte’ tags follow
bytes while ‘packet’ tags follow packets. Another important difference between
these two kinds of tags is that byte tags cannot be removed and are expected to
be written once, and read many times, while packet tags are expected to be
written once, read many times, and removed exactly once. An example of a ‘byte’
tag is a FlowIdTag which contains a flow id and is set by the application
generating traffic. An example of a ‘packet’ tag is a cross-layer QoS class id
set by an application and processed by a lower-level MAC layer.</p>
<p>Memory management of Packet objects is entirely automatic and extremely
efficient: memory for the application-level payload can be modeled by a virtual
buffer of zero-filled bytes for which memory is never allocated unless
explicitly requested by the user or unless the packet is fragmented or
serialized out to a real network device. Furthermore, copying, adding, and,
removing headers or trailers to a packet has been optimized to be virtually free
through a technique known as Copy On Write.</p>
<p>Packets (messages) are fundamental objects in the simulator and
their design is important from a performance and resource management
perspective. There are various ways to design the simulation packet, and
tradeoffs among the different approaches. In particular, there is a tension
between ease-of-use, performance, and safe interface design.</p>
<div class="section" id="packet-design-overview">
<h2>Packet design overview<a class="headerlink" href="#packet-design-overview" title="Permalink to this headline">¶</a></h2>
<p>Unlike <em>ns-2</em>, in which Packet objects contain a buffer of C++
structures corresponding to protocol headers, each network packet in
<em>ns-3</em> contains a byte Buffer, a list of byte Tags, a list of
packet Tags, and a PacketMetadata object:</p>
<ul class="simple">
<li><p>The byte buffer stores the serialized content of the chunks added to a packet.
The serialized representation of these chunks is expected to match that of
real network packets bit for bit (although nothing forces you to do this)
which means that the content of a packet buffer is expected to be that of a
real packet.  Packets can also be created with an arbitrary zero-filled
payload for which no real memory is allocated.</p></li>
<li><p>Each list of tags stores an arbitrarily large set of arbitrary user-provided
data structures in the packet.  Each Tag is uniquely identified by its type;
only one instance of each type of data structure is allowed in a list of tags.
These tags typically contain per-packet cross-layer information or flow
identifiers (i.e., things that you wouldn’t find in the bits on the wire).</p></li>
</ul>
<div class="figure align-default" id="id2">
<span id="id1"></span><img alt="_images/packet.png" src="_images/packet.png" />
<p class="caption"><span class="caption-text">Implementation overview of Packet class.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#id1"><span class="std std-ref">Implementation overview of Packet class.</span></a> is a high-level overview of the Packet implementation;
more detail on the byte Buffer implementation is provided later in Figure
<a class="reference internal" href="#buffer"><span class="std std-ref">Implementation overview of a packet’s byte Buffer.</span></a>. In <em>ns-3</em>, the Packet byte buffer is analogous to a Linux skbuff
or BSD mbuf; it is a serialized representation of the actual data in the packet.
The tag lists are containers for extra items useful for simulation convenience;
if a Packet is converted to an emulated packet and put over an actual network,
the tags are stripped off and the byte buffer is copied directly into a real
packet.</p>
<p>Packets are reference counted objects. They are handled with smart pointer (Ptr)
objects like many of the objects in the <em>ns-3</em> system.  One small difference you
will see is that class Packet does not inherit from class Object or class
RefCountBase, and implements the Ref() and Unref() methods directly. This was
designed to avoid the overhead of a vtable in class Packet.</p>
<p>The Packet class is designed to be copied cheaply; the overall design
is based on Copy on Write (COW).  When there are multiple references
to a packet object, and there is an operation on one of them, only
so-called “dirty” operations will trigger a deep copy of the packet:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Packet::AddHeader()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Packet::AddTrailer()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">both</span> <span class="pre">versions</span> <span class="pre">of</span> <span class="pre">ns3::Packet::AddAtEnd()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Packet::RemovePacketTag()</span></code></p></li>
</ul>
<p>The fundamental classes for adding to and removing from the byte buffer are
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Header</span></code> and <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Trailer</span></code>. Headers are more common but the below
discussion also largely applies to protocols using trailers. Every protocol
header that needs to be inserted and removed from a Packet instance should
derive from the abstract Header base class and implement the private pure
virtual methods listed below:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::SerializeTo()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::DeserializeFrom()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::GetSerializedSize()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::PrintTo()</span></code></p></li>
</ul>
<p>Basically, the first three functions are used to serialize and deserialize
protocol control information to/from a Buffer. For example, one may define
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">TCPHeader</span> <span class="pre">:</span> <span class="pre">public</span> <span class="pre">Header</span></code>. The TCPHeader object will typically
consist of some private data (like a sequence number) and public interface
access functions (such as checking the bounds of an input). But the underlying
representation of the TCPHeader in a Packet Buffer is 20 serialized bytes (plus
TCP options). The TCPHeader::SerializeTo() function would therefore be designed
to write these 20 bytes properly into the packet, in network byte order. The
last function is used to define how the Header object prints itself onto an
output stream.</p>
<p>Similarly, user-defined Tags can be appended to the packet. Unlike Headers,
Tags are not serialized into a contiguous buffer but are stored in lists. Tags
can be flexibly defined to be any type, but there can only be one instance of
any particular object type in the Tags buffer at any time.</p>
</div>
<div class="section" id="using-the-packet-interface">
<h2>Using the packet interface<a class="headerlink" href="#using-the-packet-interface" title="Permalink to this headline">¶</a></h2>
<p>This section describes how to create and use the <code class="docutils literal notranslate"><span class="pre">ns3::Packet</span></code> object.</p>
<div class="section" id="creating-a-new-packet">
<h3>Creating a new packet<a class="headerlink" href="#creating-a-new-packet" title="Permalink to this headline">¶</a></h3>
<p>The following command will create a new packet with a new unique Id.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="p">();</span>
</pre></div>
</div>
<p>What is the Uid (unique Id)?  It is an internal id that the system uses to
identify packets.  It can be fetched via the following method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">GetUid</span> <span class="p">();</span>
</pre></div>
</div>
<p>But please note the following. This uid is an internal uid and cannot be counted
on to provide an accurate counter of how many “simulated packets” of a
particular protocol are in the system. It is not trivial to make this uid into
such a counter, because of questions such as what should the uid be when the
packet is sent over broadcast media, or when fragmentation occurs. If a user
wants to trace actual packet counts, he or she should look at e.g. the IP ID
field or transport sequence numbers, or other packet or frame counters at other
protocol layers.</p>
<p>We mentioned above that it is possible to create packets with zero-filled
payloads that do not actually require a memory allocation (i.e., the packet may
behave, when delays such as serialization or transmission delays are computed,
to have a certain number of payload bytes, but the bytes will only be allocated
on-demand when needed).  The command to do this is, when the packet is
created:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
<p>where N is a positive integer.</p>
<p>The packet now has a size of N bytes, which can be verified by the GetSize()
method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \returns the size in bytes of the packet (including the zero-filled</span>
<span class="cm"> *          initial payload)</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">GetSize</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>You can also initialize a packet with a character buffer. The input
data is copied and the input buffer is untouched. The constructor
applied is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Packet</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>Here is an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">pkt1</span> <span class="o">=</span> <span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*&gt;</span> <span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">),</span> <span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>Packets are freed when there are no more references to them, as with all <em>ns-3</em>
objects referenced by the Ptr class.</p>
</div>
<div class="section" id="adding-and-removing-buffer-data">
<h3>Adding and removing Buffer data<a class="headerlink" href="#adding-and-removing-buffer-data" title="Permalink to this headline">¶</a></h3>
<p>After the initial packet creation (which may possibly create some fake initial
bytes of payload), all subsequent buffer data is added by adding objects of
class Header or class Trailer. Note that, even if you are in the application
layer, handling packets, and want to write application data, you write it as an
ns3::Header or ns3::Trailer. If you add a Header, it is prepended to the
packet, and if you add a Trailer, it is added to the end of the packet. If you
have no data in the packet, then it makes no difference whether you add a Header
or Trailer. Since the APIs and classes for header and trailer are pretty much
identical, we’ll just look at class Header here.</p>
<p>The first step is to create a new header class. All new Header classes
must inherit from class Header, and implement the following methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Serialize</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Deserialize</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetSerializedSize</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">()</span></code></p></li>
</ul>
<p>To see a simple example of how these are done, look at the UdpHeader class
headers src/internet/model/udp-header.cc. There are many other examples within
the source code.</p>
<p>Once you have a header (or you have a preexisting header), the following
Packet API can be used to add or remove such headers.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Add header to this packet. This method invokes the</span>
<span class="cm"> * Header::GetSerializedSize and Header::Serialize</span>
<span class="cm"> * methods to reserve space in the buffer and request the</span>
<span class="cm"> * header to serialize itself in the packet buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to add to this packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">AddHeader</span> <span class="p">(</span><span class="k">const</span> <span class="n">Header</span> <span class="o">&amp;</span> <span class="n">header</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * Deserialize and remove the header from the internal buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This method invokes Header::Deserialize (begin) and should be used for</span>
<span class="cm"> * fixed-length headers.</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to remove from the internal buffer.</span>
<span class="cm"> * \returns the number of bytes removed from the packet.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">RemoveHeader</span> <span class="p">(</span><span class="n">Header</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * Deserialize but does _not_ remove the header from the internal buffer.</span>
<span class="cm"> * This method invokes Header::Deserialize.</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to read from the internal buffer.</span>
<span class="cm"> * \returns the number of bytes read from the packet.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">PeekHeader</span> <span class="p">(</span><span class="n">Header</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance, here are the typical operations to add and remove a UDP header.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// add header</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="p">();</span>
<span class="n">UdpHeader</span> <span class="n">udpHeader</span><span class="p">;</span>
<span class="c1">// Fill out udpHeader fields appropriately</span>
<span class="n">packet</span><span class="o">-&gt;</span><span class="n">AddHeader</span> <span class="p">(</span><span class="n">udpHeader</span><span class="p">);</span>
<span class="p">...</span>
<span class="c1">// remove header</span>
<span class="n">UdpHeader</span> <span class="n">udpHeader</span><span class="p">;</span>
<span class="n">packet</span><span class="o">-&gt;</span><span class="n">RemoveHeader</span> <span class="p">(</span><span class="n">udpHeader</span><span class="p">);</span>
<span class="c1">// Read udpHeader fields as needed</span>
</pre></div>
</div>
<p>If the header is variable-length, then another variant of RemoveHeader() is
needed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \brief Deserialize and remove the header from the internal buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This method invokes Header::Deserialize (begin, end) and should be</span>
<span class="cm"> * used for variable-length headers (where the size is determined somehow</span>
<span class="cm"> * by the caller).</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to remove from the internal buffer.</span>
<span class="cm"> * \param size number of bytes to deserialize</span>
<span class="cm"> * \returns the number of bytes removed from the packet.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">RemoveHeader</span> <span class="p">(</span><span class="n">Header</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the caller must figure out and provide the right ‘size’ as
an argument (the Deserialization routine may not know when to stop).  An
example of this type of header would be a series of Type-Length-Value (TLV)
information elements, where the ending point of the series of TLVs can
be deduced from the packet length.</p>
</div>
<div class="section" id="adding-and-removing-tags">
<h3>Adding and removing Tags<a class="headerlink" href="#adding-and-removing-tags" title="Permalink to this headline">¶</a></h3>
<p>There is a single base class of Tag that all packet tags must derive from. They
are used in two different tag lists in the packet; the lists have different
semantics and different expected use cases.</p>
<p>As the names imply, ByteTags follow bytes and PacketTags follow packets. What
this means is that when operations are done on packets, such as fragmentation,
concatenation, and appending or removing headers, the byte tags keep track of
which packet bytes they cover. For instance, if a user creates a TCP segment,
and applies a ByteTag to the segment, each byte of the TCP segment will be
tagged. However, if the next layer down inserts an IPv4 header, this ByteTag
will not cover those bytes.  The converse is true for the PacketTag; it covers a
packet despite the operations on it.</p>
<p>PacketTags are limited in size to 20 bytes. This is a modifiable compile-time
constant in <code class="docutils literal notranslate"><span class="pre">src/network/model/packet-tag-list.h</span></code>. ByteTags have no such restriction.</p>
<p>Each tag type must subclass <code class="docutils literal notranslate"><span class="pre">ns3::Tag</span></code>, and only one instance of
each Tag type may be in each tag list. Here are a few differences in the
behavior of packet tags and byte tags.</p>
<ul class="simple">
<li><p><strong>Fragmentation:</strong>  As mentioned above, when a packet is fragmented, each
packet fragment (which is a new packet) will get a copy of all packet tags,
and byte tags will follow the new packet boundaries (i.e. if the fragmented
packets fragment across a buffer region covered by the byte tag, both packet
fragments will still have the appropriate buffer regions byte tagged).</p></li>
<li><p><strong>Concatenation:</strong> When packets are combined, two different buffer regions
will become one. For byte tags, the byte tags simply follow the respective
buffer regions. For packet tags, only the tags on the first packet survive
the merge.</p></li>
<li><p><strong>Finding and Printing:</strong> Both classes allow you to iterate over all of the
tags and print them.</p></li>
<li><p><strong>Removal:</strong> Users can add and remove the same packet tag multiple times on a
single packet (AddPacketTag () and RemovePacketTag ()). The packet However,
once a byte tag is added, it can only be removed by stripping all byte tags
from the packet. Removing one of possibly multiple byte tags is not supported
by the current API.</p></li>
</ul>
<p>As of <em>ns-3.5</em> and later, Tags are not serialized and deserialized to a buffer when
<code class="docutils literal notranslate"><span class="pre">Packet::Serialize</span> <span class="pre">()</span></code> and <code class="docutils literal notranslate"><span class="pre">Packet::Deserialize</span> <span class="pre">()</span></code> are called; this is an
open bug.</p>
<p>If a user wants to take an existing packet object and reuse it as a new packet,
he or she should remove all byte tags and packet tags before doing so. An
example is the UdpEchoServer class, which takes the received packet and “turns
it around” to send back to the echo client.</p>
<p>The Packet API for byte tags is given below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \param tag the new tag to add to this packet</span>
<span class="cm"> *</span>
<span class="cm"> * Tag each byte included in this packet with the</span>
<span class="cm"> * new tag.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that adding a tag is a const operation which is pretty</span>
<span class="cm"> * un-intuitive. The rationale is that the content and behavior of</span>
<span class="cm"> * a packet is _not_ changed when a tag is added to a packet: any</span>
<span class="cm"> * code which was not aware of the new tag is going to work just</span>
<span class="cm"> * the same if the new tag is added. The real reason why adding a</span>
<span class="cm"> * tag was made a const operation is to allow a trace sink which gets</span>
<span class="cm"> * a packet to tag the packet, even if the packet is const (and most</span>
<span class="cm"> * trace sources should use const packets because it would be</span>
<span class="cm"> * totally evil to allow a trace sink to modify the content of a</span>
<span class="cm"> * packet).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">AddByteTag</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tag</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * \returns an iterator over the set of byte tags included in this packet.</span>
<span class="cm"> */</span>
<span class="n">ByteTagIterator</span> <span class="nf">GetByteTagIterator</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * \param tag the tag to search in this packet</span>
<span class="cm"> * \returns true if the requested tag type was found, false otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * If the requested tag type is found, it is copied in the user&#39;s</span>
<span class="cm"> * provided tag instance.</span>
<span class="cm"> */</span>
<span class="kt">bool</span> <span class="nf">FindFirstMatchingByteTag</span> <span class="p">(</span><span class="n">Tag</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Remove all the tags stored in this packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">RemoveAllByteTags</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * \param os output stream in which the data should be printed.</span>
<span class="cm"> *</span>
<span class="cm"> * Iterate over the tags present in this packet, and</span>
<span class="cm"> * invoke the Print method of each tag stored in the packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">PrintByteTags</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The Packet API for packet tags is given below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \param tag the tag to store in this packet</span>
<span class="cm"> *</span>
<span class="cm"> * Add a tag to this packet. This method calls the</span>
<span class="cm"> * Tag::GetSerializedSize and, then, Tag::Serialize.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this method is const, that is, it does not</span>
<span class="cm"> * modify the state of this packet, which is fairly</span>
<span class="cm"> * un-intuitive.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">AddPacketTag</span> <span class="p">(</span><span class="k">const</span> <span class="n">Tag</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * \param tag the tag to remove from this packet</span>
<span class="cm"> * \returns true if the requested tag is found, false</span>
<span class="cm"> *          otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a tag from this packet. This method calls</span>
<span class="cm"> * Tag::Deserialize if the tag is found.</span>
<span class="cm"> */</span>
<span class="kt">bool</span> <span class="nf">RemovePacketTag</span> <span class="p">(</span><span class="n">Tag</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * \param tag the tag to search in this packet</span>
<span class="cm"> * \returns true if the requested tag is found, false</span>
<span class="cm"> *          otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Search a matching tag and call Tag::Deserialize if it is found.</span>
<span class="cm"> */</span>
<span class="kt">bool</span> <span class="nf">PeekPacketTag</span> <span class="p">(</span><span class="n">Tag</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * Remove all packet tags.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">RemoveAllPacketTags</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * \param os the stream in which we want to print data.</span>
<span class="cm"> *</span>
<span class="cm"> * Print the list of &#39;packet&#39; tags.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa Packet::AddPacketTag, Packet::RemovePacketTag, Packet::PeekPacketTag,</span>
<span class="cm"> *  Packet::RemoveAllPacketTags</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">PrintPacketTags</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * \returns an object which can be used to iterate over the list of</span>
<span class="cm"> *  packet tags.</span>
<span class="cm"> */</span>
<span class="n">PacketTagIterator</span> <span class="nf">GetPacketTagIterator</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Here is a simple example illustrating the use of tags from the
code in <code class="docutils literal notranslate"><span class="pre">src/internet/model/udp-socket-impl.cc</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// pointer to a pre-existing packet</span>
<span class="n">SocketIpTtlTag</span> <span class="n">tag</span>
<span class="n">tag</span><span class="p">.</span><span class="n">SetTtl</span> <span class="p">(</span><span class="n">m_ipMulticastTtl</span><span class="p">);</span> <span class="c1">// Convey the TTL from UDP layer to IP layer</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">AddPacketTag</span> <span class="p">(</span><span class="n">tag</span><span class="p">);</span>
</pre></div>
</div>
<p>This tag is read at the IP layer, then stripped (<code class="docutils literal notranslate"><span class="pre">src/internet/model/ipv4-l3-protocol.cc</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">m_defaultTtl</span><span class="p">;</span>
<span class="n">SocketIpTtlTag</span> <span class="n">tag</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">RemovePacketTag</span> <span class="p">(</span><span class="n">tag</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ttl</span> <span class="o">=</span> <span class="n">tag</span><span class="p">.</span><span class="n">GetTtl</span> <span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="fragmentation-and-concatenation">
<h3>Fragmentation and concatenation<a class="headerlink" href="#fragmentation-and-concatenation" title="Permalink to this headline">¶</a></h3>
<p>Packets may be fragmented or merged together.  For example, to fragment a packet
<code class="docutils literal notranslate"><span class="pre">p</span></code> of 90 bytes into two packets, one containing the first 10 bytes and the
other containing the remaining 80, one may call the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">frag0</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">CreateFragment</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">frag1</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">CreateFragment</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</pre></div>
</div>
<p>As discussed above, the packet tags from <code class="docutils literal notranslate"><span class="pre">p</span></code> will follow to both packet
fragments, and the byte tags will follow the byte ranges as needed.</p>
<p>Now, to put them back together:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">frag0</span><span class="o">-&gt;</span><span class="n">AddAtEnd</span> <span class="p">(</span><span class="n">frag1</span><span class="p">);</span>
</pre></div>
</div>
<p>Now frag0 should be equivalent to the original packet <code class="docutils literal notranslate"><span class="pre">p</span></code>.  If, however, there
were operations on the fragments before being reassembled (such as tag
operations or header operations), the new packet will not be the same.</p>
</div>
<div class="section" id="enabling-metadata">
<h3>Enabling metadata<a class="headerlink" href="#enabling-metadata" title="Permalink to this headline">¶</a></h3>
<p>We mentioned above that packets, being on-the-wire representations of byte
buffers, present a problem to print out in a structured way unless the printing
function has access to the context of the header.  For instance, consider a
tcpdump-like printer that wants to pretty-print the contents of a packet.</p>
<p>To enable this usage, packets may have metadata enabled (disabled by default for
performance reasons). This class is used by the Packet class to record every
operation performed on the packet’s buffer, and provides an implementation of
<code class="docutils literal notranslate"><span class="pre">Packet::Print</span> <span class="pre">()</span></code> method that uses the metadata to analyze the content of the
packet’s buffer.</p>
<p>The metadata is also used to perform extensive sanity checks at runtime when
performing operations on a Packet. For example, this metadata is used to verify
that when you remove a header from a packet, this same header was actually
present at the front of the packet. These errors will be detected and will abort
the program.</p>
<p>To enable this operation, users will typically insert one or both of these
statements at the beginning of their programs:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Packet</span><span class="o">::</span><span class="n">EnablePrinting</span> <span class="p">();</span>
<span class="n">Packet</span><span class="o">::</span><span class="n">EnableChecking</span> <span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sample-programs">
<h2>Sample programs<a class="headerlink" href="#sample-programs" title="Permalink to this headline">¶</a></h2>
<p>See <code class="docutils literal notranslate"><span class="pre">src/network/examples/main-packet-header.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">src/network/examples/main-packet-tag.cc</span></code>.</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="private-member-variables">
<h3>Private member variables<a class="headerlink" href="#private-member-variables" title="Permalink to this headline">¶</a></h3>
<p>A Packet object’s interface provides access to some private data:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Buffer</span> <span class="n">m_buffer</span><span class="p">;</span>
<span class="n">ByteTagList</span> <span class="n">m_byteTagList</span><span class="p">;</span>
<span class="n">PacketTagList</span> <span class="n">m_packetTagList</span><span class="p">;</span>
<span class="n">PacketMetadata</span> <span class="n">m_metadata</span><span class="p">;</span>
<span class="k">mutable</span> <span class="kt">uint32_t</span> <span class="n">m_refCount</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">m_globalUid</span><span class="p">;</span>
</pre></div>
</div>
<p>Each Packet has a Buffer and two Tags lists, a PacketMetadata object, and a ref
count. A static member variable keeps track of the UIDs allocated. The actual
uid of the packet is stored in the PacketMetadata.</p>
<p>Note:
that real network packets do not have a UID; the UID is therefore an instance of
data that normally would be stored as a Tag in the packet. However, it was felt
that a UID is a special case that is so often used in simulations that it would
be more convenient to store it in a member variable.</p>
</div>
<div class="section" id="buffer-implementation">
<h3>Buffer implementation<a class="headerlink" href="#buffer-implementation" title="Permalink to this headline">¶</a></h3>
<p>Class Buffer represents a buffer of bytes. Its size is automatically adjusted to
hold any data prepended or appended by the user. Its implementation is optimized
to ensure that the number of buffer resizes is minimized, by creating new
Buffers of the maximum size ever used.  The correct maximum size is learned at
runtime during use by recording the maximum size of each packet.</p>
<p>Authors of new Header or Trailer classes need to know the public API of the
Buffer class.  (add summary here)</p>
<p>The byte buffer is implemented as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">BufferData</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">m_count</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">m_size</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">m_initialStart</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">m_dirtyStart</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">m_dirtySize</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">m_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">BufferData</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">m_zeroAreaSize</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">m_start</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">m_size</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_count</span></code>: reference count for BufferData structure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_size</span></code>: size of data buffer stored in BufferData structure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_initialStart</span></code>: offset from start of data buffer where data
was first inserted</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_dirtyStart</span></code>: offset from start of buffer where every Buffer
which holds a reference to this BufferData instance have written data so far</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_dirtySize</span></code>: size of area where data has been written so far</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_data</span></code>: pointer to data buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buffer::m_zeroAreaSize</span></code>: size of zero area which extends before
<code class="docutils literal notranslate"><span class="pre">m_initialStart</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buffer::m_start</span></code>: offset from start of buffer to area used by this buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buffer::m_size</span></code>: size of area used by this Buffer in its BufferData
structure</p></li>
</ul>
<div class="figure align-default" id="id3">
<span id="buffer"></span><img alt="_images/buffer.png" src="_images/buffer.png" />
<p class="caption"><span class="caption-text">Implementation overview of a packet’s byte Buffer.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>This data structure is summarized in Figure <a class="reference internal" href="#buffer"><span class="std std-ref">Implementation overview of a packet’s byte Buffer.</span></a>. Each Buffer holds a
pointer to an instance of a BufferData. Most Buffers should be able to share the
same underlying BufferData and thus simply increase the BufferData’s reference
count. If they have to change the content of a BufferData inside the Dirty Area,
and if the reference count is not one, they first create a copy of the
BufferData and then complete their state-changing operation.</p>
</div>
<div class="section" id="tags-implementation">
<h3>Tags implementation<a class="headerlink" href="#tags-implementation" title="Permalink to this headline">¶</a></h3>
<p>(XXX revise me)</p>
<p>Tags are implemented by a single pointer which points to the start of a
linked list ofTagData data structures. Each TagData structure points
to the next TagData in the list (its next pointer contains zero to
indicate the end of the linked list). Each TagData contains an integer
unique id which identifies the type of the tag stored in the TagData.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">TagData</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">TagData</span> <span class="o">*</span><span class="n">m_next</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">m_id</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">m_count</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">m_data</span><span class="p">[</span><span class="n">Tags</span><span class="o">::</span><span class="n">SIZE</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Tags</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">TagData</span> <span class="o">*</span><span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Adding a tag is a matter of inserting a new TagData at the head of the linked
list. Looking at a tag requires you to find the relevant TagData in the linked
list and copy its data into the user data structure. Removing a tag and updating
the content of a tag requires a deep copy of the linked list before performing
this operation.  On the other hand, copying a Packet and its tags is a matter of
copying the TagData head pointer and incrementing its reference count.</p>
<p>Tags are found by the unique mapping between the Tag type and
its underlying id. This is why at most one instance of any Tag
can be stored in a packet. The mapping between Tag type and
underlying id is performed by a registration as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* A sample Tag implementation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">MyTag</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">m_streamId</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-management">
<h3>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h3>
<p><em>Describe dataless vs. data-full packets.</em></p>
</div>
<div class="section" id="copy-on-write-semantics">
<h3>Copy-on-write semantics<a class="headerlink" href="#copy-on-write-semantics" title="Permalink to this headline">¶</a></h3>
<p>The current implementation of the byte buffers and tag list is based on COW
(Copy On Write). An introduction to COW can be found in Scott Meyer’s “More
Effective C++”, items 17 and 29). This design feature and aspects of the public
interface borrows from the packet design of the Georgia Tech Network Simulator.
This implementation of COW uses a customized reference counting smart pointer
class.</p>
<p>What COW means is that copying packets without modifying them is very cheap (in
terms of CPU and memory usage) and modifying them can be also very cheap. What
is key for proper COW implementations is being able to detect when a given
modification of the state of a packet triggers a full copy of the data prior to
the modification: COW systems need to detect when an operation is “dirty” and
must therefore invoke a true copy.</p>
<p>Dirty operations:</p>
<ul class="simple">
<li><p>ns3::Packet::AddHeader</p></li>
<li><p>ns3::Packet::AddTrailer</p></li>
<li><p>both versions of ns3::Packet::AddAtEnd</p></li>
<li><p>ns3::Packet::RemovePacketTag</p></li>
</ul>
<p>Non-dirty operations:</p>
<ul class="simple">
<li><p>ns3::Packet::AddPacketTag</p></li>
<li><p>ns3::Packet::PeekPacketTag</p></li>
<li><p>ns3::Packet::RemoveAllPacketTags</p></li>
<li><p>ns3::Packet::AddByteTag</p></li>
<li><p>ns3::Packet::FindFirstMatchingByteTag</p></li>
<li><p>ns3::Packet::RemoveAllByteTags</p></li>
<li><p>ns3::Packet::RemoveHeader</p></li>
<li><p>ns3::Packet::RemoveTrailer</p></li>
<li><p>ns3::Packet::CreateFragment</p></li>
<li><p>ns3::Packet::RemoveAtStart</p></li>
<li><p>ns3::Packet::RemoveAtEnd</p></li>
<li><p>ns3::Packet::CopyData</p></li>
</ul>
<p>Dirty operations will always be slower than non-dirty operations, sometimes by
several orders of magnitude. However, even the dirty operations have been
optimized for common use-cases which means that most of the time, these
operations will not trigger data copies and will thus be still very fast.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Packets</a><ul>
<li><a class="reference internal" href="#packet-design-overview">Packet design overview</a></li>
<li><a class="reference internal" href="#using-the-packet-interface">Using the packet interface</a><ul>
<li><a class="reference internal" href="#creating-a-new-packet">Creating a new packet</a></li>
<li><a class="reference internal" href="#adding-and-removing-buffer-data">Adding and removing Buffer data</a></li>
<li><a class="reference internal" href="#adding-and-removing-tags">Adding and removing Tags</a></li>
<li><a class="reference internal" href="#fragmentation-and-concatenation">Fragmentation and concatenation</a></li>
<li><a class="reference internal" href="#enabling-metadata">Enabling metadata</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sample-programs">Sample programs</a></li>
<li><a class="reference internal" href="#implementation-details">Implementation details</a><ul>
<li><a class="reference internal" href="#private-member-variables">Private member variables</a></li>
<li><a class="reference internal" href="#buffer-implementation">Buffer implementation</a></li>
<li><a class="reference internal" href="#tags-implementation">Tags implementation</a></li>
<li><a class="reference internal" href="#memory-management">Memory management</a></li>
<li><a class="reference internal" href="#copy-on-write-semantics">Copy-on-write semantics</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="network.html"
                        title="previous chapter">Network Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="error-model.html"
                        title="next chapter">Error Model</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/packets.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="error-model.html" title="Error Model"
             >next</a> |</li>
        <li class="right" >
          <a href="network.html" title="Network Module"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li class="nav-item nav-item-1"><a href="network.html" >Network Module</a><span class="navelem">&nbsp;</span></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2019.
      Last updated on Apr 29, 2020 17:37.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.2.
    </div>
  </body>
</html>