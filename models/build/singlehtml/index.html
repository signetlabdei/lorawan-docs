
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Model Library</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/default.css" />
    <script src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico"
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="singlehtml";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>


  </head><body>
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" width="100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo">
              <a id="ns3_home1"
                 href="http://www.nsnam.org/">
                 <img alt="ns-3 Logo" style="background-color: unset;"
                      src="_static/ns-3-inverted-notext-small.png"/>
              </a>
            </td>
            <td id="projecttext">
              <div id="projectbrief">A Discrete-Event Network Simulator</div>
              <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
            </td>

            <td id="ns3-menu">
              <div class="menu">
                <ul >
                  <li style="background-image:none">
                    <a id="ns3_home2"
                         href="http://www.nsnam.org/"
                         >&nbsp;&nbsp;Home</a>
                  </li>
                  <li><span
                        onmouseover="mopen('mTuts')"
                        onmouseout="mclosetime()"
                          >Tutorials &nbsp;&#x25BC;</span>
                      <div id="mTuts"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_tut"
                           href="/docs/tutorial/html/index.html"
                            >English</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDocs')"
                        onmouseout="mclosetime()"
                          >Documentation &nbsp;&#x25BC;</span>
                      <div id="mDocs"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_ins"
                           href="/docs/installation/html/index.html"
                           >Installation</a><br/>
                        <a id="ns3_man"
                           href="/docs/manual/html/index.html"
                           >Manual</a><br/>
                        <a id="ns3_mod"
                           href="/docs/models/html/index.html"
                           >Models</a><br/>
                        <a id="ns3_con"
                           href="/docs/contributing/html/index.html"
                           >Contributing</a><br/>
                        <a id="ns3_wiki"
                           href="http://www.nsnam.org/wiki"
                           >Wiki</a><br/>
                      </div>
                  </li>
                  <li><span
                        onmouseover="mopen('mDev')"
                        onmouseout="mclosetime()"
                          >Development &nbsp;&#x25BC;</span>
                      <div id="mDev"
                          onmouseover="mcancelclosetime()"
                          onmouseout="mclosetime()">
                        <a id="ns3_api"
                           href="/docs/doxygen/html/index.html"
                           >API Docs</a><br/>
                        <a id="ns3_bugs"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/issues"
                           >Issue Tracker</a><br/>
                        <a id="ns3_merge"
                         href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests"
                           >Merge Requests</a><br/>
                      </div>
                  </li>
                </ul>
              </div>
            </td>

            <td id="projectsection">
              <span style="margin-right:10px">Models</span>
            </td>
          </tr>
        </tbody>
      </table>
      <script  type="text/javascript">ns3_write_links()</script>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="#">Models</a><span class="navelem">&nbsp;</span></li>

        <li class="nav-item nav-item-this"><a href="">Model Library</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="ns-3-model-library">
<h1>ns-3 Model Library<a class="headerlink" href="#ns-3-model-library" title="Link to this heading">¶</a></h1>
<p>This is the <em>ns-3 Model Library</em> documentation. Primary documentation for the ns-3 project is organized as
follows:</p>
<ul class="simple">
<li><p>Several guides that are version controlled for each release (the
<a class="reference external" href="https://www.nsnam.org/documentation/latest/">latest release</a>) and
<a class="reference external" href="https://www.nsnam.org/ns-3-dev/documentation/">development tree</a>:</p>
<ul>
<li><p>Tutorial</p></li>
<li><p>Installation Guide</p></li>
<li><p>Manual</p></li>
<li><p>Model Library <em>(this document)</em></p></li>
<li><p>Contributing Guide</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://www.nsnam.org/docs/doxygen/index.html">ns-3 Doxygen</a>: Documentation of the public APIs of
the simulator</p></li>
<li><p><a class="reference external" href="https://www.nsnam.org/wiki/Main_Page">ns-3 wiki</a></p></li>
</ul>
<p>This document is written in <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> for <a class="reference external" href="https://www.sphinx-doc.org/">Sphinx</a> and is maintained in the
<code class="docutils literal notranslate"><span class="pre">doc/models</span></code> directory of ns-3’s source code (and much of the source content is also pulled
from the <code class="docutils literal notranslate"><span class="pre">doc/</span></code> directory of each module.  Source file column width is 100 columns.</p>
<div class="toctree-wrapper compound">
<span id="document-organization"></span><section id="organization">
<h2><span class="section-number">1. </span>Organization<a class="headerlink" href="#organization" title="Link to this heading">¶</a></h2>
<p>This manual compiles documentation for <em>ns-3</em> models and supporting
software that enable users to construct network simulations.
It is important to distinguish between <strong>modules</strong> and <strong>models</strong>:</p>
<ul class="simple">
<li><p><em>ns-3</em> software is organized into separate <em>modules</em> that are each
built as a separate software library.  Individual ns-3 programs can link
the modules (libraries) they need to conduct their simulation.</p></li>
<li><p><em>ns-3</em> <em>models</em> are abstract representations of real-world objects,
protocols, devices, etc.</p></li>
</ul>
<p>An <em>ns-3</em> module may consist of more than one model (for instance, the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">internet</span></code> module contains models for both TCP and UDP).  In general,
ns-3 models do not span multiple software modules, however.</p>
<p>This manual provides documentation about the models of <em>ns-3</em>.  It
complements two other sources of documentation concerning models:</p>
<ul class="simple">
<li><p>the model APIs are documented, from a programming perspective, using
<a class="reference external" href="http://www.doxygen.org">Doxygen</a>.  Doxygen for ns-3 models is available
<a class="reference external" href="http://www.nsnam.org/docs/doxygen/index.html">on the project web server</a>.</p></li>
<li><p>the <em>ns-3</em> core is documented in the developer’s manual.  <em>ns-3</em> models make
use of the facilities of the core, such as attributes, default values,
random numbers, test frameworks, etc.  Consult the
<a class="reference external" href="http://www.nsnam.org">main web site</a> to find copies of the manual.</p></li>
</ul>
<p>Finally, additional documentation about various aspects of <em>ns-3</em> may
exist on the <a class="reference external" href="http://www.nsnam.org/wiki">project wiki</a>.</p>
<p>A sample outline of how to write model library documentation can be
found by executing the <code class="docutils literal notranslate"><span class="pre">create-module.py</span></code> program and looking at the
template created in the file <code class="docutils literal notranslate"><span class="pre">new-module/doc/new-module.rst</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>src
$<span class="w"> </span>./create-module.py<span class="w"> </span>new-module
</pre></div>
</div>
<p>The remainder of this document is organized alphabetically by module name.</p>
<p>If you are new to <em>ns-3</em>, you might first want to read below about the network
module, which contains some fundamental models for the simulator.
The packet model, models for different address formats, and abstract
base classes for objects such as nodes, net devices, channels, sockets, and
applications are discussed there.</p>
</section>
<span id="document-animation"></span><div class="toctree-wrapper compound">
</div>
<section id="animation">
<h2><span class="section-number">2. </span>Animation<a class="headerlink" href="#animation" title="Link to this heading">¶</a></h2>
<p>Animation is an important tool for network simulation. While <em>ns-3</em> does not
contain a default graphical animation tool, we currently have two ways to provide
animation, namely using the PyViz method or the NetAnim method.
The PyViz method is described in <a class="reference external" href="http://www.nsnam.org/wiki/PyViz">http://www.nsnam.org/wiki/PyViz</a>.</p>
<p>We will describe the NetAnim method briefly here.</p>
<section id="netanim">
<h3><span class="section-number">2.1. </span>NetAnim<a class="headerlink" href="#netanim" title="Link to this heading">¶</a></h3>
<p>NetAnim is a standalone, Qt5-based software executable that uses a trace file generated during
an <em>ns-3</em> simulation to display the topology and animate the packet flow between nodes.</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="_images/NetAnim_3_105.png"><img alt="_images/NetAnim_3_105.png" src="_images/NetAnim_3_105.png" style="width: 500px; height: 400px;" /></a>
<figcaption>
<p><span class="caption-text">An example of packet animation on wired-links</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In addition, NetAnim also provides useful features such as tables to display meta-data of packets like the image below</p>
<figure class="align-center" id="id2">
<a class="reference internal image-reference" href="_images/PacketStatistics.png"><img alt="_images/PacketStatistics.png" src="_images/PacketStatistics.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-text">An example of tables for packet meta-data with protocol filters</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>A way to visualize the trajectory of a mobile node</p>
<figure class="align-center" id="id3">
<a class="reference internal image-reference" href="_images/Trajectory.png"><img alt="_images/Trajectory.png" src="_images/Trajectory.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-text">An example of the trajectory of a mobile node</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>A way to display the routing-tables of multiple nodes at various points in time</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/RoutingTables.png"><img alt="_images/RoutingTables.png" src="_images/RoutingTables.png" style="width: 500px;" /></a>
</figure>
<p>A way to display counters associated with multiple nodes as a chart or a table</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/NodeCountersChart.png"><img alt="_images/NodeCountersChart.png" src="_images/NodeCountersChart.png" style="width: 500px;" /></a>
</figure>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/NodeCountersTable.png"><img alt="_images/NodeCountersTable.png" src="_images/NodeCountersTable.png" style="width: 500px;" /></a>
</figure>
<p>A way to view the timeline of packet transmit and receive events</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/PacketTimeline.png"><img alt="_images/PacketTimeline.png" src="_images/PacketTimeline.png" style="width: 500px;" /></a>
</figure>
<section id="methodology">
<h4><span class="section-number">2.1.1. </span>Methodology<a class="headerlink" href="#methodology" title="Link to this heading">¶</a></h4>
<p>The class ns3::AnimationInterface is responsible for the creation the trace XML file.
AnimationInterface uses the tracing infrastructure to track packet flows between nodes.
AnimationInterface registers itself as a trace hook for tx and rx events before the simulation
begins. When a packet is scheduled for transmission or reception, the corresponding tx and rx
trace hooks in AnimationInterface are called. When the rx hooks are called, AnimationInterface will be aware of the two endpoints between which a packet has flowed, and adds this information
to the trace file, in XML format along with the corresponding tx and rx timestamps. The XML format
will be discussed in a later section. It is important to note that AnimationInterface records a
packet only if the rx trace hooks are called. Every tx event must be matched by an rx event.</p>
</section>
<section id="downloading-netanim">
<h4><span class="section-number">2.1.2. </span>Downloading NetAnim<a class="headerlink" href="#downloading-netanim" title="Link to this heading">¶</a></h4>
<p>If NetAnim is not already available in the <em>ns-3</em> package you downloaded, you can do the following:</p>
<p>The latest version of NetAnim can be downloaded using git with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://gitlab.com/nsnam/netanim.git
</pre></div>
</div>
</section>
<section id="building-netanim">
<h4><span class="section-number">2.1.3. </span>Building NetAnim<a class="headerlink" href="#building-netanim" title="Link to this heading">¶</a></h4>
<section id="prerequisites">
<h5><span class="section-number">2.1.3.1. </span>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading">¶</a></h5>
<p>Qt5 (5.4 and over) is required to build NetAnim. The ns-3 Installation Guide
lists some packages to install for some
<a class="reference external" href="https://www.nsnam.org/docs/installation/html/linux.html#optional">Linux</a> systems,
for <cite>macOS &lt;https://www.nsnam.org/docs/installation/html/macos.html#optional&gt;</cite>, and
for <a class="reference external" href="https://www.nsnam.org/docs/installation/html/windows.html">Windows</a>.</p>
<p>The <a class="reference external" href="https://www.qt.io/download">Qt site</a> also provides download options.</p>
</section>
<section id="build-steps">
<h5><span class="section-number">2.1.3.2. </span>Build steps<a class="headerlink" href="#build-steps" title="Link to this heading">¶</a></h5>
<p>To build NetAnim use the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>netanim
$<span class="w"> </span>make<span class="w"> </span>clean
$<span class="w"> </span>qmake<span class="w"> </span>NetAnim.pro
$<span class="w"> </span>make
</pre></div>
</div>
<p>Note: qmake could be “qmake-qt5” in some systems</p>
<p>This should create an executable named “NetAnim” in the same directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="w"> </span>$<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>NetAnim
-rwxr-xr-x<span class="w"> </span><span class="m">1</span><span class="w"> </span>john<span class="w"> </span>john<span class="w"> </span><span class="m">390395</span><span class="w"> </span><span class="m">2012</span>-05-22<span class="w"> </span><span class="m">08</span>:32<span class="w"> </span>NetAnim
</pre></div>
</div>
</section>
</section>
<section id="usage">
<h4><span class="section-number">2.1.4. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>Using NetAnim is a two-step process</p>
<p>Step 1:Generate the animation XML trace file during simulation using “ns3::AnimationInterface” in the <em>ns-3</em> code base.</p>
<p>Step 2:Load the XML trace file generated in Step 1 with the offline Qt4-based animator named NetAnim.</p>
<section id="step-1-generate-xml-animation-trace-file">
<h5><span class="section-number">2.1.4.1. </span>Step 1: Generate XML animation trace file<a class="headerlink" href="#step-1-generate-xml-animation-trace-file" title="Link to this heading">¶</a></h5>
<p>The class “AnimationInterface” under “src/netanim” uses underlying <em>ns-3</em> trace sources
to construct a timestamped ASCII file in XML format.</p>
<p>Examples are found under src/netanim/examples
Example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>-d<span class="w"> </span>debug<span class="w"> </span>--enable-examples
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;dumbbell-animation&quot;</span>
</pre></div>
</div>
<p>The above will create an XML file dumbbell-animation.xml</p>
<section id="mandatory">
<h6><span class="section-number">2.1.4.1.1. </span>Mandatory<a class="headerlink" href="#mandatory" title="Link to this heading">¶</a></h6>
<ol class="arabic simple">
<li><p>Ensure that your program’s CMakeLists.txt includes the “netanim” module. An example of such a CMakeLists.txt is at src/netanim/examples/CMakeLists.txt.</p></li>
<li><p>Include the header [#include “ns3/netanim-module.h”] in your test program</p></li>
<li><p>Add the statement</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">AnimationInterface</span><span class="w"> </span><span class="n">anim</span><span class="p">(</span><span class="s">&quot;animation.xml&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// where &quot;animation.xml&quot; is any arbitrary filename</span>
</pre></div>
</div>
<p>[for versions before ns-3.13 you also have to use the line “anim.SetXMLOutput() to set the XML mode and also use anim.StartAnimation();]</p>
</section>
<section id="optional">
<h6><span class="section-number">2.1.4.1.2. </span>Optional<a class="headerlink" href="#optional" title="Link to this heading">¶</a></h6>
<p>The following are optional but useful steps:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 1</span>
<span class="n">anim</span><span class="p">.</span><span class="n">SetMobilityPollInterval</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>AnimationInterface records the position of all nodes every 250 ms by default. The statement above sets
the periodic interval at which AnimationInterface records the position of all nodes. If the nodes are
expected to move very little, it is useful to set a high mobility poll interval to avoid large XML files.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 2</span>
<span class="n">anim</span><span class="p">.</span><span class="n">SetConstantPosition</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>AnimationInterface requires that the position of all nodes be set. In <em>ns-3</em> this is done by setting an associated MobilityModel. “SetConstantPosition” is a quick way to set the x-y coordinates of a node which is stationary.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 3</span>
<span class="n">anim</span><span class="p">.</span><span class="n">SetStartTime</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">150</span><span class="p">));</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">anim</span><span class="p">.</span><span class="n">SetStopTime</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">150</span><span class="p">));</span>
</pre></div>
</div>
<p>AnimationInterface can generate large XML files. The above statements restricts the window between which AnimationInterface does tracing. Restricting the window serves to focus only on relevant portions of the simulation and creating manageably small XML files</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 4</span>
<span class="n">AnimationInterface</span><span class="w"> </span><span class="n">anim</span><span class="p">(</span><span class="s">&quot;animation.xml&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">50000</span><span class="p">);</span>
</pre></div>
</div>
<p>Using the above constructor ensures that each animation XML trace file has only 50000 packets. For example, if AnimationInterface captures 150000 packets, using the above constructor splits the capture into 3 files</p>
<ul class="simple">
<li><p>animation.xml - containing the packet range 1-50000</p></li>
<li><p>animation.xml-1 - containing the packet range 50001-100000</p></li>
<li><p>animation.xml-2 - containing the packet range 100001-150000</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 5</span>
<span class="n">anim</span><span class="p">.</span><span class="n">EnablePacketMetadata</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>With the above statement, AnimationInterface records the meta-data of each packet in the xml trace file. Metadata can be used by NetAnim to provide better statistics and filter, along with providing some brief information about the packet such as TCP sequence number or source &amp; destination IP address during packet animation.</p>
<p>CAUTION: Enabling this feature will result in larger XML trace files.
Please do NOT enable this feature when using Wimax links.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 6</span>
<span class="n">anim</span><span class="p">.</span><span class="n">UpdateNodeDescription</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Access-point&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>With the above statement, AnimationInterface assigns the text “Access-point” to node 5.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 7</span>
<span class="n">anim</span><span class="p">.</span><span class="n">UpdateNodeSize</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">);</span>
</pre></div>
</div>
<p>With the above statement, AnimationInterface sets the node size to scale by 1.5. NetAnim automatically scales the graphics view to fit the oboundaries of the topology. This means that NetAnim, can abnormally scale a node’s size too high or too low. Using AnimationInterface::UpdateNodeSize allows you to overwrite the default scaling in NetAnim and use your own custom scale.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Step 8</span>
<span class="n">anim</span><span class="p">.</span><span class="n">UpdateNodeCounter</span><span class="p">(</span><span class="mi">89</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">3.4</span><span class="p">);</span>
</pre></div>
</div>
<p>With the above statement, AnimationInterface sets the counter with Id == 89, associated with Node 7 with the value 3.4.
The counter with Id 89 is obtained using AnimationInterface::AddNodeCounter. An example usage for this is in src/netanim/examples/resource-counters.cc.</p>
</section>
</section>
<section id="step-2-loading-the-xml-in-netanim">
<h5><span class="section-number">2.1.4.2. </span>Step 2: Loading the XML in NetAnim<a class="headerlink" href="#step-2-loading-the-xml-in-netanim" title="Link to this heading">¶</a></h5>
<ol class="arabic simple">
<li><p>Assuming NetAnim was built, use the command “./NetAnim” to launch NetAnim. Please review the section “Building NetAnim” if NetAnim is not available.</p></li>
<li><p>When NetAnim is opened, click on the File open button at the top-left corner, select the XML file generated during Step 1.</p></li>
<li><p>Hit the green play button to begin animation.</p></li>
</ol>
<p>Here is a video illustrating this
<a class="reference external" href="http://www.youtube.com/watch?v=tz_hUuNwFDs">http://www.youtube.com/watch?v=tz_hUuNwFDs</a></p>
</section>
</section>
<section id="wiki">
<h4><span class="section-number">2.1.5. </span>Wiki<a class="headerlink" href="#wiki" title="Link to this heading">¶</a></h4>
<p>For detailed instructions on installing “NetAnim”, F.A.Qs and loading the XML trace file
(mentioned earlier) using NetAnim please refer:
<a class="reference external" href="http://www.nsnam.org/wiki/NetAnim">http://www.nsnam.org/wiki/NetAnim</a></p>
</section>
</section>
</section>
<span id="document-antenna"></span><section id="antenna-module">
<h2><span class="section-number">3. </span>Antenna Module<a class="headerlink" href="#antenna-module" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-antenna-design"></span><section id="design-documentation">
<h3><span class="section-number">3.1. </span>Design documentation<a class="headerlink" href="#design-documentation" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4><span class="section-number">3.1.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>The Antenna module provides:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>a class (Angles) and utility functions to deal with angles</p></li>
<li><p>a base class (AntennaModel) that provides an interface for the modeling of the radiation pattern of an antenna;</p></li>
<li><p>a set of classes derived from this base class that each models the radiation pattern of different types of antennas;</p></li>
<li><p>a base class (PhasedArrayModel) that provides a flexible interface for modeling a number of Phase Antenna Array (PAA) models</p></li>
<li><p>a class (UniformPlanarArray) derived from this base class, implementing a Uniform Planar Array (UPA) supporting both rectangular and linear lattices</p></li>
</ol>
</div></blockquote>
</section>
<section id="angles">
<h4><span class="section-number">3.1.2. </span>Angles<a class="headerlink" href="#angles" title="Link to this heading">¶</a></h4>
<p>The Angles class holds information about an angle in 3D space using spherical coordinates in radian units.
Specifically, it uses the azimuth-inclination convention, where</p>
<ul class="simple">
<li><p>Inclination is the angle between the zenith direction (positive z-axis) and the desired direction. It is included in the range [0, pi] radians.</p></li>
<li><p>Azimuth is the signed angle measured from the positive x-axis, where a positive direction goes towards the positive y-axis. It is included in the range [-pi, pi) radians.</p></li>
</ul>
<p>Multiple constructors are present, supporting the most common ways to encode information on a direction.
A static boolean variable allows the user to decide whether angles should be printed in radian or degree units.</p>
<p>A number of angle-related utilities are offered, such as radians/degree conversions, for both scalars and vectors, and angle wrapping.</p>
</section>
<section id="antennamodel">
<h4><span class="section-number">3.1.3. </span>AntennaModel<a class="headerlink" href="#antennamodel" title="Link to this heading">¶</a></h4>
<p>The AntennaModel uses the coordinate system adopted in <a class="reference internal" href="index.html#balanis" id="id1"><span>[Balanis]</span></a> and
depicted in Figure <a class="reference internal" href="#fig-antenna-coordinate-system"><span class="std std-ref">Coordinate system of the AntennaModel</span></a>. This system
is obtained by translating the Cartesian coordinate system used by the
ns-3 MobilityModel into the new origin <img class="math" src="_images/math/c99a3a8536ea2d9844720cdf27f57bde44bfe52c.png" alt="o"/> which is the location
of the antenna, and then transforming the coordinates of every generic
point <img class="math" src="_images/math/141bbefb74014fc5e43499901bf78607ae335583.png" alt="p"/> of the space from Cartesian coordinates
<img class="math" src="_images/math/bbddf8102f08f7da59439138f9804ddd226c4ff9.png" alt="(x,y,z)"/> into spherical coordinates
<img class="math" src="_images/math/18ee10acec3b85dbf40af9c510677ae1d87d715b.png" alt="(r, \theta,\phi)"/>.
The antenna model neglects the radial component <img class="math" src="_images/math/79a3d439d28652c547386f39b555d90d3aaf102d.png" alt="r"/>, and
only considers the angle components <img class="math" src="_images/math/37bbd4cc87f19f560747ab3eafaae576aa236f1a.png" alt="(\theta, \phi)"/>. An antenna
radiation pattern is then expressed as a mathematical function
<img class="math" src="_images/math/dad3038eef47dfc9bd4372f68057820cf63499d5.png" alt="g(\theta, \phi) \longrightarrow \mathcal{R}"/> that returns the
gain (in dB) for each possible direction of
transmission/reception. All angles are expressed in radians.</p>
<figure class="align-center" id="id12">
<span id="fig-antenna-coordinate-system"></span><img alt="_images/antenna-coordinate-system.png" src="_images/antenna-coordinate-system.png" />
<figcaption>
<p><span class="caption-text">Coordinate system of the AntennaModel</span><a class="headerlink" href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="single-antenna-models">
<h4><span class="section-number">3.1.4. </span>Single antenna models<a class="headerlink" href="#single-antenna-models" title="Link to this heading">¶</a></h4>
<p>In this section we describe the antenna radiation pattern models that
are included within the antenna module.</p>
<section id="isotropicantennamodel">
<h5><span class="section-number">3.1.4.1. </span>IsotropicAntennaModel<a class="headerlink" href="#isotropicantennamodel" title="Link to this heading">¶</a></h5>
<p>This antenna radiation pattern model provides a unitary gain (0 dB)
for all direction.</p>
</section>
<section id="cosineantennamodel">
<h5><span class="section-number">3.1.4.2. </span>CosineAntennaModel<a class="headerlink" href="#cosineantennamodel" title="Link to this heading">¶</a></h5>
<p>This is the cosine model described in <a class="reference internal" href="index.html#chunjian" id="id2"><span>[Chunjian]</span></a>: the antenna gain is
determined as:</p>
<div class="math">
<p><img src="_images/math/0501f83a80cfa30d9656f54e7c6e46d6795d96e4.png" alt="g(\phi, \theta) = \cos^{n} \left(\frac{\phi - \phi_{0}}{2}  \right)"/></p>
</div><p>where <img class="math" src="_images/math/a956602db46e7595fcc9cb2d525b135937059894.png" alt="\phi_{0}"/> is the azimuthal orientation of the antenna
(i.e., its direction of maximum gain) and the exponential</p>
<div class="math">
<p><img src="_images/math/8bf012f1a60ac32efe151cf00cdc403a1bdfa157.png" alt="n = -\frac{3}{20 \log_{10} \left( \cos \frac{\phi_{3dB}}{4} \right)}"/></p>
</div><p>determines the desired 3dB beamwidth <img class="math" src="_images/math/fce6d2ba692580bc0b0ceb7930982f2d493a47c2.png" alt="\phi_{3dB}"/>. Note that
this radiation pattern is independent of the inclination angle
<img class="math" src="_images/math/8a87f04e7d7cca18343c084cceca5237fae62491.png" alt="\theta"/>.</p>
<p>A major difference between the model of <a class="reference internal" href="index.html#chunjian" id="id3"><span>[Chunjian]</span></a> and the one
implemented in the class CosineAntennaModel is that only the element
factor (i.e., what described by the above formulas) is considered. In
fact, <a class="reference internal" href="index.html#chunjian" id="id4"><span>[Chunjian]</span></a> also considered an additional antenna array
factor. The reason why the latter is excluded is that we expect that
the average user would desire to specify a given beamwidth exactly,
without adding an array factor at a latter stage which would in
practice alter the effective beamwidth of the resulting radiation
pattern.</p>
</section>
<section id="parabolicantennamodel">
<h5><span class="section-number">3.1.4.3. </span>ParabolicAntennaModel<a class="headerlink" href="#parabolicantennamodel" title="Link to this heading">¶</a></h5>
<p>This model is based on the parabolic approximation of the main lobe radiation pattern. It is often used in the context of cellular system to model the radiation pattern of a cell sector, see for instance <a class="reference internal" href="index.html#r4-092042a" id="id5"><span>[R4-092042a]</span></a> and <a class="reference internal" href="index.html#calcev" id="id6"><span>[Calcev]</span></a>. The antenna gain in dB is determined as:</p>
<div class="math">
<p><img src="_images/math/61a84ea93f809aa7c07d91ce0b88ed3582713257.png" alt="g_{dB}(\phi, \theta) = -\min \left( 12 \left(\frac{\phi  - \phi_{0}}{\phi_{3dB}} \right)^2, A_{max} \right)"/></p>
</div><p>where <img class="math" src="_images/math/a956602db46e7595fcc9cb2d525b135937059894.png" alt="\phi_{0}"/> is the azimuthal orientation of the antenna
(i.e., its direction of maximum gain), <img class="math" src="_images/math/fce6d2ba692580bc0b0ceb7930982f2d493a47c2.png" alt="\phi_{3dB}"/> is its 3 dB
beamwidth, and <img class="math" src="_images/math/ba660177e8630ff885d97bcb1a73da10ef853427.png" alt="A_{max}"/> is the maximum attenuation in dB of the
antenna. Note that this radiation pattern is independent of the inclination angle
<img class="math" src="_images/math/8a87f04e7d7cca18343c084cceca5237fae62491.png" alt="\theta"/>.</p>
</section>
<section id="threegppantennamodel">
<h5><span class="section-number">3.1.4.4. </span>ThreeGppAntennaModel<a class="headerlink" href="#threegppantennamodel" title="Link to this heading">¶</a></h5>
<p>This model implements the antenna element described in <a class="footnote-reference brackets" href="#id11" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>.
Parameters are fixed from the technical report, thus no attributes nor setters are provided.
The model is largely based on the <a class="reference internal" href="#parabolicantennamodel">ParabolicAntennaModel</a>.</p>
</section>
</section>
<section id="phased-array-model">
<h4><span class="section-number">3.1.5. </span>Phased Array Model<a class="headerlink" href="#phased-array-model" title="Link to this heading">¶</a></h4>
<p>The class PhasedArrayModel has been created with flexibility in mind.
It abstracts the basic idea of a Phased Antenna Array (PAA) by removing any constraint on the
position of each element, and instead generalizes the concept of steering and beamforming vectors,
solely based on the generalized location of the antenna elements.
For details on Phased Array Antennas see for instance <a class="reference internal" href="index.html#mailloux" id="id8"><span>[Mailloux]</span></a>.</p>
<p>Derived classes must implement the following functions:</p>
<ul class="simple">
<li><p>GetNumberOfElements: returns the number of antenna elements</p></li>
<li><p>GetElementLocation: returns the location of the antenna element with the specified index, normalized with respect to the wavelength</p></li>
<li><p>GetElementFieldPattern: returns the horizontal and vertical components of the antenna element field pattern at the specified direction. Same polarization (configurable) for all antenna elements of the array is considered.</p></li>
</ul>
<p>The class PhasedArrayModel also assumes that all antenna elements are equal, a typical key assumption which allows to model the PAA field pattern as the sum of the array factor, given by the geometry of the location of the antenna elements, and the element field pattern.
Any class derived from AntennaModel is a valid antenna element for the PhasedArrayModel, allowing for a great flexibility of the framework.</p>
<section id="uniformplanararray">
<span id="gpp-antenna-model"></span><h5><span class="section-number">3.1.5.1. </span>UniformPlanarArray<a class="headerlink" href="#uniformplanararray" title="Link to this heading">¶</a></h5>
<p>The class UniformPlanarArray is a generic implementation of Uniform Planar Arrays (UPAs),
supporting rectangular and linear regular lattices.
It loosely follows the implementation described in the 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id11" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>,
considering only a single a single panel, i.e., <img class="math" src="_images/math/4ed359faa5c3c9fba1d1bfc6ef1925e6f5ea21af.png" alt="N_{g} = M_{g} = 1"/>.</p>
<p>By default, the array is orthogonal to the x-axis, pointing towards the positive
direction, but the orientation can be changed through the attributes “BearingAngle”,
which adjusts the azimuth angle, and “DowntiltAngle”, which adjusts the elevation angle.
The slant angle is instead fixed and assumed to be 0.</p>
<p>The number of antenna elements in the vertical and horizontal directions can be configured
through the attributes “NumRows” and “NumColumns”, while the spacing between the horizontal
and vertical elements can be configured through the attributes “AntennaHorizontalSpacing”
and “AntennaVerticalSpacing”.</p>
<p>The polarization of each antenna element in the array is determined by the polarization
slant angle through the attribute “PolSlantAngle”, as described in <a class="footnote-reference brackets" href="#id11" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a> (i.e., <img class="math" src="_images/math/67744a93eb9815d579a6086823ef779c602ae5c0.png" alt="{\zeta}"/>).</p>
<div role="list" class="citation-list">
<div class="citation" id="balanis" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Balanis</a><span class="fn-bracket">]</span></span>
<p>C.A. Balanis, “Antenna Theory - Analysis and Design”,  Wiley, 2nd Ed.</p>
</div>
<div class="citation" id="chunjian" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Chunjian<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id4">3</a>)</span>
<p>Li Chunjian, “Efficient Antenna Patterns for
Three-Sector WCDMA Systems”, Master of Science Thesis, Chalmers
University of Technology, Göteborg, Sweden, 2003</p>
</div>
<div class="citation" id="calcev" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">Calcev</a><span class="fn-bracket">]</span></span>
<p>George Calcev and Matt Dillon, “Antenna Tilt Control in
CDMA Networks”, in Proc. of the 2nd Annual International Wireless
Internet Conference (WICON), 2006</p>
</div>
<div class="citation" id="r4-092042a" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">R4-092042a</a><span class="fn-bracket">]</span></span>
<p>3GPP TSG RAN WG4 (Radio) Meeting #51, R4-092042, Simulation
assumptions and parameters for FDD HeNB RF requirements.</p>
</div>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id9">2</a>,<a role="doc-backlink" href="#id10">3</a>)</span>
<p>3GPP. 2018. TR 38.901, Study on channel model for frequencies from 0.5 to 100 GHz, V15.0.0. (2018-06).</p>
</aside>
</aside>
<div role="list" class="citation-list">
<div class="citation" id="mailloux" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">Mailloux</a><span class="fn-bracket">]</span></span>
<p>Robert J. Mailloux, “Phased Array Antenna Handbook”, Artech House, 2nd Ed.</p>
</div>
</div>
</section>
</section>
</section>
<span id="document-antenna-user"></span><section id="user-documentation">
<h3><span class="section-number">3.2. </span>User Documentation<a class="headerlink" href="#user-documentation" title="Link to this heading">¶</a></h3>
<p>The antenna modeled can be used with all the wireless technologies and
physical layer models that support it. Currently, this includes
the physical layer models based on the SpectrumPhy. Please refer to
the documentation of each of these models for details.</p>
</section>
<span id="document-antenna-testing"></span><section id="testing-documentation">
<h3><span class="section-number">3.3. </span>Testing Documentation<a class="headerlink" href="#testing-documentation" title="Link to this heading">¶</a></h3>
<p>In this section we describe the test suites included with the antenna
module that verify its correct functionality.</p>
<section id="angles">
<h4><span class="section-number">3.3.1. </span>Angles<a class="headerlink" href="#angles" title="Link to this heading">¶</a></h4>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">angles</span></code> verifies that the Angles class is
constructed properly by correct conversion from 3D Cartesian
coordinates according to the available methods (construction from a
single vector and from a pair of vectors). For each method, several
test cases are provided that compare the values <img class="math" src="_images/math/0ac854486d93d62a483084a2ba31f50e882d0c3a.png" alt="(\phi, \theta)"/>
determined by the constructor to known reference values. The test
passes if for each case the values are equal to the reference up to a
tolerance of <img class="math" src="_images/math/7ad35b9be4b83628d6b33155d6f4236e9914c381.png" alt="10^{-10}"/> which accounts for numerical errors.</p>
</section>
<section id="degreestoradians">
<h4><span class="section-number">3.3.2. </span>DegreesToRadians<a class="headerlink" href="#degreestoradians" title="Link to this heading">¶</a></h4>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">degrees-radians</span></code> verifies that the methods
<code class="docutils literal notranslate"><span class="pre">DegreesToRadians</span></code> and <code class="docutils literal notranslate"><span class="pre">RadiansToDegrees</span></code> work properly by
comparing with known reference values in a number of test
cases. Each test case passes if the comparison is equal up to a
tolerance of <img class="math" src="_images/math/7ad35b9be4b83628d6b33155d6f4236e9914c381.png" alt="10^{-10}"/> which accounts for numerical errors.</p>
</section>
<section id="isotropicantennamodel">
<h4><span class="section-number">3.3.3. </span>IsotropicAntennaModel<a class="headerlink" href="#isotropicantennamodel" title="Link to this heading">¶</a></h4>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">isotropic-antenna-model</span></code> checks that the
<code class="docutils literal notranslate"><span class="pre">IsotropicAntennaModel</span></code> class works properly, i.e., returns always a
0dB gain regardless of the direction.</p>
</section>
<section id="cosineantennamodel">
<h4><span class="section-number">3.3.4. </span>CosineAntennaModel<a class="headerlink" href="#cosineantennamodel" title="Link to this heading">¶</a></h4>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">cosine-antenna-model</span></code> checks that the
<code class="docutils literal notranslate"><span class="pre">CosineAntennaModel</span></code> class works properly. Several test cases are
provided that check for the antenna gain value calculated at different
directions and for different values of the orientation, the reference
gain and the beamwidth. The reference gain is calculated by hand. Each
test case passes if the reference gain in dB is equal to the value returned
by <code class="docutils literal notranslate"><span class="pre">CosineAntennaModel</span></code> within a tolerance of 0.001, which accounts
for the approximation done for the calculation of the reference
values.</p>
</section>
<section id="parabolicantennamodel">
<h4><span class="section-number">3.3.5. </span>ParabolicAntennaModel<a class="headerlink" href="#parabolicantennamodel" title="Link to this heading">¶</a></h4>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">parabolic-antenna-model</span></code> checks that the
<code class="docutils literal notranslate"><span class="pre">ParabolicAntennaModel</span></code> class works properly. Several test cases are
provided that check for the antenna gain value calculated at different
directions and for different values of the orientation, the maximum attenuation
and the beamwidth. The reference gain is calculated by hand. Each
test case passes if the reference gain in dB is equal to the value returned
by <code class="docutils literal notranslate"><span class="pre">ParabolicAntennaModel</span></code> within a tolerance of 0.001, which accounts
for the approximation done for the calculation of the reference
values.</p>
</section>
</section>
</div>
</section>
<span id="document-aodv"></span><section id="ad-hoc-on-demand-distance-vector-aodv">
<h2><span class="section-number">4. </span>Ad Hoc On-Demand Distance Vector (AODV)<a class="headerlink" href="#ad-hoc-on-demand-distance-vector-aodv" title="Link to this heading">¶</a></h2>
<p>This model implements the base specification of the Ad Hoc On-Demand
Distance Vector (AODV) protocol. The implementation is based on
<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3561.html"><strong>RFC 3561</strong></a>.</p>
<p>The model was written by Elena Buchatskaia and Pavel Boyko of ITTP RAS,
and is based on the ns-2 AODV model developed by the CMU/MONARCH group
and optimized and tuned by Samir Das and Mahesh Marina, University of
Cincinnati, and also on the AODV-UU implementation by Erik Nordström of
Uppsala University.</p>
<section id="model-description">
<h3><span class="section-number">4.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the AODV model lives in the directory <cite>src/aodv</cite>.</p>
<section id="design">
<h4><span class="section-number">4.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>Class <code class="docutils literal notranslate"><span class="pre">ns3::aodv::RoutingProtocol</span></code> implements all functionality of
service packet exchange and inherits from <code class="docutils literal notranslate"><span class="pre">ns3::Ipv4RoutingProtocol</span></code>.
The base class defines two virtual functions for packet routing and
forwarding.  The first one, <code class="docutils literal notranslate"><span class="pre">ns3::aodv::RouteOutput</span></code>, is used for
locally originated packets, and the second one, <code class="docutils literal notranslate"><span class="pre">ns3::aodv::RouteInput</span></code>,
is used for forwarding and/or delivering received packets.</p>
<p>Protocol operation depends on many adjustable parameters. Parameters for
this functionality are attributes of <code class="docutils literal notranslate"><span class="pre">ns3::aodv::RoutingProtocol</span></code>.
Parameter default values are drawn from the RFC and allow the
enabling/disabling protocol features, such as broadcasting HELLO messages,
broadcasting data packets and so on.</p>
<p>AODV discovers routes on demand.  Therefore, the AODV model buffers all
packets while a route request packet (RREQ) is disseminated.
A packet queue is implemented in aodv-rqueue.cc. A smart pointer to
the packet, <code class="docutils literal notranslate"><span class="pre">ns3::Ipv4RoutingProtocol::ErrorCallback</span></code>,
<code class="docutils literal notranslate"><span class="pre">ns3::Ipv4RoutingProtocol::UnicastForwardCallback</span></code>, and the IP header
are stored in this queue. The packet queue implements garbage collection
of old packets and a queue size limit.</p>
<p>The routing table implementation supports garbage collection of
old entries and state machine, defined in the standard.
It is implemented as a STL map container. The key is a destination IP address.</p>
<p>Some elements of protocol operation aren’t described in the RFC. These
elements generally concern cooperation of different OSI model layers.
The model uses the following heuristics:</p>
<ul class="simple">
<li><p>This AODV implementation can detect the presence of unidirectional
links and avoid them if necessary.  If the node the model receives an
RREQ for is a neighbor, the cause may be a unidirectional link.
This heuristic is taken from AODV-UU implementation and can be disabled.</p></li>
<li><p>Protocol operation strongly depends on broken link detection mechanism.
The model implements two such heuristics.  First, this implementation
support HELLO messages. However HELLO messages are not a good way to
perform neighbor sensing in a wireless environment (at least not over
802.11). Therefore, one may experience bad performance when running over
wireless.  There are several reasons for this: 1) HELLO messages are
broadcasted. In 802.11, broadcasting is often done at a
lower bit rate than unicasting, thus HELLO messages can travel further
than unicast data. 2) HELLO messages are small, thus less prone to
bit errors than data transmissions, and 3) Broadcast transmissions are
not guaranteed to be bidirectional, unlike unicast transmissions.
Second, we use layer 2 feedback when possible. Link are considered to be
broken if frame transmission results in a transmission failure for all
retries. This mechanism is meant for active links and works faster than
the first method.</p></li>
</ul>
<p>The layer 2 feedback implementation relies on the <code class="docutils literal notranslate"><span class="pre">TxErrHeader</span></code> trace source,
currently supported in AdhocWifiMac only.</p>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">4.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>The model is for IPv4 only.  The following optional protocol optimizations
are not implemented:</p>
<ol class="arabic simple">
<li><p>Local link repair.</p></li>
<li><p>RREP, RREQ and HELLO message extensions.</p></li>
</ol>
<p>These techniques require direct access to IP header, which contradicts
the assertion from the AODV RFC that AODV works over UDP.  This model uses
UDP for simplicity, hindering the ability to implement certain protocol
optimizations. The model doesn’t use low layer raw sockets because they
are not portable.</p>
</section>
<section id="future-work">
<h4><span class="section-number">4.1.3. </span>Future Work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h4>
<p>No announced plans.</p>
</section>
</section>
</section>
<span id="document-applications"></span><section id="gpp-http-applications">
<h2><span class="section-number">5. </span>3GPP HTTP applications<a class="headerlink" href="#gpp-http-applications" title="Link to this heading">¶</a></h2>
<section id="model-description">
<h3><span class="section-number">5.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The model is a part of the applications library. The HTTP model is based on a commonly
used 3GPP model in standardization <a class="reference internal" href="#id4">[4]</a>.</p>
<section id="design">
<h4><span class="section-number">5.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>This traffic generator simulates web browsing traffic using the Hypertext
Transfer Protocol (HTTP). It consists of one or more <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClient</span></code>
applications which connect to a <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServer</span></code> application. The client
models a web browser which requests web pages to the server. The server
is then responsible to serve the web pages as requested. Please refer to
<code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClientHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServerHelper</span></code> for usage instructions.</p>
<p>Technically speaking, the client transmits <em>request objects</em> to demand a
service from the server. Depending on the type of request received, the
server transmits either:</p>
<blockquote>
<div><ul class="simple">
<li><p>a <em>main object</em>, i.e., the HTML file of the web page; or</p></li>
<li><p>an <em>embedded object</em>, e.g., an image referenced by the HTML file.</p></li>
</ul>
</div></blockquote>
<p>The main and embedded object sizes are illustrated in figures <a class="reference internal" href="#fig-http-main-object-size"><span class="std std-ref">3GPP HTTP main object size histogram</span></a>
and <a class="reference internal" href="#fig-http-embedded-object-size"><span class="std std-ref">3GPP HTTP embedded object size histogram</span></a>.</p>
<figure class="align-default" id="id5" style="width: 15cm">
<span id="fig-http-main-object-size"></span><img alt="_images/http-main-object-size.png" src="_images/http-main-object-size.png" />
<figcaption>
<p><span class="caption-text">3GPP HTTP main object size histogram</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id6" style="width: 15cm">
<span id="fig-http-embedded-object-size"></span><img alt="_images/http-embedded-object-size.png" src="_images/http-embedded-object-size.png" />
<figcaption>
<p><span class="caption-text">3GPP HTTP embedded object size histogram</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p></p>
<p>A major portion of the traffic pattern is <em>reading time</em>, which does not
generate any traffic. Because of this, one may need to simulate a good
number of clients and/or sufficiently long simulation duration in order to
generate any significant traffic in the system. Reading time is illustrated in
<a class="reference internal" href="#fig-http-reading-time"><span class="std std-ref">3GPP HTTP reading time histogram</span></a>.</p>
<figure class="align-default" id="id7" style="width: 15cm">
<span id="fig-http-reading-time"></span><img alt="_images/http-reading-time.png" src="_images/http-reading-time.png" />
<figcaption>
<p><span class="caption-text">3GPP HTTP reading time histogram</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="gpp-http-server-description">
<h5><span class="section-number">5.1.1.1. </span>3GPP HTTP server description<a class="headerlink" href="#gpp-http-server-description" title="Link to this heading">¶</a></h5>
<p>3GPP HTTP server is a model application which simulates the traffic of a web server. This
application works in conjunction with <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClient</span></code> applications.</p>
<p>The application works by responding to requests. Each request is a small
packet of data which contains <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpHeader</span></code>. The value of the <em>content type</em>
field of the header determines the type of object that the client is
requesting. The possible type is either a <em>main object</em> or an <em>embedded object</em>.</p>
<p>The application is responsible to generate the right type of object and send
it back to the client. The size of each object to be sent is randomly
determined (see <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpVariables</span></code>). Each object may be sent as multiple packets
due to limited socket buffer space.</p>
<p>To assist with the transmission, the application maintains several instances
of <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServerTxBuffer</span></code>. Each instance keeps track of the object type to be
served and the number of bytes left to be sent.</p>
<p>The application accepts connection request from clients. Every connection is
kept open until the client disconnects.</p>
<p>Maximum transmission unit (MTU) size is configurable in <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServer</span></code> or in
<code class="docutils literal notranslate"><span class="pre">ThreeGppHttpVariables</span></code>. By default, the low variant is 536 bytes and high variant is 1460 bytes.
The default values are set with the intention of having a TCP header (size of which is 40 bytes) added
in the packet in such way that lower layers can avoid splitting packets. The change of MTU sizes
affects all TCP sockets after the server application has started. It is mainly visible in sizes of
packets received by <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClient</span></code> applications.</p>
</section>
<section id="gpp-http-client-description">
<h5><span class="section-number">5.1.1.2. </span>3GPP HTTP client description<a class="headerlink" href="#gpp-http-client-description" title="Link to this heading">¶</a></h5>
<p>3GPP HTTP client is a model application which simulates the traffic of a web browser. This
application works in conjunction with an ThreeGppHttpServer application.</p>
<p>In summary, the application works as follows.</p>
<ol class="arabic">
<li><p>Upon start, it opens a connection to the destination web server
(ThreeGppHttpServer).</p></li>
<li><p>After the connection is established, the application immediately requests
a <em>main object</em> from the server by sending a request packet.</p></li>
<li><p>After receiving a main object (which can take some time if it consists of
several packets), the application “parses” the main object. Parsing time
is illustrated in figure <a class="reference internal" href="#fig-http-parsing-time"><span class="std std-ref">3GPP HTTP parsing time histogram</span></a>.</p></li>
<li><p>The parsing takes a short time (randomly determined) to determine the
number of <em>embedded objects</em> (also randomly determined) in the web page.
Number of embedded object is illustrated in <a class="reference internal" href="#fig-http-num-of-embedded-objects"><span class="std std-ref">3GPP HTTP number of embedded objects histogram</span></a>.</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>If at least one embedded object is determined, the application requests</dt><dd><p>the first embedded object from the server. The request for the next
embedded object follows after the previous embedded object has been
completely received.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If there is no more embedded object to request, the application enters</dt><dd><p>the <em>reading time</em>.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Reading time is a long delay (again, randomly determined) where the
application does not induce any network traffic, thus simulating the user
reading the downloaded web page.</p></li>
<li><p>After the reading time is finished, the process repeats to step #2.</p></li>
</ol>
<figure class="align-default" id="id8" style="width: 15cm">
<span id="fig-http-parsing-time"></span><img alt="_images/http-parsing-time.png" src="_images/http-parsing-time.png" />
<figcaption>
<p><span class="caption-text">3GPP HTTP parsing time histogram</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id9" style="width: 15cm">
<span id="fig-http-num-of-embedded-objects"></span><img alt="_images/http-num-of-embedded-objects.png" src="_images/http-num-of-embedded-objects.png" />
<figcaption>
<p><span class="caption-text">3GPP HTTP number of embedded objects histogram</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The client models HTTP <em>persistent connection</em>, i.e., HTTP 1.1, where the
connection to the server is maintained and used for transmitting and receiving
all objects.</p>
<p>Each request by default has a constant size of 350 bytes. A <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpHeader</span></code>
is attached to each request packet. The header contains information
such as the content type requested (either main object or embedded object)
and the timestamp when the packet is transmitted (which will be used to
compute the delay and RTT of the packet).</p>
</section>
</section>
<section id="references">
<h4><span class="section-number">5.1.2. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<p>Many aspects of the traffic are randomly determined by <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpVariables</span></code>.
A separate instance of this object is used by the HTTP server and client applications.
These characteristics are based on a legacy 3GPP specification. The description
can be found in the following references:</p>
<p></p>
<p id="id1">[1] 3GPP TR 25.892, “Feasibility Study for Orthogonal Frequency Division Multiplexing (OFDM) for UTRAN enhancement”</p>
<p></p>
<p id="id2">[2] IEEE 802.16m, “Evaluation Methodology Document (EMD)”, IEEE 802.16m-08/004r5, July 2008.</p>
<p></p>
<p id="id3">[3] NGMN Alliance, “NGMN Radio Access Performance Evaluation Methodology”, v1.0, January 2008.</p>
<p></p>
<p id="id4">[4] 3GPP2-TSGC5, “HTTP, FTP and TCP models for 1xEV-DV simulations”, 2001.</p>
<p></p>
</section>
</section>
<section id="usage">
<h3><span class="section-number">5.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The three-gpp-http-example can be referenced to see basic usage of the HTTP applications.
In summary, using the <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServerHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClientHelper</span></code> allow the
user to easily install <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServer</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClient</span></code> applications to nodes.
The helper objects can be used to configure attribute values for the client
and server objects, but not for the <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpVariables</span></code> object. Configuration of variables
is done by modifying attributes of <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpVariables</span></code>, which should be done prior to helpers
installing applications to nodes.</p>
<p>The client and server provide a number of ns-3 trace sources such as
“Tx”, “Rx”, “RxDelay”, and “StateTransition” on the server side, and a large
number on the client side (“ConnectionEstablished”,
“ConnectionClosed”,”TxMainObjectRequest”, “TxEmbeddedObjectRequest”,
“RxMainObjectPacket”, “RxMainObject”, “RxEmbeddedObjectPacket”,
“RxEmbeddedObject”, “Rx”, “RxDelay”, “RxRtt”, “StateTransition”).</p>
<section id="building-the-3gpp-http-applications">
<h4><span class="section-number">5.2.1. </span>Building the 3GPP HTTP applications<a class="headerlink" href="#building-the-3gpp-http-applications" title="Link to this heading">¶</a></h4>
<p>Building the applications does not require any special steps to be taken. It suffices to enable
the applications module.</p>
</section>
<section id="examples">
<h4><span class="section-number">5.2.2. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>For an example demonstrating HTTP applications
run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &#39;three-gpp-http-example&#39;
</pre></div>
</div>
<p>By default, the example will print out the web page requests of the client and responses of the
server and client receiving content packets by using LOG_INFO of <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpServer</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpClient</span></code>.</p>
</section>
<section id="tests">
<h4><span class="section-number">5.2.3. </span>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h4>
<p>For testing HTTP applications, three-gpp-http-client-server-test is provided. Run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./test.py -s three-gpp-http-client-server-test
</pre></div>
</div>
<p>The test consists of simple Internet nodes having HTTP server and client applications installed.
Multiple variant scenarios are tested: delay is 3ms, 30ms or 300ms, bit error rate 0 or 5.0*10^(-6),
MTU size 536 or 1460 bytes and either IPV4 or IPV6 is used. A simulation with each combination of
these parameters is run multiple times to verify functionality with different random variables.</p>
<p>Test cases themselves are rather simple: test verifies that HTTP object packet bytes sent match
total bytes received by the client, and that <code class="docutils literal notranslate"><span class="pre">ThreeGppHttpHeader</span></code> matches the expected packet.</p>
</section>
</section>
</section>
<span id="document-bridge"></span><section id="bridge-netdevice">
<h2><span class="section-number">6. </span>Bridge NetDevice<a class="headerlink" href="#bridge-netdevice" title="Link to this heading">¶</a></h2>
<p><em>Placeholder chapter</em></p>
<p>Some examples of the use of Bridge NetDevice can be found in <code class="docutils literal notranslate"><span class="pre">examples/csma/</span></code>
directory.</p>
</section>
<span id="document-brite"></span><section id="brite-integration">
<h2><span class="section-number">7. </span>BRITE Integration<a class="headerlink" href="#brite-integration" title="Link to this heading">¶</a></h2>
<p>This model implements an interface to BRITE, the Boston university
Representative Internet Topology gEnerator <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. BRITE is a standard tool for
generating realistic internet topologies. The ns-3 model, described herein,
provides a helper class to facilitate generating ns-3 specific topologies
using BRITE configuration files. BRITE builds the original graph which is
stored as nodes and edges in the ns-3 BriteTopolgyHelper class. In the ns-3
integration of BRITE, the generator generates a topology and then provides
access to leaf nodes for each AS generated.  ns-3 users can than attach
custom topologies to these leaf nodes either by creating them manually or
using topology generators provided in ns-3.</p>
<p>There are three major types of topologies available in BRITE:  Router,
AS, and Hierarchical which is a combination of AS and Router.   For the
purposes of ns-3 simulation, the most useful are likely to be Router and
Hierarchical.  Router level topologies be generated using either the Waxman
model or the Barabasi-Albert model.  Each model has different parameters that
effect topology creation.  For flat router topologies, all nodes are considered
to be in the same AS.</p>
<p>BRITE Hierarchical topologies contain two levels.  The first is the AS level.
This level can be also be created by using either the Waxman model or the
Barabasi-Albert model.  Then for each node in the AS topology, a router level
topology is constructed.  These router level topologies can again either use
the Waxman model or the Barbasi-Albert model.  BRITE interconnects these separate
router topologies as specified by the AS level topology.  Once the hierarchical
topology is constructed, it is flattened into a large router level topology.</p>
<p>Further information can be found in the BRITE user manual: <a class="reference external" href="http://www.cs.bu.edu/brite/publications/usermanual.pdf">http://www.cs.bu.edu/brite/publications/usermanual.pdf</a></p>
<section id="model-description">
<h3><span class="section-number">7.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The model relies on building an external BRITE library,
and then building some ns-3 helpers that call out to the library.
The source code for the ns-3 helpers lives in the directory
<code class="docutils literal notranslate"><span class="pre">src/brite/helper</span></code>.</p>
<section id="design">
<h4><span class="section-number">7.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>To generate the BRITE topology, ns-3 helpers call out to the external BRITE library,
and using a standard BRITE configuration file, the BRITE code builds a graph with nodes
and edges according to this configuration file. Please see the BRITE documentation
or the example configuration files in src/brite/examples/conf_files to get a better
grasp of BRITE configuration options. The graph built by BRITE is returned to ns-3,
and a ns-3 implementation of the graph is built.  Leaf nodes for each AS are available
for the user to either attach custom topologies or install ns-3 applications directly.</p>
</section>
<section id="references">
<h4><span class="section-number">7.1.2. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Alberto Medina, Anukool Lakhina, Ibrahim Matta, and John Byers. BRITE: An Approach to Universal Topology Generation. In Proceedings of the International Workshop on Modeling, Analysis and Simulation of Computer and Telecommunications Systems- MASCOTS ‘01, Cincinnati, Ohio, August 2001.</p>
</aside>
</aside>
</section>
</section>
<section id="usage">
<h3><span class="section-number">7.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The brite-generic-example can be referenced to see basic usage of the BRITE
interface. In summary, the BriteTopologyHelper is used as the interface point
by passing in a BRITE configuration file. Along with the configuration file a
BRITE formatted random seed file can also be passed in.  If a seed file is not
passed in, the helper will create a seed file using ns-3’s UniformRandomVariable.
Once the topology has been generated by BRITE, BuildBriteTopology() is called to
create the ns-3 representation.  Next IP Address can be assigned to the topology
using either AssignIpv4Addresses() or AssignIpv6Addresses().  It should be noted
that each point-to-point link in the topology will be treated as a new network
therefore for IPV4 a /30 subnet should be used to avoid wasting a large amount of
the available address space.</p>
<p>Example BRITE configuration files can be found in /src/brite/examples/conf_files/.
ASBarbasi and ASWaxman are examples of AS only topologies.  The RTBarabasi and
RTWaxman files are examples of router only topologies.  Finally the
TD_ASBarabasi_RTWaxman configuration file is an example of a Hierarchical topology
that uses the Barabasi-Albert model for the AS level and the Waxman model for each
of the router level topologies.   Information on the BRITE parameters used in these files
can be found in the BRITE user manual.</p>
<section id="building-brite-integration">
<h4><span class="section-number">7.2.1. </span>Building BRITE Integration<a class="headerlink" href="#building-brite-integration" title="Link to this heading">¶</a></h4>
<p>The first step is to download and build the ns-3 specific BRITE repository:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>hg<span class="w"> </span>clone<span class="w"> </span>http://code.nsnam.org/BRITE
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>BRITE
$<span class="w"> </span>make
</pre></div>
</div>
<p>This will build BRITE and create a library, libbrite.so, within the BRITE
directory.</p>
<p>Once BRITE has been built successfully, we proceed to configure ns-3 with
BRITE support. Change to your ns-3 directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--with-brite<span class="o">=</span>/your/path/to/brite/source<span class="w"> </span>--enable-examples
</pre></div>
</div>
<p>Make sure it says ‘enabled’ beside ‘BRITE Integration’. If it does not, then
something has gone wrong. Either you have forgotten to build BRITE first
following the steps above, or ns-3 could not find your BRITE directory.</p>
<p>Next, build ns-3:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3
</pre></div>
</div>
</section>
<section id="examples">
<h4><span class="section-number">7.2.2. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>For an example demonstrating BRITE integration
run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s1">&#39;brite-generic-example&#39;</span>
</pre></div>
</div>
<p>By enabling the verbose parameter, the example will print out the node and
edge information in a similar format to standard BRITE output. There are
many other command-line parameters including confFile, tracing, and nix, described below:</p>
<blockquote>
<div><dl class="simple">
<dt>confFile</dt><dd><p>A BRITE configuration file. Many different BRITE configuration
file examples exist in the src/brite/examples/conf_files directory, for
example, RTBarabasi20.conf and RTWaxman.conf. Please refer to
the conf_files directory for more examples.</p>
</dd>
<dt>tracing</dt><dd><p>Enables ascii tracing.</p>
</dd>
<dt>nix</dt><dd><p>Enables nix-vector routing. Global routing is used by default.</p>
</dd>
</dl>
</div></blockquote>
<p>The generic BRITE example also support visualization using pyviz, assuming
python bindings in ns-3 are enabled:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>brite-generic-example<span class="w"> </span>--vis
</pre></div>
</div>
<p>Simulations involving BRITE can also be used with MPI.  The total number of MPI instances is
passed to the BRITE topology helper where a modulo divide is used to assign the nodes for each
AS to a MPI instance.  An example can be found in src/brite/examples:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mpirun<span class="w"> </span>-np<span class="w"> </span><span class="m">2</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>brite-MPI-example
</pre></div>
</div>
<p>Please see the ns-3 MPI documentation for information on setting up MPI with ns-3.</p>
</section>
</section>
</section>
<span id="document-buildings"></span><section id="buildings-module">
<h2><span class="section-number">8. </span>Buildings Module<a class="headerlink" href="#buildings-module" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-buildings-design"></span><p>cd .. include:: replace.txt</p>
<section id="design-documentation">
<h3><span class="section-number">8.1. </span>Design documentation<a class="headerlink" href="#design-documentation" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4><span class="section-number">8.1.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>The Buildings module provides:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>a new class (<code class="docutils literal notranslate"><span class="pre">Building</span></code>) that models the presence of a building in a simulation scenario;</p></li>
<li><p>a new class (<code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code>) that allows to specify the location, size and characteristics of buildings present in the simulated area, and allows the placement of nodes inside those buildings;</p></li>
<li><p>a container class with the definition of the most useful pathloss models and the correspondent variables called <code class="docutils literal notranslate"><span class="pre">BuildingsPropagationLossModel</span></code>.</p></li>
<li><p>a new propagation model (<code class="docutils literal notranslate"><span class="pre">HybridBuildingsPropagationLossModel</span></code>) working with the mobility model just introduced, that allows to model the phenomenon of indoor/outdoor propagation in the presence of buildings.</p></li>
<li><p>a simplified model working only with Okumura Hata (<code class="docutils literal notranslate"><span class="pre">OhBuildingsPropagationLossModel</span></code>) considering the phenomenon of indoor/outdoor propagation in the presence of buildings.</p></li>
<li><p>a channel condition model (<code class="docutils literal notranslate"><span class="pre">BuildingsChannelConditionModel</span></code>) which determined the LOS/NLOS channel condition based on the <code class="docutils literal notranslate"><span class="pre">Building</span></code> objects deployed in the scenario.</p></li>
<li><p>hybrid channel condition models (<code class="docutils literal notranslate"><span class="pre">ThreeGppV2vUrbanChannelConditionModel</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreeGppV2vHighwayChannelConditionModel</span></code>) specifically designed to model vehicular environments (more information can be found in the <a class="reference internal" href="index.html#sec-3gpp-v2v-ch-cond"><span class="std std-ref">documentation of the propagation module</span></a>)</p></li>
</ol>
</div></blockquote>
<p>The models have been designed with LTE in mind, though their implementation is in fact independent from any LTE-specific code, and can be used with other ns-3 wireless technologies as well (e.g., wifi, wimax).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">HybridBuildingsPropagationLossModel</span></code> pathloss model included is obtained through a combination of several well known pathloss models in order to mimic different environmental scenarios such as urban, suburban and open areas. Moreover, the model considers both outdoor and indoor indoor and outdoor communication has to be included since HeNB might be installed either within building and either outside. In case of indoor communication, the model has to consider also the type of building in outdoor &lt;-&gt; indoor communication according to some general criteria such as the wall penetration losses of the common materials; moreover it includes some general configuration for the internal walls in indoor communications.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">OhBuildingsPropagationLossModel</span></code> pathloss model has been created for simplifying the previous one removing the thresholds for switching from one model to other. For doing this it has been used only one propagation model from the one available (i.e., the Okumura Hata). The presence of building is still considered in the model; therefore all the considerations of above regarding the building type are still valid. The same consideration can be done for what concern the environmental scenario and frequency since both of them are parameters of the model considered.</p>
</section>
<section id="the-building-class">
<h4><span class="section-number">8.1.2. </span>The Building class<a class="headerlink" href="#the-building-class" title="Link to this heading">¶</a></h4>
<p>The model includes a specific class called <code class="docutils literal notranslate"><span class="pre">Building</span></code> which contains a ns3 <code class="docutils literal notranslate"><span class="pre">Box</span></code> class for defining the dimension of the building. In order to implements the characteristics of the pathloss models included, the <code class="docutils literal notranslate"><span class="pre">Building</span></code> class supports the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p>building type:</p>
<ul>
<li><p>Residential (default value)</p></li>
<li><p>Office</p></li>
<li><p>Commercial</p></li>
</ul>
</li>
<li><p>external walls type</p>
<ul>
<li><p>Wood</p></li>
<li><p>ConcreteWithWindows (default value)</p></li>
<li><p>ConcreteWithoutWindows</p></li>
<li><p>StoneBlocks</p></li>
</ul>
</li>
<li><p>number of floors (default value 1, which means only ground-floor)</p></li>
<li><p>number of rooms in x-axis (default value 1)</p></li>
<li><p>number of rooms in y-axis (default value 1)</p></li>
</ul>
</div></blockquote>
<p>The Building class is based on the following assumptions:</p>
<blockquote>
<div><ul class="simple">
<li><p>a buildings is represented as a rectangular parallelepiped (i.e., a box)</p></li>
<li><p>the walls are parallel to the x, y, and z axis</p></li>
<li><p>a building is divided into a grid of rooms, identified by the following parameters:</p>
<ul>
<li><p>number of floors</p></li>
<li><p>number of rooms along the x-axis</p></li>
<li><p>number of rooms along the y-axis</p></li>
</ul>
</li>
<li><p>the z axis is the vertical axis, i.e., floor numbers increase for increasing z axis values</p></li>
<li><p>the x and y room indices start from 1 and increase along the x and y axis respectively</p></li>
<li><p>all rooms in a building have equal size</p></li>
</ul>
</div></blockquote>
</section>
<section id="the-mobilitybuildinginfo-class">
<h4><span class="section-number">8.1.3. </span>The MobilityBuildingInfo class<a class="headerlink" href="#the-mobilitybuildinginfo-class" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> class, which inherits from the ns3 class <code class="docutils literal notranslate"><span class="pre">Object</span></code>, is in charge of maintaining information about the position of a node with respect to building. The information managed by <code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> is:</p>
<blockquote>
<div><ul class="simple">
<li><p>whether the node is indoor or outdoor</p></li>
<li><p>if indoor:</p>
<ul>
<li><p>in which building the node is</p></li>
<li><p>in which room the node is positioned (x, y and floor room indices)</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>The class <code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> is used by <code class="docutils literal notranslate"><span class="pre">BuildingsPropagationLossModel</span></code> class, which inherits from the ns3 class <code class="docutils literal notranslate"><span class="pre">PropagationLossModel</span></code> and manages the pathloss computation of the single components and their composition according to the nodes’ positions. Moreover, it implements also the shadowing, that is the loss due to obstacles in the main path (i.e., vegetation, buildings, etc.).</p>
<p>It is to be noted that, <code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> can be used by any other propagation model. However, based on the information at the time of this writing, only the ones defined in the building module are designed for considering the constraints introduced by the buildings.</p>
</section>
<section id="itur1238propagationlossmodel">
<h4><span class="section-number">8.1.4. </span>ItuR1238PropagationLossModel<a class="headerlink" href="#itur1238propagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This class implements a building-dependent indoor propagation loss model based on the ITU P.1238 model, which includes losses due to type of building (i.e., residential, office and commercial).
The analytical expression is given in the following.</p>
<div class="math">
<p><img src="_images/math/1b59b2d1cbefd429fd62e46a74fad923f9b43a00.png" alt="L_\mathrm{total} = 20\log f + N\log d + L_f(n)- 28 [dB]"/></p>
</div><p>where:</p>
<blockquote>
<div><p><img class="math" src="_images/math/fc14c5fe1e291426c255daa135c0be80cdeec34c.png" alt="N = \left\{ \begin{array}{lll} 28 &amp; residential \\ 30 &amp; office \\ 22 &amp; commercial\end{array} \right."/> : power loss coefficient [dB]</p>
<p><img class="math" src="_images/math/0e0a2fe57f9f090f78c7783ee8a09e70a863650e.png" alt="L_f = \left\{ \begin{array}{lll} 4n &amp; residential \\ 15+4(n-1) &amp; office \\ 6+3(n-1) &amp; commercial\end{array} \right."/></p>
<p><img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> : number of floors between base station and mobile (<img class="math" src="_images/math/969f0c92cb26b47d648011fbbe75d77fd15aed94.png" alt="n\ge 1"/>)</p>
<p><img class="math" src="_images/math/5b7752c757e0b691a80ab8227eadb8a8389dc58a.png" alt="f"/> : frequency [MHz]</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> : distance (where <img class="math" src="_images/math/db10afad5935d7bfdaef771f520a88131811e1bb.png" alt="d &gt; 1"/>) [m]</p>
</div></blockquote>
</section>
<section id="buildingspropagationlossmodel">
<h4><span class="section-number">8.1.5. </span>BuildingsPropagationLossModel<a class="headerlink" href="#buildingspropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>The BuildingsPropagationLossModel provides an additional set of building-dependent pathloss model elements that are used to implement different pathloss logics. These pathloss model elements are described in the following subsections.</p>
<section id="external-wall-loss-ewl">
<h5><span class="section-number">8.1.5.1. </span>External Wall Loss (EWL)<a class="headerlink" href="#external-wall-loss-ewl" title="Link to this heading">¶</a></h5>
<p>This component models the penetration loss through walls for indoor to outdoor communications and vice-versa. The values are taken from the <a class="reference internal" href="index.html#cost231" id="id1"><span>[cost231]</span></a> model.</p>
<blockquote>
<div><ul class="simple">
<li><p>Wood ~ 4 dB</p></li>
<li><p>Concrete with windows (not metallized) ~ 7 dB</p></li>
<li><p>Concrete without windows ~ 15 dB (spans between 10 and 20 in COST231)</p></li>
<li><p>Stone blocks ~ 12 dB</p></li>
</ul>
</div></blockquote>
</section>
<section id="internal-walls-loss-iwl">
<h5><span class="section-number">8.1.5.2. </span>Internal Walls Loss (IWL)<a class="headerlink" href="#internal-walls-loss-iwl" title="Link to this heading">¶</a></h5>
<p>This component models the penetration loss occurring in indoor-to-indoor communications within the same building. The total loss is calculated assuming that each single internal wall has a constant penetration loss <img class="math" src="_images/math/8ab801bd035b6cd02d68936001b7580fac6dbf59.png" alt="L_{siw}"/>, and approximating the number of walls that are penetrated with the manhattan distance (in number of rooms) between the transmitter and the receiver. In detail, let <img class="math" src="_images/math/5ea99039cd8359fa2e14317dbfae4497ebbc1360.png" alt="x_1"/>, <img class="math" src="_images/math/7a4a430067dab11b32cfcddbd7d7fd6b5f4d3070.png" alt="y_1"/>, <img class="math" src="_images/math/b7bda214149c6fe0d7c6c494b0c896805bf51262.png" alt="x_2"/>, <img class="math" src="_images/math/f5f424471e1f942a67eedbdbb512954c4e722fe8.png" alt="y_2"/> denote the room number along the <img class="math" src="_images/math/888f7c323ac0341871e867220ae2d76467d74d6e.png" alt="x"/> and <img class="math" src="_images/math/1b5e577d6216dca3af7d87aa122a0b9b360d6cb3.png" alt="y"/> axis respectively for user 1 and 2; the total loss <img class="math" src="_images/math/0cd88930472b30226751fa2623d58bc566b2aa9f.png" alt="L_{IWL}"/> is calculated as</p>
<div class="math">
<p><img src="_images/math/a090a1b1586d3c821c9c54c9deb22335ef91eaa8.png" alt="L_{IWL} = L_{siw} (|x_1 -x_2| + |y_1 - y_2|)"/></p>
</div></section>
<section id="height-gain-model-hg">
<h5><span class="section-number">8.1.5.3. </span>Height Gain Model (HG)<a class="headerlink" href="#height-gain-model-hg" title="Link to this heading">¶</a></h5>
<p>This component model the gain due to the fact that the transmitting device is on a floor above the ground. In the literature <a class="reference internal" href="index.html#turkmani" id="id2"><span>[turkmani]</span></a> this gain has been evaluated as about 2 dB per floor. This gain can be applied to all the indoor to outdoor communications and vice-versa.</p>
</section>
<section id="shadowing-model">
<h5><span class="section-number">8.1.5.4. </span>Shadowing Model<a class="headerlink" href="#shadowing-model" title="Link to this heading">¶</a></h5>
<p>The shadowing is modeled according to a log-normal distribution with variable standard deviation as function of the relative position (indoor or outdoor) of the MobilityModel instances involved. One random value is drawn for each pair of MobilityModels, and stays constant for that pair during the whole simulation. Thus, the model is appropriate for static nodes only.</p>
<p>The model considers that the mean of the shadowing loss in dB is always 0. For the variance, the model considers three possible values of standard deviation, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p>outdoor (<code class="docutils literal notranslate"><span class="pre">m_shadowingSigmaOutdoor</span></code>, default value of 7 dB) <img class="math" src="_images/math/0ddf75a1ca2f1bfed73cf5979d143009b4b921a9.png" alt="\rightarrow X_\mathrm{O} \sim N(\mu_\mathrm{O}, \sigma_\mathrm{O}^2)"/>.</p></li>
<li><p>indoor (<code class="docutils literal notranslate"><span class="pre">m_shadowingSigmaIndoor</span></code>, default value of 10 dB) <img class="math" src="_images/math/eaa579267af7df99970196393f33c1229867406b.png" alt="\rightarrow X_\mathrm{I} \sim N(\mu_\mathrm{I}, \sigma_\mathrm{I}^2)"/>.</p></li>
<li><p>external walls penetration (<code class="docutils literal notranslate"><span class="pre">m_shadowingSigmaExtWalls</span></code>, default value 5 dB) <img class="math" src="_images/math/e9194367755a91fb8f6dcd82c113e4287ff5e6f0.png" alt="\rightarrow X_\mathrm{W} \sim N(\mu_\mathrm{W}, \sigma_\mathrm{W}^2)"/></p></li>
</ul>
</div></blockquote>
<p>The simulator generates a shadowing value per each active link according to nodes’ position the first time the link is used for transmitting. In case of transmissions from outdoor nodes to indoor ones, and vice-versa, the standard deviation (<img class="math" src="_images/math/ec3114f58044c82a13e533d91b137cd773cd3d75.png" alt="\sigma_\mathrm{IO}"/>) has to be calculated as the square root of the sum of the quadratic values of the standard deviatio in case of outdoor nodes and the one for the external walls penetration. This is due to the fact that that the components producing the shadowing are independent of each other; therefore, the variance of a distribution resulting from the sum of two independent normal ones is the sum of the variances.</p>
<div class="math">
<p><img src="_images/math/f66f6f662c8bf14c64f7765775787154e9c10499.png" alt="X \sim N(\mu,\sigma^2) \mbox{ and } Y \sim N(\nu,\tau^2)

Z = X + Y \sim Z (\mu + \nu, \sigma^2 + \tau^2)

\Rightarrow \sigma_\mathrm{IO} = \sqrt{\sigma_\mathrm{O}^2 + \sigma_\mathrm{W}^2}"/></p>
</div></section>
</section>
<section id="pathloss-logics">
<h4><span class="section-number">8.1.6. </span>Pathloss logics<a class="headerlink" href="#pathloss-logics" title="Link to this heading">¶</a></h4>
<p>In the following we describe the different pathloss logic that are implemented by inheriting from BuildingsPropagationLossModel.</p>
<section id="hybridbuildingspropagationlossmodel">
<h5><span class="section-number">8.1.6.1. </span>HybridBuildingsPropagationLossModel<a class="headerlink" href="#hybridbuildingspropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">HybridBuildingsPropagationLossModel</span></code> pathloss model included is obtained through a combination of several well known pathloss models in order to mimic different outdoor and indoor scenarios, as well as indoor-to-outdoor and outdoor-to-indoor scenarios. In detail, the class <code class="docutils literal notranslate"><span class="pre">HybridBuildingsPropagationLossModel</span></code> integrates the following pathloss models:</p>
<blockquote>
<div><ul class="simple">
<li><p>OkumuraHataPropagationLossModel (OH) (at frequencies &gt; 2.3 GHz substituted by Kun2600MhzPropagationLossModel)</p></li>
<li><p>ItuR1411LosPropagationLossModel and ItuR1411NlosOverRooftopPropagationLossModel (I1411)</p></li>
<li><p>ItuR1238PropagationLossModel (I1238)</p></li>
<li><p>the pathloss elements of the BuildingsPropagationLossModel (EWL, HG, IWL)</p></li>
</ul>
</div></blockquote>
<p>The following pseudo-code illustrates how the different pathloss model elements described above are integrated in  <code class="docutils literal notranslate"><span class="pre">HybridBuildingsPropagationLossModel</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">txNode</span> <span class="ow">is</span> <span class="n">outdoor</span><span class="p">)</span>
  <span class="n">then</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">outdoor</span><span class="p">)</span>
      <span class="n">then</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">km</span><span class="p">)</span>
          <span class="n">then</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">or</span> <span class="n">txNode</span> <span class="ow">is</span> <span class="n">below</span> <span class="n">the</span> <span class="n">rooftop</span><span class="p">)</span>
              <span class="n">then</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span>
              <span class="k">else</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span>
          <span class="k">else</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span>
      <span class="k">else</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">indoor</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">km</span><span class="p">)</span>
          <span class="n">then</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">or</span> <span class="n">txNode</span> <span class="ow">is</span> <span class="n">below</span> <span class="n">the</span> <span class="n">rooftop</span><span class="p">)</span>
              <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span> <span class="o">+</span> <span class="n">EWL</span> <span class="o">+</span> <span class="n">HG</span>
            <span class="k">else</span>
              <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span> <span class="o">+</span> <span class="n">EWL</span> <span class="o">+</span> <span class="n">HG</span>
          <span class="k">else</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span> <span class="o">+</span> <span class="n">EWL</span> <span class="o">+</span> <span class="n">HG</span>
<span class="k">else</span> <span class="p">(</span><span class="n">txNode</span> <span class="ow">is</span> <span class="n">indoor</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">indoor</span><span class="p">)</span>
    <span class="n">then</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">same</span> <span class="n">building</span><span class="p">)</span>
        <span class="n">then</span>
          <span class="n">L</span> <span class="o">=</span> <span class="n">I1238</span> <span class="o">+</span> <span class="n">IWL</span>
        <span class="k">else</span>
          <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">EWL</span>
   <span class="k">else</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">outdoor</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">km</span><span class="p">)</span>
      <span class="n">then</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">or</span> <span class="n">txNode</span> <span class="ow">is</span> <span class="n">below</span> <span class="n">the</span> <span class="n">rooftop</span><span class="p">)</span>
              <span class="n">then</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span> <span class="o">+</span> <span class="n">EWL</span> <span class="o">+</span> <span class="n">HG</span>
              <span class="k">else</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span> <span class="o">+</span> <span class="n">EWL</span> <span class="o">+</span> <span class="n">HG</span>
      <span class="k">else</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">I1411</span> <span class="o">+</span> <span class="n">EWL</span>
</pre></div>
</div>
<p>We note that, for the case of communication between two nodes below rooftop level with distance is greater then 1 km, we still consider the I1411 model, since OH is specifically designed for macro cells and therefore for antennas above the roof-top level.</p>
<p>For the ITU-R P.1411 model we consider both the LOS and NLoS versions. In particular, we considers the LoS propagation for distances that are shorted than a tunable threshold (<code class="docutils literal notranslate"><span class="pre">m_itu1411NlosThreshold</span></code>). In case on NLoS propagation, the over the roof-top model is taken in consideration for modeling both macro BS and SC. In case on NLoS several parameters scenario dependent have been included, such as average street width, orientation, etc. The values of such parameters have to be properly set according to the scenario implemented, the model does not calculate natively their values. In case any values is provided, the standard ones are used, apart for the height of the mobile and BS, which instead their integrity is tested directly in the code (i.e., they have to be greater then zero).  In the following we give the expressions of the components of the model.</p>
<p>We also note that the use of different propagation models (OH, I1411, I1238 with their variants) in HybridBuildingsPropagationLossModel can result in discontinuities of the pathloss with respect to distance. A proper tuning of the attributes (especially the distance threshold attributes) can avoid these discontinuities. However, since the behavior of each model depends on several other parameters (frequency, node height, etc), there is no default value of these thresholds that can avoid the discontinuities in all possible configurations. Hence, an appropriate tuning of these parameters is left to the user.</p>
</section>
<section id="ohbuildingspropagationlossmodel">
<h5><span class="section-number">8.1.6.2. </span>OhBuildingsPropagationLossModel<a class="headerlink" href="#ohbuildingspropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">OhBuildingsPropagationLossModel</span></code> class has been created as a simple means to solve the discontinuity problems of <code class="docutils literal notranslate"><span class="pre">HybridBuildingsPropagationLossModel</span></code> without doing scenario-specific  parameter tuning. The solution is to use only one propagation loss model (i.e., Okumura Hata), while retaining the structure of the pathloss logic for the calculation of other path loss components (such as wall penetration losses). The result is a model that is free of discontinuities (except those due to walls), but that is less realistic overall for a generic scenario with buildings and outdoor/indoor users, e.g., because Okumura Hata is not suitable neither for indoor communications nor for outdoor communications below rooftop level.</p>
<p>In detail, the class <code class="docutils literal notranslate"><span class="pre">OhBuildingsPropagationLossModel</span></code> integrates the following pathloss models:</p>
<blockquote>
<div><ul class="simple">
<li><p>OkumuraHataPropagationLossModel (OH)</p></li>
<li><p>the pathloss elements of the BuildingsPropagationLossModel (EWL, HG, IWL)</p></li>
</ul>
</div></blockquote>
<p>The following pseudo-code illustrates how the different pathloss model elements described above are integrated in <code class="docutils literal notranslate"><span class="pre">OhBuildingsPropagationLossModel</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">txNode</span> <span class="ow">is</span> <span class="n">outdoor</span><span class="p">)</span>
  <span class="n">then</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">outdoor</span><span class="p">)</span>
      <span class="n">then</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span>
      <span class="k">else</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">indoor</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span> <span class="o">+</span> <span class="n">EWL</span>
<span class="k">else</span> <span class="p">(</span><span class="n">txNode</span> <span class="ow">is</span> <span class="n">indoor</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">indoor</span><span class="p">)</span>
    <span class="n">then</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">same</span> <span class="n">building</span><span class="p">)</span>
        <span class="n">then</span>
          <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span> <span class="o">+</span> <span class="n">IWL</span>
        <span class="k">else</span>
          <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">EWL</span>
   <span class="k">else</span> <span class="p">(</span><span class="n">rxNode</span> <span class="ow">is</span> <span class="n">outdoor</span><span class="p">)</span>
      <span class="n">L</span> <span class="o">=</span> <span class="n">OH</span> <span class="o">+</span> <span class="n">EWL</span>
</pre></div>
</div>
<p>We note that OhBuildingsPropagationLossModel is a significant simplification with respect to HybridBuildingsPropagationLossModel, due to the fact that OH is used always. While this gives a less accurate model in some scenarios (especially below rooftop and indoor), it effectively avoids the issue of pathloss discontinuities that affects HybridBuildingsPropagationLossModel.</p>
</section>
</section>
</section>
<span id="document-buildings-user"></span><section id="user-documentation">
<h3><span class="section-number">8.2. </span>User Documentation<a class="headerlink" href="#user-documentation" title="Link to this heading">¶</a></h3>
<section id="how-to-use-buildings-in-a-simulation">
<h4><span class="section-number">8.2.1. </span>How to use buildings in a simulation<a class="headerlink" href="#how-to-use-buildings-in-a-simulation" title="Link to this heading">¶</a></h4>
<p>In this section we explain the basic usage of the buildings model within a
simulation program.</p>
<section id="include-the-headers">
<h5><span class="section-number">8.2.1.1. </span>Include the headers<a class="headerlink" href="#include-the-headers" title="Link to this heading">¶</a></h5>
<p>Add this at the beginning of your simulation program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;ns3/buildings-module.h&gt;</span>
</pre></div>
</div>
</section>
<section id="create-a-building">
<h5><span class="section-number">8.2.1.2. </span>Create a building<a class="headerlink" href="#create-a-building" title="Link to this heading">¶</a></h5>
<p>As an example, let’s create a residential 10 x 20 x 10 building:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">x_min</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">double</span> <span class="n">x_max</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
<span class="n">double</span> <span class="n">y_min</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">double</span> <span class="n">y_max</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">;</span>
<span class="n">double</span> <span class="n">z_min</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">double</span> <span class="n">z_max</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Building</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Building</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">SetBoundaries</span><span class="p">(</span><span class="n">Box</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">));</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">SetBuildingType</span><span class="p">(</span><span class="n">Building</span><span class="p">::</span><span class="n">Residential</span><span class="p">);</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">SetExtWallsType</span><span class="p">(</span><span class="n">Building</span><span class="p">::</span><span class="n">ConcreteWithWindows</span><span class="p">);</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">SetNFloors</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">SetNRoomsX</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">SetNRoomsY</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>This building has three floors and an internal 3 x 2  grid of rooms of equal size.</p>
<p>The helper class GridBuildingAllocator is also available to easily
create a set of buildings with identical characteristics placed on a
rectangular grid. Here’s an example of how to use it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">GridBuildingAllocator</span><span class="o">&gt;</span>  <span class="n">gridBuildingAllocator</span><span class="p">;</span>
<span class="n">gridBuildingAllocator</span> <span class="o">=</span> <span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">GridBuildingAllocator</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;GridWidth&quot;</span><span class="p">,</span> <span class="n">UintegerValue</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;LengthX&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;LengthY&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;DeltaX&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;DeltaY&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;Height&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetBuildingAttribute</span><span class="p">(</span><span class="s2">&quot;NRoomsX&quot;</span><span class="p">,</span> <span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetBuildingAttribute</span><span class="p">(</span><span class="s2">&quot;NRoomsY&quot;</span><span class="p">,</span> <span class="n">UintegerValue</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetBuildingAttribute</span><span class="p">(</span><span class="s2">&quot;NFloors&quot;</span><span class="p">,</span> <span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;MinX&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s2">&quot;MinY&quot;</span><span class="p">,</span> <span class="n">DoubleValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">gridBuildingAllocator</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</pre></div>
</div>
<p>This will create a 3x2 grid of 6 buildings, each 7 x 13 x 6 m with 2 x
4 rooms inside and 2 foors; the buildings are spaced by 3 m on both
the x and the y axis.</p>
</section>
<section id="setup-nodes-and-mobility-models">
<h5><span class="section-number">8.2.1.3. </span>Setup nodes and mobility models<a class="headerlink" href="#setup-nodes-and-mobility-models" title="Link to this heading">¶</a></h5>
<p>Nodes and mobility models are configured as usual, however in order to
use them with the buildings model you need an additional call to
<code class="docutils literal notranslate"><span class="pre">BuildingsHelper::Install()</span></code>, so as to let the mobility model include
the information on their position w.r.t. the buildings. Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MobilityHelper</span> <span class="n">mobility</span><span class="p">;</span>
<span class="n">mobility</span><span class="o">.</span><span class="n">SetMobilityModel</span><span class="p">(</span><span class="s2">&quot;ns3::ConstantPositionMobilityModel&quot;</span><span class="p">);</span>
<span class="n">ueNodes</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">mobility</span><span class="o">.</span><span class="n">Install</span><span class="p">(</span><span class="n">ueNodes</span><span class="p">);</span>
<span class="n">BuildingsHelper</span><span class="p">::</span><span class="n">Install</span><span class="p">(</span><span class="n">ueNodes</span><span class="p">);</span>
</pre></div>
</div>
<p>It is to be noted that any mobility model can be used. However, the
user is advised to make sure that the behavior of the mobility model
being used is consistent with the presence of Buildings. For example,
using a simple random mobility over the whole simulation area in
presence of buildings might easily results in node moving in and out
of buildings, regardless of the presence of walls.</p>
<p>One dedicated buildings-aware mobility model is the
<code class="docutils literal notranslate"><span class="pre">RandomWalk2dOutdoorMobilityModel</span></code>.  This class is similar to the
<code class="docutils literal notranslate"><span class="pre">RandomWalk2dMobilityModel</span></code> but avoids placing the trajectory
on a path that would intersect a building wall.  If a boundary
is encountered (either the bounding box or a building wall), the
model rebounds with a random direction and speed that ensures that
the trajectory stays outside the buildings.  An example program
that demonstrates the use of this model is the
<code class="docutils literal notranslate"><span class="pre">src/buildings/examples/outdoor-random-walk-example.cc</span></code> which
has an associated shell script to plot the traces generated.
Another example program demonstrates how this outdoor mobility
model can be used as the basis of a group mobility model, with
the outdoor buildings-aware model serving as the parent or
reference mobility model, and with additional nodes defining a
child mobility model providing the offset from the reference
mobility model.  This example,
<code class="docutils literal notranslate"><span class="pre">src/buildings/example/outdoor-group-mobility-example.cc</span></code>,
also has an associated shell script
(<code class="docutils literal notranslate"><span class="pre">outdoor-group-mobility-animate.sh</span></code>) that can be used to generate
an animated GIF of the group’s movement.</p>
</section>
<section id="place-some-nodes">
<h5><span class="section-number">8.2.1.4. </span>Place some nodes<a class="headerlink" href="#place-some-nodes" title="Link to this heading">¶</a></h5>
<p>You can place nodes in your simulation using several methods, which
are described in the following.</p>
<section id="legacy-positioning-methods">
<h6><span class="section-number">8.2.1.4.1. </span>Legacy positioning methods<a class="headerlink" href="#legacy-positioning-methods" title="Link to this heading">¶</a></h6>
<p>Any legacy ns-3 positioning method can be used to place node in the
simulation. The important additional step is to For example, you can
place nodes manually like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">ConstantPositionMobilityModel</span><span class="o">&gt;</span> <span class="n">mm0</span> <span class="o">=</span> <span class="n">enbNodes</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">ConstantPositionMobilityModel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">ConstantPositionMobilityModel</span><span class="o">&gt;</span> <span class="n">mm1</span> <span class="o">=</span> <span class="n">enbNodes</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">ConstantPositionMobilityModel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">mm0</span><span class="o">-&gt;</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">));</span>
<span class="n">mm1</span><span class="o">-&gt;</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">));</span>

<span class="n">MobilityHelper</span> <span class="n">mobility</span><span class="p">;</span>
<span class="n">mobility</span><span class="o">.</span><span class="n">SetMobilityModel</span><span class="p">(</span><span class="s2">&quot;ns3::ConstantPositionMobilityModel&quot;</span><span class="p">);</span>
<span class="n">ueNodes</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">mobility</span><span class="o">.</span><span class="n">Install</span><span class="p">(</span><span class="n">ueNodes</span><span class="p">);</span>
<span class="n">BuildingsHelper</span><span class="p">::</span><span class="n">Install</span><span class="p">(</span><span class="n">ueNodes</span><span class="p">);</span>
<span class="n">mm0</span><span class="o">-&gt;</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">));</span>
<span class="n">mm1</span><span class="o">-&gt;</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">));</span>
</pre></div>
</div>
<p>Alternatively, you could use any existing PositionAllocator
class. The coordinates of the node will determine whether it is placed
outdoor or indoor and, if indoor, in which building and room it is placed.</p>
</section>
<section id="building-specific-positioning-methods">
<h6><span class="section-number">8.2.1.4.2. </span>Building-specific positioning methods<a class="headerlink" href="#building-specific-positioning-methods" title="Link to this heading">¶</a></h6>
<p>The following position allocator classes are available to place node
in special positions with respect to buildings:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RandomBuildingPositionAllocator</span></code>: Allocate each position by
randomly choosing a building from the list of all buildings, and
then randomly choosing a position inside the building.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RandomRoomPositionAllocator</span></code>: Allocate each position by randomly
choosing a room from the list of rooms in all buildings, and then
randomly choosing a position inside the room.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SameRoomPositionAllocator</span></code>: Walks a given NodeContainer
sequentially, and for each node allocate a new position randomly in
the same room of that node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FixedRoomPositionAllocator</span></code>: Generate a random position
uniformly distributed in the volume of a chosen room inside a
chosen building.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="making-the-mobility-model-consistent-for-a-node">
<h5><span class="section-number">8.2.1.5. </span>Making the Mobility Model Consistent for a node<a class="headerlink" href="#making-the-mobility-model-consistent-for-a-node" title="Link to this heading">¶</a></h5>
<p>Initially, a mobility model of a node is made consistent when a node is
initialized, which eventually triggers a call to the <code class="docutils literal notranslate"><span class="pre">DoInitialize</span></code>
method of the <cite>MobilityBuildingInfo`</cite> class. In particular, it calls the
<code class="docutils literal notranslate"><span class="pre">MakeMobilityModelConsistent</span></code> method, which goes through the lists of
all buildings, determine if the node is indoor or outdoor, and if indoor
it also determines the building in which the node is located and the
corresponding floor number inside the building. Moreover, this method also
caches the position of the node, which is used to make the mobility model
consistent for a moving node whenever the <code class="docutils literal notranslate"><span class="pre">IsInside</span></code> method of
<code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> class is called.</p>
</section>
<section id="building-aware-pathloss-model">
<h5><span class="section-number">8.2.1.6. </span>Building-aware pathloss model<a class="headerlink" href="#building-aware-pathloss-model" title="Link to this heading">¶</a></h5>
<p>After you placed buildings and nodes in a simulation, you can use a
building-aware pathloss model in a simulation exactly in the same way
you would use any regular path loss model. How to do this is specific
for the wireless module that you are considering (lte, wifi, wimax,
etc.), so please refer to the documentation of that model for specific
instructions.</p>
</section>
<section id="building-aware-channel-condition-models">
<h5><span class="section-number">8.2.1.7. </span>Building-aware channel condition models<a class="headerlink" href="#building-aware-channel-condition-models" title="Link to this heading">¶</a></h5>
<p>The class BuildingsChannelConditionModel implements a <a class="reference external" href="propagation.html#channelconditionmodel">channel condition model</a>
which determines the LOS/NLOS channel state based on the buildings deployed in
the scenario.
In addition, based on the wall material of the building, low/high building
penetration losses are considered, as defined in 3GPP TS 38.901 7.4.3.1.
In particular, for O2I condition, in case of Wood or ConcreteWithWindows material,
low losses are considered in the pathloss calculation. In case the material has
been set to ConcreteWithoutWindows or StoneBlocks, high losses are considered.
Notice that in certain corner cases, such as the I2O2I interference, the model
underestimates losses by applying either low or high losses based on the wall material
of the involved nodes. For a more accurate estimation the model can be further extended.</p>
<p>The classes <code class="docutils literal notranslate"><span class="pre">ThreeGppV2vUrbanChannelConditionModel</span></code> and
<code class="docutils literal notranslate"><span class="pre">ThreeGppV2vHighwayChannelConditionModel</span></code> implement hybrid channel condition
models, specifically designed to model vehicular environments.
More information can be found in the <a class="reference internal" href="index.html#sec-3gpp-v2v-ch-cond"><span class="std std-ref">documentation
of the propagation module</span></a>.</p>
</section>
</section>
<section id="main-configurable-attributes">
<h4><span class="section-number">8.2.2. </span>Main configurable attributes<a class="headerlink" href="#main-configurable-attributes" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Building</span></code> class has the following configurable parameters:</p>
<ul class="simple">
<li><p>building type: Residential, Office and Commercial.</p></li>
<li><p>external walls type: Wood, ConcreteWithWindows, ConcreteWithoutWindows and StoneBlocks.</p></li>
<li><p>building bounds: a <code class="docutils literal notranslate"><span class="pre">Box</span></code> class with the building bounds.</p></li>
<li><p>number of floors.</p></li>
<li><p>number of rooms in x-axis and y-axis (rooms can be placed only in a grid way).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">BuildingMobilityLossModel</span></code> parameter configurable with the ns3 attribute system is represented by the bound (string <code class="docutils literal notranslate"><span class="pre">Bounds</span></code>) of the simulation area by providing a <code class="docutils literal notranslate"><span class="pre">Box</span></code> class with the area bounds. Moreover, by means of its methods the following parameters can be configured:</p>
<ul class="simple">
<li><p>the number of floor the node is placed (default 0).</p></li>
<li><p>the position in the rooms grid.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">BuildingPropagationLossModel</span></code> class has the following configurable parameters configurable with the attribute system:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Frequency</span></code>: reference frequency (default 2160 MHz), note that by setting the frequency the wavelength is set accordingly automatically and vice-versa).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lambda</span></code>: the wavelength (0.139 meters, considering the above frequency).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ShadowSigmaOutdoor</span></code>: the standard deviation of the shadowing for outdoor nodes (default 7.0).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ShadowSigmaIndoor</span></code>: the standard deviation of the shadowing for indoor nodes (default 8.0).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ShadowSigmaExtWalls</span></code>: the standard deviation of the shadowing due to external walls penetration for outdoor to indoor communications (default 5.0).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RooftopLevel</span></code>: the level of the rooftop of the building in meters (default 20 meters).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Los2NlosThr</span></code>: the value of distance of the switching point between line-of-sigth and non-line-of-sight propagation model in meters (default 200 meters).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ITU1411DistanceThr</span></code>: the value of distance of the switching point between short range (ITU 1211) communications and long range (Okumura Hata) in meters (default 200 meters).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinDistance</span></code>: the minimum distance in meters between two nodes for evaluating the pathloss (considered neglictible before this threshold) (default 0.5 meters).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Environment</span></code>: the environment scenario among Urban, SubUrban and OpenAreas (default Urban).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CitySize</span></code>: the dimension of the city among Small, Medium, Large (default Large).</p></li>
</ul>
<p>In order to use the hybrid mode, the class to be used is the <code class="docutils literal notranslate"><span class="pre">HybridBuildingMobilityLossModel</span></code>, which allows the selection of the proper pathloss model according to the pathloss logic presented in the design chapter. However, this solution has the problem that the pathloss model switching points might present discontinuities due to the different characteristics of the model. This implies that according to the specific scenario, the threshold used for switching have to be properly tuned.
The simple <code class="docutils literal notranslate"><span class="pre">OhBuildingMobilityLossModel</span></code> overcome this problem by using only the Okumura Hata model and the wall penetration losses.</p>
</section>
</section>
<span id="document-buildings-testing"></span><section id="testing-documentation">
<h3><span class="section-number">8.3. </span>Testing Documentation<a class="headerlink" href="#testing-documentation" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4><span class="section-number">8.3.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>To test and validate the ns-3 Building Pathloss module, some test suites is provided which are integrated with the ns-3 test framework. To run them, you need to have configured the build of the simulator in this way:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-tests<span class="w"> </span>--enable-modules<span class="o">=</span>buildings
$<span class="w"> </span>./test.py
</pre></div>
</div>
<p>The above will run not only the test suites belonging to the buildings module, but also those belonging to all the other ns-3 modules on which the buildings module depends. See the ns-3 manual for generic information on the testing framework.</p>
<p>You can get a more detailed report in HTML format in this way:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./test.py<span class="w"> </span>-w<span class="w"> </span>results.html
</pre></div>
</div>
<p>After the above command has run, you can view the detailed result for each test by opening the file <code class="docutils literal notranslate"><span class="pre">results.html</span></code> with a web browser.</p>
<p>You can run each test suite separately using this command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>test-suite-name
</pre></div>
</div>
<p>For more details about <code class="docutils literal notranslate"><span class="pre">test.py</span></code> and the ns-3 testing framework, please refer to the ns-3 manual.</p>
</section>
<section id="description-of-the-test-suites">
<h4><span class="section-number">8.3.2. </span>Description of the test suites<a class="headerlink" href="#description-of-the-test-suites" title="Link to this heading">¶</a></h4>
<section id="buildingshelper-test">
<h5><span class="section-number">8.3.2.1. </span>BuildingsHelper test<a class="headerlink" href="#buildingshelper-test" title="Link to this heading">¶</a></h5>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">buildings-helper</span></code> checks that the method <code class="docutils literal notranslate"><span class="pre">BuildingsHelper::MakeAllInstancesConsistent</span> <span class="pre">()</span></code> works properly, i.e., that the BuildingsHelper is successful in locating if nodes are outdoor or indoor, and if indoor that they are located in the correct building, room and floor. Several test cases are provided with different buildings (having different size, position, rooms and floors) and different node positions. The test passes if each every node is located correctly.</p>
</section>
<section id="buildingpositionallocator-test">
<h5><span class="section-number">8.3.2.2. </span>BuildingPositionAllocator test<a class="headerlink" href="#buildingpositionallocator-test" title="Link to this heading">¶</a></h5>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">building-position-allocator</span></code> feature two test cases that check that respectively RandomRoomPositionAllocator and SameRoomPositionAllocator work properly. Each test cases involves a single 2x3x2 room building (total 12 rooms) at known coordinates and respectively 24 and 48 nodes. Both tests check that the number of nodes allocated in each room is the expected one and that the position of the nodes is also correct.</p>
</section>
<section id="buildings-pathloss-tests">
<h5><span class="section-number">8.3.2.3. </span>Buildings Pathloss tests<a class="headerlink" href="#buildings-pathloss-tests" title="Link to this heading">¶</a></h5>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">buildings-pathloss-model</span></code> provides different unit tests that compare the expected results of the buildings pathloss module in specific scenarios with pre calculated values obtained offline with an Octave script (test/reference/buildings-pathloss.m). The tests are considered passed if the two values are equal up to a tolerance of 0.1, which is deemed appropriate for the typical usage of pathloss values (which are in dB).</p>
<p>In the following we detailed the scenarios considered, their selection has been done for covering the wide set of possible pathloss logic combinations. The pathloss logic results therefore implicitly tested.</p>
<section id="test-1-okumura-hata">
<h6><span class="section-number">8.3.2.3.1. </span>Test #1 Okumura Hata<a class="headerlink" href="#test-1-okumura-hata" title="Link to this heading">¶</a></h6>
<p>In this test we test the standard Okumura Hata model; therefore both eNB and UE are placed outside at a distance of 2000 m. The frequency used is the E-UTRA band #5, which correspond to 869 MHz (see table 5.5-1 of 36.101). The test includes also the validation of the areas extensions (i.e., urban, suburban and open-areas) and of the city size (small, medium and large).</p>
</section>
<section id="test-2-cost231-model">
<h6><span class="section-number">8.3.2.3.2. </span>Test #2 COST231 Model<a class="headerlink" href="#test-2-cost231-model" title="Link to this heading">¶</a></h6>
<p>This test is aimed at validating the COST231 model. The test is similar to the Okumura Hata one, except that the frequency used is the EUTRA band #1 (2140 MHz) and that the test can be performed only for large and small cities in urban scenarios due to model limitations.</p>
</section>
<section id="test-3-2-6-ghz-model">
<h6><span class="section-number">8.3.2.3.3. </span>Test #3 2.6 GHz model<a class="headerlink" href="#test-3-2-6-ghz-model" title="Link to this heading">¶</a></h6>
<p>This test validates the 2.6 GHz Kun model. The test is similar to Okumura Hata one except that the frequency is the EUTRA band #7 (2620 MHz) and the test can be performed only in urban scenario.</p>
</section>
<section id="test-4-itu1411-los-model">
<h6><span class="section-number">8.3.2.3.4. </span>Test #4 ITU1411 LoS model<a class="headerlink" href="#test-4-itu1411-los-model" title="Link to this heading">¶</a></h6>
<p>This test is aimed at validating the ITU1411 model in case of line of sight within street canyons transmissions. In this case the UE is placed at 100 meters far from the eNB, since the threshold for switching between LoS and NLoS is left to default one (i.e., 200 m.).</p>
</section>
<section id="test-5-itu1411-nlos-model">
<h6><span class="section-number">8.3.2.3.5. </span>Test #5 ITU1411 NLoS model<a class="headerlink" href="#test-5-itu1411-nlos-model" title="Link to this heading">¶</a></h6>
<p>This test is aimed at validating the ITU1411 model in case of non line of sight over the rooftop transmissions. In this case the UE is placed at 900 meters far from the eNB, in order to be above the threshold for switching between LoS and NLoS is left to default one (i.e., 200 m.).</p>
</section>
<section id="test-6-itup1238-model">
<h6><span class="section-number">8.3.2.3.6. </span>Test #6 ITUP1238 model<a class="headerlink" href="#test-6-itup1238-model" title="Link to this heading">¶</a></h6>
<p>This test is aimed at validating the ITUP1238 model in case of indoor transmissions. In this case both the UE and the eNB are placed in a residential building with walls made of concrete with windows. Ue is placed at the second floor and distances 30 meters far from the eNB, which is placed at the first floor.</p>
</section>
<section id="test-7-outdoor-indoor-with-okumura-hata-model">
<h6><span class="section-number">8.3.2.3.7. </span>Test #7 Outdoor -&gt; Indoor with Okumura Hata model<a class="headerlink" href="#test-7-outdoor-indoor-with-okumura-hata-model" title="Link to this heading">¶</a></h6>
<p>This test validates the outdoor to indoor transmissions for large distances. In this case the UE is placed in a residential building with wall made of concrete with windows and distances 2000 meters from the outdoor eNB.</p>
</section>
<section id="test-8-outdoor-indoor-with-itu1411-model">
<h6><span class="section-number">8.3.2.3.8. </span>Test #8 Outdoor -&gt; Indoor with ITU1411 model<a class="headerlink" href="#test-8-outdoor-indoor-with-itu1411-model" title="Link to this heading">¶</a></h6>
<p>This test validates the outdoor to indoor transmissions for short distances. In this case the UE is placed in a residential building with walls made of concrete with windows and distances 100 meters from the outdoor eNB.</p>
</section>
<section id="test-9-indoor-outdoor-with-itu1411-model">
<h6><span class="section-number">8.3.2.3.9. </span>Test #9 Indoor -&gt; Outdoor with ITU1411 model<a class="headerlink" href="#test-9-indoor-outdoor-with-itu1411-model" title="Link to this heading">¶</a></h6>
<p>This test validates the outdoor to indoor transmissions for very short distances. In this case the eNB is placed in the second floor of a residential building with walls made of concrete with windows and distances 100 meters from the outdoor UE (i.e., LoS communication). Therefore the height gain has to be included in the pathloss evaluation.</p>
</section>
<section id="test-10-indoor-outdoor-with-itu1411-model">
<h6><span class="section-number">8.3.2.3.10. </span>Test #10 Indoor -&gt; Outdoor with ITU1411 model<a class="headerlink" href="#test-10-indoor-outdoor-with-itu1411-model" title="Link to this heading">¶</a></h6>
<p>This test validates the outdoor to indoor transmissions for short distances. In this case the eNB is placed in the second floor of a residential building with walls made of concrete with windows and distances 500 meters from the outdoor UE (i.e., NLoS communication). Therefore the height gain has to be included in the pathloss evaluation.</p>
</section>
</section>
<section id="buildings-shadowing-test">
<h5><span class="section-number">8.3.2.4. </span>Buildings Shadowing Test<a class="headerlink" href="#buildings-shadowing-test" title="Link to this heading">¶</a></h5>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">buildings-shadowing-test</span></code> is a unit test intended to verify the statistical distribution of the shadowing model implemented by <code class="docutils literal notranslate"><span class="pre">BuildingsPathlossModel</span></code>. The shadowing is modeled according to a normal distribution with mean <img class="math" src="_images/math/7ce60f266b2df2bc6b500297a81535521758494a.png" alt="\mu = 0"/> and variable standard deviation <img class="math" src="_images/math/b52df27bfb0b1e3af0c2c68a7b9da459178c2a7d.png" alt="\sigma"/>, according to models commonly used in literature. Three test cases are provided, which cover the cases of indoor, outdoor and indoor-to-outdoor communications.
Each test case generates 1000 different samples of shadowing for different pairs of MobilityModel instances in a given scenario. Shadowing values are obtained by subtracting from the total loss value returned by <code class="docutils literal notranslate"><span class="pre">HybridBuildingsPathlossModel</span></code> the path loss component which is constant and pre-determined for each test case. The test verifies that the sample mean and sample variance of the shadowing values fall within the 99% confidence interval of the sample mean and sample variance. The test also verifies that the shadowing values returned at successive times for the same pair of MobilityModel instances is constant.</p>
</section>
<section id="buildings-channel-condition-model-test">
<h5><span class="section-number">8.3.2.5. </span>Buildings Channel Condition Model Test<a class="headerlink" href="#buildings-channel-condition-model-test" title="Link to this heading">¶</a></h5>
<p>The BuildingsChannelConditionModelTestSuite tests the class BuildingsChannelConditionModel.
It checks if the channel condition between two nodes is correctly determined when a
building is deployed.</p>
</section>
</section>
</section>
<span id="document-buildings-references"></span><section id="references">
<h3><span class="section-number">8.4. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="turkmani" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>turkmani<span class="fn-bracket">]</span></span>
<p>Turkmani A.M.D., J.D. Parson and D.G. Lewis, “Radio propagation into buildings at 441, 900 and 1400 MHz”,
in Proc. of 4th Int. Conference on Land Mobile Radio, 1987.</p>
</div>
</div>
</section>
</div>
</section>
<span id="document-click"></span><section id="click-modular-router-integration">
<h2><span class="section-number">9. </span>Click Modular Router Integration<a class="headerlink" href="#click-modular-router-integration" title="Link to this heading">¶</a></h2>
<p>Click is a software architecture for building configurable routers.
By using different combinations of packet processing units called elements,
a Click router can be made to perform a specific kind of functionality.
This flexibility provides a good platform for testing and experimenting with
different protocols.</p>
<section id="model-description">
<h3><span class="section-number">9.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the Click model lives in the directory <code class="docutils literal notranslate"><span class="pre">src/click</span></code>.</p>
<section id="design">
<h4><span class="section-number">9.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>ns-3’s design is well suited for an integration with Click due to the following reasons:</p>
<ul class="simple">
<li><p>Packets in ns-3 are serialised/deserialised as they move up/down the stack. This allows ns-3 packets to be passed to and from Click as they are.</p></li>
<li><p>This also means that any kind of ns-3 traffic generator and transport should work easily on top of Click.</p></li>
<li><p>By striving to implement click as an Ipv4RoutingProtocol instance, we can avoid significant changes to the LL and MAC layer of the ns-3 code.</p></li>
</ul>
<p>The design goal was to make the ns-3-click public API simple enough such that the user needs to merely add an Ipv4ClickRouting instance to the node, and inform each Click node of the Click configuration file (.click file) that it is to use.</p>
<p>This model implements the interface to the Click Modular Router and
provides the Ipv4ClickRouting class to allow a node to use Click
for external routing. Unlike normal Ipv4RoutingProtocol sub types,
Ipv4ClickRouting doesn’t use a RouteInput() method, but instead,
receives a packet on the appropriate interface and processes it
accordingly. Note that you need to have a routing table type element
in your Click graph to use Click for external routing. This is needed
by the RouteOutput() function inherited from Ipv4RoutingProtocol.
Furthermore, a Click based node uses a different kind of L3 in the
form of Ipv4L3ClickProtocol, which is a trimmed down version of
Ipv4L3Protocol. Ipv4L3ClickProtocol passes on packets passing through
the stack to Ipv4ClickRouting for processing.</p>
<section id="developing-a-simulator-api-to-allow-ns-3-to-interact-with-click">
<h5><span class="section-number">9.1.1.1. </span>Developing a Simulator API to allow ns-3 to interact with Click<a class="headerlink" href="#developing-a-simulator-api-to-allow-ns-3-to-interact-with-click" title="Link to this heading">¶</a></h5>
<p>Much of the API is already well defined, which allows Click to probe for information from the simulator (like a Node’s ID, an Interface ID and so forth). By retaining most of the methods, it should be possible to write new implementations specific to ns-3 for the same functionality.</p>
<p>Hence, for the Click integration with ns-3, a class named Ipv4ClickRouting will handle the interaction with Click. The code for the same can be found in <code class="docutils literal notranslate"><span class="pre">src/click/model/ipv4-click-routing.{cc,h}</span></code>.</p>
</section>
<section id="packet-hand-off-between-ns-3-and-click">
<h5><span class="section-number">9.1.1.2. </span>Packet hand off between ns-3 and Click<a class="headerlink" href="#packet-hand-off-between-ns-3-and-click" title="Link to this heading">¶</a></h5>
<p>There are four kinds of packet hand-offs that can occur between ns-3 and Click.</p>
<ul class="simple">
<li><p>L4 to L3</p></li>
<li><p>L3 to L4</p></li>
<li><p>L3 to L2</p></li>
<li><p>L2 to L3</p></li>
</ul>
<p>To overcome this, we implement Ipv4L3ClickProtocol, a stripped down version of Ipv4L3Protocol. Ipv4L3ClickProtocol passes packets to and from Ipv4ClickRouting appropriately to perform routing.</p>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">9.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>In its current state, the NS-3 Click Integration is limited to use only with L3, leaving NS-3 to handle L2. We are currently working on adding Click MAC support as well. See the usage section to make sure that you design your Click graphs accordingly.</p></li>
<li><p>Furthermore, ns-3-click will work only with userlevel elements. The complete list of elements are available at <a class="reference external" href="https://web.archive.org/web/20171003052722/http://read.cs.ucla.edu/click/elements">https://web.archive.org/web/20171003052722/http://read.cs.ucla.edu/click/elements</a>. Elements that have ‘all’, ‘userlevel’ or ‘ns’ mentioned beside them may be used.</p></li>
<li><p>As of now, the ns-3 interface to Click is Ipv4 only. We will be adding Ipv6 support in the future.</p></li>
</ul>
</section>
<section id="references">
<h4><span class="section-number">9.1.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Eddie Kohler, Robert Morris, Benjie Chen, John Jannotti, and M. Frans Kaashoek. The click modular router. ACM Transactions on Computer Systems 18(3), August 2000, pages 263-297.</p></li>
<li><p>Lalith Suresh P., and Ruben Merz. Ns-3-click: click modular router integration for ns-3. In Proc. of 3rd International ICST Workshop on NS-3 (WNS3), Barcelona, Spain. March, 2011.</p></li>
<li><p>Michael Neufeld, Ashish Jain, and Dirk Grunwald. Nsclick: bridging network simulation and deployment. MSWiM ‘02: Proceedings of the 5th ACM international workshop on Modeling analysis and simulation of wireless and mobile systems, 2002, Atlanta, Georgia, USA. <a class="reference external" href="http://doi.acm.org/10.1145/570758.570772">http://doi.acm.org/10.1145/570758.570772</a></p></li>
</ul>
</section>
</section>
<section id="usage">
<h3><span class="section-number">9.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<section id="building-click">
<h4><span class="section-number">9.2.1. </span>Building Click<a class="headerlink" href="#building-click" title="Link to this heading">¶</a></h4>
<p>The first step is to clone Click from the github repository and build it:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/kohler/click
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>click/
$<span class="w"> </span>./configure<span class="w"> </span>--disable-linuxmodule<span class="w"> </span>--enable-nsclick<span class="w"> </span>--enable-wifi
$<span class="w"> </span>make
</pre></div>
</div>
<p>The –enable-wifi flag may be skipped if you don’t intend on using Click with Wifi.
* Note: You don’t need to do a ‘make install’.</p>
<p>Once Click has been built successfully, change into the ns-3 directory and
configure ns-3 with Click Integration support:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests<span class="w"> </span>--with-nsclick<span class="o">=</span>/path/to/click/source
</pre></div>
</div>
<p>Hint:  If you have click installed one directory above ns-3 (such as in the
ns-3-allinone directory), and the name of the directory is ‘click’ (or
a symbolic link to the directory is named ‘click’), then the –with-nsclick
specifier is not necessary; the ns-3 build system will successfully find
the directory.</p>
<p>If it says ‘enabled’ beside ‘NS-3 Click Integration Support’, then you’re good to go. Note: If running modular ns-3, the minimum set of modules required to run all ns-3-click examples is wifi, csma and config-store.</p>
<p>Next, try running one of the examples:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>nsclick-simple-lan
</pre></div>
</div>
<p>You may then view the resulting .pcap traces, which are named nsclick-simple-lan-0-0.pcap and nsclick-simple-lan-0-1.pcap.</p>
</section>
<section id="click-graph-instructions">
<h4><span class="section-number">9.2.2. </span>Click Graph Instructions<a class="headerlink" href="#click-graph-instructions" title="Link to this heading">¶</a></h4>
<p>The following should be kept in mind when making your Click graph:</p>
<ul class="simple">
<li><p>Only userlevel elements can be used.</p></li>
<li><p>You will need to replace FromDevice and ToDevice elements with FromSimDevice and ToSimDevice elements.</p></li>
<li><p>Packets to the kernel are sent up using ToSimDevice(tap0,IP).</p></li>
<li><p>For any node, the device which sends/receives packets to/from the kernel, is named ‘tap0’. The remaining interfaces should be named eth0, eth1 and so forth (even if you’re using wifi). Please note that the device numbering should begin from 0. In future, this will be made flexible so that users can name devices in their Click file as they wish.</p></li>
<li><p>A routing table element is a mandatory. The OUTports of the routing table element should correspond to the interface number of the device through which the packet will ultimately be sent out. Violating this rule will lead to really weird packet traces. This routing table element’s name should then be passed to the Ipv4ClickRouting protocol object as a simulation parameter. See the Click examples for details.</p></li>
<li><p>The current implementation leaves Click with mainly L3 functionality, with ns-3 handling L2. We will soon begin working to support the use of MAC protocols on Click as well. This means that as of now, Click’s Wifi specific elements cannot be used with ns-3.</p></li>
</ul>
</section>
<section id="debugging-packet-flows-from-click">
<h4><span class="section-number">9.2.3. </span>Debugging Packet Flows from Click<a class="headerlink" href="#debugging-packet-flows-from-click" title="Link to this heading">¶</a></h4>
<p>From any point within a Click graph, you may use the Print (<a class="reference external" href="https://web.archive.org/web/20171003052722/http://read.cs.ucla.edu/click/elements/print">https://web.archive.org/web/20171003052722/http://read.cs.ucla.edu/click/elements/print</a>) element and its variants for pretty printing of packet contents. Furthermore, you may generate pcap traces of packets flowing through a Click graph by using the ToDump (<a class="reference external" href="https://web.archive.org/web/20171003052722/http://read.cs.ucla.edu/click/elements/todump">https://web.archive.org/web/20171003052722/http://read.cs.ucla.edu/click/elements/todump</a>) element as well. For instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">myarpquerier</span>
<span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Print</span><span class="p">(</span><span class="n">fromarpquery</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>
<span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ToDump</span><span class="p">(</span><span class="n">out_arpquery</span><span class="p">,</span><span class="n">PER_NODE</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ethout</span><span class="p">;</span>
</pre></div>
</div>
<p>and …will print the contents of packets that flow out of the ArpQuerier, then generate a pcap trace file which will have a suffix ‘out_arpquery’, for each node using the Click file, before pushing packets onto ‘ethout’.</p>
</section>
<section id="helper">
<h4><span class="section-number">9.2.4. </span>Helper<a class="headerlink" href="#helper" title="Link to this heading">¶</a></h4>
<p>To have a node run Click, the easiest way would be to use the ClickInternetStackHelper
class in your simulation script. For instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ClickInternetStackHelper</span><span class="w"> </span><span class="n">click</span><span class="p">;</span>
<span class="n">click</span><span class="p">.</span><span class="n">SetClickFile</span><span class="p">(</span><span class="n">myNodeContainer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;nsclick-simple-lan.click&quot;</span><span class="p">);</span>
<span class="n">click</span><span class="p">.</span><span class="n">SetRoutingTableElement</span><span class="p">(</span><span class="n">myNodeContainer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;u/rt&quot;</span><span class="p">);</span>
<span class="n">click</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">myNodeContainer</span><span class="p">);</span>
</pre></div>
</div>
<p>The example scripts inside <code class="docutils literal notranslate"><span class="pre">src/click/examples/</span></code> demonstrate the use of Click based nodes
in different scenarios. The helper source can be found inside <code class="docutils literal notranslate"><span class="pre">src/click/helper/click-internet-stack-helper.{h,cc}</span></code></p>
</section>
<section id="examples">
<h4><span class="section-number">9.2.5. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The following examples have been written, which can be found in <code class="docutils literal notranslate"><span class="pre">src/click/examples/</span></code>:</p>
<ul class="simple">
<li><p>nsclick-simple-lan.cc and nsclick-raw-wlan.cc: A Click based node communicating with a normal ns-3 node without Click, using Csma and Wifi respectively. It also demonstrates the use of TCP on top of Click, something which the original nsclick implementation for NS-2 couldn’t achieve.</p></li>
<li><p>nsclick-udp-client-server-csma.cc and nsclick-udp-client-server-wifi.cc: A 3 node LAN (Csma and Wifi respectively) wherein 2 Click based nodes run a UDP client, that sends packets to a third Click based node running a UDP server.</p></li>
<li><p>nsclick-routing.cc: One Click based node communicates to another via a third node that acts as an IP router (using the IP router Click configuration). This demonstrates routing using Click.</p></li>
</ul>
<p>Scripts are available within <code class="docutils literal notranslate"><span class="pre">&lt;click-dir&gt;/conf/</span></code> that allow you to generate Click files for some common scenarios. The IP Router used in <code class="docutils literal notranslate"><span class="pre">nsclick-routing.cc</span></code> was generated from the make-ip-conf.pl file and slightly adapted to work with ns-3-click.</p>
</section>
</section>
<section id="validation">
<h3><span class="section-number">9.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>This model has been tested as follows:</p>
<ul class="simple">
<li><p>Unit tests have been written to verify the internals of Ipv4ClickRouting. This can be found in <code class="docutils literal notranslate"><span class="pre">src/click/ipv4-click-routing-test.cc</span></code>. These tests verify whether the methods inside Ipv4ClickRouting which deal with Device name to ID, IP Address from device name and Mac Address from device name bindings work as expected.</p></li>
<li><p>The examples have been used to test Click with actual simulation scenarios. These can be found in <code class="docutils literal notranslate"><span class="pre">src/click/examples/</span></code>. These tests cover the following: the use of different kinds of transports on top of Click, TCP/UDP, whether Click nodes can communicate with non-Click based nodes, whether Click nodes can communicate with each other, using Click to route packets using static routing.</p></li>
<li><p>Click has been tested with Csma, Wifi and Point-to-Point devices. Usage instructions are available in the preceding section.</p></li>
</ul>
</section>
</section>
<span id="document-csma"></span><section id="csma-netdevice">
<h2><span class="section-number">10. </span>CSMA NetDevice<a class="headerlink" href="#csma-netdevice" title="Link to this heading">¶</a></h2>
<p>This is the introduction to CSMA NetDevice chapter, to complement the CSMA model
doxygen.</p>
<section id="overview-of-the-csma-model">
<h3><span class="section-number">10.1. </span>Overview of the CSMA model<a class="headerlink" href="#overview-of-the-csma-model" title="Link to this heading">¶</a></h3>
<p>The <em>ns-3</em> CSMA device models a simple bus network in the spirit of Ethernet.
Although it does not model any real physical network you could ever build or
buy, it does provide some very useful functionality.</p>
<p>Typically when one thinks of a bus network Ethernet or IEEE 802.3 comes to mind.
Ethernet uses CSMA/CD (Carrier Sense Multiple Access with Collision Detection
with exponentially increasing backoff to contend for the shared transmission
medium. The <em>ns-3</em> CSMA device models only a portion of this process, using the
nature of the globally available channel to provide instantaneous (faster than
light) carrier sense and priority-based collision “avoidance.” Collisions in the
sense of Ethernet never happen and so the <em>ns-3</em> CSMA device does not model
collision detection, nor will any transmission in progress be “jammed.”</p>
<section id="csma-layer-model">
<h4><span class="section-number">10.1.1. </span>CSMA Layer Model<a class="headerlink" href="#csma-layer-model" title="Link to this heading">¶</a></h4>
<p>There are a number of conventions in use for describing layered communications
architectures in the literature and in textbooks. The most common layering model
is the ISO seven layer reference model. In this view the CsmaNetDevice and
CsmaChannel pair occupies the lowest two layers – at the physical (layer one),
and data link (layer two) positions. Another important reference model is that
specified by RFC 1122, “Requirements for Internet Hosts – Communication
Layers.” In this view the CsmaNetDevice and CsmaChannel pair occupies the lowest
layer – the link layer. There is also a seemingly endless litany of alternative
descriptions found in textbooks and in the literature. We adopt the naming
conventions used in the IEEE 802 standards which speak of LLC, MAC, MII and PHY
layering. These acronyms are defined as:</p>
<ul class="simple">
<li><p>LLC:  Logical Link Control;</p></li>
<li><p>MAC:  Media Access Control;</p></li>
<li><p>MII:  Media Independent Interface;</p></li>
<li><p>PHY:  Physical Layer.</p></li>
</ul>
<p>In this case the <em>LLC</em> and <em>MAC</em> are sublayers of the OSI data link layer and
the <em>MII</em> and <em>PHY</em> are sublayers of the OSI physical layer.</p>
<p>The “top” of the CSMA device defines the transition from the network layer to
the data link layer. This transition is performed by higher layers by calling
either CsmaNetDevice::Send or CsmaNetDevice::SendFrom.</p>
<p>In contrast to the IEEE 802.3 standards, there is no precisely specified PHY in
the CSMA model in the sense of wire types, signals or pinouts. The “bottom”
interface of the CsmaNetDevice can be thought of as as a kind of Media
Independent Interface (MII) as seen in the “Fast Ethernet” (IEEE 802.3u)
specifications. This MII interface fits into a corresponding media independent
interface on the CsmaChannel. You will not find the equivalent of a 10BASE-T or
a 1000BASE-LX PHY.</p>
<p>The CsmaNetDevice calls the CsmaChannel through a media independent interface.
There is a method defined to tell the channel when to start “wiggling the wires”
using the method CsmaChannel::TransmitStart, and a method to tell the channel
when the transmission process is done and the channel should begin propagating
the last bit across the “wire”: CsmaChannel::TransmitEnd.</p>
<p>When the TransmitEnd method is executed, the channel will model a single uniform
signal propagation delay in the medium and deliver copes of the packet to each
of the devices attached to the packet via the CsmaNetDevice::Receive method.</p>
<p>There is a “pin” in the device media independent interface corresponding to
“COL” (collision). The state of the channel may be sensed by calling
CsmaChannel::GetState. Each device will look at this “pin” before starting a
send and will perform appropriate backoff operations if required.</p>
<p>Properly received packets are forwarded up to higher levels from the
CsmaNetDevice via a callback mechanism. The callback function is initialized by
the higher layer (when the net device is attached) using
CsmaNetDevice::SetReceiveCallback and is invoked upon “proper” reception of a
packet by the net device in order to forward the packet up
the protocol stack.</p>
</section>
</section>
<section id="csma-channel-model">
<h3><span class="section-number">10.2. </span>CSMA Channel Model<a class="headerlink" href="#csma-channel-model" title="Link to this heading">¶</a></h3>
<p>The class CsmaChannel models the actual transmission medium. There is no fixed
limit for the number of devices connected to the channel. The CsmaChannel models
a data rate and a speed-of-light delay which can be accessed via the attributes
“DataRate” and “Delay” respectively. The data rate provided to the channel is
used to set the data rates used by the transmitter sections of the CSMA devices
connected to the channel. There is no way to independently set data rates in the
devices. Since the data rate is only used to calculate a delay time, there is no
limitation (other than by the data type holding the value) on the speed at which
CSMA channels and devices can operate; and no restriction based on any kind of
PHY characteristics.</p>
<p>The CsmaChannel has three states, <code class="docutils literal notranslate"><span class="pre">IDLE</span></code>, <code class="docutils literal notranslate"><span class="pre">TRANSMITTING</span></code> and
<code class="docutils literal notranslate"><span class="pre">PROPAGATING</span></code>. These three states are “seen” instantaneously by all devices on
the channel. By this we mean that if one device begins or ends a simulated
transmission, all devices on the channel are <em>immediately</em> aware of the
change in state. There is no time during which one device may see an <code class="docutils literal notranslate"><span class="pre">IDLE</span></code>
channel while another device physically further away in the collision domain may
have begun transmitting with the associated signals not propagated down the
channel to other devices. Thus there is no need for collision detection in the
CsmaChannel model and it is not implemented in any way.</p>
<p>We do, as the name indicates, have a Carrier Sense aspect to the model.  Since
the simulator is single threaded, access to the common channel will be
serialized by the simulator. This provides a deterministic mechanism for
contending for the channel. The channel is allocated (transitioned from state
<code class="docutils literal notranslate"><span class="pre">IDLE</span></code> to state <code class="docutils literal notranslate"><span class="pre">TRANSMITTING</span></code>) on a first-come first-served basis.
The channel always goes through a three state process:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IDLE</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">TRANSMITTING</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">PROPAGATING</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IDLE</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TRANSMITTING</span></code> state models the time during which the source net device is
actually wiggling the signals on the wire. The <code class="docutils literal notranslate"><span class="pre">PROPAGATING</span></code> state models the
time after the last bit was sent, when the signal is propagating down the wire
to the “far end.”</p>
<p>The transition to the <code class="docutils literal notranslate"><span class="pre">TRANSMITTING</span></code> state is  driven by a call to
CsmaChannel::TransmitStart which is called by the net device that transmits the
packet. It is the responsibility of that device to end the transmission with a
call to CsmaChannel::TransmitEnd at the appropriate simulation time that
reflects the time elapsed to put all of the packet bits on the wire. When
TransmitEnd is called, the channel schedules an event corresponding to a single
speed-of-light delay. This delay applies to all net devices on the channel
identically. You can think of a symmetrical hub in which the packet bits
propagate to a central location and then back out equal length cables to the
other devices on the channel. The single “speed of light” delay then corresponds
to the time it takes for: 1) a signal to propagate from one CsmaNetDevice
through its cable to the hub; plus 2) the time it takes for the hub to forward
the packet out a port; plus 3) the time it takes for the signal in question to
propagate to the destination net device.</p>
<p>The CsmaChannel models a broadcast medium so the packet is delivered to all of
the devices on the channel (including the source) at the end of the propagation
time. It is the responsibility of the sending device to determine whether or not
it receives a packet broadcast over the channel.</p>
<p>The CsmaChannel provides following Attributes:</p>
<ul class="simple">
<li><p>DataRate:  The bitrate for packet transmission on connected devices;</p></li>
<li><p>Delay: The speed of light transmission delay for the channel.</p></li>
</ul>
</section>
<section id="csma-net-device-model">
<h3><span class="section-number">10.3. </span>CSMA Net Device Model<a class="headerlink" href="#csma-net-device-model" title="Link to this heading">¶</a></h3>
<p>The CSMA network device appears somewhat like an Ethernet device. The
CsmaNetDevice provides following Attributes:</p>
<ul class="simple">
<li><p>Address:  The Mac48Address of the device;</p></li>
<li><p>SendEnable:  Enable packet transmission if true;</p></li>
<li><p>ReceiveEnable:  Enable packet reception if true;</p></li>
<li><p>EncapsulationMode:  Type of link layer encapsulation to use;</p></li>
<li><p>RxErrorModel:  The receive error model;</p></li>
<li><p>TxQueue:  The transmit queue used by the device;</p></li>
<li><p>InterframeGap:  The optional time to wait between “frames”;</p></li>
<li><p>Rx:  A trace source for received packets;</p></li>
<li><p>Drop:  A trace source for dropped packets.</p></li>
</ul>
<p>The CsmaNetDevice supports the assignment of a “receive error model.” This is an
ErrorModel object that is used to simulate data corruption on the link.</p>
<p>Packets sent over the CsmaNetDevice are always routed through the transmit queue
to provide a trace hook for packets sent out over the network. This transmit
queue can be set (via attribute) to model different queuing strategies.</p>
<p>Also configurable by attribute is the encapsulation method used by the device.
Every packet gets an EthernetHeader that includes the destination and source MAC
addresses, and a length/type field. Every packet also gets an EthernetTrailer
which includes the FCS. Data in the packet may be encapsulated in different
ways.</p>
<p>By default, or by setting the “EncapsulationMode” attribute to “Dix”, the
encapsulation is according to the DEC, Intel, Xerox standard. This is sometimes
called EthernetII framing and is the familiar destination MAC, source MAC,
EtherType, Data, CRC format.</p>
<p>If the “EncapsulationMode” attribute is set to “Llc”, the encapsulation is by
LLC SNAP. In this case, a SNAP header is added that contains the EtherType (IP
or ARP).</p>
<p>The other implemented encapsulation modes are IP_ARP (set “EncapsulationMode” to
“IpArp”) in which the length type of the Ethernet header receives the protocol
number of the packet; or ETHERNET_V1 (set “EncapsulationMode” to “EthernetV1”)
in which the length type of the Ethernet header receives the length of the
packet.  A “Raw” encapsulation mode is defined but not implemented – use of the
RAW mode results in an assertion.</p>
<p>Note that all net devices on a channel must be set to the same encapsulation
mode for correct results. The encapsulation mode is not sensed at the receiver.</p>
<p>The CsmaNetDevice implements a random exponential backoff algorithm that is
executed if the channel is determined to be busy (<code class="docutils literal notranslate"><span class="pre">TRANSMITTING</span></code> or
<code class="docutils literal notranslate"><span class="pre">PPROPAGATING</span></code>) when the device wants to start propagating. This results in a
random delay of up to pow (2, retries) - 1 microseconds before a retry is
attempted. The default maximum number of retries is 1000.</p>
</section>
<section id="using-the-csmanetdevice">
<h3><span class="section-number">10.4. </span>Using the CsmaNetDevice<a class="headerlink" href="#using-the-csmanetdevice" title="Link to this heading">¶</a></h3>
<p>The CSMA net devices and channels are typically created and configured using the
associated <code class="docutils literal notranslate"><span class="pre">CsmaHelper</span></code> object.  The various <em>ns-3</em> device helpers generally
work in a similar way, and their use is seen in many of our example programs.</p>
<p>The conceptual model of interest is that of a bare computer “husk” into which
you plug net devices. The bare computers are created using a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>
helper. You just ask this helper to create as many computers (we call them
<code class="docutils literal notranslate"><span class="pre">Nodes</span></code>) as you need on your network:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">csmaNodes</span><span class="p">;</span>
<span class="n">csmaNodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">nCsmaNodes</span><span class="p">);</span>
</pre></div>
</div>
<p>Once you have your nodes, you need to instantiate a <code class="docutils literal notranslate"><span class="pre">CsmaHelper</span></code> and set any
attributes you may want to change.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">CsmaHelper</span><span class="w"> </span><span class="n">csma</span><span class="p">;</span>
<span class="n">csma</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;100Mbps&quot;</span><span class="p">));</span>
<span class="n">csma</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">NanoSeconds</span><span class="p">(</span><span class="mi">6560</span><span class="p">)));</span>

<span class="n">csma</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;EncapsulationMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;Dix&quot;</span><span class="p">));</span>
<span class="n">csma</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;FrameSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2000</span><span class="p">));</span>
</pre></div>
</div>
<p>Once the attributes are set, all that remains is to create the devices and
install them on the required nodes, and to connect the devices together using a
CSMA channel. When we create the net devices, we add them to a container to
allow you to use them in the future. This all takes just one line of code.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">csmaDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csma</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">csmaNodes</span><span class="p">);</span>
</pre></div>
</div>
<p>We recommend thinking carefully about changing these Attributes, since
it can result in behavior that surprises users.  We allow this because
we believe flexibility is important.  As an example of a possibly
surprising effect of changing Attributes, consider the following:</p>
<p>The Mtu Attribute indicates the Maximum Transmission Unit to the device.
This is the size of the largest Protocol Data Unit (PDU) that the
device can send.  This Attribute defaults to 1500 bytes and corresponds
to a number found in RFC 894, “A Standard for the Transmission of IP
Datagrams over Ethernet Networks.”  The number is actually derived
from the maximum packet size for 10Base5 (full-spec Ethernet) networks –
1518 bytes.  If you subtract DIX encapsulation overhead for Ethernet
packets (18 bytes) you will end up with a maximum possible data size (MTU)
of 1500 bytes.  One can also find that the MTU for IEEE 802.3 networks
is 1492 bytes.  This is because LLC/SNAP encapsulation adds an extra eight
bytes of overhead to the packet.  In both cases, the underlying network
hardware is limited to 1518 bytes, but the MTU is different because the
encapsulation is different.</p>
<p>If one leaves the Mtu Attribute at 1500 bytes and changes the encapsulation
mode Attribute to Llc, the result will be a network that encapsulates 1500
byte PDUs with LLC/SNAP framing resulting in packets of 1526 bytes.  This
would be illegal in many networks, but we allow you do do this.  This
results in a simulation that quite subtly does not reflect what you might
be expecting since a real device would balk at sending a 1526 byte packet.</p>
<p>There also exist jumbo frames (1500 &lt; MTU &lt;= 9000 bytes) and super-jumbo
(MTU &gt; 9000 bytes) frames that are not officially sanctioned by IEEE but
are available in some high-speed (Gigabit) networks and NICs.  In the
CSMA model, one could leave the encapsulation mode set to Dix, and set the
Mtu to 64000 bytes – even though an associated CsmaChannel DataRate was
left at 10 megabits per second (certainly not Gigabit Ethernet).  This
would essentially model an Ethernet switch made out of vampire-tapped
1980s-style 10Base5 networks that support super-jumbo datagrams, which is
certainly not something that was ever made, nor is likely to ever be made;
however it is quite easy for you to configure.</p>
<p>Be careful about assumptions regarding what CSMA is actually modelling and
how configuration (Attributes) may allow you to swerve considerably away
from reality.</p>
</section>
<section id="csma-tracing">
<h3><span class="section-number">10.5. </span>CSMA Tracing<a class="headerlink" href="#csma-tracing" title="Link to this heading">¶</a></h3>
<p>Like all <em>ns-3</em> devices, the CSMA Model provides a number of trace sources.
These trace sources can be hooked using your own custom trace code, or you can
use our helper functions to arrange for tracing to be enabled on devices you
specify.</p>
<section id="upper-level-mac-hooks">
<h4><span class="section-number">10.5.1. </span>Upper-Level (MAC) Hooks<a class="headerlink" href="#upper-level-mac-hooks" title="Link to this heading">¶</a></h4>
<p>From the point of view of tracing in the net device, there are several
interesting points to insert trace hooks. A convention inherited from other
simulators is that packets destined for transmission onto attached networks pass
through a single “transmit queue” in the net device. We provide trace hooks at
this point in packet flow, which corresponds (abstractly) only to a transition
from the network to data link layer, and call them collectively the device MAC
hooks.</p>
<p>When a packet is sent to the CSMA net device for transmission it always passes
through the transmit queue. The transmit queue in the CsmaNetDevice inherits
from Queue, and therefore inherits three trace sources:</p>
<ul class="simple">
<li><p>An Enqueue operation source (see Queue::m_traceEnqueue);</p></li>
<li><p>A Dequeue operation source (see Queue::m_traceDequeue);</p></li>
<li><p>A Drop operation source (see Queue::m_traceDrop).</p></li>
</ul>
<p>The upper-level (MAC) trace hooks for the CsmaNetDevice are, in fact, exactly
these three trace sources on the single transmit queue of the device.</p>
<p>The m_traceEnqueue event is triggered when a packet is placed on the transmit
queue. This happens at the time that CsmaNetDevice::Send or
CsmaNetDevice::SendFrom is called by a higher layer to queue a packet for
transmission.</p>
<p>The m_traceDequeue event is triggered when a packet is removed from the transmit
queue. Dequeues from the transmit queue can happen in three situations:  1) If
the underlying channel is idle when the CsmaNetDevice::Send or
CsmaNetDevice::SendFrom is called, a packet is dequeued from the transmit queue
and immediately transmitted;  2) If the underlying channel is idle, a packet may
be dequeued and immediately transmitted in an internal TransmitCompleteEvent
that functions much like a transmit complete interrupt service routine; or 3)
from the random exponential backoff handler if a timeout is detected.</p>
<p>Case (3) implies that a packet is dequeued from the transmit queue if it is
unable to be transmitted according to the backoff rules. It is important to
understand that this will appear as a Dequeued packet and it is easy to
incorrectly assume that the packet was transmitted since it passed through the
transmit queue. In fact, a packet is actually dropped by the net device in this
case. The reason for this behavior is due to the definition of the Queue Drop
event. The m_traceDrop event is, by definition, fired when a packet cannot be
enqueued on the transmit queue because it is full. This event only fires if the
queue is full and we do not overload this event to indicate that the CsmaChannel
is “full.”</p>
</section>
<section id="lower-level-phy-hooks">
<h4><span class="section-number">10.5.2. </span>Lower-Level (PHY) Hooks<a class="headerlink" href="#lower-level-phy-hooks" title="Link to this heading">¶</a></h4>
<p>Similar to the upper level trace hooks, there are trace hooks available at the
lower levels of the net device. We call these the PHY hooks. These events fire
from the device methods that talk directly to the CsmaChannel.</p>
<p>The trace source m_dropTrace is called to indicate a packet that is dropped by
the device. This happens in two cases: First, if the receive side of the net
device is not enabled (see CsmaNetDevice::m_receiveEnable and the associated
attribute “ReceiveEnable”).</p>
<p>The m_dropTrace is also used to indicate that a packet was discarded as corrupt
if a receive error model is used (see CsmaNetDevice::m_receiveErrorModel and the
associated attribute “ReceiveErrorModel”).</p>
<p>The other low-level trace source fires on reception of an accepted packet (see
CsmaNetDevice::m_rxTrace). A packet is accepted if it is destined for the
broadcast address, a multicast address, or to the MAC address assigned to the
net device.</p>
</section>
</section>
<section id="summary">
<h3><span class="section-number">10.6. </span>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h3>
<p>The ns3 CSMA model is a simplistic model of an Ethernet-like network.  It
supports a Carrier-Sense function and allows for Multiple Access to a
shared medium.  It is not physical in the sense that the state of the
medium is instantaneously shared among all devices.  This means that there
is no collision detection required in this model and none is implemented.
There will never be a “jam” of a packet already on the medium.  Access to
the shared channel is on a first-come first-served basis as determined by
the simulator scheduler.  If the channel is determined to be busy by looking
at the global state, a random exponential backoff is performed and a retry
is attempted.</p>
<p>Ns-3 Attributes provide a mechanism for setting various parameters in the
device and channel such as addresses, encapsulation modes and error model
selection.  Trace hooks are provided in the usual manner with a set of
upper level hooks corresponding to a transmit queue and used in ASCII
tracing; and also a set of lower level hooks used in pcap tracing.</p>
<p>Although the ns-3 CsmaChannel and CsmaNetDevice does not model any kind of
network you could build or buy, it does provide us with some useful
functionality.  You should, however, understand that it is explicitly not
Ethernet or any flavor of IEEE 802.3 but an interesting subset.</p>
</section>
</section>
<span id="document-dsdv"></span><section id="dsdv-routing">
<h2><span class="section-number">11. </span>DSDV Routing<a class="headerlink" href="#dsdv-routing" title="Link to this heading">¶</a></h2>
<p>Destination-Sequenced Distance Vector (DSDV) routing protocol is a pro-active, table-driven routing protocol
for MANETs developed by Charles E. Perkins and Pravin Bhagwat in 1994. It uses the hop count as metric in route
selection.</p>
<p>This model was developed by
<a class="reference external" href="https://resilinets.org/">the ResiliNets research group</a>
at the University of Kansas.  A paper on this model exists at
<a class="reference external" href="https://resilinets.org/resilinets_publications.html#.E2.80.9CDestination-Sequenced_Distance_Vector_.28DSDV.29_Routing_Protocol_Implementation_in_ns-3.E2.80.9D">this URL</a>.</p>
<section id="dsdv-routing-overview">
<h3><span class="section-number">11.1. </span>DSDV Routing Overview<a class="headerlink" href="#dsdv-routing-overview" title="Link to this heading">¶</a></h3>
<p>DSDV Routing Table: Every node will maintain a table listing all the other nodes it has known either directly
or through some neighbors. Every node has a single entry in the routing table. The entry will have information
about the node’s IP address, last known sequence number and the hop count to reach that node. Along with these
details the table also keeps track of the nexthop neighbor to reach the destination node, the timestamp of the last
update received for that node.</p>
<p>The DSDV update message consists of three fields, Destination Address, Sequence Number and Hop Count.</p>
<p>Each node uses 2 mechanisms to send out the DSDV updates. They are,</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Periodic Updates</dt><dd><p>Periodic updates are sent out after every m_periodicUpdateInterval(default:15s). In this update the node broadcasts
out its entire routing table.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Trigger Updates</dt><dd><p>Trigger Updates are small updates in-between the periodic updates. These updates are sent out whenever a node
receives a DSDV packet that caused a change in its routing table. The original paper did not clearly mention
when for what change in the table should a DSDV update be sent out. The current implementation sends out an update
irrespective of the change in the routing table.</p>
</dd>
</dl>
</li>
</ol>
<p>The updates are accepted based on the metric for a particular node. The first factor determining the acceptance of
an update is the sequence number. It has to accept the update if the sequence number of the update message is higher
irrespective of the metric. If the update with same sequence number is received, then the update with least metric
(hopCount) is given precedence.</p>
<p>In highly mobile scenarios, there is a high chance of route fluctuations, thus we have the concept of weighted
settling time where an update with change in metric will not be advertised to neighbors. The node waits for
the settling time to make sure that it did not receive the update from its old neighbor before sending out
that update.</p>
<p>The current implementation covers all the above features of DSDV. The current implementation also has a request queue
to buffer packets that have no routes to destination. The default is set to buffer up to 5 packets per destination.</p>
</section>
<section id="references">
<h3><span class="section-number">11.2. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<p>Link to the Paper: <a class="reference external" href="http://portal.acm.org/citation.cfm?doid=190314.190336">http://portal.acm.org/citation.cfm?doid=190314.190336</a></p>
</section>
</section>
<span id="document-dsr"></span><section id="dsr-routing">
<h2><span class="section-number">12. </span>DSR Routing<a class="headerlink" href="#dsr-routing" title="Link to this heading">¶</a></h2>
<p>Dynamic Source Routing (DSR) protocol is a reactive routing protocol designed specifically
for use in multi-hop wireless ad hoc networks of mobile nodes.</p>
<p>This model was developed by
<a class="reference external" href="https://resilinets.org/">the ResiliNets research group</a>
at the University of Kansas.</p>
<section id="dsr-routing-overview">
<h3><span class="section-number">12.1. </span>DSR Routing Overview<a class="headerlink" href="#dsr-routing-overview" title="Link to this heading">¶</a></h3>
<p>This model implements the base specification of the Dynamic Source Routing
(DSR) protocol. Implementation is based on <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4728.html"><strong>RFC 4728</strong></a>, with some extensions
and modifications to the RFC specifications.</p>
<p>DSR operates on a on-demand behavior. Therefore, our DSR model buffers all
packets while a route request packet (RREQ) is disseminated. We implement
a packet buffer in dsr-rsendbuff.cc. The packet queue implements
garbage collection of old packets and a queue size limit. When the packet
is sent out from the send buffer, it will be queued in maintenance buffer
for next hop acknowledgment.</p>
<p>The maintenance buffer then buffers the already sent out packets and waits
for the notification of packet delivery.  Protocol operation strongly
depends on broken link detection mechanism. We implement the three heuristics
recommended based the RFC as follows:</p>
<p>First, we use link layer feedback when possible, which is also the fastest
mechanism of these three to detect link errors. A link is considered to be
broken if frame transmission results in a transmission failure for all
retries. This mechanism is meant for active links and works much faster
than in its absence.  DSR is able to
detect the link layer transmission failure and notify that as broken.
Recalculation of routes will be triggered
when needed.  If user does not want to use link layer acknowledgment,
it can be tuned by setting “LinkAcknowledgment” attribute to false in
“dsr-routing.cc”.</p>
<p>Second, passive acknowledgment should be used whenever possible. The node
turns on “promiscuous” receive mode, in which it can receive packets not
destined for itself, and when the node assures the delivery of that data
packet to its destination, it cancels the passive acknowledgment timer.</p>
<p>Last, we use a network layer acknowledge scheme to notify the receipt of
a packet. Route request packet will not be acknowledged or retransmitted.</p>
<p>The Route Cache implementation support garbage collection of old entries
and state machine, as defined in the
standard.  It implements as a STL map container. The key is the
destination IP address.</p>
<p>DSR operates with direct access to IP header, and operates between network
and transport layer.  When packet is sent out from transport layer, it
passes itself to DSR and DSR header is appended.</p>
<p>We have two caching mechanisms: path cache and link cache.  The path cache
saves the whole path in the cache.  The paths are sorted based on the
hop count, and whenever one path is not able to be used, we change to the
next path.  The link cache is a slightly better design in the sense that it
uses different subpaths and uses Implemented Link Cache using
Dijkstra algorithm, and this part is implemented by
Song Luan &lt;<a class="reference external" href="mailto:lsuper&#37;&#52;&#48;mail&#46;ustc&#46;edu&#46;cn">lsuper<span>&#64;</span>mail<span>&#46;</span>ustc<span>&#46;</span>edu<span>&#46;</span>cn</a>&gt;.</p>
<p>The following optional protocol optimizations aren’t implemented:</p>
<ul class="simple">
<li><p>Flow state</p></li>
<li><p>First Hop External (F), Last Hop External (L) flags</p></li>
<li><p>Handling unknown DSR options</p></li>
<li><dl class="simple">
<dt>Two types of error headers:</dt><dd><ol class="arabic simple">
<li><p>flow state not supported option</p></li>
<li><p>unsupported option (not going to happen in simulation)</p></li>
</ol>
</dd>
</dl>
</li>
</ul>
<section id="dsr-update-in-ns-3-17">
<h4><span class="section-number">12.1.1. </span>DSR update in ns-3.17<a class="headerlink" href="#dsr-update-in-ns-3-17" title="Link to this heading">¶</a></h4>
<p>We originally used “TxErrHeader” in Ptr&lt;WifiMac&gt; to indicate the transmission
error of a specific packet in link layer, however, it was not working
quite correctly since even when the packet was dropped, this header was
not recorded in the trace file.  We used to a different path on implementing
the link layer notification mechanism.  We look into the trace file by
finding packet receive event.  If we find one receive event for the
data packet, we count that as the indicator for successful data delivery.</p>
</section>
<section id="useful-parameters">
<h4><span class="section-number">12.1.2. </span>Useful parameters<a class="headerlink" href="#useful-parameters" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">Parameter</span>                <span class="o">|</span> <span class="n">Description</span>                        <span class="o">|</span> <span class="n">Default</span>     <span class="o">|</span>
<span class="o">+==========================+====================================+=============+</span>
<span class="o">|</span> <span class="n">MaxSendBuffLen</span>           <span class="o">|</span> <span class="n">Maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">packets</span> <span class="n">that</span> <span class="n">can</span> <span class="o">|</span> <span class="mi">64</span>          <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="n">be</span> <span class="n">stored</span> <span class="ow">in</span> <span class="n">send</span> <span class="n">buffer</span>           <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">MaxSendBuffTime</span>          <span class="o">|</span> <span class="n">Maximum</span> <span class="n">time</span> <span class="n">packets</span> <span class="n">can</span> <span class="n">be</span> <span class="n">queued</span> <span class="o">|</span> <span class="n">Seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">send</span> <span class="n">buffer</span>                 <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">MaxMaintLen</span>              <span class="o">|</span> <span class="n">Maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">packets</span> <span class="n">that</span> <span class="n">can</span> <span class="o">|</span> <span class="mi">50</span>          <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="n">be</span> <span class="n">stored</span> <span class="ow">in</span> <span class="n">maintenance</span> <span class="n">buffer</span>    <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">MaxMaintTime</span>             <span class="o">|</span> <span class="n">Maximum</span> <span class="n">time</span> <span class="n">packets</span> <span class="n">can</span> <span class="n">be</span> <span class="n">queued</span> <span class="o">|</span> <span class="n">Seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="ow">in</span> <span class="n">maintenance</span> <span class="n">buffer</span>              <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">MaxCacheLen</span>              <span class="o">|</span> <span class="n">Maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">route</span> <span class="n">entries</span>    <span class="o">|</span> <span class="mi">64</span>          <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="n">that</span> <span class="n">can</span> <span class="n">be</span> <span class="n">stored</span> <span class="ow">in</span> <span class="n">route</span> <span class="n">cache</span>  <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">RouteCacheTimeout</span>        <span class="o">|</span> <span class="n">Maximum</span> <span class="n">time</span> <span class="n">the</span> <span class="n">route</span> <span class="n">cache</span> <span class="n">can</span>   <span class="o">|</span> <span class="n">Seconds</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span><span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="n">be</span> <span class="n">queued</span> <span class="ow">in</span> <span class="n">route</span> <span class="n">cache</span>           <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">RreqRetries</span>              <span class="o">|</span> <span class="n">Maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">retransmissions</span>  <span class="o">|</span> <span class="mi">16</span>          <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="k">for</span> <span class="n">request</span> <span class="n">discovery</span> <span class="n">of</span> <span class="n">a</span> <span class="n">route</span>   <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">CacheType</span>                <span class="o">|</span> <span class="n">Use</span> <span class="n">Link</span> <span class="n">Cache</span> <span class="ow">or</span> <span class="n">use</span> <span class="n">Path</span> <span class="n">Cache</span>   <span class="o">|</span> <span class="s2">&quot;LinkCache&quot;</span> <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span>                                    <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
<span class="o">|</span> <span class="n">LinkAcknowledgment</span>       <span class="o">|</span> <span class="n">Enable</span> <span class="n">Link</span> <span class="n">layer</span> <span class="n">acknowledgment</span>   <span class="o">|</span> <span class="kc">True</span>        <span class="o">|</span>
<span class="o">|</span>                          <span class="o">|</span> <span class="n">mechanism</span>                          <span class="o">|</span>             <span class="o">|</span>
<span class="o">+-------------------------</span> <span class="o">+------------------------------------+-------------+</span>
</pre></div>
</div>
</section>
<section id="implementation-modification">
<h4><span class="section-number">12.1.3. </span>Implementation modification<a class="headerlink" href="#implementation-modification" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>The DsrFsHeader has added 3 fields: message type, source id, destination id, and these changes only for post-processing
1. Message type is used to identify the data packet from control packet
2. source id is used to identify the real source of the data packet since we have to deliver the packet hop-by-hop and the Ipv4Header is not carrying the real source and destination ip address as needed
3. destination id is for same reason of above</p></li>
<li><p>Route Reply header is not word-aligned in DSR RFC, change it to word-aligned in implementation</p></li>
<li><p>DSR works as a shim header between transport and network protocol, it needs its own forwarding mechanism, we are changing the packet transmission to hop-by-hop delivery, so we added two fields in dsr fixed header to notify packet delivery</p></li>
</ul>
</section>
<section id="current-route-cache-implementation">
<h4><span class="section-number">12.1.4. </span>Current Route Cache implementation<a class="headerlink" href="#current-route-cache-implementation" title="Link to this heading">¶</a></h4>
<p>This implementation used “path cache”, which is simple to implement and ensures loop-free paths:</p>
<ul class="simple">
<li><p>the path cache has automatic expire policy</p></li>
<li><p>the cache saves multiple route entries for a certain destination and sort the entries based on hop counts</p></li>
<li><p>the MaxEntriesEachDst can be tuned to change the maximum entries saved for a single destination</p></li>
<li><p>when adding multiple routes for one destination, the route is compared based on hop-count and expire time, the one with less hop count or relatively new route is favored</p></li>
<li><p>Future implementation may include “link cache” as another possibility</p></li>
</ul>
</section>
</section>
<section id="dsr-instructions">
<h3><span class="section-number">12.2. </span>DSR Instructions<a class="headerlink" href="#dsr-instructions" title="Link to this heading">¶</a></h3>
<p>The following should be kept in mind when running DSR as routing protocol:</p>
<ul class="simple">
<li><p>NodeTraversalTime is the time it takes to traverse two neighboring nodes and should be chosen to fit the transmission range</p></li>
<li><p>PassiveAckTimeout is the time a packet in maintenance buffer wait for passive acknowledgment, normally set as two times of NodeTraversalTime</p></li>
<li><p>RouteCacheTimeout should be set smaller value when the nodes’ velocity become higher. The default value is 300s.</p></li>
</ul>
</section>
<section id="helper">
<h3><span class="section-number">12.3. </span>Helper<a class="headerlink" href="#helper" title="Link to this heading">¶</a></h3>
<p>To have a node run DSR, the easiest way would be to use the DsrHelper
and DsrMainHelpers in your simulation script. For instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">DsrHelper</span><span class="w"> </span><span class="n">dsr</span><span class="p">;</span>
<span class="n">DsrMainHelper</span><span class="w"> </span><span class="n">dsrMain</span><span class="p">;</span>
<span class="n">dsrMain</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">dsr</span><span class="p">,</span><span class="w"> </span><span class="n">adhocNodes</span><span class="p">);</span>
</pre></div>
</div>
<p>The example scripts inside <code class="docutils literal notranslate"><span class="pre">src/dsr/examples/</span></code> demonstrate the use of DSR based nodes in different scenarios.
The helper source can be found inside <code class="docutils literal notranslate"><span class="pre">src/dsr/helper/dsr-main-helper.{h,cc}</span></code>
and <code class="docutils literal notranslate"><span class="pre">src/dsr/helper/dsr-helper.{h,cc}</span></code></p>
</section>
<section id="examples">
<h3><span class="section-number">12.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h3>
<p>The example can be found in <code class="docutils literal notranslate"><span class="pre">src/dsr/examples/</span></code>:</p>
<ul class="simple">
<li><p>dsr.cc use DSR as routing protocol within a traditional MANETs environment[3].</p></li>
</ul>
<p>DSR is also built in the routing comparison case in <code class="docutils literal notranslate"><span class="pre">examples/routing/</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">manet-routing-compare.cc</span></code> is a comparison case with built in MANET routing protocols and can generate its own results.</p></li>
</ul>
</section>
<section id="validation">
<h3><span class="section-number">12.5. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>This model has been tested as follows:</p>
<ul class="simple">
<li><p>Unit tests have been written to verify the internals of DSR. This can be found in <code class="docutils literal notranslate"><span class="pre">src/dsr/test/dsr-test-suite.cc</span></code>. These tests verify whether the methods inside DSR module which deal with packet buffer, headers work correctly.</p></li>
<li><p>Simulation cases similar to [3] have been tested and have comparable results.</p></li>
<li><p>manet-routing-compare.cc has been used to compare DSR with three of other routing protocols.</p></li>
</ul>
<p>A paper was presented on these results at the Workshop on ns-3 in 2011.</p>
</section>
<section id="limitations">
<h3><span class="section-number">12.6. </span>Limitations<a class="headerlink" href="#limitations" title="Link to this heading">¶</a></h3>
<p>The model is not fully compliant with <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4728.html"><strong>RFC 4728</strong></a>. As an example, Dsr fixed size header
has been extended and it is four octets longer then the RFC specification.
As a consequence, the DSR headers can not be correctly decoded by Wireshark.</p>
<p>The model full compliance with the RFC is planned for the future.</p>
</section>
<section id="references">
<h3><span class="section-number">12.7. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<p>[1] Original paper: <a class="reference external" href="https://web.archive.org/web/20150430233910/http://www.monarch.cs.rice.edu/monarch-papers/dsr-chapter00.pdf">https://web.archive.org/web/20150430233910/http://www.monarch.cs.rice.edu/monarch-papers/dsr-chapter00.pdf</a></p>
<p>[2] RFC 4728 <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc4728">https://datatracker.ietf.org/doc/html/rfc4728</a></p>
<p>[3] Broch’s comparison paper: <a class="reference external" href="https://web.archive.org/web/20150725135435/http://www.monarch.cs.rice.edu/monarch-papers/mobicom98.ps">https://web.archive.org/web/20150725135435/http://www.monarch.cs.rice.edu/monarch-papers/mobicom98.ps</a></p>
</section>
</section>
<span id="document-emulation-overview"></span><section id="emulation-overview">
<h2><span class="section-number">13. </span>Emulation Overview<a class="headerlink" href="#emulation-overview" title="Link to this heading">¶</a></h2>
<p><em>ns-3</em> has been designed for integration into testbed and virtual machine
environments. We have addressed this need by providing two kinds of net devices.
The first kind of device is a file descriptor net device (<code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code>),
which is a generic device type that can read and write from a file descriptor.
By associating this file descriptor with different things on the host
system, different capabilities can be provided.  For instance, the
FdNetDevice can be associated with an underlying packet socket to provide
emulation capabilities.  This allows <em>ns-3</em> simulations
to send data on a “real” network. The second kind, called a <code class="docutils literal notranslate"><span class="pre">TapBridge</span></code>
<code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> allows a “real” host to participate in an <em>ns-3</em> simulation as if
it were one of the simulated nodes. An <em>ns-3</em> simulation may be constructed with
any combination of simulated or emulated devices.</p>
<p><strong>Note:</strong> Prior to ns-3.17, the emulation capability was provided by a
special device called an <code class="docutils literal notranslate"><span class="pre">Emu</span></code> NetDevice; the <code class="docutils literal notranslate"><span class="pre">Emu</span></code> NetDevice has
been replaced by the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code>.</p>
<p>One of the use-cases we want to support is that of a testbed. A concrete example
of an environment of this kind is the ORBIT testbed. ORBIT is a laboratory
emulator/field trial network arranged as a two dimensional grid of 400 802.11
radio nodes. We integrate with ORBIT by using their “imaging” process to load
and run <em>ns-3</em> simulations on the ORBIT array. We can use our
<code class="docutils literal notranslate"><span class="pre">EmuFdNetDevice</span></code>
to drive the hardware in the testbed and we can accumulate results either using
the <em>ns-3</em> tracing and logging functions, or the native ORBIT data gathering
techniques. See <a class="reference external" href="http://www.orbit-lab.org/">http://www.orbit-lab.org/</a> for details on the ORBIT
testbed.</p>
<p>A simulation of this kind is shown in the following figure:</p>
<figure class="align-default" id="id1">
<span id="testbed"></span><img alt="_images/testbed.png" src="_images/testbed.png" />
<figcaption>
<p><span class="caption-text">Example Implementation of Testbed Emulation.</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>You can see that there are separate hosts, each running a subset of a “global”
simulation. Instead of an <em>ns-3</em> channel connecting the hosts, we use real
hardware provided by the testbed. This allows <em>ns-3</em> applications and protocol
stacks attached to a simulation node to communicate over real hardware.</p>
<p>We expect the primary use for this configuration will be to generate repeatable
experimental results in a real-world network environment that includes all of
the <em>ns-3</em> tracing, logging, visualization and statistics gathering tools.</p>
<p>In what can be viewed as essentially an inverse configuration, we allow “real”
machines running native applications and protocol stacks to integrate with an
<em>ns-3</em> simulation. This allows for the simulation of large networks connected to
a real machine, and also enables virtualization. A simulation of this kind is
shown in the following figure:</p>
<figure class="align-default" id="id2">
<span id="emulated-channel"></span><img alt="_images/emulated-channel.png" src="_images/emulated-channel.png" />
<figcaption>
<p><span class="caption-text">Implementation overview of emulated channel.</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Here, you will see that there is a single host with a number of virtual machines
running on it. An <em>ns-3</em> simulation is shown running in the virtual machine shown
in the center of the figure. This simulation has a number of nodes with
associated <em>ns-3</em> applications and protocol stacks that are talking to an <em>ns-3</em>
channel through native simulated <em>ns-3</em> net devices.</p>
<p>There are also two virtual machines shown at the far left and far right of the
figure. These VMs are running native (Linux) applications and protocol stacks.
The VM is connected into the simulation by a Linux Tap net device. The user-mode
handler for the Tap device is instantiated in the simulation and attached to a
proxy node that represents the native VM in the simulation. These handlers allow
the Tap devices on the native VMs to behave as if they were <em>ns-3</em> net devices in
the simulation VM. This, in turn, allows the native software and protocol suites
in the native VMs to believe that they are connected to the simulated <em>ns-3</em>
channel.</p>
<p>We expect the typical use case for this environment will be to analyze the
behavior of native applications and protocol suites in the presence of large
simulated <em>ns-3</em> networks.</p>
<p>The basic testbed mode of emulation uses raw sockets.  Two other variants
(netmap-based and DPDK-based emulation) have been recently added; these
make use of more recent network interface cards that make use of
directly-mapped memory capabilities to improve packet processing efficiency.</p>
<p>For more details:</p>
<div class="toctree-wrapper compound">
<span id="document-fd-net-device"></span><section id="file-descriptor-netdevice">
<h3><span class="section-number">13.1. </span>File Descriptor NetDevice<a class="headerlink" href="#file-descriptor-netdevice" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">src/fd-net-device</span></code> module provides the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> class,
which is able to read and write traffic using a file descriptor
provided by the user.  This file descriptor can be associated to a TAP
device, to a raw socket, to a user space process generating/consuming
traffic, etc.
The user has full freedom to define how external traffic is generated
and <em>ns-3</em> traffic is consumed.</p>
<p>Different mechanisms to associate a simulation to external traffic can
be provided through helper classes.  Two specific helpers are provided:</p>
<ul class="simple">
<li><p>EmuFdNetDeviceHelper (to associate the <em>ns-3</em> device with a physical device
in the host machine)</p></li>
<li><p>TapFdNetDeviceHelper (to associate the ns-3 device with the file descriptor
from a tap device in the host machine)</p></li>
</ul>
<section id="model-description">
<h4><span class="section-number">13.1.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for this module lives in the directory <code class="docutils literal notranslate"><span class="pre">src/fd-net-device</span></code>.</p>
<p>The FdNetDevice is a special type of <em>ns-3</em> NetDevice that reads traffic
to and from a file descriptor.  That is, unlike pure simulation NetDevice
objects that write frames to and from a simulated channel, this FdNetDevice
directs frames out of the simulation to a file descriptor.  The file
descriptor may be associated to a Linux TUN/TAP device, to a socket, or
to a user-space process.</p>
<p>It is up to the user of this device to provide a file descriptor.  The
type of file descriptor being provided determines what is being
modelled.  For instance, if the file descriptor provides a raw socket
to a WiFi card on the host machine, the device being modelled is a
WiFi device.</p>
<p>From the conceptual “top” of the device looking down, it looks to the
simulated node like a device supporting a 48-bit IEEE MAC address that
can be bridged, supports broadcast, and uses IPv4 ARP or IPv6 Neighbor
Discovery, although these attributes can be tuned on a per-use-case basis.</p>
<section id="design">
<h5><span class="section-number">13.1.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>The FdNetDevice implementation makes use of a reader object,
extended from the <code class="docutils literal notranslate"><span class="pre">FdReader</span></code> class in the <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">src/core</span></code> module,
which manages a separate thread from the main <em>ns-3</em> execution thread, in order
to read traffic from the file descriptor.</p>
<p>Upon invocation of the <code class="docutils literal notranslate"><span class="pre">StartDevice</span></code> method, the reader object is initialized
and starts the reading thread.
Before device start, a file descriptor must be previously associated to the
FdNetDevice with the <code class="docutils literal notranslate"><span class="pre">SetFileDescriptor</span></code> invocation.</p>
<p>The creation and configuration of the file descriptor can be left to a
number of helpers, described in more detail below. When this is done, the
invocation of <code class="docutils literal notranslate"><span class="pre">SetFileDescriptor</span></code> is responsibility of
the helper and must not be directly invoked by the user.</p>
<p>Upon reading an incoming frame from the file descriptor, the reader
will pass the frame to the <code class="docutils literal notranslate"><span class="pre">ReceiveCallback</span></code> method, whose
task it is to schedule the reception of the frame by the device as a
<em>ns-3</em> simulation event. Since the new frame is passed from the reader
thread to the main <em>ns-3</em> simulation thread, thread-safety issues
are avoided by using the <code class="docutils literal notranslate"><span class="pre">ScheduleWithContext</span></code> call instead of the
regular <code class="docutils literal notranslate"><span class="pre">Schedule</span></code> call.</p>
<p>In order to avoid overwhelming the scheduler when the incoming data rate
is too high, a counter is kept with the number of frames that are currently
scheduled to be received by the device. If this counter reaches the value
given by the <code class="docutils literal notranslate"><span class="pre">RxQueueSize</span></code> attribute in the device, then the new frame will
be dropped silently.</p>
<p>The actual reception of the new frame by the device occurs when the
scheduled <code class="docutils literal notranslate"><span class="pre">FordwarUp</span></code> method is invoked by the simulator.
This method acts as if a new frame had arrived from a channel attached
to the device. The device then decapsulates the frame, removing any layer 2
headers, and forwards it to upper network stack layers of the node.
The <code class="docutils literal notranslate"><span class="pre">ForwardUp</span></code> method will remove the frame headers,
according to the frame encapsulation type defined by the <code class="docutils literal notranslate"><span class="pre">EncapsulationMode</span></code>
attribute, and invoke the receive callback passing an IP packet.</p>
<p>An extra header, the PI header, can be present when the file descriptor is
associated to a TAP device that was created without setting the IFF_NO_PI flag.
This extra header is removed if <code class="docutils literal notranslate"><span class="pre">EncapsulationMode</span></code> is set to DIXPI value.</p>
<p>In the opposite direction, packets generated inside the simulation that are
sent out through the device, will be passed to the <code class="docutils literal notranslate"><span class="pre">Send</span></code> method, which
will in turn invoke the <code class="docutils literal notranslate"><span class="pre">SendFrom</span></code> method. The latter method will add the
necessary layer 2 headers, and simply write the newly created frame to the
file descriptor.</p>
</section>
<section id="scope-and-limitations">
<h5><span class="section-number">13.1.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h5>
<p>Users of this device are cautioned that there is no flow control
across the file descriptor boundary, when using in emulation mode.
That is, in a Linux system, if the speed of writing network packets
exceeds the ability of the underlying physical device to buffer the
packets, backpressure up to the writing application will be applied
to avoid local packet loss.  No such flow control is provided across
the file descriptor interface, so users must be aware of this limitation.</p>
<p>As explained before, the RxQueueSize attribute limits the number of packets
that can be pending to be received by the device.
Frames read from the file descriptor while the number of pending packets is
in its maximum will be silently dropped.</p>
<p>The mtu of the device defaults to the Ethernet II MTU value. However, helpers
are supposed to set the mtu to the right value to reflect the characteristics
of the network interface associated to the file descriptor.
If no helper is used, then the responsibility of setting the correct mtu value
for the device falls back to the user.
The size of the read buffer on the file descriptor reader is set to the
mtu value in the <code class="docutils literal notranslate"><span class="pre">StartDevice</span></code> method.</p>
<p>The FdNetDevice class currently supports three encapsulation modes,
DIX for Ethernet II frames, LLC for 802.2 LLC/SNAP frames,
and DIXPI for Ethernet II frames with an additional TAP PI header.
This means that traffic traversing the file descriptor is expected to be
Ethernet II compatible.  IEEE 802.1q (VLAN) tagging is not supported.
Attaching an FdNetDevice to a wireless interface is possible as long as the
driver provides Ethernet II frames to the socket API.
Note that to associate a FdNetDevice to a wireless card in ad-hoc mode,
the MAC address of the device must be set to the real card MAC address, else
any incoming traffic a fake MAC address will be discarded by the driver.</p>
<p>As mentioned before, three helpers are provided with the fd-net-device module.
Each individual helper (file descriptor type) may have platform
limitations.  For instance, threading, real-time simulation mode, and the
ability to create TUN/TAP devices are prerequisites to using the
provided helpers.  Support for these modes can be found in the output
of the <code class="docutils literal notranslate"><span class="pre">ns3</span> <span class="pre">configure</span></code> step, e.g.:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Threading Primitives          : enabled
Real Time Simulator           : enabled
Emulated Net Device           : enabled
Tap Bridge                    : enabled
</pre></div>
</div>
<p>It is important to mention that while testing the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> we have found
an upper bound limit for TCP throughput when using 1Gb Ethernet links of 60Mbps.
This limit is most likely due to the processing power of the computers involved
in the tests.</p>
</section>
</section>
<section id="usage">
<h4><span class="section-number">13.1.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>The usage pattern for this type of device is similar to other net devices
with helpers that install to node pointers or node containers.
When using the base <code class="docutils literal notranslate"><span class="pre">FdNetDeviceHelper</span></code> the user is responsible for
creating and setting the file descriptor by himself.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">FdNetDeviceHelper</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>

<span class="c1">// file descriptor generation</span>
<span class="p">...</span>

<span class="n">device</span><span class="o">-&gt;</span><span class="n">SetFileDescriptor</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</pre></div>
</div>
<p>Most commonly a FdNetDevice will be used to interact with the host system.
In these cases it is almost certain that the user will want to run in real-time
emulation mode, and to enable checksum computations.
The typical program statements are as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GlobalValue</span><span class="o">::</span><span class="n">Bind</span><span class="p">(</span><span class="s">&quot;SimulatorImplementationType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;ns3::RealtimeSimulatorImpl&quot;</span><span class="p">));</span>
<span class="n">GlobalValue</span><span class="o">::</span><span class="n">Bind</span><span class="p">(</span><span class="s">&quot;ChecksumEnabled&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>The easiest way to set up an experiment that interacts with a Linux host
system is to user the <code class="docutils literal notranslate"><span class="pre">Emu</span></code> and <code class="docutils literal notranslate"><span class="pre">Tap</span></code> helpers.
Perhaps the most unusual part of these helper implementations
relates to the requirement for executing some of the code with super-user
permissions. Rather than force the user to execute the entire simulation as
root, we provide a small “creator” program that runs as root and does any
required high-permission sockets work. The easiest way to set the right
privileges for the “creator” programs, is by enabling the <code class="docutils literal notranslate"><span class="pre">--enable-sudo</span></code>
flag when performing <code class="docutils literal notranslate"><span class="pre">ns3</span> <span class="pre">configure</span></code>.</p>
<p>We do a similar thing for both the <code class="docutils literal notranslate"><span class="pre">Emu</span></code> and the <code class="docutils literal notranslate"><span class="pre">Tap</span></code> devices.  The
high-level view is that the <code class="docutils literal notranslate"><span class="pre">CreateFileDescriptor</span></code> method creates a local interprocess
(Unix) socket, forks, and executes the small creation program. The small
program, which runs as suid root, creates a raw socket and sends back the raw
socket file descriptor over the Unix socket that is passed to it as a parameter.
The raw socket is passed as a control message (sometimes called ancillary data)
of type SCM_RIGHTS.</p>
<section id="helpers">
<h5><span class="section-number">13.1.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<section id="emufdnetdevicehelper">
<h6><span class="section-number">13.1.2.1.1. </span>EmuFdNetDeviceHelper<a class="headerlink" href="#emufdnetdevicehelper" title="Link to this heading">¶</a></h6>
<p>The EmuFdNetDeviceHelper creates a raw socket to an underlying physical
device, and provides the socket descriptor to the FdNetDevice.  This
allows the <em>ns-3</em> simulation to read frames from and write frames to
a network device on the host.</p>
<p>The emulation helper permits to transparently integrate a simulated
<em>ns-3</em> node into a network composed of real nodes.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------+     +-----------------------+
|         host 1       |     |         host 2        |
+----------------------+     +-----------------------+
|    ns-3 simulation   |     |                       |
+----------------------+     |         Linux         |
|       ns-3 Node      |     |     Network Stack     |
|  +----------------+  |     |   +----------------+  |
|  |    ns-3 TCP    |  |     |   |       TCP      |  |
|  +----------------+  |     |   +----------------+  |
|  |    ns-3 IP     |  |     |   |       IP       |  |
|  +----------------+  |     |   +----------------+  |
|  |   FdNetDevice  |  |     |   |                |  |
|  |    10.1.1.1    |  |     |   |                |  |
|  +----------------+  |     |   +    ETHERNET    +  |
|  |   raw socket   |  |     |   |                |  |
|--+----------------+--|     |   +----------------+  |
|       | eth0 |       |     |        | eth0 |       |
+-------+------+-------+     +--------+------+-------+

        10.1.1.11                     10.1.1.12

            |                            |
            +----------------------------+
</pre></div>
</div>
<p>This helper replaces the functionality of the <code class="docutils literal notranslate"><span class="pre">EmuNetDevice</span></code> found in
<em>ns-3</em> prior to ns-3.17, by bringing this type of device into the common
framework of the FdNetDevice.  The <code class="docutils literal notranslate"><span class="pre">EmuNetDevice</span></code> was deprecated
in favor of this new helper.</p>
<p>The device is configured to perform
MAC spoofing to separate simulation network traffic from other
network traffic that may be flowing to and from the host.</p>
<p>One can use this helper in a testbed situation where the host on
which the simulation is running has a specific interface of interest which
drives the testbed hardware. You would also need to set this specific interface
into promiscuous mode and provide an appropriate device name to the <em>ns-3</em>
simulation.  Additionally, hardware offloading of segmentation and checksums
should be disabled.</p>
<p>The helper only works if the underlying interface is up and in
promiscuous mode. Packets will be sent out over the device, but we use MAC
spoofing. The MAC addresses will be generated (by default) using the
Organizationally Unique Identifier (OUI) 00:00:00 as a base. This vendor code
is not assigned to any organization and so should not conflict with any real
hardware.</p>
<p>It is always up to the user to determine that using these MAC addresses is okay
on your network and won’t conflict with anything else (including another
simulation using such devices) on your network. If you are using the emulated
FdNetDevice configuration in separate simulations,
you must consider global MAC address
assignment issues and ensure that MAC addresses are unique across all
simulations. The emulated net device respects the MAC address provided in the
<code class="docutils literal notranslate"><span class="pre">Address</span></code> attribute so you can do this manually. For larger simulations, you
may want to set the OUI in the MAC address allocation function.</p>
<p>Before invoking the <code class="docutils literal notranslate"><span class="pre">Install</span></code> method, the correct device name must be configured
on the helper using the <code class="docutils literal notranslate"><span class="pre">SetDeviceName</span></code> method. The device name is required to
identify which physical device should be used to open the raw socket.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EmuFdNetDeviceHelper</span><span class="w"> </span><span class="n">emu</span><span class="p">;</span>
<span class="n">emu</span><span class="p">.</span><span class="n">SetDeviceName</span><span class="p">(</span><span class="n">deviceName</span><span class="p">);</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">emu</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">device</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Address&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Mac48AddressValue</span><span class="p">(</span><span class="n">Mac48Address</span><span class="o">::</span><span class="n">Allocate</span><span class="p">()));</span>
</pre></div>
</div>
</section>
<section id="tapfdnetdevicehelper">
<h6><span class="section-number">13.1.2.1.2. </span>TapFdNetDeviceHelper<a class="headerlink" href="#tapfdnetdevicehelper" title="Link to this heading">¶</a></h6>
<p>A Tap device is a special type of Linux device for which one end of the
device appears to the kernel as a virtual net_device, and the other
end is provided as a file descriptor to user-space.  This file descriptor
can be passed to the FdNetDevice.  Packets forwarded to the TAP device
by the kernel will show up in the FdNetDevice in <em>ns-3</em>.</p>
<p>Users should note that this usage of TAP devices is different than that
provided by the TapBridge NetDevice found in <code class="docutils literal notranslate"><span class="pre">src/tap-bridge</span></code>.
The model in this helper is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+-------------------------------------+
|                host                 |
+-------------------------------------+
|    ns-3 simulation   |              |
+----------------------+              |
|      ns-3 Node       |              |
|  +----------------+  |              |
|  |    ns-3 TCP    |  |              |
|  +----------------+  |              |
|  |    ns-3 IP     |  |              |
|  +----------------+  |              |
|  |   FdNetDevice  |  |              |
|--+----------------+--+    +------+  |
|       | TAP  |            | eth0 |  |
|       +------+            +------+  |
|     192.168.0.1               |     |
+-------------------------------|-----+
                                |
                                |
                                ------------ (Internet) -----
</pre></div>
</div>
<p>In the above, the configuration requires that the host be able to forward
traffic generated by the simulation to the Internet.</p>
<p>The model in TapBridge (in another module) is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+--------+
|  Linux |
|  host  |                    +----------+
| ------ |                    |   ghost  |
|  apps  |                    |   node   |
| ------ |                    | -------- |
|  stack |                    |    IP    |     +----------+
| ------ |                    |   stack  |     |   node   |
|  TAP   |                    |==========|     | -------- |
| device | &lt;----- IPC ------&gt; |   tap    |     |    IP    |
+--------+                    |  bridge  |     |   stack  |
                              | -------- |     | -------- |
                              |   ns-3   |     |   ns-3   |
                              |   net    |     |   net    |
                              |  device  |     |  device  |
                              +----------+     +----------+
                                   ||               ||
                              +---------------------------+
                              |        ns-3 channel       |
                              +---------------------------+
</pre></div>
</div>
<p>In the above, packets instead traverse <em>ns-3</em> NetDevices and Channels.</p>
<p>The usage pattern for this example is that the user sets the
MAC address and either (or both) the IPv4 and IPv6 addresses and masks
on the device, and the PI header if needed.  For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TapFdNetDeviceHelper</span><span class="w"> </span><span class="n">helper</span><span class="p">;</span>
<span class="n">helper</span><span class="p">.</span><span class="n">SetDeviceName</span><span class="p">(</span><span class="n">deviceName</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">SetModePi</span><span class="p">(</span><span class="n">modePi</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">SetTapIpv4Address</span><span class="p">(</span><span class="n">tapIp</span><span class="p">);</span>
<span class="n">helper</span><span class="p">.</span><span class="n">SetTapIpv4Mask</span><span class="p">(</span><span class="n">tapMask</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">helper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="attributes">
<h5><span class="section-number">13.1.2.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> provides a number of attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Address</span></code>:  The MAC address of the device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Start</span></code>:  The simulation start time to spin up the device thread</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Stop</span></code>:  The simulation start time to stop the device thread</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EncapsulationMode</span></code>:  Link-layer encapsulation format</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RxQueueSize</span></code>:  The buffer size of the read queue on the file descriptor</dt><dd><p>thread (default of 1000 packets)</p>
</dd>
</dl>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Start</span></code> and <code class="docutils literal notranslate"><span class="pre">Stop</span></code> do not normally need to be specified unless the
user wants to limit the time during which this device is active.
<code class="docutils literal notranslate"><span class="pre">Address</span></code> needs to be set to some kind of unique MAC address if the
simulation will be interacting with other real devices somehow using
real MAC addresses.  Typical code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Address&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Mac48AddressValue</span><span class="p">(</span><span class="n">Mac48Address</span><span class="o">::</span><span class="n">Allocate</span><span class="p">()));</span>
</pre></div>
</div>
</section>
<section id="output">
<h5><span class="section-number">13.1.2.3. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>Ascii and PCAP tracing is provided similar to the other <em>ns-3</em> NetDevice
types, through the helpers, such as (e.g.):</p>
<dl class="simple">
<dt>::</dt><dd><p>EmuFdNetDeviceHelper emu;
NetDeviceContainer devices = emu.Install(node);
…
emu.EnablePcap(“emu-ping”, device, true);</p>
</dd>
</dl>
<p>The standard set of Mac-level NetDevice trace sources is provided.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxTx</span></code>:  Trace source triggered when <em>ns-3</em> provides the device with a
new frame to send</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxTxDrop</span></code>:  Trace source if write to file descriptor fails</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxPromiscRx</span></code>:  Whenever any valid Mac frame is received</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxRx</span></code>:  Whenever a valid Mac frame is received for this device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sniffer</span></code>:  Non-promiscuous packet sniffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PromiscSniffer</span></code>:  Promiscuous packet sniffer (for tcpdump-like traces)</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">13.1.2.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>Several examples are provided:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dummy-network.cc</span></code>:  This simple example creates two nodes and
interconnects them with a Unix pipe by passing the file descriptors
from the socketpair into the FdNetDevice objects of the respective nodes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">realtime-dummy-network.cc</span></code>:  Same as dummy-network.cc but uses the real time
simulator implementnation instead of the default one.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd2fd-onoff.cc</span></code>: This example is aimed at measuring the throughput of the
FdNetDevice in a pure simulation. For this purpose two FdNetDevices, attached to
different nodes but in a same simulation, are connected using a socket pair.
TCP traffic is sent at a saturating data rate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-onoff.cc</span></code>: This example is aimed at measuring the throughput of the
FdNetDevice  when using the EmuFdNetDeviceHelper to attach the simulated
device to a real device in the host machine. This is achieved by saturating
the channel with TCP traffic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-ping.cc</span></code>: This example uses the EmuFdNetDeviceHelper to send ICMP
traffic over a real channel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-udp-echo.cc</span></code>: This example uses the EmuFdNetDeviceHelper to send UDP
traffic over a real channel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-tap-ping.cc</span></code>: This example uses the TapFdNetDeviceHelper to send ICMP
traffic over a real channel.</p></li>
</ul>
</section>
</section>
</section>
<span id="document-netmap-net-device"></span><section id="netmap-netdevice">
<h3><span class="section-number">13.2. </span>Netmap NetDevice<a class="headerlink" href="#netmap-netdevice" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">fd-net-device</span></code> module provides the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> class, a class derived
from the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> which is able to read and write traffic using a netmap file descriptor.
This netmap file descriptor must be associated to a real ethernet device in the host machine.
The <code class="docutils literal notranslate"><span class="pre">NetmapNetDeviceHelper</span></code> class supports the configuration of a <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>.</p>
<p>netmap is a fast packet processing capability that bypasses the
host networking stack and gains direct access to network device.
netmap was developed by Luigi Rizzo <a class="reference internal" href="index.html#rizzo2012" id="id1"><span>[Rizzo2012]</span></a> and is maintained as
an open source project on GitHub at <a class="reference external" href="https://github.com/luigirizzo/netmap">https://github.com/luigirizzo/netmap</a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> for <em>ns-3</em> <a class="reference internal" href="index.html#imputato2019" id="id2"><span>[Imputato2019]</span></a> was developed by Pasquale Imputato in the 2017-19 timeframe.  The use of NetmapNetDevice requires that the
host system has netmap support (and for best performance, the drivers
must support netmap and must be using a netmap-enabled device driver).  Users
can expect that emulation support using Netmap will support higher packets
per second than emulation using FdNetDevice with raw sockets (which pass
through the Linux networking kernel).</p>
<div role="list" class="citation-list">
<div class="citation" id="rizzo2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Rizzo2012</a><span class="fn-bracket">]</span></span>
<p>Luigi Rizzo, “netmap: A Novel Framework for Fast Packet I/O”, Proceedings of 2012 USENIX Annual Technical Conference, June 2012.</p>
</div>
<div class="citation" id="imputato2019" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Imputato2019</a><span class="fn-bracket">]</span></span>
<p>Pasquale Imputato, Stefano Avallone, Enhancing the fidelity of network emulation through direct access to device buffers, Journal of Network and Computer Applications, Volume 130, 2019, Pages 63-75, (<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1084804519300220">http://www.sciencedirect.com/science/article/pii/S1084804519300220</a>)</p>
</div>
</div>
<section id="model-description">
<h4><span class="section-number">13.2.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<section id="design">
<h5><span class="section-number">13.2.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>Because netmap uses file descriptor based communication to interact with the
real device, the straightforward approach to design a new <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code> around
netmap is to have it inherit from the existing <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> and implement
a specialized version of the operations specific to netmap.
The operations that require a specialized implementation are the
initialization, because the NIC has to be put in netmap mode, and the
read/write methods, which have to make use of the netmap API to coordinate
the exchange of packets with the netmap rings.</p>
<p>In the initialization stage, the network device is switched to netmap mode,
so that <em>ns-3</em> is able to send/receive packets to/from the
real network device by writing/reading them to/from the netmap rings.
Following the design of the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code>, a separate reading thread is
started during the initialization. The task of the reading thread is
to wait for new incoming packets in the netmap receiver rings, in order
to schedule the events of packet reception. In
the initialization of the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>, an additional thread,
the sync thread, is started. The sync thread is required because, in order
to reduce the cost of the system calls, netmap does not automatically
transfer a packet written to a slot of the netmap ring to the transmission
ring or to the installed qdisc. It is up to the user process to
periodically request a synchronization of the netmap ring. Therefore,
the purpose of the sync thread is to periodically make a TXSYNC ioctl
request, so that pending packets in the netmap ring are transferred to
the transmission ring, if in native mode, or to the installed qdisc, if in
generic mode. Also, as described further below, the
sync thread is exploited to perform flow control and notify the BQL library
about the
amount of bytes that have been transferred to the network device.</p>
<p>The read method is called by the reading thread to retrieve new incoming
packets stored in the netmap receiver ring and pass them to the appropriate
<em>ns-3</em> protocol handler for further processing within the simulator’s network
stack. After retrieving packets, the reading thread also synchronizes
the netmap receiver ring, so that the retrieved packets can be removed
from the netmap receiver ring.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> also specializes the write method, i.e., the method
used to transmit a packet received from the upper layer (the <em>ns-3</em> traffic
control layer).  The write method uses the netmap API to write the packet to a
free slot in the netmap
transmission ring. After writing a packet, the write method checks whether
there is enough room in the netmap transmission ring for another packet.
If not, the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> stops its queue so that the <em>ns-3</em> traffic
control layer does not attempt to send a packet that could not be stored in
the netmap transmission ring.</p>
<p>A stopped <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> queue needs to be restarted as soon as some
room is made in the netmap transmission ring. The sync thread can be exploited
for this purpose, given that it periodically synchronizes the netmap
transmission ring. In particular, the sync thread also checks the number of
free slots in the netmap transmission ring in case the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>
queue is stopped.  If the number of free slots exceeds a configurable value,
the sync thread restarts the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>
queue and wakes the associated <em>ns-3</em> qdisc. The NetmapNetDevice also supports
BQL: the write method notifies the BQL library of the amount of bytes that
have been written to the netmap transmission ring, while the sync thread
notifies the BQL library of the amount of bytes that have been removed from
the netmap transmission ring and transferred to the NIC since the previous
notification.</p>
</section>
<section id="scope-and-limitations">
<h5><span class="section-number">13.2.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h5>
<p>The main scope of <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> is to support the flow-control between
the physical device and the upper layer and using at best the computational
resources to process packets.  However, the (Linux) system and network
device must support netmap to make use of this feature.</p>
</section>
</section>
<section id="usage">
<h4><span class="section-number">13.2.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>The installation of netmap itself on a host machine is out of scope for
this document.  Refer to the <a class="reference external" href="https://github.com/luigirizzo/netmap">netmap GitHub README</a> for instructions.</p>
<p>The <em>ns-3</em> netmap code has only been tested on Linux; it is not clear whether
other operating systems can be supported.</p>
<p>If <em>ns-3</em> is able to detect the presence of netmap on the system, it will
report that:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Netmap emulation FdNetDevice  : not enabled
</pre></div>
</div>
<p>If not, it will report:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Netmap emulation FdNetDevice  : not enabled (needs net/netmap_user.h)
</pre></div>
</div>
<p>To run FdNetDevice-enabled simulations, one must pass the <code class="docutils literal notranslate"><span class="pre">--enable-sudo</span></code>
option to <code class="docutils literal notranslate"><span class="pre">./ns3</span> <span class="pre">configure</span></code>, or else run the simulations with root
privileges.</p>
<section id="helpers">
<h5><span class="section-number">13.2.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p><em>ns-3</em> netmap support uses a <code class="docutils literal notranslate"><span class="pre">NetMapNetDeviceHelper</span></code> helper object to
install the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>.  In other respects, the API and use is similar
to that of the <code class="docutils literal notranslate"><span class="pre">EmuFdNetDeviceHelper</span></code>.</p>
</section>
<section id="attributes">
<h5><span class="section-number">13.2.2.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>There is one attribute specialized to <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>, named
<code class="docutils literal notranslate"><span class="pre">SyncAndNotifyQueuePeriod</span></code>.  This value takes an integer number of
microseconds, and is used as the period of time after which the device
syncs the netmap ring and notifies queue status.  The value should be
close to the interrupt coalescence period of the real device.  Users
may want to tune this parameter for their own system; it should be
a compromise between CPU usage and accuracy in the ring sync (if it is
too high, the device goes into starvation and lower throughput occurs).</p>
</section>
<section id="output">
<h5><span class="section-number">13.2.2.3. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> does not provide any specialized output, but
supports the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> output and traces (such as a promiscuous sniffer
trace).</p>
</section>
<section id="examples">
<h5><span class="section-number">13.2.2.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>Several examples are provided:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-onoff.cc</span></code>: This example is aimed at measuring the throughput of the
<code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> when using the <code class="docutils literal notranslate"><span class="pre">NetmapNetDeviceHelper</span></code> to attach the
simulated device to a real device in the host machine. This is achieved
by saturating the channel with TCP or UDP traffic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-ping.cc</span></code>: This example uses the <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> to send ICMP
traffic over a real device.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fd-emu-tc.cc</span></code>: This example configures a router on a machine with two</dt><dd><p>interfaces in emulated mode through netmap. The aim is to explore different
qdiscs behaviours on the backlog of a device emulated bottleneck side.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-send.cc</span></code>: This example builds a node with a device in
emulation mode through netmap.  The aim is to measure the maximum transmit
rate in packets per second (pps) achievable with <code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code> on
a specific machine.</p></li>
</ul>
<p>Note that all the examples run in emulation mode through netmap (with
<code class="docutils literal notranslate"><span class="pre">NetmapNetDevice</span></code>) and raw socket (with <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code>).</p>
</section>
</section>
</section>
<span id="document-dpdk-net-device"></span><section id="dpdk-netdevice">
<h3><span class="section-number">13.3. </span>DPDK NetDevice<a class="headerlink" href="#dpdk-netdevice" title="Link to this heading">¶</a></h3>
<p>Data Plane Development Kit (DPDK) is a library hosted by The Linux Foundation
to accelerate packet processing workloads (<a class="reference external" href="https://www.dpdk.org/">https://www.dpdk.org/</a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> class provides the implementation of a network device which uses DPDK’s fast packet processing abilities and bypasses the kernel. This class is included in the <code class="docutils literal notranslate"><span class="pre">src/fd-net-device</span> <span class="pre">model</span></code>. The <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> class inherits the <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> class and overrides the functions which are required by <em>ns-3</em> to interact with DPDK environment.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> for <em>ns-3</em> <a class="reference internal" href="index.html#patel2019" id="id1"><span>[Patel2019]</span></a> was developed by Harsh Patel,
Hrishikesh Hiraskar and Mohit P. Tahiliani. They were supported by Intel
Technology India Pvt. Ltd., Bangalore for this work.</p>
<div role="list" class="citation-list">
<div class="citation" id="patel2019" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Patel2019</a><span class="fn-bracket">]</span></span>
<p>Harsh Patel, Hrishikesh Hiraskar, Mohit P. Tahiliani, “Extending Network Emulation Support in ns-3 using DPDK”, Proceedings of the 2019 Workshop on ns-3, ACM, Pages 17-24, (<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3321349.3321358">https://dl.acm.org/doi/abs/10.1145/3321349.3321358</a>)</p>
</div>
</div>
<section id="model-description">
<h4><span class="section-number">13.3.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> is a network device which provides network emulation capabilities i.e. to allow simulated nodes to interact with real hosts and vice versa. The main feature of the <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> is that is uses the Environment Abstraction Layer (EAL) provided by DPDK to perform fast packet processing. EAL hides the device specific attributes from the applications and provides an interface via which the applications can interact directly with the Network Interface Card (NIC). This allows <em>ns-3</em> to send/receive packets directly to/from the NIC without the kernel involvement.</p>
<section id="design">
<h5><span class="section-number">13.3.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> is designed to act as an interface between <em>ns-3</em> and DPDK environment. There are 3 main phases in the life cycle of <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code>:</p>
<ul class="simple">
<li><p>Initialization</p></li>
<li><p>Packet Transfer - Read and Write</p></li>
<li><p>Termination</p></li>
</ul>
<section id="initialization">
<h6><span class="section-number">13.3.1.1.1. </span>Initialization<a class="headerlink" href="#initialization" title="Link to this heading">¶</a></h6>
<p><code class="docutils literal notranslate"><span class="pre">DpdkNetDeviceHelper</span></code> model is responsible for the initialization of <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code>. After this, the EAL is initialized, a memory pool is allocated, access to the Ethernet port is obtained and it is initialized, reception (Rx) and transmission (Tx) queues are set up on the port, Rx and Tx buffers are set up and LaunchCore method is called which will launch the <code class="docutils literal notranslate"><span class="pre">HandleRx</span></code> method to handle reading of packets in burst.</p>
</section>
<section id="packet-transfer">
<h6><span class="section-number">13.3.1.1.2. </span>Packet Transfer<a class="headerlink" href="#packet-transfer" title="Link to this heading">¶</a></h6>
<p>DPDK interacts with packet in the form of mbuf, a data structure provided by it, while <em>ns-3</em> interacts with packets in the form of raw buffer. The packet transfer functions take care of converting DPDK mbufs to <em>ns-3</em> buffers. The functions are read and write.</p>
<ul class="simple">
<li><p>Read: <code class="docutils literal notranslate"><span class="pre">HandleRx</span></code> method takes care of reading the packets from NIC and transferring them to <em>ns-3</em> Internet Stack. This function is called by <code class="docutils literal notranslate"><span class="pre">LaunchCore</span></code> method which is launched during initialization. It continuously polls the NIC using DPDK API for packets to read. It reads the mbuf packets in burst from NIC Rx ring, which are placed into Rx buffer upon read. For each mbuf packet in Rx buffer, it then converts it to <em>ns-3</em> raw buffer and then forwards the packet to <em>ns-3</em> Internet Stack.</p></li>
<li><p>Write: <code class="docutils literal notranslate"><span class="pre">Write</span></code> method handles transmission of packets. <em>ns-3</em> provides this packet in the form of a buffer, which is converted to packet mbuf and then placed in the Tx buffer. These packets are then transferred to NIC Tx ring when the Tx buffer is full, from where they will be transmitted by the NIC. However, there might be a scenario where there are not enough packets to fill the Tx buffer. This will lead to stale packet mbufs in buffer. In such cases, the <code class="docutils literal notranslate"><span class="pre">Write</span></code> function schedules a manual flush of these stale packet mbufs to NIC Tx ring, which will occur upon a certain timeout period. The default value of this timeout is set to <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">ms</span></code>.</p></li>
</ul>
</section>
<section id="termination">
<h6><span class="section-number">13.3.1.1.3. </span>Termination<a class="headerlink" href="#termination" title="Link to this heading">¶</a></h6>
<p>When <em>ns-3</em> is done using <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code>, the <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> will stop polling for Rx, free the allocated mbuf packets and then the mbuf pool. Lastly, it will stop the Ethernet device and close the port.</p>
</section>
</section>
<section id="scope-and-limitations">
<h5><span class="section-number">13.3.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h5>
<p>The current implementation supports only one NIC to be bound to DPDK with single  Rx and Tx on the NIC. This can be extended to support multiple NICs and multiple Rx/Tx queues simultaneously. Currently there is no support for Jumbo frames, which can be added. Offloading, scheduling features can also be added. Flow control and support for qdisc can be added to provide a more extensive model for network testing.</p>
</section>
</section>
<section id="dpdk-installation">
<h4><span class="section-number">13.3.2. </span>DPDK Installation<a class="headerlink" href="#dpdk-installation" title="Link to this heading">¶</a></h4>
<p>This section contains information on downloading DPDK source code and setting up DPDK for <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> to work.</p>
<section id="is-my-nic-supported-by-dpdk">
<h5><span class="section-number">13.3.2.1. </span>Is my NIC supported by DPDK?<a class="headerlink" href="#is-my-nic-supported-by-dpdk" title="Link to this heading">¶</a></h5>
<p>Check <a class="reference external" href="https://core.dpdk.org/supported/">Supported Devices</a>.</p>
</section>
<section id="not-supported-use-virtual-machine-instead">
<h5><span class="section-number">13.3.2.2. </span>Not supported? Use Virtual Machine instead<a class="headerlink" href="#not-supported-use-virtual-machine-instead" title="Link to this heading">¶</a></h5>
<p>Install <a class="reference external" href="https://www.virtualbox.org/">Oracle VM VirtualBox</a>. Create a new VM and install Ubuntu on it. Open settings, create a network adapter with following configuration:</p>
<ul class="simple">
<li><p>Attached to: Bridged Adapter</p></li>
<li><p>Name: The host network device you want to use</p></li>
<li><dl class="simple">
<dt>In Advanced</dt><dd><ul>
<li><p>Adapter Type: Intel PRO/1000 MT Server (82545EM) or any other DPDK supported NIC</p></li>
<li><p>Promiscuous Mode: Allow All</p></li>
<li><p>Select Cable Connected</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Then rest of the steps are same as follows.</p>
<p>DPDK can be installed in 2 ways:</p>
<ul class="simple">
<li><p>Install DPDK on Ubuntu</p></li>
<li><p>Compile DPDK from source</p></li>
</ul>
</section>
<section id="install-dpdk-on-ubuntu">
<h5><span class="section-number">13.3.2.3. </span>Install DPDK on Ubuntu<a class="headerlink" href="#install-dpdk-on-ubuntu" title="Link to this heading">¶</a></h5>
<p>To install DPDK on Ubuntu, run the following command:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>apt-get install dpdk dpdk-dev libdpdk-dev dpdk-igb-uio-dkms
</pre></div>
</div>
<p>Ubuntu 20.04 has packaged DPDK v19.11 LTS which is tested with this module and DpdkNetDevice will only be enabled if this version is available.</p>
</section>
<section id="compile-from-source">
<h5><span class="section-number">13.3.2.4. </span>Compile from Source<a class="headerlink" href="#compile-from-source" title="Link to this heading">¶</a></h5>
<p>To compile DPDK from source, you need to perform the following 4 steps:</p>
<section id="download-the-source">
<h6><span class="section-number">13.3.2.4.1. </span>1. Download the source<a class="headerlink" href="#download-the-source" title="Link to this heading">¶</a></h6>
<p>Visit the <a class="reference external" href="https://core.dpdk.org/download/">DPDK Downloads</a> page to download the latest stable source. (This module has been tested with version 19.11 LTS and DpdkNetDevice will only be enabled if this version is available.)</p>
</section>
<section id="configure-dpdk-as-a-shared-library">
<h6><span class="section-number">13.3.2.4.2. </span>2. Configure DPDK as a shared library<a class="headerlink" href="#configure-dpdk-as-a-shared-library" title="Link to this heading">¶</a></h6>
<p>In the DPDK directory, edit the <code class="docutils literal notranslate"><span class="pre">config/common_base</span></code> file to change the following line to compile DPDK as a shared library:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Compile to share library
CONFIG_RTE_BUILD_SHARED_LIB=y
</pre></div>
</div>
</section>
<section id="install-the-source">
<h6><span class="section-number">13.3.2.4.3. </span>3. Install the source<a class="headerlink" href="#install-the-source" title="Link to this heading">¶</a></h6>
<p>Refer to <a class="reference external" href="https://doc.dpdk.org/guides/linux_gsg/build_dpdk.html">Installation</a> for detailed instructions.</p>
<p>For a 64 bit linux machine with gcc, run:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>make install T=x86_64-native-linuxapp-gcc DESTDIR=install
</pre></div>
</div>
</section>
<section id="export-dpdk-environment-variables">
<h6><span class="section-number">13.3.2.4.4. </span>4. Export DPDK Environment variables<a class="headerlink" href="#export-dpdk-environment-variables" title="Link to this heading">¶</a></h6>
<p>Export the following environment variables:</p>
<ul class="simple">
<li><p>RTE_SDK as the your DPDK source folder.</p></li>
<li><p>RTE_TARGET as the build target directory.</p></li>
</ul>
<p>For example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>export RTE_SDK=/home/username/dpdk/dpdk-stable-19.11.1
export RTE_TARGET=x86_64-native-linuxapp-gcc
</pre></div>
</div>
<p>(Note: In case DPDK is moved, ns-3 needs to be reconfigured using <code class="docutils literal notranslate"><span class="pre">./ns3</span> <span class="pre">configure</span> <span class="pre">[options]</span></code>)</p>
<p>It is advisable that you export these variables in <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> or similar for reusability.</p>
</section>
</section>
<section id="load-dpdk-drivers-to-kernel">
<h5><span class="section-number">13.3.2.5. </span>Load DPDK Drivers to kernel<a class="headerlink" href="#load-dpdk-drivers-to-kernel" title="Link to this heading">¶</a></h5>
<p>Execute the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sudo modprobe uio_pci_generic
sudo modprobe uio
sudo modprobe vfio-pci

sudo modprobe igb_uio # for ubuntu package
# OR
sudo insmod $RTE_SDK/$RTE_TARGET/kmod/igb_uio.ko # for dpdk source
</pre></div>
</div>
<p>These should be done every time you reboot your system.</p>
</section>
<section id="configure-hugepages">
<h5><span class="section-number">13.3.2.6. </span>Configure hugepages<a class="headerlink" href="#configure-hugepages" title="Link to this heading">¶</a></h5>
<p>Refer <a class="reference external" href="https://doc.dpdk.org/guides/linux_gsg/sys_reqs.html">System Requirements</a> for detailed instructions.</p>
<p>To allocate hugepages at runtime, write a value such as ‘256’ to the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>echo 256 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
</pre></div>
</div>
<p>To allocate hugepages at boot time, edit <code class="docutils literal notranslate"><span class="pre">/etc/default/grub</span></code>, and following to <code class="docutils literal notranslate"><span class="pre">GRUB_CMDLINE_LINUX_DEFAULT</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>hugepages=256
</pre></div>
</div>
<p>We suggest minimum of number of <code class="docutils literal notranslate"><span class="pre">256</span></code> to run our applications. (This is to test an application run at 1 Gbps on a 1 Gbps NIC.) You can use any number of hugepages based on your system capacity and application requirements.</p>
<p>Then update the grub configurations using:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sudo update-grub
</pre></div>
</div>
<p>OR</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sudo update-grub2
</pre></div>
</div>
<p>You will need to reboot your system in order to see these changes.</p>
<p>To check allocation of hugepages, run:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cat /proc/meminfo | grep HugePages
</pre></div>
</div>
<p>You will see the number of hugepages allocated, they should be equal to the number you used above.</p>
<p>Once the hugepage memory is reserved (at either runtime or boot time),
to make the memory available for DPDK use, perform the following steps:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sudo mkdir /mnt/huge
sudo mount -t hugetlbfs nodev /mnt/huge
</pre></div>
</div>
<p>The mount point can be made permanent across reboots, by adding the following line to the <code class="docutils literal notranslate"><span class="pre">/etc/fstab</span></code> file:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nodev /mnt/huge hugetlbfs defaults 0 0
</pre></div>
</div>
</section>
</section>
<section id="usage">
<h4><span class="section-number">13.3.3. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>The status of DPDK support is shown in the output of <code class="docutils literal notranslate"><span class="pre">./ns3</span> <span class="pre">configure</span></code>.  If
it is found, a user should see:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DPDK NetDevice                : enabled
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DpdkNetDeviceHelper</span></code> class supports the configuration of <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------+
|         host 1       |
+----------------------+
|   ns-3 simulation    |
+----------------------+
|       ns-3 Node      |
|  +----------------+  |
|  |    ns-3 TCP    |  |
|  +----------------+  |
|  |    ns-3 IP     |  |
|  +----------------+  |
|  |  DpdkNetDevice |  |
|  |    10.1.1.1    |  |
|  +----------------+  |
|  |   raw socket   |  |
|--+----------------+--|
|       | eth0 |       |
+-------+------+-------+

        10.1.1.11

            |
            +-------------- ( Internet ) ----
</pre></div>
</div>
<p>Initialization of DPDK driver requires initialization of EAL. EAL requires PMD (Poll Mode Driver) Library for using NIC. DPDK supports multiple Poll Mode Drivers and you can use one that works for your NIC. PMD Library can be set via <code class="docutils literal notranslate"><span class="pre">DpdkNetDeviceHelper::SetPmdLibrary</span></code>, as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DpdkNetDeviceHelper* dpdk = new DpdkNetDeviceHelper();
dpdk-&gt;SetPmdLibrary(&quot;librte_pmd_e1000.so&quot;);
</pre></div>
</div>
<p>Also, NIC should be bound to DPDK Driver in order to be used with EAL. The default driver used is <code class="docutils literal notranslate"><span class="pre">uio_pci_generic</span></code> which supports most of the NICs. You can change it using <code class="docutils literal notranslate"><span class="pre">DpdkNetDeviceHelper::SetDpdkDriver</span></code>, as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DpdkNetDeviceHelper* dpdk = new DpdkNetDeviceHelper();
dpdk-&gt;SetDpdkDriver(&quot;igb_uio&quot;);
</pre></div>
</div>
<section id="attributes">
<h5><span class="section-number">13.3.3.1. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> provides a number of attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TxTimeout</span></code> - The time to wait before transmitting burst from Tx Buffer (in us). (default - <code class="docutils literal notranslate"><span class="pre">2000</span></code>) This attribute is only used to flush out buffer in case it is not filled. This attribute can be decrease for low data rate traffic. For high data rate traffic, this attribute needs no change.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxRxBurst</span></code> - Size of Rx Burst. (default - <code class="docutils literal notranslate"><span class="pre">64</span></code>) This attribute can be increased for higher data rates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxTxBurst</span></code> - Size of Tx Burst. (default - <code class="docutils literal notranslate"><span class="pre">64</span></code>) This attribute can be increased for higher data rates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MempoolCacheSize</span></code> - Size of mempool cache. (default - <code class="docutils literal notranslate"><span class="pre">256</span></code>) This attribute can be increased for higher data rates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NbRxDesc</span></code> - Number of Rx descriptors. (default - <code class="docutils literal notranslate"><span class="pre">1024</span></code>) This attribute can be increased for higher data rates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NbTxDesc</span></code> - Number of Tx descriptors. (default - <code class="docutils literal notranslate"><span class="pre">1024</span></code>) This attribute can be increased for higher data rates.</p></li>
</ul>
<p>Note: Default values work well with 1Gbps traffic.</p>
</section>
<section id="output">
<h5><span class="section-number">13.3.3.2. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>As <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> is inherited from <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code>, all the output methods provided by <code class="docutils literal notranslate"><span class="pre">FdNetDevice</span></code> can be used directly.</p>
</section>
<section id="examples">
<h5><span class="section-number">13.3.3.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The following examples are provided:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-ping.cc</span></code>: This example can be configured to use the <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> to send ICMP traffic bypassing the kernel over a real channel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd-emu-onoff.cc</span></code>: This example can be configured to measure the throughput of the <code class="docutils literal notranslate"><span class="pre">DpdkNetDevice</span></code> by sending traffic from the simulated node to a real device using the <code class="docutils literal notranslate"><span class="pre">ns3::OnOffApplication</span></code> while leveraging DPDK’s fast packet processing abilities. This is achieved by saturating the channel with TCP/UDP traffic.</p></li>
</ul>
</section>
</section>
</section>
<span id="document-tap"></span><section id="tap-netdevice">
<h3><span class="section-number">13.4. </span>Tap NetDevice<a class="headerlink" href="#tap-netdevice" title="Link to this heading">¶</a></h3>
<p>The Tap NetDevice can be used to allow a host system or virtual machines to
interact with a simulation.</p>
<section id="tapbridge-model-overview">
<h4><span class="section-number">13.4.1. </span>TapBridge Model Overview<a class="headerlink" href="#tapbridge-model-overview" title="Link to this heading">¶</a></h4>
<p>The Tap Bridge is designed to integrate “real” internet hosts (or more
precisely, hosts that support Tun/Tap devices) into ns-3 simulations.  The
goal is to make it appear to a “real” host node in that it has an ns-3 net
device as a local device.  The concept of a “real host” is a bit slippery
since the “real host” may actually be virtualized using readily available
technologies such as VMware, VirtualBox or OpenVZ.</p>
<p>Since we are, in essence, connecting the inputs and outputs of an ns-3 net
device to the inputs and outputs of a Linux Tap net device, we call this
arrangement a Tap Bridge.</p>
<p>There are three basic operating modes of this device available to users.
Basic functionality is essentially identical, but the modes are different
in details regarding how the arrangement is created and configured;
and what devices can live on which side of the bridge.</p>
<p>We call these three modes the ConfigureLocal, UseLocal and UseBridge modes.
The first “word” in the camel case mode identifier indicates who has the
responsibility for creating and configuring the taps.  For example,
the “Configure” in ConfigureLocal mode indicates that it is the TapBridge
that has responsibility for configuring the tap.  In UseLocal mode and
UseBridge modes, the “Use” prefix indicates that the TapBridge is asked to
“Use” an existing configuration.</p>
<p>In other words, in ConfigureLocal mode, the TapBridge has the responsibility
for creating and configuring the TAP devices.  In UseBridge or UseLocal
modes, the user provides a configuration and the TapBridge adapts to that
configuration.</p>
<section id="tapbridge-configurelocal-mode">
<h5><span class="section-number">13.4.1.1. </span>TapBridge ConfigureLocal Mode<a class="headerlink" href="#tapbridge-configurelocal-mode" title="Link to this heading">¶</a></h5>
<p>In the ConfigureLocal mode, the configuration of the tap device is ns-3
configuration-centric.  Configuration information is taken from a device
in the ns-3 simulation and a tap device matching the ns-3 attributes is
automatically created.  In this case, a Linux computer is made to appear as
if it was directly connected to a simulated ns-3 network.</p>
<p>This is illustrated below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+--------+
|  Linux |
|  host  |                    +----------+
| ------ |                    |   ghost  |
|  apps  |                    |   node   |
| ------ |                    | -------- |
|  stack |                    |    IP    |     +----------+
| ------ |                    |   stack  |     |   node   |
|  TAP   |                    |==========|     | -------- |
| device | &lt;----- IPC ------&gt; |   tap    |     |    IP    |
+--------+                    |  bridge  |     |   stack  |
                              | -------- |     | -------- |
                              |   ns-3   |     |   ns-3   |
                              |   net    |     |   net    |
                              |  device  |     |  device  |
                              +----------+     +----------+
                                   ||               ||
                              +---------------------------+
                              |        ns-3 channel       |
                              +---------------------------+
</pre></div>
</div>
<p>In this case, the “ns-3 net device” in the “ghost node” appears as if it
were actually replacing the TAP device in the Linux host.  The ns-3
simulation creates the TAP device on the underlying Linux OS and configures
the IP and MAC addresses of the TAP device to match the values assigned to
the simulated ns-3 net device.  The “IPC” link shown above is the network
tap mechanism in the underlying OS.  The whole arrangement acts as a
conventional bridge; but a bridge between devices that happen to have the
same shared MAC and IP addresses.</p>
<p>Here, the user is not required to provide any configuration information
specific to the tap.  A tap device will be created and configured by ns-3
according to its defaults, and the tap device will have its name assigned
by the underlying operating system according to its defaults.</p>
<p>If the user has a requirement to access the created tap device, he or she
may optionally provide a “DeviceName” attribute.  In this case, the created
OS tap device will be named accordingly.</p>
<p>The ConfigureLocal mode is the default operating mode of the Tap Bridge.</p>
</section>
<section id="tapbridge-uselocal-mode">
<h5><span class="section-number">13.4.1.2. </span>TapBridge UseLocal Mode<a class="headerlink" href="#tapbridge-uselocal-mode" title="Link to this heading">¶</a></h5>
<p>The UseLocal mode is quite similar to the ConfigureLocal mode.  The
significant difference is, as the mode name implies, the TapBridge is
going to “Use” an existing tap device previously created and configured
by the user.  This mode is particularly useful when a virtualization
scheme automatically creates tap devices and ns-3 is used to provide
simulated networks for those devices.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+--------+
|  Linux |
|  host  |                    +----------+
| ------ |                    |   ghost  |
|  apps  |                    |   node   |
| ------ |                    | -------- |
|  stack |                    |    IP    |     +----------+
| ------ |                    |   stack  |     |   node   |
|  TAP   |                    |==========|     | -------- |
| device | &lt;----- IPC ------&gt; |   tap    |     |    IP    |
| MAC X  |                    |  bridge  |     |   stack  |
+--------+                    | -------- |     | -------- |
                              |   ns-3   |     |   ns-3   |
                              |   net    |     |   net    |
                              |  device  |     |  device  |
                              |  MAC Y   |     |  MAC Z   |
                              +----------+     +----------+
                                   ||               ||
                              +---------------------------+
                              |        ns-3 channel       |
                              +---------------------------+
</pre></div>
</div>
<p>In this case, the pre-configured MAC address of the “Tap device” (MAC X)
will not be the same as that of the bridged “ns-3 net device” (MAC Y) shown
in the illustration above.  In order to bridge to ns-3 net devices which do
not support SendFrom() (especially wireless STA nodes) we impose a requirement
that only one Linux device (with one unique MAC address – here X) generates
traffic that flows across the IPC link.  This is because the MAC addresses of
traffic across the IPC link will be “spoofed” or changed to make it appear to
Linux and ns-3 that they have the same address.  That is, traffic moving from
the Linux host to the ns-3 ghost node will have its MAC address changed from
X to Y and traffic from the ghost node to the Linux host will have its MAC
address changed from Y to X.  Since there is a one-to-one correspondence
between devices, there may only be one MAC source flowing from the Linux side.
This means that Linux bridges with more than one net device added are
incompatible with UseLocal mode.</p>
<p>In UseLocal mode, the user is expected to create and configure a tap device
completely outside the scope of the ns-3 simulation using something like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>tuntap<span class="w"> </span>add<span class="w"> </span>mode<span class="w"> </span>tap<span class="w"> </span>tap0
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>address<span class="w"> </span>add<span class="w"> </span><span class="m">10</span>.1.1.1/24<span class="w"> </span>dev<span class="w"> </span>tap0
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>dev<span class="w"> </span>tap0<span class="w"> </span>address<span class="w"> </span><span class="m">08</span>:00:2e:00:00:01<span class="w"> </span>up
</pre></div>
</div>
<p>To tell the TapBridge what is going on, the user will set either directly
into the TapBridge or via the TapBridgeHelper, the “DeviceName” attribute.
In the case of the configuration above, the “DeviceName” attribute would be
set to “tap0” and the “Mode” attribute would be set to “UseLocal”.</p>
<p>One particular use case for this mode is in the OpenVZ environment.  There it
is possible to create a Tap device on the “Hardware Node” and move it into a
Virtual Private Server.  If the TapBridge is able to use an existing tap device
it is then possible to avoid the overhead of an OS bridge in that environment.</p>
</section>
<section id="tapbridge-usebridge-mode">
<h5><span class="section-number">13.4.1.3. </span>TapBridge UseBridge Mode<a class="headerlink" href="#tapbridge-usebridge-mode" title="Link to this heading">¶</a></h5>
<p>The simplest mode for those familiar with Linux networking is the UseBridge
mode.  Again, the “Use” prefix indicates that the TapBridge is going to Use
an existing configuration.  In this case, the TapBridge is going to logically
extend a Linux bridge into ns-3.</p>
<p>This is illustrated below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+---------+
|  Linux  |                             +----------+
| ------- |                             |   ghost  |
|  apps   |                             |   node   |
| ------- |                             | -------- |
|  stack  |                             |    IP    |     +----------+
| ------- | +--------+                  |   stack  |     |   node   |
| Virtual | |  TAP   |                  |==========|     | -------- |
| Device  | | Device | &lt;---- IPC -----&gt; |   tap    |     |    IP    |
+---------+ +--------+                  |  bridge  |     |   stack  |
    ||          ||                      | -------- |     | -------- |
+--------------------+                  |   ns-3   |     |   ns-3   |
|     OS Bridge      |                  |   net    |     |   net    |
+--------------------+                  |  device  |     |  device  |
                                        +----------+     +----------+
                                             ||               ||
                                        +---------------------------+
                                        |        ns-3 channel       |
                                        +---------------------------+
</pre></div>
</div>
<p>In this case, a computer running Linux applications, protocols, etc., is
connected to a ns-3 simulated network in such a way as to make it appear
to the Linux host that the TAP device is a real network device participating
in the Linux bridge.</p>
<p>In the ns-3 simulation, a TapBridge is created to match each TAP Device.
The name of the TAP Device is assigned to the Tap Bridge using the
“DeviceName” attribute.  The TapBridge then logically extends the OS bridge
to encompass the ns-3 net device.</p>
<p>Since this mode logically extends an OS bridge, there may be many Linux net
devices on the non-ns-3 side of the bridge.  Therefore, like a net device on
any bridge, the ns-3 net device must deal with the possibly of many source
addresses.  Thus, ns-3 devices must support SendFrom()
(NetDevice::SupportsSendFrom() must return true) in order to be configured
for use in UseBridge mode.</p>
<p>It is expected that the user will do something like the following to
configure the bridge and tap completely outside ns-3:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>link<span class="w"> </span>add<span class="w"> </span>mybridge<span class="w"> </span><span class="nb">type</span><span class="w"> </span>bridge
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>address<span class="w"> </span>add<span class="w"> </span><span class="m">10</span>.1.1.1/24<span class="w"> </span>dev<span class="w"> </span>mybridge
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>tuntap<span class="w"> </span>add<span class="w"> </span>mode<span class="w"> </span>tap<span class="w"> </span>mytap
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>dev<span class="w"> </span>mytap<span class="w"> </span>address<span class="w"> </span><span class="m">00</span>:00:00:00:00:01<span class="w"> </span>up
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>dev<span class="w"> </span>mytap<span class="w"> </span>master<span class="w"> </span>mybridge
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>dev<span class="w"> </span>...<span class="w"> </span>master<span class="w"> </span>mybridge
$<span class="w"> </span>sudo<span class="w"> </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>dev<span class="w"> </span>mybridge<span class="w"> </span>up
</pre></div>
</div>
<p>To tell the TapBridge what is going on, the user will set either directly
into the TapBridge or via the TapBridgeHelper, the “DeviceName” attribute.
In the case of the configuration above, the “DeviceName” attribute would be
set to “mytap” and the “Mode” attribute would be set to “UseBridge”.</p>
<p>This mode is especially  useful in the case of virtualization where the
configuration of the virtual hosts may be dictated by another system and
not be changeable to suit ns-3.  For example, a particular VM scheme may create
virtual “vethx” or “vmnetx” devices that appear local to virtual hosts.  In
order to connect to such systems, one would need to manually create TAP devices
on the host system and bridge these TAP devices to the existing (VM) virtual
devices.  The job of the Tap Bridge in this case is to extend the bridge to
join a ns-3 net device.</p>
</section>
<section id="tapbridge-configurelocal-operation">
<h5><span class="section-number">13.4.1.4. </span>TapBridge ConfigureLocal Operation<a class="headerlink" href="#tapbridge-configurelocal-operation" title="Link to this heading">¶</a></h5>
<p>In ConfigureLocal mode, the TapBridge and therefore its associated ns-3 net
device appears to the Linux host computer as a network device just like any
arbitrary “eth0” or “ath0” might appear.  The creation and configuration
of the TAP device is done by the ns-3 simulation and no manual configuration
is required by the user.  The IP addresses, MAC addresses, gateways, etc.,
for created TAP devices are extracted from the simulation itself by querying
the configuration of the ns-3 device and the TapBridge Attributes.</p>
<p>Since the MAC addresses are identical on the Linux side and the ns-3 side,
we can use Send() on the ns-3 device which is available on all ns-3 net devices.
Since the MAC addresses are identical there is no requirement to hook the
promiscuous callback on the receive side.  Therefore there are no restrictions
on the kinds of net device that are usable in ConfigureLocal mode.</p>
<p>The TapBridge appears to an ns-3 simulation as a channel-less net device.
This device must not have an IP address associated with it, but the bridged
(ns-3) net device must have an IP address.  Be aware that this is the inverse
of an ns-3 BridgeNetDevice (or a conventional bridge in general) which
demands that its bridge ports not have IP addresses, but allows the bridge
device itself to have an IP address.</p>
<p>The host computer will appear in a simulation as a “ghost” node that contains
one TapBridge for each NetDevice that is being bridged.  From the perspective
of a simulation, the only difference between a ghost node and any other node
will be the presence of the TapBridge devices.  Note however, that the
presence of the TapBridge does affect the connectivity of the net device to
the IP stack of the ghost node.</p>
<p>Configuration of address information and the ns-3 devices is not changed in
any way if a TapBridge is present.  A TapBridge will pick up the addressing
information from the ns-3 net device to which it is connected (its “bridged”
net device) and use that information to create and configure the TAP device
on the real host.</p>
<p>The end result of this is a situation where one can, for example, use the
standard ping utility on a real host to ping a simulated ns-3 node.  If
correct routes are added to the internet host (this is expected to be done
automatically in future ns-3 releases), the routing systems in ns-3 will
enable correct routing of the packets across simulated ns-3 networks.
For an example of this, see the example program, tap-wifi-dumbbell.cc in
the ns-3 distribution.</p>
<p>The Tap Bridge lives in a kind of a gray world somewhere between a Linux host
and an ns-3 bridge device.  From the Linux perspective, this code appears as
the user mode handler for a TAP net device.  In ConfigureLocal mode, this Tap
device is automatically created by the ns-3 simulation.  When the Linux host
writes to one of these automatically created /dev/tap devices, the write is
redirected into the TapBridge that lives in the ns-3 world; and from this
perspective, the packet write on Linux becomes a packet read in the Tap Bridge.
In other words, a Linux process writes a packet to a tap device and this packet
is redirected by the network tap mechanism toan ns-3 process where it is
received by the TapBridge as a result of a read operation there.  The TapBridge
then writes the packet to the ns-3 net device to which it is bridged; and
therefore it appears as if the Linux host sent a packet directly through an
ns-3 net device onto an ns-3 network.</p>
<p>In the other direction, a packet received by the ns-3 net device connected to
the Tap Bridge is sent via a receive callback to the TapBridge.  The
TapBridge then takes that packet and writes it back to the host using the
network tap mechanism.  This write to the device will appear to the Linux
host as if a packet has arrived on a net device; and therefore as if a packet
received by the ns-3 net device during a simulation has appeared on a real
Linux net device.</p>
<p>The upshot is that the Tap Bridge appears to bridge a tap device on a
Linux host in the “real world” to an ns-3 net device in the simulation.
Because the TAP device and the bridged ns-3 net device have the same MAC
address and the network tap IPC link is not externalized, this particular
kind of bridge makes it appear that a ns-3 net device is actually installed
in the Linux host.</p>
<p>In order to implement this on the ns-3 side, we need a “ghost node” in the
simulation to hold the bridged ns-3 net device and the TapBridge.  This node
should not actually do anything else in the simulation since its job is
simply to make the net device appear in Linux.  This is not just arbitrary
policy, it is because:</p>
<ul class="simple">
<li><p>Bits sent to the TapBridge from higher layers in the ghost node (using
the TapBridge Send method) are completely ignored.  The TapBridge is
not, itself, connected to any network, neither in Linux nor in ns-3.  You
can never send nor receive data over a TapBridge from the ghost node.</p></li>
<li><p>The bridged ns-3 net device has its receive callback disconnected
from the ns-3 node and reconnected to the Tap Bridge.  All data received
by a bridged device will then be sent to the Linux host and will not be
received by the node.  From the perspective of the ghost node, you can
send over this device but you cannot ever receive.</p></li>
</ul>
<p>Of course, if you understand all of the issues you can take control of
your own destiny and do whatever you want – we do not actively
prevent you from using the ghost node for anything you decide.  You
will be able to perform typical ns-3 operations on the ghost node if
you so desire.  The internet stack, for example, must be there and
functional on that node in order to participate in IP address
assignment and global routing.  However, as mentioned above,
interfaces talking to any TapBridge or associated bridged net devices
will not work completely.  If you understand exactly what you are
doing, you can set up other interfaces and devices on the ghost node
and use them; or take advantage of the operational send side of the
bridged devices to create traffic generators.  We generally recommend
that you treat this node as a ghost of the Linux host and leave it to
itself, though.</p>
</section>
<section id="tapbridge-uselocal-mode-operation">
<h5><span class="section-number">13.4.1.5. </span>TapBridge UseLocal Mode Operation<a class="headerlink" href="#tapbridge-uselocal-mode-operation" title="Link to this heading">¶</a></h5>
<p>As described in above, the TapBridge acts like a bridge from the “real” world
into the simulated ns-3 world.  In the case of the ConfigureLocal mode,
life is easy since the IP address of the Tap device matches the IP address of
the ns-3 device and the MAC address of the Tap device matches the MAC address
of the ns-3 device; and there is a one-to-one relationship between the
devices.</p>
<p>Things are slightly complicated when a Tap device is externally configured
with a  different MAC address than the ns-3 net device.  The conventional way
to deal with this kind of difference is to use promiscuous mode in the
bridged device to receive packets destined for the different MAC address and
forward them off to Linux.  In order to move packets the other way, the
conventional solution is SendFrom() which allows a caller to “spoof” or change
the source MAC address to match the different Linux MAC address.</p>
<p>We do have a specific requirement to be able to bridge Linux Virtual Machines
onto wireless STA nodes.  Unfortunately, the 802.11 spec doesn’t provide a
good way to implement SendFrom(), so we have to work around that problem.</p>
<p>To this end, we provided the UseLocal mode of the Tap Bridge.  This mode allows
you approach the problem as if you were creating a bridge with a single net
device.  A single allowed address on the Linux side is remembered in the
TapBridge, and all packets coming from the Linux side are repeated out the
ns-3 side using the ns-3 device MAC source address.  All packets coming in
from the ns-3 side are repeated out the Linux side using the remembered MAC
address.  This allows us to use Send() on the ns-3 device side which is
available on all ns-3 net devices.</p>
<p>UseLocal mode is identical to the ConfigureLocal mode except for the creation
and configuration of the tap device and the MAC address spoofing.</p>
</section>
<section id="tapbridge-usebridge-operation">
<h5><span class="section-number">13.4.1.6. </span>TapBridge UseBridge Operation<a class="headerlink" href="#tapbridge-usebridge-operation" title="Link to this heading">¶</a></h5>
<p>As described in the ConfigureLocal mode section, when the Linux host writes to
one of the /dev/tap devices, the write is redirected into the TapBridge
that lives in the ns-3 world.  In the case of the UseBridge mode, these
packets will need to be sent out on the ns-3 network as if they were sent on
a device participating in the Linux bridge.  This means calling the
SendFrom() method on the bridged device and providing the source MAC address
found in the packet.</p>
<p>In the other direction, a packet received by an ns-3 net device is hooked
via callback to the TapBridge.  This must be done in promiscuous mode since
the goal is to bridge the ns-3 net device onto the OS bridge of which the
TAP device is a part.</p>
<p>For these reasons, only ns-3 net devices that support SendFrom() and have a
hookable promiscuous receive callback are allowed to participate in UseBridge
mode TapBridge configurations.</p>
</section>
</section>
<section id="tap-bridge-channel-model">
<h4><span class="section-number">13.4.2. </span>Tap Bridge Channel Model<a class="headerlink" href="#tap-bridge-channel-model" title="Link to this heading">¶</a></h4>
<p>There is no channel model associated with the Tap Bridge.  In fact, the
intention is make it appear that the real internet host is connected to
the channel of the bridged net device.</p>
</section>
<section id="tap-bridge-tracing-model">
<h4><span class="section-number">13.4.3. </span>Tap Bridge Tracing Model<a class="headerlink" href="#tap-bridge-tracing-model" title="Link to this heading">¶</a></h4>
<p>Unlike most ns-3 devices, the TapBridge does not provide any standard trace
sources.  This is because the bridge is an intermediary that is essentially
one function call away from the bridged device.  We expect that the trace
hooks in the bridged device will be sufficient for most users,</p>
</section>
<section id="using-the-tapbridge">
<h4><span class="section-number">13.4.4. </span>Using the TapBridge<a class="headerlink" href="#using-the-tapbridge" title="Link to this heading">¶</a></h4>
<p>We expect that most users will interact with the TapBridge device through
the TapBridgeHelper.  Users of other helper classes, such as CSMA or Wifi,
should be comfortable with the idioms used there.</p>
</section>
</section>
</div>
</section>
<span id="document-energy"></span><section id="energy-framework">
<h2><span class="section-number">14. </span>Energy Framework<a class="headerlink" href="#energy-framework" title="Link to this heading">¶</a></h2>
<p>Energy is a key issue for wireless devices, and network researchers
often need to investigate the energy consumption at a node or in the
overall network while running network simulations in <em>ns-3</em>.
This requires <em>ns-3</em> to support an energy framework.
Further, as concepts such as fuel cells and energy
scavenging are becoming viable for low power wireless devices,
incorporating the effect of these emerging technologies into
simulations requires support for modeling diverse energy models in
ns-3. The <em>ns-3</em> energy framework provides the basis for energy storing
consumption and harvesting.</p>
<section id="model-description">
<h3><span class="section-number">14.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The framework is implemented into the <code class="docutils literal notranslate"><span class="pre">src/energy/</span></code> folder.</p>
<p>The <em>ns-3</em> energy framework is composed of 3 essential parts:</p>
<ul class="simple">
<li><p><strong>Energy source models.</strong> Represent storing energy sources such as batteries or capacitors.</p></li>
<li><p><strong>Energy consumption models.</strong> Represent a portion of a device that draws energy from energy sources. Examples of this include sensors, radio transceivers, vehicles, UAV, etc.</p></li>
<li><p><strong>Energy harvesting models.</strong> Represent devices that provide energy to energy sources. For example, solar panels and chargers.</p></li>
</ul>
<figure class="align-default" id="id7">
<span id="fig-energyframework"></span><img alt="_images/energyFramework.png" src="_images/energyFramework.png" />
<figcaption>
<p><span class="caption-text"><em>ns-3</em> energy framework</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="energy-source-models">
<h4><span class="section-number">14.1.1. </span>Energy Source Models<a class="headerlink" href="#energy-source-models" title="Link to this heading">¶</a></h4>
<p>An energy source represents a power supply. In <em>ns-3</em>, nodes can
have one or more energy sources. Likewise, energy sources can be
connected to multiple energy consuption models (Device energy models).
Connecting an energy source to a device energy model implies that the
corresponding device draws power from the source.
When energy is completely drained from the energy source, it notifies to the device energy models on
the node such that each device energy model can react to this event. Further, each node
can access the energy source objects for information such as remaining capacity , voltage or
state of charge (SoC). This enables the implementation of energy aware protocols in ns-3.</p>
<p>In order to model a wide range of power supplies such as batteries, the energy source must be able to capture characteristics of these supplies. There are 2 important characteristics or effects related to practical batteries:</p>
<ul class="simple">
<li><p><strong>Rate Capacity Effect.</strong> Decrease of battery lifetime when the current draw is higher than the rated value of the battery.</p></li>
<li><p><strong>Recovery Effect.</strong> Increase of battery lifetime when the battery is alternating between discharge and idle states.</p></li>
</ul>
<p>In order to incorporate the Rate Capacity Effect, the Energy Source
uses current draw from all the devices on the same node to calculate
energy consumption. Moreover, multiple Energy Harvesters can be
connected to the Energy Source in order to replenish its energy. The
Energy Source periodically polls all the devices and energy harvesters
on the same node to calculate the total current drain and hence the
energy consumption. When a device changes state, its corresponding
Device Energy Model will notify the Energy Source of this change and
new total current draw will be calculated. Similarly, every Energy
Harvester update triggers an update to the connected Energy Source.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">EnergySource</span></code> base class keeps a list of devices (<code class="docutils literal notranslate"><span class="pre">DeviceEnergyModel</span></code> objects) and energy harvesters (<code class="docutils literal notranslate"><span class="pre">EnergyHarvester</span></code> objects) that are using the particular Energy Source as power supply. When energy is completely drained, the Energy Source will notify all devices on this list. Each device can then handle this event independently, based on the desired behavior that should be followed in case of power outage.</p>
<section id="generic-batttery-model">
<h5><span class="section-number">14.1.1.1. </span>Generic Batttery Model<a class="headerlink" href="#generic-batttery-model" title="Link to this heading">¶</a></h5>
<p>The Generic battery model is able to represent 4 basic types of batteries
chemestries: Lithium-Ion (LiIon) or Lithium Polymer (LiPo), Nickel Cadmium (NiCd),
Lead Acid, and Nickel-metal hydride (NiMH). The main difference between these batteries
is the shape of the discharge curves when using constant discharge current and that
NiCd and NiMh batteries hysteresis phenomenon is also modeled. Peurket effect, aging,
temperature and variable battery impedance is not considered for all batteries. batteries
with similar discharge behavior might be also represented but one of the 4 basic
arqueotipes must be chosen.</p>
<p>The Generic Battery Model is directly based by the works of Trembley et al.
Tremblay’s model on itself is based on a popular battery model created by Shepherd.
Tremblay’s model consist in visually identify a set of points from batteries manufacters’
discharge curves datasheets.</p>
<figure class="align-default" id="id8">
<span id="id1"></span><img alt="_images/dischargeCurve.png" src="_images/dischargeCurve.png" />
<figcaption>
<p><span class="caption-text"><em>ns-3</em> Generic Battery Model Points in battery discharge curve.</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The 3 basic set of points that require identification in a datasheet are:</p>
<ul class="simple">
<li><p><img class="math" src="_images/math/01ba3ba1e5a8a79eeed38026e5dfea2c89634c67.png" alt="V_{full}:"/> The full battery voltage</p></li>
<li><p><img class="math" src="_images/math/2cf6f4be884ff687b56bf0b3ab7ba2ee90c5b58b.png" alt="Q:"/> The maximum battery capacity</p></li>
<li><p><img class="math" src="_images/math/e3bff569b762d1c05e724b0342db656839cf9116.png" alt="V_{exp}:"/> The voltage at the end of the exponential zone</p></li>
<li><p><img class="math" src="_images/math/5f698658c81f79ce93f9336d8c5681601f85ce09.png" alt="Q_{exp}:"/> The capacity at the end of the exponential zone</p></li>
<li><p><img class="math" src="_images/math/5c77744d77afded345115c1eebebc73800ce646e.png" alt="V_{nom}:"/> The voltage at the end of the exponential zone</p></li>
<li><p><img class="math" src="_images/math/1386e92b5f2a83792b90d93ecf3a25ec4dd7729c.png" alt="Q_{nom}:"/> The capacity at the end of the exponential zone</p></li>
</ul>
<p>Additionally, it is also necessary to set the values of:</p>
<ul class="simple">
<li><p><img class="math" src="_images/math/809e2e1b65ae55bec0ed9dbce6a27510ccc6249e.png" alt="R:"/> The battery impedance (The battery internal resistance)</p></li>
<li><p><img class="math" src="_images/math/3e726176f54b4b7ca56b4b119caa06d564b4c28a.png" alt="i_{typical}:"/> The typical current value used to discharge the battery, this value is used to calculate some of the constants used in the model.</p></li>
<li><p><img class="math" src="_images/math/be928587a701017c529df780f39c7e881c4f75f5.png" alt="cutoffVoltage:"/> Required if we desired to inform connected energy consumption models that the battery has reached its discharged point.</p></li>
<li><p><img class="math" src="_images/math/4975a9d6a86e654f3ef7750c7fcd4da0a7b3cc3f.png" alt="i:"/> The discharge current used to discharge the battery. This value is provided by the energy consumption model attached to the battery.</p></li>
</ul>
<p>The value of <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is typically included in the datatsheets, however, because <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> variability is not modeled in <em>ns-3</em> (The resistance is fixed), it is necessary
to discretely adjust its value to obtain the desired discharge curves. The value <img class="math" src="_images/math/a811a8a051ef7560155d166f791629a7fb3e71c2.png" alt="i_{typical}"/> can
be obtained by inferring its value from the discharged curves shown in datasheets. When modeling
the behavior of a new battery, it is important to chose values that satisfies more than one curve,
trial an error adjustments might be necessary to obtain the desired results.</p>
<p>Attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FullVoltage</span></code>: Represents the <img class="math" src="_images/math/8e947de26e616369a3b554e87ab9d777b3021757.png" alt="V_{full}"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxCapacity</span></code>: Represents the <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ExponentialVoltage</span></code>: Represents the <img class="math" src="_images/math/35713cd7104a70c141f57f2ee5a105789bedc3a8.png" alt="V_{exp}"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ExponentialCapacity</span></code>: Represents the <img class="math" src="_images/math/f6eab52357c6a65754d2deb7b53e70c9beaea9b3.png" alt="Q_{exp}"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NominalVoltage</span></code>: Represents the <img class="math" src="_images/math/1f6dbcc4c478c3288318e410014f675a9877f94b.png" alt="V_{nom}"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NominalCapacity</span></code>: Represents the <img class="math" src="_images/math/489f48b44f1a92c74bdacc52d5fce30e5c0aed20.png" alt="Q_{nom}"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InternalResistance</span></code>: Represents the <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TypicalDischargeCurrent</span></code>: Represents the <img class="math" src="_images/math/a811a8a051ef7560155d166f791629a7fb3e71c2.png" alt="i_{typical}"/> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CutoffVoltage</span></code>: The voltage where the battery is considered depleted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BatteryType</span></code>: Indicates the battery type used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PeriodicEnergyUpdateInterval</span></code>: Indicates how often the update values are obtained.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LowBatteryThreshold</span></code>: Additional voltage threshold to indicate when the battery has low energy.</p></li>
</ul>
<p>The process described above can be simplified by installing batteries presents of previously tested
batteries using helpers. Details on helpers usage are detailed in the following sections.</p>
</section>
<section id="rv-battery-model">
<h5><span class="section-number">14.1.1.2. </span>RV Battery Model<a class="headerlink" href="#rv-battery-model" title="Link to this heading">¶</a></h5>
<p>Attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelPeriodicEnergyUpdateInterval</span></code>: RV battery model sampling
interval.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelOpenCircuitVoltage</span></code>: RV battery model open circuit voltage.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelCutoffVoltage</span></code>: RV battery model cutoff voltage.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelAlphaValue</span></code>: RV battery model alpha value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelBetaValue</span></code>: RV battery model beta value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelNumOfTerms</span></code>: The number of terms of the infinite sum for estimating battery level.</p></li>
</ul>
</section>
<section id="basic-energy-source">
<h5><span class="section-number">14.1.1.3. </span>Basic Energy Source<a class="headerlink" href="#basic-energy-source" title="Link to this heading">¶</a></h5>
<p>Attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BasicEnergySourceInitialEnergyJ</span></code>: Initial energy stored in
basic energy source.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BasicEnergySupplyVoltageV</span></code>: Initial supply voltage for basic energy source.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PeriodicEnergyUpdateInterval</span></code>: Time between two consecutive periodic energy updates.</p></li>
</ul>
</section>
</section>
<section id="energy-consumption-models">
<h4><span class="section-number">14.1.2. </span>Energy Consumption Models<a class="headerlink" href="#energy-consumption-models" title="Link to this heading">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">DeviceEnergyModel</span></code> is the energy consumption model of a device installed on the node.
It is designed to be a state based model where each device is assumed to have a number of states, and each state is associated with a power consumption value.
Whenever the state of the device changes, the corresponding <code class="docutils literal notranslate"><span class="pre">DeviceEnergyModel</span></code> will notify the associated <code class="docutils literal notranslate"><span class="pre">EnergySourceModel</span></code> of the new current draw of the device.
The <code class="docutils literal notranslate"><span class="pre">EnergySourceModel</span></code> will then calculate the new total current draw and update the remaining energy. A <code class="docutils literal notranslate"><span class="pre">DeviceEnergyModel</span></code> can also be used for devices that do not have finite number of states.
For example, in an electric vehicle, the current draw of the motor is determined by its speed.
Since the vehicle’s speed can take continuous values within a certain range, it is infeasible to define a set of discrete states of operation.
However, by converting the speed value into current draw directly, the same set of <code class="docutils literal notranslate"><span class="pre">DeviceEnergyModel</span></code> APIs can still be used.</p>
<section id="wifi-radio-energy-model">
<h5><span class="section-number">14.1.2.1. </span>WiFi Radio Energy Model<a class="headerlink" href="#wifi-radio-energy-model" title="Link to this heading">¶</a></h5>
<p>The WiFi Radio Energy Model is the energy consumption model of a Wifi
net device. It provides a state for each of the available states of
the PHY layer: Idle, CcaBusy, Tx, Rx, ChannelSwitch, Sleep, Off. Each of
such states is associated with a value (in Ampere) of the current draw
(see below for the corresponding attribute names). A Wifi Radio Energy
Model PHY Listener is registered to the Wifi PHY in order to be
notified of every Wifi PHY state transition. At every transition, the
energy consumed in the previous state is computed and the energy
source is notified in order to update its remaining energy.</p>
<p>The Wifi Tx Current Model gives the possibility to compute the current
draw in the transmit state as a function of the nominal tx power (in
dBm), as observed in several experimental measurements. To this
purpose, the Wifi Radio Energy Model PHY Listener is notified of the
nominal tx power used to transmit the current frame and passes such a
value to the Wifi Tx Current Model which takes care of updating the
current draw in the Tx state. Hence, the energy consumption is
correctly computed even if the Wifi Remote Station Manager performs
per-frame power control. Currently, a Linear Wifi Tx Current Model is
implemented which computes the tx current as a linear function
(according to parameters that can be specified by the user) of the
nominal tx power in dBm.</p>
<p>The Wifi Radio Energy Model offers the possibility to specify a
callback that is invoked when the energy source is depleted. If such a
callback is not specified when the Wifi Radio Energy Model Helper is
used to install the model on a device, a callback is implicitly made
so that the Wifi PHY is put in the OFF mode (hence no frame is
transmitted nor received afterwards) when the energy source is
depleted. Likewise, it is possible to specify a callback that is
invoked when the energy source is recharged (which might occur in case
an energy harvester is connected to the energy source). If such a
callback is not specified when the Wifi Radio Energy Model Helper is
used to install the model on a device, a callback is implicitly made
so that the Wifi PHY is resumed from the OFF mode when the energy
source is recharged.</p>
<p>Attributes</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IdleCurrentA</span></code>: The default radio Idle current in Ampere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CcaBusyCurrentA</span></code>: The default radio CCA Busy State current in Ampere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TxCurrentA</span></code>: The radio Tx current in Ampere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RxCurrentA</span></code>: The radio Rx current in Ampere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SwitchingCurrentA</span></code>: The default radio Channel Switch current in Ampere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SleepCurrentA</span></code>: The radio Sleep current in Ampere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TxCurrentModel</span></code>: A pointer to the attached tx current model.</p></li>
</ul>
</section>
</section>
<section id="energy-harvesting-models">
<h4><span class="section-number">14.1.3. </span>Energy Harvesting Models<a class="headerlink" href="#energy-harvesting-models" title="Link to this heading">¶</a></h4>
<p>The energy harvester represents the elements that supply energy from
the environment and recharge an energy source to which it is
connected. The energy harvester includes the complete implementation
of the actual energy harvesting device (e.g., a solar panel) and the
environment (e.g., the solar radiation). This means that in
implementing an energy harvester, the energy contribution of the
environment and the additional energy requirements of the energy
harvesting device such as the conversion efficiency and the internal
power consumption of the device needs to be jointly modeled.</p>
</section>
</section>
<section id="usage">
<h3><span class="section-number">14.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The main way that ns-3 users will typically interact with the Energy
Framework is through the helper API and through the publicly visible
attributes of the framework. The helper API is defined in
<code class="docutils literal notranslate"><span class="pre">src/energy/helper/*.h</span></code>.</p>
<p>In order to use the energy framework, the user must install an Energy
Source for the node of interest, the corresponding Device Energy Model
for the network devices and, if necessary, the one or more Energy
Harvester. Energy Source (objects) are aggregated onto each node by
the Energy Source Helper. In order to allow multiple energy sources
per node, we aggregate an Energy Source Container rather than directly
aggregating a source object.</p>
<p>The Energy Source object keeps a list of Device Energy Model and
Energy Harvester objects using the source as power supply. Device
Energy Model objects are installed onto the Energy Source by the
Device Energy Model Helper, while Energy Harvester object are
installed by the Energy Harvester Helper. User can access the Device
Energy Model objects through the Energy Source object to obtain energy
consumption information of individual devices. Moreover, the user can
access to the Energy Harvester objects in order to gather information
regarding the current harvestable power and the total energy harvested
by the harvester.</p>
<section id="helpers">
<h4><span class="section-number">14.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p><strong>Energy Source Helper:</strong></p>
<p>Base helper class for Energy Source objects, this helper Aggregates
Energy Source object onto a node. Child implementation of this class
creates the actual Energy Source object.</p>
<p><strong>Device Energy Model Helper:</strong></p>
<p>Base helper class for Device Energy Model objects, this helper
attaches Device Energy Model objects onto Energy Source objects. Child
implementation of this class creates the actual Device Energy Model
object.</p>
<p><strong>Energy Harvesting Helper:</strong></p>
<p>Base helper class for Energy Harvester objects, this helper attaches
Energy Harvester objects onto Energy Source objects. Child
implementation of this class creates the actual Energy Harvester
object.</p>
<p><strong>Generic Battery Model Helper:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">GenericBatteryModelHelper</span></code> can be used to easily install an energy source into a
node or node container of one of four types of chemestries (Li-Ion,Lead Acid, NiCd,NiMH).
Users must use one of the available presets that represent an specific battery.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GenericBatteryModelHelper</span><span class="w"> </span><span class="n">batteryHelper</span><span class="p">;</span>
<span class="n">EnergySourceContainer</span>
<span class="n">energySourceContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">batteryHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodeContainer</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">PANASONIC_CGR18650DA_LION</span><span class="p">);</span>
<span class="n">batteryHelper</span><span class="p">.</span><span class="n">SetCellPack</span><span class="p">(</span><span class="n">energySourceContainer</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>In the previous example, the <code class="docutils literal notranslate"><span class="pre">GenericBatteryModelHelper</span></code> was used to install a Panasonic CGR18650DA
Li-Ion battery. Likewise, the helper is used to define a cell pack of 4 batteries. 2 batteries
connected in series and 2 connected in parallel (2S,2P).</p>
<p>Another option is to manually configure the values that makes the preset:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">devicesEnergyModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">SimpleDeviceEnergyModel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">batteryModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">GenericBatteryModel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;FullVoltage&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.39</span><span class="p">));</span><span class="w">            </span><span class="c1">// Qfull</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;MaxCapacity&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">7.0</span><span class="p">));</span><span class="w">             </span><span class="c1">// Q</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;NominalVoltage&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.18</span><span class="p">));</span><span class="w">         </span><span class="c1">// Vnom</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;NominalCapacity&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">6.25</span><span class="p">));</span><span class="w">        </span><span class="c1">// QNom</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;ExponentialVoltage&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.28</span><span class="p">));</span><span class="w">     </span><span class="c1">// Vexp</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;ExponentialCapacity&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.3</span><span class="p">));</span><span class="w">     </span><span class="c1">// Qexp</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;InternalResistance&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.0046</span><span class="p">));</span><span class="w">   </span><span class="c1">// R</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;TypicalDischargeCurrent&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.3</span><span class="p">));</span><span class="w"> </span><span class="c1">// i typical</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;CutoffVoltage&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span><span class="w">           </span><span class="c1">// End of charge.</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;BatteryType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">EnumValue</span><span class="p">(</span><span class="n">NIMH_NICD</span><span class="p">));</span><span class="w">         </span><span class="c1">// General battery type</span>
<span class="n">batteryModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DynamicCast</span><span class="o">&lt;</span><span class="n">GenericBatteryModel</span><span class="o">&gt;</span>
<span class="w">               </span><span class="p">(</span><span class="n">batteryHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">PANASONIC_HHR650D_NIMH</span><span class="p">));</span>
<span class="n">devicesEnergyModel</span><span class="o">-&gt;</span><span class="n">SetEnergySource</span><span class="p">(</span><span class="n">batteryModel</span><span class="p">);</span>
<span class="n">batteryModel</span><span class="o">-&gt;</span><span class="n">AppendDeviceEnergyModel</span><span class="p">(</span><span class="n">devicesEnergyModel</span><span class="p">);</span>
<span class="n">devicesEnergyModel</span><span class="o">-&gt;</span><span class="n">SetNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</pre></div>
</div>
<p>Usage of both of these type of configurations are shown in <code class="docutils literal notranslate"><span class="pre">generic-battery-discharge-example.cc</span></code>.
The following table is a list of the available presents in <em>ns-3</em>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Preset Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PANASONIC_CGR18650DA_LION</p></td>
<td><p>Panasonic Li-Ion  (3.6V, 2450Ah, Size A)</p></td>
</tr>
<tr class="row-odd"><td><p>PANASONIC_HHR650D_NIMH</p></td>
<td><p>Panasonic NiMh HHR550D (1.2V 6.5Ah, Size D)</p></td>
</tr>
<tr class="row-even"><td><p>CSB_GP1272_LEADACID</p></td>
<td><p>CSB Lead Acid GP1272 (12V,7.2Ah)</p></td>
</tr>
<tr class="row-odd"><td><p>PANASONIC_N700AAC_NICD</p></td>
<td><p>Panasonic NiCd N-700AAC (1.2V 700mAh, Size: AA)</p></td>
</tr>
<tr class="row-even"><td><p>RSPRO_LGP12100_LEADACID</p></td>
<td><p>Rs Pro Lead Acid LGP12100 (12V, 100Ah)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tracing">
<h4><span class="section-number">14.2.2. </span>Tracing<a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h4>
<p>Traced values differ between Energy Sources, Devices Energy Models and
Energy Harvesters implementations, please look at the specific child
class for details.</p>
<p><strong>Basic Energy Source</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RemainingEnergy</span></code>: Remaining energy at BasicEnergySource.</p></li>
</ul>
<p><strong>RV Battery Model</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelBatteryLevel</span></code>: RV battery model battery level.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RvBatteryModelBatteryLifetime</span></code>: RV battery model battery lifetime.</p></li>
</ul>
<p><strong>WiFi Radio Energy Model</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TotalEnergyConsumption</span></code>: Total energy consumption of the radio device.</p></li>
</ul>
<p><strong>Basic Energy Harvester</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HarvestedPower</span></code>: Current power provided by the BasicEnergyHarvester.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TotalEnergyHarvested</span></code>: Total energy harvested by the BasicEnergyHarvester.</p></li>
</ul>
</section>
<section id="examples">
<h4><span class="section-number">14.2.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The following examples have been written.</p>
<p>Examples in <code class="docutils literal notranslate"><span class="pre">src/energy/examples</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basic-energy-model-test.cc</span></code>: Demonstrates the use of a Basic energy source with a Wifi radio model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generic-battery-discharge-example.cc</span></code>: Demonstrates the installation of battery energy sources. The output of this example shows the discharge curve of 5 different batteries.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generic-battery-discharge-example.py</span></code>: A simplified version of the previous example but using python bindings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generic-battery-wifiradio-example.cc</span></code>: Demonstrates the use and installation of the Generic Battery Model with the WifiRadio model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rv-battery-model-test.cc</span></code>: Discharge example of a RV energy source model.</p></li>
</ul>
<p>Examples in <code class="docutils literal notranslate"><span class="pre">examples/energy</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">energy-model-example.cc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">energy-model-with-harvesting-example.cc</span></code>: Shows the harvesting model usage. Only usable with basicEnergySources.</p></li>
</ul>
</section>
<section id="tests">
<h4><span class="section-number">14.2.4. </span>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h4>
<p>The following tests have been written, which can be found in <code class="docutils literal notranslate"><span class="pre">src/energy/tests/</span></code>:</p>
</section>
</section>
<section id="validation">
<h3><span class="section-number">14.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The RV battery model is validated by comparing results with what was presented in the original RV battery model paper. The generic battery model is validated by superimposing the obtained discharge curves with manufacters’s datasheets plots. The following shows the results of the <code class="docutils literal notranslate"><span class="pre">generic-battery-discharge-example.cc</span></code> superimposed to manufacter’s datasheets charts:</p>
<figure class="align-default" id="id9">
<span id="fig-leadacid"></span><img alt="_images/leadacid.png" src="_images/leadacid.png" />
<figcaption>
<p><span class="caption-text">Lead acid battery discharge curve (CSB GP1272)</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id10">
<span id="fig-liion"></span><img alt="_images/liion.png" src="_images/liion.png" />
<figcaption>
<p><span class="caption-text">Li-Ion battery discharge curve (Panasonic CGR18650DA)</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id11">
<span id="fig-nicd"></span><img alt="_images/nicd.png" src="_images/nicd.png" />
<figcaption>
<p><span class="caption-text">NiCd battery discharge curve (Panasonic N-700AAC)</span><a class="headerlink" href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id12">
<span id="fig-nimh"></span><img alt="_images/nimh.png" src="_images/nimh.png" />
<figcaption>
<p><span class="caption-text">NiMH battery discharge curve (Panasonic HHR650D)</span><a class="headerlink" href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="scope-and-limitations">
<h4><span class="section-number">14.3.1. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>In the <code class="docutils literal notranslate"><span class="pre">GenericBatteryModel</span></code> charging behavior (voltage as a function of SoC) is included but is not been thoroughly tested. Testing requires the implementation of a harvesting device (A charger) capable of providing a CCCV charging method typically used in batteries.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">GenericBatteryModel</span></code> impedance (battery resistance) is constant, battery aging or temperature effects are not considered.</p></li>
<li><p>The Rv battery model has some reported issues (See: issue #164)</p></li>
<li><p>The harvesting mode can only be used with basic energy sources because it does not consider the current capacity or voltage of the battery.</p></li>
</ul>
</section>
<section id="future-work">
<h4><span class="section-number">14.3.2. </span>Future Work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Support of device energy models for PHY layers (lr-wpan, WiMax, etc) and other pieces of hardware (UAV, sensors, CPU).</p></li>
<li><p>Support for realistical charging batteries in the <code class="docutils literal notranslate"><span class="pre">GenericBatteryModule</span></code>.</p></li>
<li><p>Support for device capable of charging batteries (e.g. chargers with CCCV capabilities).</p></li>
<li><p>Implement an energy harvester that recharges the energy sources according to the power levels defined in a user customizable dataset of real measurements.</p></li>
</ul>
</section>
<section id="references">
<h4><span class="section-number">14.3.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<p>Energy source models and energy consumption models:</p>
<p>[<a class="reference external" href="https://labs.ece.uw.edu/nsl/papers/SIMUTools-11.pdf">1</a>] H. Wu, S. Nabar and R. Poovendran. An Energy Framework for the Network Simulator 3 (ns-3).</p>
<p>[2] M. Handy and D. Timmermann. Simulation of mobile wireless networks with accurate modelling of non-linear battery effects. In Proc. of Applied simulation and Modeling (ASM), 2003.</p>
<p>[3] D. N. Rakhmatov and S. B. Vrudhula. An analytical high-level battery model for use in energy management of portable electronic systems. In Proc. of IEEE/ACM International Conference on Computer Aided Design (ICCAD’01), pages 488-493, November 2001.</p>
<p>[4] D. N. Rakhmatov, S. B. Vrudhula, and D. A. Wallach. Battery lifetime prediction for energy-aware computing. In Proc. of the 2002 International Symposium on Low Power Electronics and Design (ISLPED’02), pages 154-159, 2002.</p>
<p>[<a class="reference external" href="https://www.mdpi.com/2032-6653/3/2/289">5</a>] Olivier Tremblay and Louis-A. Dessaint. 2009. Experimental Validation of a Battery Dynamic Model for EV Applications. World Electric Vehicle Journal 3, 2 (2009), 289–298. <a class="reference external" href="https://doi.org/10.3390/wevj3020289">https://doi.org/10.3390/wevj3020289</a></p>
<p>[<a class="reference external" href="https://ieeexplore.ieee.org/document/4544139">6</a>] Olivier Tremblay, Louis-A. Dessaint, and Abdel-Illah Dekkiche. 2007. A Generic Battery Model for the Dynamic Simulation of Hybrid Electric Vehicles. In 2007 IEEE Vehicle Power and Propulsion Conference. 284–289. <a class="reference external" href="https://doi.org/10.1109/VPPC.2007.4544139">https://doi.org/10.1109/VPPC.2007.4544139</a></p>
<p>[<a class="reference external" href="https://www.mathworks.com/help/sps/powersys/ref/battery.html">7</a>]  MatWorks SimuLink Generic Battery Model</p>
<p>[8] C. M. Shepherd. 1965. Design of Primary and Secondary Cells: II . An Equation Describing Battery Discharge. Journal of The Electrochemical Society 112, 7 (jul 1965), 657. <a class="reference external" href="https://doi.org/10.1149/1.2423659">https://doi.org/10.1149/1.2423659</a></p>
<p>[<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3592149.3592156">9</a>] Alberto Gallegos Ramonet, Alexander Guzman Urbina, and Kazuhiko Kinoshita. 2023. Evaluation and Extension of ns-3 Battery Framework. In Proceedings of the 2023 Workshop on ns-3 (WNS3 ‘23). Association for Computing Machinery, New York, NY, USA, 102–108. <a class="reference external" href="https://doi.org/10.1145/3592149.3592156">https://doi.org/10.1145/3592149.3592156</a></p>
<p>Energy Harvesting Models:</p>
<p>[10] C. Tapparello, H. Ayatollahi and W. Heinzelman. Extending the Energy Framework for Network Simulator 3 (ns-3). Workshop on ns-3 (WNS3), Poster Session, Atlanta, GA, USA. May, 2014.</p>
<p>[11] C. Tapparello, H. Ayatollahi and W. Heinzelman. Energy Harvesting Framework for Network Simulator 3 (ns-3). 2nd International Workshop on Energy Neutral Sensing Systems (ENSsys), Memphis, TN, USA. November 6, 2014.</p>
</section>
</section>
</section>
<span id="document-flow-monitor"></span><section id="flow-monitor">
<h2><span class="section-number">15. </span>Flow Monitor<a class="headerlink" href="#flow-monitor" title="Link to this heading">¶</a></h2>
<section id="model-description">
<h3><span class="section-number">15.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the module lives in the directory <code class="docutils literal notranslate"><span class="pre">src/flow-monitor</span></code>.</p>
<p>The Flow Monitor module goal is to provide a flexible system to measure the
performance of network protocols. The module uses probes, installed in network
nodes, to track the packets exchanged by the nodes, and it will measure
a number of parameters. Packets are divided according to the flow they belong
to, where each flow is defined according to the probe’s characteristics (e.g.,
for IP, a flow is defined as the packets with the same {protocol, source (IP, port),
destination (IP, port)} tuple.</p>
<p>The statistics are collected for each flow can be exported in XML format. Moreover,
the user can access the probes directly to request specific stats about each flow.</p>
<section id="design">
<h4><span class="section-number">15.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>Flow Monitor module is designed in a modular way. It can be extended by subclassing
<code class="docutils literal notranslate"><span class="pre">ns3::FlowProbe</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::FlowClassifier</span></code>.
Typically, a subclass of <code class="docutils literal notranslate"><span class="pre">ns3::FlowProbe</span></code> works by listening to the appropriate
class Traces, and then uses its own <code class="docutils literal notranslate"><span class="pre">ns3::FlowClassifier</span></code> subclass to classify
the packets passing though each node.</p>
<p>Each Probe can try to listen to other classes traces (e.g., <code class="docutils literal notranslate"><span class="pre">ns3::Ipv4FlowProbe</span></code>
will try to use any <code class="docutils literal notranslate"><span class="pre">ns3::NetDevice</span></code> trace named <code class="docutils literal notranslate"><span class="pre">TxQueue/Drop</span></code>) but this
is something that the user should not rely into blindly, because the trace is not
guaranteed to be in every type of <code class="docutils literal notranslate"><span class="pre">ns3::NetDevice</span></code>. As an example,
<code class="docutils literal notranslate"><span class="pre">CsmaNetDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code> have a <code class="docutils literal notranslate"><span class="pre">TxQueue/Drop</span></code> trace, while
<code class="docutils literal notranslate"><span class="pre">WiFiNetDevice</span></code> does not.</p>
<p>The full module design is described in <a class="reference internal" href="index.html#flowmonitor" id="id1"><span>[FlowMonitor]</span></a></p>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">15.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>At the moment, probes and classifiers are available only for IPv4 and IPv6.</p>
<p>IPv4 and IPv6 probes will classify packets in four points:</p>
<ul class="simple">
<li><p>When a packet is sent (SendOutgoing IPv[4,6] traces)</p></li>
<li><p>When a packet is forwarded (UnicastForward IPv[4,6] traces)</p></li>
<li><p>When a packet is received (LocalDeliver IPv[4,6] traces)</p></li>
<li><p>When a packet is dropped (Drop IPv[4,6] traces)</p></li>
</ul>
<p>Since the packets are tracked at IP level, any retransmission caused by L4 protocols (e.g., TCP)
will be seen by the probe as a new packet.</p>
<p>A Tag will be added to the packet (<code class="docutils literal notranslate"><span class="pre">ns3::Ipv[4,6]FlowProbeTag</span></code>). The tag will carry
basic packet’s data, useful for the packet’s classification.</p>
<p>It must be underlined that only L4 (TCP, UDP) packets are, so far, classified.
Moreover, only unicast packets will be classified.
These limitations may be removed in the future.</p>
<p>The data collected for each flow are:</p>
<ul class="simple">
<li><p>timeFirstTxPacket: when the first packet in the flow was transmitted;</p></li>
<li><p>timeLastTxPacket: when the last packet in the flow was transmitted;</p></li>
<li><p>timeFirstRxPacket: when the first packet in the flow was received by an end node;</p></li>
<li><p>timeLastRxPacket: when the last packet in the flow was received;</p></li>
<li><p>delaySum: the sum of all end-to-end delays for all received packets of the flow;</p></li>
<li><p>jitterSum: the sum of all end-to-end delay jitter (delay variation) values for all received packets of the flow, as defined in <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3393.html"><strong>RFC 3393</strong></a>;</p></li>
<li><p>txBytes, txPackets: total number of transmitted bytes / packets for the flow;</p></li>
<li><p>rxBytes, rxPackets: total number of received bytes / packets for the flow;</p></li>
<li><p>lostPackets: total number of packets that are assumed to be lost (not reported over 10 seconds);</p></li>
<li><p>timesForwarded: the number of times a packet has been reportedly forwarded;</p></li>
<li><p>delayHistogram, jitterHistogram, packetSizeHistogram: histogram versions for the delay, jitter, and packet sizes, respectively;</p></li>
<li><p>packetsDropped, bytesDropped: the number of lost packets and bytes, divided according to the loss reason code (defined in the probe).</p></li>
</ul>
<p>It is worth pointing out that the probes measure the packet bytes including IP headers.
The L2 headers are not included in the measure.</p>
<p>These stats will be written in XML form upon request (see the Usage section).</p>
<p>Due to the above design, FlowMonitor can not generate statistics when used with DSR routing
protocol (because DSR forwards packets using broadcast addresses)</p>
<section id="the-lost-packets-problem">
<h5><span class="section-number">15.1.2.1. </span>The “lost” packets problem<a class="headerlink" href="#the-lost-packets-problem" title="Link to this heading">¶</a></h5>
<p>At the end of a simulation, Flow Monitor could report about “lost” packets, i.e.,
packets that Flow Monitor have lost track of.</p>
<p>It is important to keep in mind that Flow Monitor records the packets statistics by
intercepting them at a given network level - let’s say at IP level. When the simulation
ends, any packet queued for transmission below the IP level will be considered as lost.</p>
<p>It is strongly suggested to consider this point when using Flow Monitor. The user can choose to:</p>
<ul class="simple">
<li><p>Ignore the lost packets (if their number is a statistically irrelevant quantity), or</p></li>
<li><p>Stop the Applications before the actual Simulation End time, leaving enough time between the two for the queued packets to be processed.</p></li>
</ul>
<p>The second method is the suggested one. Usually a few seconds are enough (the
exact value depends on the network type).</p>
<p>It is important to stress that “lost” packets could be anywhere in the network, and could count
toward the received packets or the dropped ones. Ideally, their number should be zero or a minimal
fraction of the other ones, i.e., they should be “statistically irrelevant”.</p>
</section>
</section>
<section id="references">
<h4><span class="section-number">15.1.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="flowmonitor" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">FlowMonitor</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="7">
<li><p>Carneiro, P. Fortuna, and M. Ricardo. 2009. FlowMonitor: a network monitoring framework for the network simulator 3 (NS-3). In Proceedings of the Fourth International ICST Conference on Performance Evaluation Methodologies and Tools (VALUETOOLS ‘09). <a class="reference external" href="http://dx.doi.org/10.4108/ICST.VALUETOOLS2009.7493">http://dx.doi.org/10.4108/ICST.VALUETOOLS2009.7493</a> (Full text: <a class="reference external" href="https://dl.acm.org/doi/abs/10.4108/ICST.VALUETOOLS2009.7493">https://dl.acm.org/doi/abs/10.4108/ICST.VALUETOOLS2009.7493</a>)</p></li>
</ol>
</div>
</div>
</section>
</section>
<section id="usage">
<h3><span class="section-number">15.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The module usage is extremely simple. The helper will take care of about everything.</p>
<p>The typical use is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Flow monitor</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FlowMonitor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flowMonitor</span><span class="p">;</span>
<span class="n">FlowMonitorHelper</span><span class="w"> </span><span class="n">flowHelper</span><span class="p">;</span>
<span class="n">flowMonitor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flowHelper</span><span class="p">.</span><span class="n">InstallAll</span><span class="p">();</span>

<span class="o">-</span><span class="n">yourApplicationsContainer</span><span class="o">-</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="n">stop_time</span><span class="p">));;</span>
<span class="n">Simulator</span><span class="o">::</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="n">stop_time</span><span class="o">+</span><span class="n">cleanup_time</span><span class="p">));</span>
<span class="n">Simulator</span><span class="o">::</span><span class="n">Run</span><span class="p">();</span>

<span class="n">flowMonitor</span><span class="o">-&gt;</span><span class="n">SerializeToXmlFile</span><span class="p">(</span><span class="s">&quot;NameOfFile.xml&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>the <code class="docutils literal notranslate"><span class="pre">SerializeToXmlFile()</span></code> function 2nd and 3rd parameters are used respectively to
activate/deactivate the histograms and the per-probe detailed stats.
Other possible alternatives can be found in the Doxygen documentation, while
<code class="docutils literal notranslate"><span class="pre">cleanup_time</span></code> is the time needed by in-flight packets to reach their destinations.</p>
<section id="helpers">
<h4><span class="section-number">15.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p>The helper API follows the pattern usage of normal helpers.
Through the helper you can install the monitor in the nodes, set the monitor attributes, and
print the statistics.</p>
<p>One important thing is: the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::FlowMonitorHelper</span></code> must be instantiated only
once in the main.</p>
</section>
<section id="attributes">
<h4><span class="section-number">15.2.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<p>The module provides the following attributes in <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::FlowMonitor</span></code>:</p>
<ul class="simple">
<li><p>MaxPerHopDelay (Time, default 10s): The maximum per-hop delay that should be considered;</p></li>
<li><p>StartTime (Time, default 0s): The time when the monitoring starts;</p></li>
<li><p>DelayBinWidth (double, default 0.001): The width used in the delay histogram;</p></li>
<li><p>JitterBinWidth (double, default 0.001): The width used in the jitter histogram;</p></li>
<li><p>PacketSizeBinWidth (double, default 20.0): The width used in the packetSize histogram;</p></li>
<li><p>FlowInterruptionsBinWidth (double, default 0.25): The width used in the flowInterruptions histogram;</p></li>
<li><p>FlowInterruptionsMinTime (double, default 0.5): The minimum inter-arrival time that is considered a flow interruption.</p></li>
</ul>
</section>
<section id="output">
<h4><span class="section-number">15.2.3. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h4>
<p>The main model output is an XML formatted report about flow statistics. An example is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;?</span><span class="n">xml</span><span class="w"> </span><span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="w"> </span><span class="o">?&gt;</span>
<span class="o">&lt;</span><span class="n">FlowMonitor</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">FlowStats</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">Flow</span><span class="w"> </span><span class="n">flowId</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="n">timeFirstTxPacket</span><span class="o">=</span><span class="s">&quot;+0.0ns&quot;</span><span class="w"> </span><span class="n">timeFirstRxPacket</span><span class="o">=</span><span class="s">&quot;+20067198.0ns&quot;</span><span class="w"> </span><span class="n">timeLastTxPacket</span><span class="o">=</span><span class="s">&quot;+2235764408.0ns&quot;</span><span class="w"> </span><span class="n">timeLastRxPacket</span><span class="o">=</span><span class="s">&quot;+2255831606.0ns&quot;</span><span class="w"> </span><span class="n">delaySum</span><span class="o">=</span><span class="s">&quot;+138731526300.0ns&quot;</span><span class="w"> </span><span class="n">jitterSum</span><span class="o">=</span><span class="s">&quot;+1849692150.0ns&quot;</span><span class="w"> </span><span class="n">lastDelay</span><span class="o">=</span><span class="s">&quot;+20067198.0ns&quot;</span><span class="w"> </span><span class="n">txBytes</span><span class="o">=</span><span class="s">&quot;2149400&quot;</span><span class="w"> </span><span class="n">rxBytes</span><span class="o">=</span><span class="s">&quot;2149400&quot;</span><span class="w"> </span><span class="n">txPackets</span><span class="o">=</span><span class="s">&quot;3735&quot;</span><span class="w"> </span><span class="n">rxPackets</span><span class="o">=</span><span class="s">&quot;3735&quot;</span><span class="w"> </span><span class="n">lostPackets</span><span class="o">=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="n">timesForwarded</span><span class="o">=</span><span class="s">&quot;7466&quot;</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">Flow</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">FlowStats</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">Ipv4FlowClassifier</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">Flow</span><span class="w"> </span><span class="n">flowId</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="n">sourceAddress</span><span class="o">=</span><span class="s">&quot;10.1.3.1&quot;</span><span class="w"> </span><span class="n">destinationAddress</span><span class="o">=</span><span class="s">&quot;10.1.2.2&quot;</span><span class="w"> </span><span class="n">protocol</span><span class="o">=</span><span class="s">&quot;6&quot;</span><span class="w"> </span><span class="n">sourcePort</span><span class="o">=</span><span class="s">&quot;49153&quot;</span><span class="w"> </span><span class="n">destinationPort</span><span class="o">=</span><span class="s">&quot;50000&quot;</span><span class="w"> </span><span class="o">/&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">Ipv4FlowClassifier</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">Ipv6FlowClassifier</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">Ipv6FlowClassifier</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">FlowProbes</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">FlowProbe</span><span class="w"> </span><span class="n">index</span><span class="o">=</span><span class="s">&quot;0&quot;</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">FlowStats</span><span class="w">  </span><span class="n">flowId</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="n">packets</span><span class="o">=</span><span class="s">&quot;3735&quot;</span><span class="w"> </span><span class="n">bytes</span><span class="o">=</span><span class="s">&quot;2149400&quot;</span><span class="w"> </span><span class="n">delayFromFirstProbeSum</span><span class="o">=</span><span class="s">&quot;+0.0ns&quot;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;/</span><span class="n">FlowStats</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">FlowProbe</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">FlowProbe</span><span class="w"> </span><span class="n">index</span><span class="o">=</span><span class="s">&quot;2&quot;</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">FlowStats</span><span class="w">  </span><span class="n">flowId</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="n">packets</span><span class="o">=</span><span class="s">&quot;7466&quot;</span><span class="w"> </span><span class="n">bytes</span><span class="o">=</span><span class="s">&quot;2224020&quot;</span><span class="w"> </span><span class="n">delayFromFirstProbeSum</span><span class="o">=</span><span class="s">&quot;+199415389258.0ns&quot;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;/</span><span class="n">FlowStats</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">FlowProbe</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">FlowProbe</span><span class="w"> </span><span class="n">index</span><span class="o">=</span><span class="s">&quot;4&quot;</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">FlowStats</span><span class="w">  </span><span class="n">flowId</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="n">packets</span><span class="o">=</span><span class="s">&quot;3735&quot;</span><span class="w"> </span><span class="n">bytes</span><span class="o">=</span><span class="s">&quot;2149400&quot;</span><span class="w"> </span><span class="n">delayFromFirstProbeSum</span><span class="o">=</span><span class="s">&quot;+138731526300.0ns&quot;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;/</span><span class="n">FlowStats</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">FlowProbe</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;/</span><span class="n">FlowProbes</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">FlowMonitor</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The output was generated by a TCP flow from 10.1.3.1 to 10.1.2.2.</p>
<p>It is worth noticing that the index 2 probe is reporting more packets and more bytes than the other probes.
That’s a perfectly normal behaviour, as packets are fragmented at IP level in that node.</p>
<p>It should also be observed that the receiving node’s probe (index 4) doesn’t count the fragments, as the
reassembly is done before the probing point.</p>
</section>
<section id="examples">
<h4><span class="section-number">15.2.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The examples are located in <cite>src/flow-monitor/examples</cite>.</p>
<p>Moreover, the following examples use the flow-monitor module:</p>
<ul class="simple">
<li><p>examples/matrix-topology/matrix-topology.cc</p></li>
<li><p>examples/routing/manet-routing-compare.cc</p></li>
<li><p>examples/routing/simple-global-routing.cc</p></li>
<li><p>examples/tcp/tcp-variants-comparison.cc</p></li>
<li><p>examples/wireless/wifi-multirate.cc</p></li>
<li><p>examples/wireless/wifi-hidden-terminal.cc</p></li>
</ul>
</section>
<section id="troubleshooting">
<h4><span class="section-number">15.2.5. </span>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Link to this heading">¶</a></h4>
<p>Do not define more than one <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::FlowMonitorHelper</span></code> in the simulation.</p>
</section>
</section>
<section id="validation">
<h3><span class="section-number">15.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The paper in the references contains a full description of the module validation against
a test network.</p>
<p>Tests are provided to ensure the Histogram correct functionality.</p>
</section>
</section>
<span id="document-internet-models"></span><section id="internet-models-ip-tcp-routing-udp">
<h2><span class="section-number">16. </span>Internet Models (IP, TCP, Routing, UDP)<a class="headerlink" href="#internet-models-ip-tcp-routing-udp" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-internet-stack"></span><section id="internet-stack">
<h3><span class="section-number">16.1. </span>Internet Stack<a class="headerlink" href="#internet-stack" title="Link to this heading">¶</a></h3>
<section id="internet-stack-aggregation">
<h4><span class="section-number">16.1.1. </span>Internet stack aggregation<a class="headerlink" href="#internet-stack-aggregation" title="Link to this heading">¶</a></h4>
<p>A bare class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Node</span></code> is not very useful as-is; other objects must be
aggregated to it to provide useful node functionality.</p>
<p>The <em>ns-3</em> source code directory <code class="docutils literal notranslate"><span class="pre">src/internet</span></code> provides implementation
of TCP/IPv4- and IPv6-related components. These include IPv4, ARP, UDP, TCP,
IPv6, Neighbor Discovery, and other related protocols.</p>
<p>Internet Nodes are not subclasses of class Node; they are simply Nodes that have
had a bunch of IP-related objects aggregated to them. They can be put together
by hand, or via a helper function <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InternetStackHelper::Install</span> <span class="pre">()</span></code>
which does the following to all nodes passed in as arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">InternetStackHelper::Install</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_ipv4Enabled</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* IPv4 stack */</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">NS_FATAL_ERROR</span><span class="p">(</span><span class="s">&quot;InternetStackHelper::Install(): Aggregating &quot;</span>
<span class="w">                         </span><span class="s">&quot;an InternetStack to a node with an existing Ipv4 object&quot;</span><span class="p">);</span>
<span class="w">          </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">      </span><span class="n">CreateAndAggregateObjectFromTypeId</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::ArpL3Protocol&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">CreateAndAggregateObjectFromTypeId</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::Ipv4L3Protocol&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">CreateAndAggregateObjectFromTypeId</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::Icmpv4L4Protocol&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// Set routing</span>
<span class="w">      </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">      </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4RoutingProtocol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4Routing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_routing</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">      </span><span class="n">ipv4</span><span class="o">-&gt;</span><span class="n">SetRoutingProtocol</span><span class="p">(</span><span class="n">ipv4Routing</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_ipv6Enabled</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* IPv6 stack */</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv6</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">NS_FATAL_ERROR</span><span class="p">(</span><span class="s">&quot;InternetStackHelper::Install(): Aggregating &quot;</span>
<span class="w">                         </span><span class="s">&quot;an InternetStack to a node with an existing Ipv6 object&quot;</span><span class="p">);</span>
<span class="w">          </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">      </span><span class="n">CreateAndAggregateObjectFromTypeId</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::Ipv6L3Protocol&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">CreateAndAggregateObjectFromTypeId</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::Icmpv6L4Protocol&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// Set routing</span>
<span class="w">      </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv6</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv6</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">      </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv6RoutingProtocol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv6Routing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_routingv6</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">      </span><span class="n">ipv6</span><span class="o">-&gt;</span><span class="n">SetRoutingProtocol</span><span class="p">(</span><span class="n">ipv6Routing</span><span class="p">);</span>

<span class="w">      </span><span class="cm">/* register IPv6 extensions and options */</span>
<span class="w">      </span><span class="n">ipv6</span><span class="o">-&gt;</span><span class="n">RegisterExtensions</span><span class="p">();</span>
<span class="w">      </span><span class="n">ipv6</span><span class="o">-&gt;</span><span class="n">RegisterOptions</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_ipv4Enabled</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">m_ipv6Enabled</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* UDP and TCP stacks */</span>
<span class="w">      </span><span class="n">CreateAndAggregateObjectFromTypeId</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::UdpL4Protocol&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">AggregateObject</span><span class="p">(</span><span class="n">m_tcpFactory</span><span class="p">.</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">      </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">PacketSocketFactory</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">PacketSocketFactory</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">      </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">AggregateObject</span><span class="p">(</span><span class="n">factory</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Where multiple implementations exist in <em>ns-3</em> (TCP, IP routing), these objects
are added by a factory object (TCP) or by a routing helper (m_routing).</p>
<p>Note that the routing protocol is configured and set outside this
function. By default, the following protocols are added:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">InternetStackHelper::Initialize</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">SetTcp</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Ipv4StaticRoutingHelper</span><span class="w"> </span><span class="n">staticRouting</span><span class="p">;</span>
<span class="w">  </span><span class="n">Ipv4GlobalRoutingHelper</span><span class="w"> </span><span class="n">globalRouting</span><span class="p">;</span>
<span class="w">  </span><span class="n">Ipv4ListRoutingHelper</span><span class="w"> </span><span class="n">listRouting</span><span class="p">;</span>
<span class="w">  </span><span class="n">Ipv6ListRoutingHelper</span><span class="w"> </span><span class="n">listRoutingv6</span><span class="p">;</span>
<span class="w">  </span><span class="n">Ipv6StaticRoutingHelper</span><span class="w"> </span><span class="n">staticRoutingv6</span><span class="p">;</span>
<span class="w">  </span><span class="n">listRouting</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">staticRouting</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">listRouting</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">globalRouting</span><span class="p">,</span><span class="w"> </span><span class="mi">-10</span><span class="p">);</span>
<span class="w">  </span><span class="n">listRoutingv6</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">staticRoutingv6</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">SetRoutingHelper</span><span class="p">(</span><span class="n">listRouting</span><span class="p">);</span>
<span class="w">  </span><span class="n">SetRoutingHelper</span><span class="p">(</span><span class="n">listRoutingv6</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By default, IPv4 and IPv6 are enabled.</p>
<section id="internet-node-structure">
<h5><span class="section-number">16.1.1.1. </span>Internet Node structure<a class="headerlink" href="#internet-node-structure" title="Link to this heading">¶</a></h5>
<p>An IP-capable Node (an <em>ns-3</em> Node augmented by aggregation to have one or more
IP stacks) has the following internal structure.</p>
<section id="layer-3-protocols">
<h6><span class="section-number">16.1.1.1.1. </span>Layer-3 protocols<a class="headerlink" href="#layer-3-protocols" title="Link to this heading">¶</a></h6>
<p>At the lowest layer, sitting above the NetDevices, are the “layer 3” protocols,
including IPv4, IPv6, ARP and so on. The class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4L3Protocol</span></code> is an implementation class whose public interface is
typically class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4</span></code>, but the
Ipv4L3Protocol public API is also used internally at present.</p>
<p>In class Ipv4L3Protocol, one method described below is <code class="docutils literal notranslate"><span class="pre">Receive</span> <span class="pre">()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">  * Lower layer calls this method after calling L3Demux::Lookup</span>
<span class="cm">  * The ARP subclass needs to know from which NetDevice this</span>
<span class="cm">  * packet is coming to:</span>
<span class="cm">  *    - implement a per-NetDevice ARP cache</span>
<span class="cm">  *    - send back arp replies on the right device</span>
<span class="cm">  */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Receive</span><span class="p">(</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">protocol</span><span class="p">,</span>
<span class="k">const</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">NetDevice</span><span class="o">::</span><span class="n">PacketType</span><span class="w"> </span><span class="n">packetType</span><span class="p">);</span>
</pre></div>
</div>
<p>First, note that the <code class="docutils literal notranslate"><span class="pre">Receive</span> <span class="pre">()</span></code> function has a matching signature to the
ReceiveCallback in the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Node</span></code>. This function pointer is
inserted into the Node’s protocol handler when <code class="docutils literal notranslate"><span class="pre">AddInterface</span> <span class="pre">()</span></code> is called.
The actual registration is done
with a statement such as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">RegisterProtocolHandler</span><span class="p">(</span><span class="w"> </span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ipv4Protocol</span><span class="o">::</span><span class="n">Receive</span><span class="p">,</span><span class="w"> </span><span class="n">ipv4</span><span class="p">),</span>
<span class="w">                         </span><span class="n">Ipv4L3Protocol</span><span class="o">::</span><span class="n">PROT_NUMBER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The Ipv4L3Protocol object is aggregated to the Node; there is only one such
Ipv4L3Protocol object. Higher-layer protocols that have a packet to send down to
the Ipv4L3Protocol object can call <code class="docutils literal notranslate"><span class="pre">GetObject&lt;Ipv4L3Protocol&gt;()</span></code> to obtain a
pointer, as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4L3Protocol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4L3Protocol</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ipv4</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ipv4</span><span class="o">-&gt;</span><span class="n">Send</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="n">saddr</span><span class="p">,</span><span class="w"> </span><span class="n">daddr</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_NUMBER</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>This class nicely demonstrates two techniques we exploit in <em>ns-3</em> to bind
objects together:  callbacks, and object aggregation.</p>
<p>Once IPv4 routing has determined that a packet is for the local node, it
forwards it up the stack.  This is done with the following function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="n">Ipv4L3Protocol</span><span class="o">::</span><span class="n">LocalDeliver</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="n">Ipv4Header</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iif</span><span class="p">)</span>
</pre></div>
</div>
<p>The first step is to find the right Ipv4L4Protocol object, based on IP protocol
number. For instance, TCP is registered in the demux as protocol number 6.
Finally, the <code class="docutils literal notranslate"><span class="pre">Receive()</span></code> function on the Ipv4L4Protocol (such as
<code class="docutils literal notranslate"><span class="pre">TcpL4Protocol::Receive</span></code> is called.</p>
<p>We have not yet introduced the class Ipv4Interface. Basically, each NetDevice is
paired with an IPv4 representation of such device. In Linux, this class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4Interface</span></code> roughly corresponds to the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in_device</span></code>; the
main purpose is to provide address-family specific information (addresses) about
an interface.</p>
<p>All the classes have appropriate traces in order to track sent, received and lost packets.
The users is encouraged to use them so to find out if (and where) a packet is dropped. A
common mistake is to forget the effects of local queues when sending packets, e.g., the ARP
queue. This can be particularly puzzling when sending jumbo packets or packet bursts using UDP.
The ARP cache pending queue is limited (3 datagrams) and IP packets might be fragmented, easily
overfilling the ARP cache queue size. In those cases it is useful to increase the ARP cache
pending size to a proper value, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::ArpCache::PendingQueueSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="n">MAX_BURST_SIZE</span><span class="o">/</span><span class="n">L2MTU</span><span class="o">*</span><span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
<p>The IPv6 implementation follows a similar architecture.  Dual-stacked nodes (one with
support for both IPv4 and IPv6) will allow an IPv6 socket to receive IPv4 connections
as a standard dual-stacked system does.  A socket bound and listening to an IPv6 endpoint
can receive an IPv4 connection and will return the remote address as an IPv4-mapped address.
Support for the IPV6_V6ONLY socket option does not currently exist.</p>
</section>
<section id="layer-4-protocols-and-sockets">
<h6><span class="section-number">16.1.1.1.2. </span>Layer-4 protocols and sockets<a class="headerlink" href="#layer-4-protocols-and-sockets" title="Link to this heading">¶</a></h6>
<p>We next describe how the transport protocols, sockets, and applications tie
together. In summary, each transport protocol implementation is a socket
factory. An application that needs a new socket</p>
<p>For instance, to create a UDP socket, an application would use a code snippet
such as the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="w"> </span><span class="n">udpSocketFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socketFactory</span><span class="o">-&gt;</span><span class="n">CreateSocket</span><span class="p">();</span>
<span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">m_local_address</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The above will query the node to get a pointer to its UDP socket factory, will
create one such socket, and will use the socket with an API similar to the
C-based sockets API, such as <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> and <code class="docutils literal notranslate"><span class="pre">Send()</span></code>.  The address passed
to the <code class="docutils literal notranslate"><span class="pre">Bind()</span></code>, <code class="docutils literal notranslate"><span class="pre">Connect()</span></code>, or <code class="docutils literal notranslate"><span class="pre">Send()</span></code> functions may be a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4Address</span></code>, <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6Address</span></code>, or <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Address</span></code>.
If a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Address</span></code> is passed in and contains anything other than
a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4Address</span></code> or <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6Address</span></code>, these functions will
return an error.  The <code class="docutils literal notranslate"><span class="pre">Bind()</span></code> and <code class="docutils literal notranslate"><span class="pre">Bind6()</span></code> functions bind to
“0.0.0.0” and “::” respectively.</p>
<p>The socket can also be bound to a specific NetDevice though the
<code class="docutils literal notranslate"><span class="pre">BindToNetDevice(Ptr&lt;NetDevice&gt;</span> <span class="pre">netdevice)</span></code> function.
<code class="docutils literal notranslate"><span class="pre">BindToNetDevice(Ptr&lt;NetDevice&gt;</span> <span class="pre">netdevice)</span></code> will bind the socket
to “0.0.0.0” and “::”(equivalent to calling <code class="docutils literal notranslate"><span class="pre">Bind()</span></code> and <code class="docutils literal notranslate"><span class="pre">Bind6()</span></code>,
unless the socket has been already bound to a specific address.
Summarizing, the correct sequence is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="w"> </span><span class="n">udpSocketFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socketFactory</span><span class="o">-&gt;</span><span class="n">CreateSocket</span><span class="p">();</span>
<span class="w"> </span><span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">BindToNetDevice</span><span class="p">(</span><span class="n">n_netDevice</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="w"> </span><span class="n">udpSocketFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socketFactory</span><span class="o">-&gt;</span><span class="n">CreateSocket</span><span class="p">();</span>
<span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">m_local_address</span><span class="p">);</span>
<span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">BindToNetDevice</span><span class="p">(</span><span class="n">n_netDevice</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The following raises an error:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="w"> </span><span class="n">udpSocketFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Udp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socketFactory</span><span class="o">-&gt;</span><span class="n">CreateSocket</span><span class="p">();</span>
<span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">BindToNetDevice</span><span class="p">(</span><span class="n">n_netDevice</span><span class="p">);</span>
<span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">m_local_address</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>See the chapter on <em>ns-3</em> sockets for more information.</p>
<p>We have described so far a socket factory (e.g. <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Udp</span></code>) and a socket,
which may be specialized (e.g., class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocket</span></code>).  There are a few
more key objects that relate to the specialized task of demultiplexing a packet
to one or more receiving sockets.  The key object in this task is class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4EndPointDemux</span></code>.  This demultiplexer stores objects of class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4EndPoint</span></code>.  This class holds the addressing/port tuple (local
port, local address, destination port, destination address) associated with the
socket, and a receive callback. This receive callback has a receive function
registered by the socket. The <code class="docutils literal notranslate"><span class="pre">Lookup()</span></code> function to Ipv4EndPointDemux
returns a list of Ipv4EndPoint objects(there may be a list since more than one
socket may match the packet). The layer-4 protocol copies the packet to each
Ipv4EndPoint and calls its <code class="docutils literal notranslate"><span class="pre">ForwardUp()</span></code> method, which then calls the
<code class="docutils literal notranslate"><span class="pre">Receive()</span></code> function registered by the socket.</p>
<p>An issue that arises when working with the sockets API on real
systems is the need to manage the reading from a socket, using
some type of I/O (e.g., blocking, non-blocking, asynchronous, …).
<em>ns-3</em> implements an asynchronous model for socket I/O; the application
sets a callback to be notified of received data ready to be read, and the
callback is invoked by the transport protocol when data is available.
This callback is specified as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Socket::SetRecvCallback</span><span class="p">(</span><span class="n">Callback</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">Address</span><span class="o">&amp;&gt;</span><span class="w"> </span><span class="n">receivedData</span><span class="p">);</span>
</pre></div>
</div>
<p>The data being received is conveyed in the Packet data buffer.  An example
usage is in class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PacketSink</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m_socket</span><span class="o">-&gt;</span><span class="n">SetRecvCallback</span><span class="p">(</span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PacketSink</span><span class="o">::</span><span class="n">HandleRead</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">));</span>
</pre></div>
</div>
<p>To summarize, internally, the UDP implementation is organized as follows:</p>
<ul class="simple">
<li><p>a <code class="docutils literal notranslate"><span class="pre">UdpImpl</span></code> class that implements the UDP socket factory functionality</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">UdpL4Protocol</span></code> class that implements the protocol logic that is
socket-independent</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">UdpSocketImpl</span></code> class that implements socket-specific aspects of UDP</p></li>
<li><p>a class called <code class="docutils literal notranslate"><span class="pre">Ipv4EndPoint</span></code> that stores the addressing tuple (local port,
local address, destination port, destination address) associated with the
socket, and a receive callback for the socket.</p></li>
</ul>
</section>
</section>
<section id="ip-capable-node-interfaces">
<h5><span class="section-number">16.1.1.2. </span>IP-capable node interfaces<a class="headerlink" href="#ip-capable-node-interfaces" title="Link to this heading">¶</a></h5>
<p>Many of the implementation details, or internal objects themselves, of
IP-capable Node objects are not exposed at the simulator public API. This
allows for different implementations; for instance, replacing the native <em>ns-3</em>
models with ported TCP/IP stack code.</p>
<p>The C++ public APIs of all of these objects is found in the <code class="docutils literal notranslate"><span class="pre">src/network</span></code>
directory, including principally:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address.h</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">socket.h</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">node.h</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packet.h</span></code></p></li>
</ul>
<p>These are typically base class objects that implement the default values used in
the implementation, implement access methods to get/set state variables, host
attributes, and implement publicly-available methods exposed to clients such as
<code class="docutils literal notranslate"><span class="pre">CreateSocket</span></code>.</p>
</section>
<section id="example-path-of-a-packet">
<h5><span class="section-number">16.1.1.3. </span>Example path of a packet<a class="headerlink" href="#example-path-of-a-packet" title="Link to this heading">¶</a></h5>
<p>These two figures show an example stack trace of how packets flow through the
Internet Node objects.</p>
<figure class="align-default" id="id1">
<span id="internet-node-send"></span><img alt="_images/internet-node-send.png" src="_images/internet-node-send.png" />
<figcaption>
<p><span class="caption-text">Send path of a packet.</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id2">
<span id="internet-node-recv"></span><img alt="_images/internet-node-recv.png" src="_images/internet-node-recv.png" />
<figcaption>
<p><span class="caption-text">Receive path of a packet.</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<span id="document-ipv4"></span><section id="ipv4">
<h3><span class="section-number">16.2. </span>IPv4<a class="headerlink" href="#ipv4" title="Link to this heading">¶</a></h3>
<p>This chapter describes the <em>ns-3</em> IPv4 address assignment and basic components tracking.</p>
<section id="ipv4-addresses-assignment">
<h4><span class="section-number">16.2.1. </span>IPv4 addresses assignment<a class="headerlink" href="#ipv4-addresses-assignment" title="Link to this heading">¶</a></h4>
<p>In order to use IPv4 on a network, the first thing to do is assigning IPv4 addresses.</p>
<p>Any IPv4-enabled <em>ns-3</em> node will have at least one NetDevice: the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::LoopbackNetDevice</span></code>.
The loopback device address is <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code>.
All the other NetDevices will have one (or more) IPv4 addresses.</p>
<p>Note that, as today, <em>ns-3</em> does not have a NAT module, and it does not follows the rules about
filtering private addresses (<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1918.html"><strong>RFC 1918</strong></a>): 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16.
These addresses are routed as any other address. This behaviour could change in the future.</p>
<p>IPv4 global addresses can be:</p>
<ul class="simple">
<li><p>manually assigned</p></li>
<li><p>assigned though DHCP</p></li>
</ul>
<p><em>ns-3</em> can use both methods, and it’s quite important to understand the implications of both.</p>
<section id="manually-assigned-ipv4-addresses">
<h5><span class="section-number">16.2.1.1. </span>Manually assigned IPv4 addresses<a class="headerlink" href="#manually-assigned-ipv4-addresses" title="Link to this heading">¶</a></h5>
<p>This is probably the easiest and most used method. As an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="nf">net</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">);</span>
<span class="n">CsmaHelper</span><span class="w"> </span><span class="n">csma</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">ndc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csma</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Assign IPv4 Addresses.&quot;</span><span class="p">);</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">ipv4</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="p">(</span><span class="s">&quot;192.168.1.0&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">NetMask</span><span class="p">(</span><span class="s">&quot;/24&quot;</span><span class="p">));</span>
<span class="n">Ipv4InterfaceContainer</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">ndc</span><span class="p">);</span>
</pre></div>
</div>
<p>This method will add two global IPv4 addresses to the nodes.</p>
<p>Note that the addresses are assigned in sequence. As a consequence, the first Node / NetDevice
will have “192.168.1.1”, the second “192.168.1.2” and so on.</p>
<p>It is possible to repeat the above to assign more than one address to a node.
However, due to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv4AddressHelper</span></code> singleton nature, one should first assign all the
addresses of a network, then change the network base (<code class="docutils literal notranslate"><span class="pre">SetBase</span></code>), then do a new assignment.</p>
<p>Alternatively, it is possible to assign a specific address to a node:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="nf">net</span><span class="p">(</span><span class="n">n0</span><span class="p">);</span>
<span class="n">CsmaHelper</span><span class="w"> </span><span class="n">csma</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">ndc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csma</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Specifically Assign an IPv4 Address.&quot;</span><span class="p">);</span>
<span class="n">Ipv4AddressHelper</span><span class="w"> </span><span class="n">ipv4</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ndc</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">GetNode</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv4proto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">ifIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">ifIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv4proto</span><span class="o">-&gt;</span><span class="n">GetInterfaceForDevice</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="n">Ipv4InterfaceAddress</span><span class="w"> </span><span class="n">ipv4Addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ipv4InterfaceAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="p">(</span><span class="s">&quot;192.168.1.42&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">NetMask</span><span class="p">(</span><span class="s">&quot;/24&quot;</span><span class="p">));</span>
<span class="n">ipv4proto</span><span class="o">-&gt;</span><span class="n">AddAddress</span><span class="p">(</span><span class="n">ifIndex</span><span class="p">,</span><span class="w"> </span><span class="n">ipv4Addr</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="dhcp-assigned-ipv4-addresses">
<h5><span class="section-number">16.2.1.2. </span>DHCP assigned IPv4 addresses<a class="headerlink" href="#dhcp-assigned-ipv4-addresses" title="Link to this heading">¶</a></h5>
<p>DHCP is available in the internet-apps module. In order to use DHCP you have to have a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DhcpServer</span></code> application in a node (the DHC server node) and a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DhcpClient</span></code> application in
each of the nodes. Note that it not necessary that all the nodes in a subnet use DHCP. Some
nodes can have static addresses.</p>
<p>All the DHCP setup is performed though the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DhcpHelper</span></code>  class. A complete example is in
<code class="docutils literal notranslate"><span class="pre">src/internet-apps/examples/dhcp-example.cc</span></code>.</p>
<p>Further info about the DHCP functionalities can be found in the <code class="docutils literal notranslate"><span class="pre">internet-apps</span></code> model documentation.</p>
</section>
</section>
<section id="tracing-in-the-ipv4-stack">
<h4><span class="section-number">16.2.2. </span>Tracing in the IPv4 Stack<a class="headerlink" href="#tracing-in-the-ipv4-stack" title="Link to this heading">¶</a></h4>
<p>The internet stack provides a number of trace sources in its various
protocol implementations.  These trace sources can be hooked using your own
custom trace code, or you can use our helper functions in some cases to
arrange for tracing to be enabled.</p>
<section id="tracing-in-arp">
<h5><span class="section-number">16.2.2.1. </span>Tracing in ARP<a class="headerlink" href="#tracing-in-arp" title="Link to this heading">¶</a></h5>
<p>ARP provides two trace hooks, one in the cache, and one in the layer three
protocol.  The trace accessor in the cache is given the name “Drop.”  When
a packet is transmitted over an interface that requires ARP, it is first
queued for transmission in the ARP cache until the required MAC address is
resolved.  There are a number of retries that may be done trying to get the
address, and if the maximum retry count is exceeded the packet in question
is dropped by ARP.  The single trace hook in the ARP cache is called,</p>
<ul class="simple">
<li><p>If an outbound packet is placed in the ARP cache pending address resolution
and no resolution can be made within the maximum retry count, the outbound
packet is dropped and this trace is fired;</p></li>
</ul>
<p>A second trace hook lives in the ARP L3 protocol (also named “Drop”) and may
be called for a  number of reasons.</p>
<ul class="simple">
<li><p>If an ARP reply is received for an entry that is not waiting for a reply,
the ARP reply packet is dropped and this trace is fired;</p></li>
<li><p>If an ARP reply is received for a non-existent entry, the ARP reply packet
is dropped and this trace is fired;</p></li>
<li><p>If an ARP cache entry is in the DEAD state (has timed out) and an ARP reply
packet is received, the reply packet is dropped and this trace is fired.</p></li>
<li><p>Each ARP cache entry has a queue of pending packets.  If the size of the
queue is exceeded, the outbound packet is dropped and this trace is fired.</p></li>
</ul>
</section>
<section id="tracing-in-ipv4">
<h5><span class="section-number">16.2.2.2. </span>Tracing in IPv4<a class="headerlink" href="#tracing-in-ipv4" title="Link to this heading">¶</a></h5>
<p>The IPv4 layer three protocol provides three trace hooks.  These are the
“Tx” (ns3::Ipv4L3Protocol::m_txTrace), “Rx” (ns3::Ipv4L3Protocol::m_rxTrace)
and “Drop” (ns3::Ipv4L3Protocol::m_dropTrace) trace sources.</p>
<p>The “Tx” trace is fired in a number of situations, all of which indicate that
a given packet is about to be sent down to a given ns3::Ipv4Interface.</p>
<ul class="simple">
<li><p>In the case of a packet destined for the broadcast address, the
Ipv4InterfaceList is iterated and for every interface that is up and can
fragment the packet or has a large enough MTU to transmit the packet,
the trace is hit.  See ns3::Ipv4L3Protocol::Send.</p></li>
<li><p>In the case of a packet that needs routing, the “Tx” trace may be fired
just before a packet is sent to the interface appropriate to the default
gateway.  See ns3::Ipv4L3Protocol::SendRealOut.</p></li>
<li><p>Also in the case of a packet that needs routing, the “Tx” trace may be
fired just before a packet is sent to the outgoing interface appropriate
to the discovered route.  See ns3::Ipv4L3Protocol::SendRealOut.</p></li>
</ul>
<p>The “Rx” trace is fired when a packet is passed from the device up to the
ns3::Ipv4L3Protocol::Receive function.</p>
<ul class="simple">
<li><p>In the receive function, the Ipv4InterfaceList is iterated, and if the
Ipv4Interface corresponding to the receiving device is found to be in the
UP state, the trace is fired.</p></li>
</ul>
<p>The “Drop” trace is fired in any case where the packet is dropped (in both
the transmit and receive paths).</p>
<ul class="simple">
<li><p>In the ns3::Ipv4Interface::Receive function, the packet is dropped and the
drop trace is hit if the interface corresponding to the receiving device
is in the DOWN state.</p></li>
<li><p>Also in the ns3::Ipv4Interface::Receive function, the packet is dropped and
the drop trace is hit if the checksum is found to be bad.</p></li>
<li><p>In ns3::Ipv4L3Protocol::Send, an outgoing packet bound for the broadcast
address is dropped and the “Drop” trace is fired if the “don’t fragment”
bit is set and fragmentation is available and required.</p></li>
<li><p>Also in ns3::Ipv4L3Protocol::Send, an outgoing packet destined for the
broadcast address is dropped and the “Drop” trace is hit if fragmentation
is not available and is required (MTU &lt; packet size).</p></li>
<li><p>In the case of a broadcast address, an outgoing packet is cloned for each
outgoing interface.  If any of the interfaces is in the DOWN state, the
“Drop” trace event fires with a reference to the copied packet.</p></li>
<li><p>In the case of a packet requiring a route, an outgoing packet is dropped
and the “Drop” trace event fires if no route to the remote host is found.</p></li>
<li><p>In ns3::Ipv4L3Protocol::SendRealOut, an outgoing packet being routed
is dropped and the “Drop” trace is fired if the “don’t fragment” bit is
set and fragmentation is available and required.</p></li>
<li><p>Also in ns3::Ipv4L3Protocol::SendRealOut, an outgoing packet being routed
is dropped and the “Drop” trace is hit if fragmentation is not available
and is required (MTU &lt; packet size).</p></li>
<li><p>An outgoing packet being routed is dropped and the “Drop” trace event fires
if the required Ipv4Interface is in the DOWN state.</p></li>
<li><p>If a packet is being forwarded, and the TTL is exceeded (see
ns3::Ipv4L3Protocol::DoForward), the packet is dropped and the “Drop” trace
event is fired.</p></li>
</ul>
</section>
</section>
<section id="explicit-congestion-notification-ecn-bits">
<h4><span class="section-number">16.2.3. </span>Explicit Congestion Notification (ECN) bits<a class="headerlink" href="#explicit-congestion-notification-ecn-bits" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>In IPv4, ECN bits are the last 2 bits in TOS field and occupy 14th and 15th
bits in the header.</p></li>
<li><p>The IPv4 header class defines an EcnType enum with all four ECN codepoints
(ECN_NotECT, ECN_ECT1, ECN_ECT0, ECN_CE) mentioned
in RFC 3168, and also a setter and getter method to handle ECN values in
the TOS field.</p></li>
</ul>
</section>
<section id="ipv4queuediscitem">
<h4><span class="section-number">16.2.4. </span>Ipv4QueueDiscItem<a class="headerlink" href="#ipv4queuediscitem" title="Link to this heading">¶</a></h4>
<p>The traffic control sublayer in <em>ns-3</em> handles objects of class
<code class="docutils literal notranslate"><span class="pre">QueueDiscItem</span></code> which are used to hold an ns3::Packet and an ns3::Header.
This is done to facilitate the marking of packets for Explicit
Congestion Notification.  The <code class="docutils literal notranslate"><span class="pre">Mark</span> <span class="pre">()</span></code> method is implemented in
Ipv4QueueDiscItem. It returns true if marking the packet is successful, i.e.,
it successfully sets the CE bit in the IPv4 header. The <code class="docutils literal notranslate"><span class="pre">Mark</span> <span class="pre">()</span></code> method
will return false, however, if the IPv4 header indicates the <code class="docutils literal notranslate"><span class="pre">ECN_NotECT</span></code>
codepoint.</p>
</section>
<section id="rfc-6621-duplicate-packet-detection">
<h4><span class="section-number">16.2.5. </span>RFC 6621 duplicate packet detection<a class="headerlink" href="#rfc-6621-duplicate-packet-detection" title="Link to this heading">¶</a></h4>
<p>To support mesh network protocols over broadcast-capable networks (e.g. Wi-Fi),
it is useful to have support for duplicate packet detection and filtering,
since nodes in a network may receive multiple copies of flooded multicast
packets arriving on different paths.  The <code class="docutils literal notranslate"><span class="pre">Ipv4L3Protocol</span></code> model in <em>ns-3</em>
has a model for hash-based duplicate packet detection (DPD) based on
Section 6.2.2 of (<span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6621.html"><strong>RFC 6621</strong></a>).  The model, disabled by default, must be
enabled by setting <code class="docutils literal notranslate"><span class="pre">EnableRFC6621</span></code> to true.  A second attribute,
<code class="docutils literal notranslate"><span class="pre">DuplicateExpire</span></code>, sets the expiration delay for erasing the cache entry
of a packet in the duplicate cache; the delay value defaults to 1ms.</p>
</section>
<section id="neighborcache">
<h4><span class="section-number">16.2.6. </span>NeighborCache<a class="headerlink" href="#neighborcache" title="Link to this heading">¶</a></h4>
<p>NeighborCacheHelper provides a way to generate ARP cache automatically. It
generates needed ARP cache before simulation start to avoid the delay and message overhead of
address resolution in simulations that are focused on other performance aspects.
The state of entries which are generated by NeighborCacheHelper is <code class="docutils literal notranslate"><span class="pre">STATIC_AUTOGENERATED</span></code>,
which is similar to <code class="docutils literal notranslate"><span class="pre">PERMANENT</span></code>, but they are not manually added or removed by user, they
will be managed by NeighborCacheHelper when user need pre-generate cache.
When user is generating neighbor caches globally, neighbor caches will update dynamically when
IPv4 addresses are removed or added; when user is generating neighbor caches partially,
NeighborCacheHelper will take care of address removal, for adding address user may rerun a
reduced-scope PopulateNeighbor() again to pick up the new IP address or manually
add an entry to keep the neighbor cache up-to-date, the reason is that: when PopulateNeighborCache()
has previously been run with a scope less than global, the code does not know whether it was previously
run with a scope of Channel, NetDeviceContainer, or Ip interface container.
The source code for NeighborCache is located in <code class="docutils literal notranslate"><span class="pre">src/internet/helper/neighbor-cache-helper</span></code>
A complete example is in <code class="docutils literal notranslate"><span class="pre">src/internet/examples/neighbor-cache-example.cc</span></code>.</p>
<section id="usage">
<h5><span class="section-number">16.2.6.1. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h5>
<p>The typical usages are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="w"> </span><span class="n">Populate</span><span class="w"> </span><span class="n">neighbor</span><span class="w"> </span><span class="n">ARP</span><span class="w"> </span><span class="n">caches</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">devices</span><span class="o">:</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NeighborCacheHelper</span><span class="w"> </span><span class="n">neighborCache</span><span class="p">;</span>
<span class="n">neighborCache</span><span class="p">.</span><span class="n">PopulateNeighborCache</span><span class="p">();</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Populate neighbor ARP caches for a given channel:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NeighborCacheHelper</span><span class="w"> </span><span class="n">neighborCache</span><span class="p">;</span>
<span class="n">neighborCache</span><span class="p">.</span><span class="n">PopulateNeighborCache</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span><span class="w">     </span><span class="c1">// channel is the Ptr&lt;Channel&gt; want to generate ARP caches</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Populate neighbor ARP caches for devices in a given NetDeviceContainer:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NeighborCacheHelper</span><span class="w"> </span><span class="n">neighborCache</span><span class="p">;</span>
<span class="n">neighborCache</span><span class="p">.</span><span class="n">PopulateNeighborCache</span><span class="p">(</span><span class="n">netDevices</span><span class="p">);</span><span class="w">   </span><span class="c1">// netDevices is the NetDeviceContainer want to generate ARP caches</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Populate neighbor ARP caches for a given Ipv4InterfaceContainer:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NeighborCacheHelper</span><span class="w"> </span><span class="n">neighborCache</span><span class="p">;</span>
<span class="n">neighborCache</span><span class="p">.</span><span class="n">PopulateNeighborCache</span><span class="p">(</span><span class="n">interfaces</span><span class="p">);</span><span class="w">    </span><span class="c1">// interfaces is the Ipv4InterfaceContainer want to generate ARP caches</span>
</pre></div>
</div>
</section>
</section>
</section>
<span id="document-ipv6"></span><section id="ipv6">
<h3><span class="section-number">16.3. </span>IPv6<a class="headerlink" href="#ipv6" title="Link to this heading">¶</a></h3>
<p>This chapter describes the <em>ns-3</em> IPv6 model capabilities and limitations along with its
usage and examples.</p>
<section id="ipv6-model-description">
<h4><span class="section-number">16.3.1. </span>IPv6 model description<a class="headerlink" href="#ipv6-model-description" title="Link to this heading">¶</a></h4>
<p>The IPv6 model is loosely patterned after the Linux implementation;
the implementation is not complete as some features of IPv6 are not of
much interest to simulation studies, and some features of IPv6 are simply
not modeled yet in <em>ns-3</em>.</p>
<p>The base class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6</span></code>
defines a generic API, while the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6L3Protocol</span></code> is the actual class
implementing the protocol. The actual classes used by the IPv6 stack are located mainly
in the directory <code class="docutils literal notranslate"><span class="pre">src/internet</span></code>.</p>
<p>The implementation of IPv6 is contained in the following files:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src/internet/model/icmpv6-header.{cc,h}
src/internet/model/icmpv6-l4-protocol.{cc,h}
src/internet/model/ipv6.{cc,h}
src/internet/model/ipv6-address-generator.{cc,h}
src/internet/model/ipv6-autoconfigured-prefix.{cc,h}
src/internet/model/ipv6-end-point.{cc,h}
src/internet/model/ipv6-end-point-demux.{cc,h}
src/internet/model/ipv6-extension.{cc,h}
src/internet/model/ipv6-extension-demux.{cc,h}
src/internet/model/ipv6-extension-header.{cc,h}
src/internet/model/ipv6-header.{cc,h}
src/internet/model/ipv6-interface.{cc,h}
src/internet/model/ipv6-interface-address.{cc,h}
src/internet/model/ipv6-l3-protocol.{cc,h}
src/internet/model/ipv6-list-routing.{cc,h}
src/internet/model/ipv6-option.{cc,h}
src/internet/model/ipv6-option-demux.{cc,h}
src/internet/model/ipv6-option-header.{cc,h}
src/internet/model/ipv6-packet-info-tag.{cc,h}
src/internet/model/ipv6-pmtu-cache.{cc,h}
src/internet/model/ipv6-raw-socket-factory.{cc,h}
src/internet/model/ipv6-raw-socket-factory-impl.{cc,h}
src/internet/model/ipv6-raw-socket-impl.{cc,h}
src/internet/model/ipv6-route.{cc,h}
src/internet/model/ipv6-routing-protocol.{cc,h}
src/internet/model/ipv6-routing-table-entry.{cc,h}
src/internet/model/ipv6-static-routing.{cc,h}
src/internet/model/ndisc-cache.{cc,h}
src/network/utils/inet6-socket-address.{cc,h}
src/network/utils/ipv6-address.{cc,h}
</pre></div>
</div>
<p>Also some helpers are involved with IPv6:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src/internet/helper/internet-stack-helper.{cc,h}
src/internet/helper/ipv6-address-helper.{cc,h}
src/internet/helper/ipv6-interface-container.{cc,h}
src/internet/helper/ipv6-list-routing-helper.{cc,h}
src/internet/helper/ipv6-routing-helper.{cc,h}
src/internet/helper/ipv6-static-routing-helper.{cc,h}
</pre></div>
</div>
<p>The model files can be roughly divided into:</p>
<ul class="simple">
<li><p>protocol models (e.g., ipv6, ipv6-l3-protocol, icmpv6-l4-protocol, etc.)</p></li>
<li><p>routing models (i.e., anything with ‘routing’ in its name)</p></li>
<li><p>sockets and interfaces (e.g., ipv6-raw-socket, ipv6-interface, ipv6-end-point, etc.)</p></li>
<li><p>address-related things</p></li>
<li><p>headers, option headers, extension headers, etc.</p></li>
<li><p>accessory classes (e.g., ndisc-cache)</p></li>
</ul>
</section>
<section id="usage">
<h4><span class="section-number">16.3.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>The following description is based on using the typical helpers found in the example code.</p>
<p>IPv6 does not need to be activated in a node. it is automatically added to the
available protocols once the Internet Stack is installed.</p>
<p>In order to <em>not</em> install IPv6 along with IPv4, it is possible to use
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::InternetStackHelper</span></code> method <cite>SetIpv6StackInstall (bool enable)</cite>
before installing the InternetStack in the nodes.</p>
<p>Note that to have an IPv6-only network (i.e., to not install the IPv4 stack in a node)
one should use <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::InternetStackHelper</span></code> method <cite>SetIpv4StackInstall (bool enable)</cite>
before the stack installation.</p>
<p>As an example, in the following code node 0 will have both IPv4 and IPv6, node 1 only
only IPv6 and node 2 only IPv4:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="n">n</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">internet</span><span class="p">;</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">internetV4only</span><span class="p">;</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">internetV6only</span><span class="p">;</span>

<span class="n">internetV4only</span><span class="p">.</span><span class="n">SetIpv6StackInstall</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="n">internetV6only</span><span class="p">.</span><span class="n">SetIpv4StackInstall</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="n">internet</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">internetV6only</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">internetV4only</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</pre></div>
</div>
<section id="ipv6-addresses-assignment">
<h5><span class="section-number">16.3.2.1. </span>IPv6 addresses assignment<a class="headerlink" href="#ipv6-addresses-assignment" title="Link to this heading">¶</a></h5>
<p>In order to use IPv6 on a network, the first thing to do is assigning IPv6 addresses.</p>
<p>Any IPv6-enabled <em>ns-3</em> node will have at least one NetDevice: the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::LoopbackNetDevice</span></code>.
The loopback device address is <code class="docutils literal notranslate"><span class="pre">::1</span></code>.
All the other NetDevices will have one or more IPv6 addresses:</p>
<ul class="simple">
<li><p>One link-local address: <code class="docutils literal notranslate"><span class="pre">fe80::interface</span> <span class="pre">ID</span></code>, where <code class="docutils literal notranslate"><span class="pre">interface</span> <span class="pre">ID</span></code> is derived from the NetDevice MAC address.</p></li>
<li><p>Zero or more global addresses, e.g., <code class="docutils literal notranslate"><span class="pre">2001:db8::1</span></code>.</p></li>
</ul>
<p>Typically the first address on an interface will be the link-local one, with the global
address(es) being the following ones.</p>
<p>IPv6 global addresses might be:</p>
<ul class="simple">
<li><p>manually assigned</p></li>
<li><p>auto-generated</p></li>
</ul>
<p><em>ns-3</em> can use both methods, and it’s quite important to understand the implications of both.</p>
<section id="manually-assigned-ipv6-addresses">
<h6><span class="section-number">16.3.2.1.1. </span>Manually assigned IPv6 addresses<a class="headerlink" href="#manually-assigned-ipv6-addresses" title="Link to this heading">¶</a></h6>
<p>This is probably the easiest and most used method. As an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="nf">net</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">);</span>
<span class="n">CsmaHelper</span><span class="w"> </span><span class="n">csma</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">ndc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csma</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Assign IPv6 Addresses.&quot;</span><span class="p">);</span>
<span class="n">Ipv6AddressHelper</span><span class="w"> </span><span class="n">ipv6</span><span class="p">;</span>
<span class="n">ipv6</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="n">Ipv6Address</span><span class="p">(</span><span class="s">&quot;2001:db8::&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Ipv6Prefix</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
<span class="n">Ipv6InterfaceContainer</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv6</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">ndc</span><span class="p">);</span>
</pre></div>
</div>
<p>This method will add two global IPv6 addresses to the nodes. Note that, as usual for IPv6,
all the nodes will also have a link-local address. Typically the first address on an
interface will be the link-local one, with the global address(es) being the following ones.</p>
<p>Note that the global addresses will be derived from the MAC address. As a consequence, expect
to have addresses similar to <code class="docutils literal notranslate"><span class="pre">2001:db8::200:ff:fe00:1</span></code>.</p>
<p>It is possible to repeat the above to assign more than one global address to a node.
However, due to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6AddressHelper</span></code> singleton nature, one should first assign all the
addresses of a network, then change the network base (<code class="docutils literal notranslate"><span class="pre">SetBase</span></code>), then do a new assignment.</p>
<p>Alternatively, it is possible to assign a specific address to a node:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="nf">net</span><span class="p">(</span><span class="n">n0</span><span class="p">);</span>
<span class="n">CsmaHelper</span><span class="w"> </span><span class="n">csma</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">ndc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csma</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Specifically Assign an IPv6 Address.&quot;</span><span class="p">);</span>
<span class="n">Ipv6AddressHelper</span><span class="w"> </span><span class="n">ipv6</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ndc</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">GetNode</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv6</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ipv6proto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ipv6</span><span class="o">&gt;</span><span class="p">();</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">ifIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">ifIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv6proto</span><span class="o">-&gt;</span><span class="n">GetInterfaceForDevice</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="n">Ipv6InterfaceAddress</span><span class="w"> </span><span class="n">ipv6Addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ipv6InterfaceAddress</span><span class="p">(</span><span class="n">Ipv6Address</span><span class="p">(</span><span class="s">&quot;2001:db8:f00d:cafe::42&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Ipv6Prefix</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
<span class="n">ipv6proto</span><span class="o">-&gt;</span><span class="n">AddAddress</span><span class="p">(</span><span class="n">ifIndex</span><span class="p">,</span><span class="w"> </span><span class="n">ipv6Addr</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="auto-generated-ipv6-addresses">
<h6><span class="section-number">16.3.2.1.2. </span>Auto-generated IPv6 addresses<a class="headerlink" href="#auto-generated-ipv6-addresses" title="Link to this heading">¶</a></h6>
<p>This is accomplished by relying on the RADVD protocol, implemented by the class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Radvd</span></code>. A helper class is available, which can be used to ease the most
common tasks, e.g., setting up a prefix on an interface, if it is announced periodically,
and if the router is the default router for that interface.</p>
<p>A fine grain configuration is possible though the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RadvdInterface</span></code> class, which
allows to setup every parameter of the announced router advertisement on a given interface.</p>
<p>It is worth mentioning that the configurations must be set up before installing the
application in the node.</p>
<p>Upon using this method, the nodes will acquire dynamically (i.e., during the simulation)
one (or more) global address(es) according to the RADVD configuration.
These addresses will be bases on the RADVD announced prefix and the node’s EUI-64.</p>
<p>Examples of RADVD use are shown in <code class="docutils literal notranslate"><span class="pre">examples/ipv6/radvd.cc</span></code>
and <code class="docutils literal notranslate"><span class="pre">examples/ipv6/radvd-two-prefix.cc</span></code>.</p>
<p>Note that the router (i.e., the node with <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Radvd</span></code>) will have to have a global address,
while the nodes using the auto-generated addresses (SLAAC) will have to have a link-local address.
This is accomplished using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6AddressHelper::AssignWithoutAddress</span></code>, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv6AddressHelper</span><span class="w"> </span><span class="n">ipv6</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="n">tmp</span><span class="p">.</span><span class="n">Add</span><span class="w"> </span><span class="p">(</span><span class="n">d1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="cm">/* n0 */</span>
<span class="n">Ipv6InterfaceContainer</span><span class="w"> </span><span class="n">iic1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv6</span><span class="p">.</span><span class="n">AssignWithoutAddress</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="w"> </span><span class="cm">/* n0 interface */</span>
</pre></div>
</div>
<section id="random-generated-ipv6-addresses">
<h6 aria-level="7"><span class="section-number">16.3.2.1.2.1. </span>Random-generated IPv6 addresses<a class="headerlink" href="#random-generated-ipv6-addresses" title="Link to this heading">¶</a></h6>
<p>While IPv6 real nodes will use randomly generated addresses to protect privacy, <em>ns-3</em>
does NOT have this capability. This feature haven’t been so far considered as interesting
for simulation.</p>
</section>
</section>
<section id="networks-with-and-without-the-onlink-property">
<h6><span class="section-number">16.3.2.1.3. </span>Networks with and without the onlink property<a class="headerlink" href="#networks-with-and-without-the-onlink-property" title="Link to this heading">¶</a></h6>
<p>IPv6 adds the concept of “on-link” for addresses and prefixes. Simplifying the concept, a
network with the on-link property behaves roughly as IPv4: a node will assume that any address
belonging to the on-link prefix is reachable on the link, so it uses Neighbor Discovery Protocol (NDP)
to find the MAC address corresponding to the IPv6 address.
If the prefix is not marked as “on-link”, then any packet is sent to the default router.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Radvd</span></code> can announce prefixes that have the on-link flag not set. Moreover, it is possible
to add an address to a node without setting the on-link property for the prefix used in the address.
The function to use is <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Ipv6AddressHelper::AssignWithoutOnLink</span></code>.</p>
</section>
<section id="duplicate-address-detection-dad">
<h6><span class="section-number">16.3.2.1.4. </span>Duplicate Address Detection (DAD)<a class="headerlink" href="#duplicate-address-detection-dad" title="Link to this heading">¶</a></h6>
<p>Nodes will perform DAD (it can be disabled using an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Icmpv6L4Protocol</span></code> attribute).
Upon receiving a DAD, however, nodes will not react to it. As is: DAD reaction is
incomplete so far.
The main reason relies on the missing random-generated address capability. Moreover,
since <em>ns-3</em> nodes will usually be well-behaving, there shouldn’t be any Duplicate Address.
This might be changed in the future, so as to avoid issues with real-world
integrated simulations.</p>
</section>
</section>
<section id="explicit-congestion-notification-ecn-bits-in-ipv6">
<h5><span class="section-number">16.3.2.2. </span>Explicit Congestion Notification (ECN) bits in IPv6<a class="headerlink" href="#explicit-congestion-notification-ecn-bits-in-ipv6" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>In IPv6, ECN bits are the last 2 bits of the Traffic class and occupy 10th and 11th bit
in the header.</p></li>
<li><p>The IPv6 header class defines an EcnType enum with all four ECN codepoints
(ECN_NotECT, ECN_ECT1, ECN_ECT0, ECN_CE) mentioned
in RFC 3168, and also a setter and getter method to handle ECN values in
the Traffic Class field.</p></li>
</ul>
</section>
</section>
<section id="ipv6queuediscitem">
<h4><span class="section-number">16.3.3. </span>Ipv6QueueDiscItem<a class="headerlink" href="#ipv6queuediscitem" title="Link to this heading">¶</a></h4>
<p>The traffic control sublayer in <em>ns-3</em> handles objects of class
<code class="docutils literal notranslate"><span class="pre">QueueDiscItem</span></code> which are used to hold an ns3::Packet and an ns3::Header.
This is done to facilitate the marking of packets for Explicit
Congestion Notification.  The <code class="docutils literal notranslate"><span class="pre">Mark</span> <span class="pre">()</span></code> method is implemented in
Ipv6QueueDiscItem. It returns true if marking the packet is successful, i.e.,
it successfully sets the CE bit in the IPv6 header. The <code class="docutils literal notranslate"><span class="pre">Mark</span> <span class="pre">()</span></code> method
will return false, however, if the IPv6 header indicates the <code class="docutils literal notranslate"><span class="pre">ECN_NotECT</span></code>
codepoint.</p>
<section id="host-and-router-behaviour-in-ipv6-and-ns3">
<h5><span class="section-number">16.3.3.1. </span>Host and Router behaviour in IPv6 and <em>ns-3</em><a class="headerlink" href="#host-and-router-behaviour-in-ipv6-and-ns3" title="Link to this heading">¶</a></h5>
<p>In IPv6 there is a clear distinction between <em>routers</em> and <em>hosts</em>. As one might expect,
routers can forward packets from an interface to another interface, while hosts drop
packets not directed to them.</p>
<p>Unfortunately, forwarding is not the only thing affected by this distinction, and forwarding
itself might be fine-tuned, e.g., to forward packets incoming from an interface and drop
packets from another interface.</p>
<p>In <em>ns-3</em> a node is configured to be an <em>host</em> by default. There are two main ways to change
this behaviour:</p>
<ul class="simple">
<li><p>Using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6InterfaceContainer</span></code> <cite>SetForwarding(uint32_t i, bool router)</cite> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is the interface index in the container.</p></li>
<li><p>Changing the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6</span></code> attribute <code class="docutils literal notranslate"><span class="pre">IpForward</span></code>.</p></li>
</ul>
<p>Either one can be used during the simulation.</p>
<p>A fine-grained setup can be accomplished by using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6Interface</span></code> <cite>SetForwarding (bool forward);</cite>
which allows to change the behaviour on a per-interface-basis.</p>
<p>Note that the node-wide configuration only serves as a convenient method to enable/disable the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6Interface</span></code> specific setting. An Ipv6Interface added to a node
with forwarding enabled will be set to be forwarding as well.
This is really important when a node has interfaces added during the simulation.</p>
<p>According to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6Interface</span></code> forwarding state, the following happens:</p>
<ul class="simple">
<li><p>Forwarding OFF</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>The node will NOT reply to Router Solicitation</p></li>
<li><p>The node will react to Router Advertisement</p></li>
<li><p>The node will periodically send Router Solicitation</p></li>
<li><p>Routing protocols MUST DROP packets not directed to the node</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Forwarding ON</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>The node will reply to Router Solicitation</p></li>
<li><p>The node will NOT react to Router Advertisement</p></li>
<li><p>The node will NOT send Router Solicitation</p></li>
<li><p>Routing protocols MUST forward packets</p></li>
</ul>
</div></blockquote>
<p>The behaviour is matching ip-sysctl.txt (<a class="reference external" href="http://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">http://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt</a>)
with the difference that it’s not possible to override the behaviour using esoteric settings
(e.g., forwarding but accept router advertisements, accept_ra=2, or forwarding but send router solicitations
forwarding=2).</p>
<p>Consider carefully the implications of packet forwarding. As an example, a node will NOT send
ICMPv6 PACKET_TOO_BIG messages from an interface with forwarding off. This is completely normal,
as the Routing protocol will drop the packet before attempting to forward it.</p>
</section>
<section id="helpers">
<h5><span class="section-number">16.3.3.2. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p>Typically the helpers used in IPv6 setup are:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::InternetStackHelper</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6AddressHelper</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6InterfaceContainer</span></code></p></li>
</ul>
<p>The use is almost identical to the corresponding IPv4 case, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="n">n</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Create IPv6 Internet Stack&quot;</span><span class="p">);</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">internetv6</span><span class="p">;</span>
<span class="n">internetv6</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Create channels.&quot;</span><span class="p">);</span>
<span class="n">CsmaHelper</span><span class="w"> </span><span class="n">csma</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csma</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;Create networks and assign IPv6 Addresses.&quot;</span><span class="p">);</span>
<span class="n">Ipv6AddressHelper</span><span class="w"> </span><span class="n">ipv6</span><span class="p">;</span>
<span class="n">ipv6</span><span class="p">.</span><span class="n">SetBase</span><span class="p">(</span><span class="n">Ipv6Address</span><span class="p">(</span><span class="s">&quot;2001:db8::&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Ipv6Prefix</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
<span class="n">Ipv6InterfaceContainer</span><span class="w"> </span><span class="n">iic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipv6</span><span class="p">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>Additionally, a common task is to enable forwarding on one of the nodes and to
setup a default route toward it in the other nodes, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">iic</span><span class="p">.</span><span class="n">SetForwarding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">iic</span><span class="p">.</span><span class="n">SetDefaultRouteInAllNodes</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>This will enable forwarding on the node <em>0</em> and will setup a default route in
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6StaticRouting</span></code> on all the other nodes. Note that this
requires that Ipv6StaticRouting is present in the nodes.</p>
<p>The IPv6 routing helpers enable the user to perform specific tasks on the
particular routing algorithm and to print the routing tables.</p>
</section>
<section id="attributes">
<h5><span class="section-number">16.3.3.3. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>Many classes in the <em>ns-3</em> IPv6 implementation contain attributes. The most
useful ones are:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>IpForward</cite>, boolean, default false. Globally enable or disable IP forwarding for all current and future IPv6 devices.</p></li>
<li><p><cite>MtuDiscover</cite>, boolean, default true. If disabled, every interface will have its MTU set to 1280 bytes.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6L3Protocol</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>DefaultTtl</cite>, uint8_t, default 64. The TTL value set by default on all outgoing packets generated on this node.</p></li>
<li><p><cite>SendIcmpv6Redirect</cite>, boolean, default true. Send the ICMPv6 Redirect when appropriate.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Icmpv6L4Protocol</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>DAD</cite>, boolean, default true. Always do DAD (Duplicate Address Detection) check.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::NdiscCache</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>UnresolvedQueueSize</cite>, uint32_t, default 3. Size of the queue for packets pending an NA reply.</p></li>
</ul>
</div></blockquote>
</section>
<section id="output">
<h5><span class="section-number">16.3.3.4. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>The IPv6 stack provides some useful trace sources:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6L3Protocol</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>Tx</cite>, Send IPv6 packet to outgoing interface.</p></li>
<li><p><cite>Rx</cite>, Receive IPv6 packet from incoming interface.</p></li>
<li><p><cite>Drop</cite>, Drop IPv6 packet.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6Extension</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>Drop</cite>, Drop IPv6 packet.</p></li>
</ul>
</div></blockquote>
<p>The latest trace source is generated when a packet contains an unknown option blocking its processing.</p>
<p>Mind that <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::NdiscCache</span></code> could drop packets as well, and they are not logged
in a trace source (yet). This might generate some confusion in the sent/received packets counters.</p>
</section>
<section id="advanced-usage">
<h5><span class="section-number">16.3.3.5. </span>Advanced Usage<a class="headerlink" href="#advanced-usage" title="Link to this heading">¶</a></h5>
<section id="ipv6-maximum-transmission-unit-mtu-and-fragmentation">
<h6><span class="section-number">16.3.3.5.1. </span>IPv6 maximum transmission unit (MTU) and fragmentation<a class="headerlink" href="#ipv6-maximum-transmission-unit-mtu-and-fragmentation" title="Link to this heading">¶</a></h6>
<p><em>ns-3</em> NetDevices define the MTU according to the L2 simulated Device. IPv6 requires
that the minimum MTU is 1280 bytes, so all NetDevices are required to support at least
this MTU. This is the link-MTU.</p>
<p>In order to support different MTUs in a source-destination path, <em>ns-3</em> IPv6 model can
perform fragmentation.
This can be either triggered by receiving a packet bigger than the link-MTU from the L4
protocols (UDP, TCP, etc.), or by receiving an ICMPv6 PACKET_TOO_BIG message.
The model mimics RFC 1981, with the following notable exceptions:</p>
<ul class="simple">
<li><p>L4 protocols are not informed of the Path MTU change</p></li>
<li><p>TCP can not change its Segment Size according to the Path-MTU.</p></li>
</ul>
<p>Both limitations are going to be removed in due time.</p>
<p>The Path-MTU cache is currently based on the source-destination IPv6 addresses. Further
classifications (e.g., flow label) are possible but not yet implemented.</p>
<p>The Path-MTU default validity time is 10 minutes. After the cache entry expiration, the
Path-MTU information is removed and the next packet will (eventually) trigger a new ICMPv6
PACKET_TOO_BIG message.
Note that 1) this is consistent with the RFC specification and 2) L4 protocols are
responsible for retransmitting the packets.</p>
</section>
</section>
<section id="examples">
<h5><span class="section-number">16.3.3.6. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The examples for IPv6 are in the directory <code class="docutils literal notranslate"><span class="pre">examples/ipv6</span></code>. These examples focus on
the most interesting IPv6 peculiarities, such as fragmentation, redirect and so on.</p>
<p>Moreover, most TCP and UDP examples located in <code class="docutils literal notranslate"><span class="pre">examples/udp</span></code>, <code class="docutils literal notranslate"><span class="pre">examples/tcp</span></code>, etc.
have a command-line option to use IPv6 instead of IPv4.</p>
</section>
<section id="troubleshooting">
<h5><span class="section-number">16.3.3.7. </span>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Link to this heading">¶</a></h5>
<p>There are just a few pitfalls to avoid while using <em>ns-3</em> IPv6.</p>
<section id="routing-loops">
<h6><span class="section-number">16.3.3.7.1. </span>Routing loops<a class="headerlink" href="#routing-loops" title="Link to this heading">¶</a></h6>
<p>Since the only (so far) routing scheme available for IPv6 is <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Ipv6StaticRouting</span></code>,
default router have to be setup manually. When there are two or more routers in a network
(e.g., node A and node B), avoid using the helper function <cite>SetDefaultRouteInAllNodes</cite>
for more than one router.</p>
<p>The consequence would be to install a default route to B in A and a default route pointing to
A in B, generating a loop.</p>
</section>
<section id="global-address-leakage">
<h6><span class="section-number">16.3.3.7.2. </span>Global address leakage<a class="headerlink" href="#global-address-leakage" title="Link to this heading">¶</a></h6>
<p>Remember that addresses in IPv6 are <em>global</em> by definition. When using IPv6 with an emulation
<em>ns-3</em> capability, avoid at all costs address leakage toward the global Internet.
It is advisable to setup an external firewall to prevent leakage.</p>
</section>
<section id="db8-32-addresses">
<h6><span class="section-number">16.3.3.7.3. </span>2001:DB8::/32 addresses<a class="headerlink" href="#db8-32-addresses" title="Link to this heading">¶</a></h6>
<p>IPv6 standard (RFC 3849) defines the <code class="docutils literal notranslate"><span class="pre">2001:DB8::/32</span></code> address class for the <em>documentation</em>.
This manual uses this convention. The addresses in this class are, however, only usable in
a document, and routers should discard them.</p>
</section>
</section>
</section>
<section id="validation">
<h4><span class="section-number">16.3.4. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The IPv6 protocols has not yet been extensively validated against real implementations.
The actual tests involve mainly performing checks of the .pcap trace files with Wireshark,
and the results are positive.</p>
</section>
<section id="neighborcache">
<h4><span class="section-number">16.3.5. </span>NeighborCache<a class="headerlink" href="#neighborcache" title="Link to this heading">¶</a></h4>
<p>NeighborCacheHelper provides a way to generate NDISC cache automatically. It generates
needed NDISC cache before simulation start to avoid the delay and message overhead of
neighbor discovery in simulations that are focused on other performance aspects.
The state of entries generate by NeighborCacheHelper is <code class="docutils literal notranslate"><span class="pre">STATIC_AUTOGENERATED</span></code>,
which is similar to <code class="docutils literal notranslate"><span class="pre">PERMANENT</span></code>, but they are not manually added or removed by user, they
will be managed by NeighborCacheHelper when user need pre-generate cache.
When user is generating neighbor caches globally, neighbor caches will update dynamically when
IPv6 addresses are removed or added; when user is generating neighbor caches partially,
NeighborCacheHelper will take care of address removal, for adding address user may rerun a
reduced-scope PopulateNeighbor() again to pick up the new IP address or manually
add an entry to keep the neighbor cache up-to-date, the reason is that: when PopulateNeighborCache()
has previously been run with a scope less than global, the code does not know whether it was previously
run with a scope of Channel, NetDeviceContainer, or Ip interface container.
The source code for NeighborCache is located in <code class="docutils literal notranslate"><span class="pre">src/internet/helper/neighbor-cache-helper</span></code>
A complete example is in <code class="docutils literal notranslate"><span class="pre">src/internet/examples/neighbor-cache-example.cc</span></code>.</p>
<section id="id1">
<h5><span class="section-number">16.3.5.1. </span>Usage<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h5>
<p>The usages for generating NDISC cache is almost the same as generating ARP cache, see
<code class="docutils literal notranslate"><span class="pre">src/internet/doc/ipv4.rst</span></code></p>
<ul class="simple">
<li><p>Populate neighbor ARP caches for a given Ipv6InterfaceContainer:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NeighborCacheHelper</span><span class="w"> </span><span class="n">neighborCache</span><span class="p">;</span>
<span class="n">neighborCache</span><span class="p">.</span><span class="n">PopulateNeighborCache</span><span class="p">(</span><span class="n">interfaces</span><span class="p">);</span><span class="w">    </span><span class="c1">// interfaces is the Ipv6InterfaceContainer want to generate ARP caches</span>
</pre></div>
</div>
</section>
</section>
</section>
<span id="document-routing-overview"></span><section id="routing-overview">
<h3><span class="section-number">16.4. </span>Routing overview<a class="headerlink" href="#routing-overview" title="Link to this heading">¶</a></h3>
<p><em>ns-3</em> is intended to support traditional routing approaches and protocols,
support ports of open source routing implementations, and facilitate research
into unorthodox routing techniques. The overall routing architecture is
described below in <a class="reference internal" href="#routing-architecture"><span class="std std-ref">Routing architecture</span></a>. Users who wish to just read
about how to configure global routing for wired topologies can read
<a class="reference internal" href="#global-centralized-routing"><span class="std std-ref">Global centralized routing</span></a>. Unicast routing protocols are described in
<a class="reference internal" href="#unicast-routing"><span class="std std-ref">Unicast routing</span></a>.  Multicast routing is documented in
<a class="reference internal" href="#multicast-routing"><span class="std std-ref">Multicast routing</span></a>.</p>
<section id="routing-architecture">
<span id="id1"></span><h4><span class="section-number">16.4.1. </span>Routing architecture<a class="headerlink" href="#routing-architecture" title="Link to this heading">¶</a></h4>
<figure class="align-default" id="id5">
<span id="fig-routing"></span><img alt="_images/routing.png" src="_images/routing.png" />
<figcaption>
<p><span class="caption-text">Overview of routing</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-routing"><span class="std std-ref">Overview of routing</span></a> shows the overall routing architecture for Ipv4. The key
objects are Ipv4L3Protocol, Ipv4RoutingProtocol(s) (a class to which all
routing/forwarding has been delegated from Ipv4L3Protocol), and Ipv4Route(s).</p>
<p>Ipv4L3Protocol must have at least one Ipv4RoutingProtocol added to it at
simulation setup time. This is done explicitly by calling
Ipv4::SetRoutingProtocol ().</p>
<p>The abstract base class Ipv4RoutingProtocol () declares a minimal interface,
consisting of two methods:  RouteOutput () and RouteInput ().  For packets
traveling outbound from a host, the transport protocol will query Ipv4 for the
Ipv4RoutingProtocol object interface, and will request a route via
Ipv4RoutingProtocol::RouteOutput ().  A Ptr to Ipv4Route object is returned.
This is analogous to a dst_cache entry in Linux. The Ipv4Route is carried down
to the Ipv4L3Protocol to avoid a second lookup there. However, some cases (e.g.
Ipv4 raw sockets) will require a call to RouteOutput()
directly from Ipv4L3Protocol.</p>
<p>For packets received inbound for forwarding or delivery,
the following steps occur. Ipv4L3Protocol::Receive() calls
Ipv4RoutingProtocol::RouteInput(). This passes the packet ownership to the
Ipv4RoutingProtocol object. There are four callbacks associated with this call:</p>
<ul class="simple">
<li><p>LocalDeliver</p></li>
<li><p>UnicastForward</p></li>
<li><p>MulticastForward</p></li>
<li><p>Error</p></li>
</ul>
<p>The Ipv4RoutingProtocol must eventually call one of these callbacks for each
packet that it takes responsibility for. This is basically how the input routing
process works in Linux.</p>
<figure class="align-default" id="id6">
<span id="routing-specialization"></span><img alt="_images/routing-specialization.png" src="_images/routing-specialization.png" />
<figcaption>
<p><span class="caption-text">Ipv4Routing specialization.</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This overall architecture is designed to support different routing approaches,
including (in the future) a Linux-like policy-based routing implementation,
proactive and on-demand routing protocols, and simple routing protocols for when
the simulation user does not really care about routing.</p>
<p><a class="reference internal" href="#routing-specialization"><span class="std std-ref">Ipv4Routing specialization.</span></a> illustrates how multiple routing protocols derive
from this base class. A class Ipv4ListRouting (implementation class
Ipv4ListRoutingImpl) provides the existing list routing approach in <em>ns-3</em>. Its
API is the same as base class Ipv4Routing except for the ability to add multiple
prioritized routing protocols (Ipv4ListRouting::AddRoutingProtocol(),
Ipv4ListRouting::GetRoutingProtocol()).</p>
<p>The details of these routing protocols are described below in
<a class="reference internal" href="#unicast-routing"><span class="std std-ref">Unicast routing</span></a>.  For now, we will first start with a basic
unicast routing capability that is intended to globally build routing
tables at simulation time t=0 for simulation users who do not care
about dynamic routing.</p>
</section>
<section id="unicast-routing">
<span id="id2"></span><h4><span class="section-number">16.4.2. </span>Unicast routing<a class="headerlink" href="#unicast-routing" title="Link to this heading">¶</a></h4>
<p>The following unicast routing protocols are defined for IPv4 and IPv6:</p>
<ul class="simple">
<li><p>classes Ipv4ListRouting and Ipv6ListRouting (used to store a prioritized list of routing protocols)</p></li>
<li><p>classes Ipv4StaticRouting and Ipv6StaticRouting (covering both unicast and multicast)</p></li>
<li><p>class Ipv4GlobalRouting (used to store routes computed by the global route
manager, if that is used)</p></li>
<li><p>class Ipv4NixVectorRouting (a more efficient version of global routing that
stores source routes in a packet header field)</p></li>
<li><p>class Rip - the IPv4 RIPv2 protocol (<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>)</p></li>
<li><p>class RipNg - the IPv6 RIPng protocol (<span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a>)</p></li>
<li><p>IPv4 Optimized Link State Routing (OLSR) (a MANET protocol defined in
<span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3626.html"><strong>RFC 3626</strong></a>)</p></li>
<li><p>IPv4 Ad Hoc On Demand Distance Vector (AODV) (a MANET protocol defined in
<span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3561.html"><strong>RFC 3561</strong></a>)</p></li>
<li><p>IPv4 Destination Sequenced Distance Vector (DSDV) (a MANET protocol)</p></li>
<li><p>IPv4 Dynamic Source Routing (DSR) (a MANET protocol)</p></li>
</ul>
<p>In the future, this architecture should also allow someone to implement a
Linux-like implementation with routing cache, or a Click modular router, but
those are out of scope for now.</p>
<section id="ipv-4-6-listrouting">
<h5><span class="section-number">16.4.2.1. </span>Ipv[4,6]ListRouting<a class="headerlink" href="#ipv-4-6-listrouting" title="Link to this heading">¶</a></h5>
<p>This section describes the current default <em>ns-3</em> Ipv[4,6]RoutingProtocol. Typically,
multiple routing protocols are supported in user space and coordinate to write a
single forwarding table in the kernel. Presently in <em>ns-3</em>, the implementation
instead allows for multiple routing protocols to build/keep their own routing
state, and the IP implementation will query each one of these routing
protocols (in some order determined by the simulation author) until a route is
found.</p>
<p>We chose this approach because it may better facilitate the integration of
disparate routing approaches that may be difficult to coordinate the writing to
a single table, approaches where more information than destination IP address
(e.g., source routing) is used to determine the next hop, and on-demand routing
approaches where packets must be cached.</p>
<section id="ipv-4-6-listrouting-addroutingprotocol">
<h6><span class="section-number">16.4.2.1.1. </span>Ipv[4,6]ListRouting::AddRoutingProtocol<a class="headerlink" href="#ipv-4-6-listrouting-addroutingprotocol" title="Link to this heading">¶</a></h6>
<p>Classes Ipv4ListRouting and Ipv6ListRouting provides a pure virtual function declaration
for the method that allows one to add a routing protocol:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">AddRoutingProtocol</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv4RoutingProtocol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">routingProtocol</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">int16_t</span><span class="w"> </span><span class="n">priority</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">AddRoutingProtocol</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ipv6RoutingProtocol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">routingProtocol</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">int16_t</span><span class="w"> </span><span class="n">priority</span><span class="p">);</span>
</pre></div>
</div>
<p>These methods are implemented respectively by class Ipv4ListRoutingImpl and by class
Ipv6ListRoutingImpl in the internet module.</p>
<p>The priority variable above governs the priority in which the routing protocols
are inserted. Notice that it is a signed int.  By default in <em>ns-3</em>, the helper
classes will instantiate a Ipv[4,6]ListRoutingImpl object, and add to it an
Ipv[4,6]StaticRoutingImpl object at priority zero.  Internally, a list of
Ipv[4,6]RoutingProtocols is stored, and and the routing protocols are each consulted
in decreasing order of priority to see whether a match is found. Therefore, if
you want your Ipv4RoutingProtocol to have priority lower than the static
routing, insert it with priority less than 0; e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MyRoutingProtocol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myRoutingProto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">MyRoutingProtocol</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">listRoutingPtr</span><span class="o">-&gt;</span><span class="n">AddRoutingProtocol</span><span class="p">(</span><span class="n">myRoutingProto</span><span class="p">,</span><span class="w"> </span><span class="mi">-10</span><span class="p">);</span>
</pre></div>
</div>
<p>Upon calls to RouteOutput() or RouteInput(), the list routing object will search
the list of routing protocols, in priority order, until a route is found. Such
routing protocol will invoke the appropriate callback and no further routing
protocols will be searched.</p>
</section>
</section>
<section id="global-centralized-routing">
<span id="id3"></span><h5><span class="section-number">16.4.2.2. </span>Global centralized routing<a class="headerlink" href="#global-centralized-routing" title="Link to this heading">¶</a></h5>
<p>Global centralized routing is sometimes called “God” routing; it is a special
implementation that walks the simulation topology and runs a shortest path
algorithm, and populates each node’s routing tables. No actual protocol overhead
(on the simulated links) is incurred with this approach. It does have a few
constraints:</p>
<ul class="simple">
<li><p><strong>Wired only:</strong>  It is not intended for use in wireless networks.</p></li>
<li><p><strong>Unicast only:</strong> It does not do multicast.</p></li>
<li><p><strong>Scalability:</strong>  Some users of this on large topologies (e.g. 1000 nodes)
have noticed that the current implementation is not very scalable. The global
centralized routing will be modified in the future to reduce computations and
runtime performance.</p></li>
</ul>
<p>Presently, global centralized IPv4 unicast routing over both point-to-point and
shared (CSMA) links is supported.</p>
<p>By default, when using the <em>ns-3</em> helper API and the default InternetStackHelper,
global routing capability will be added to the node, and global routing will be
inserted as a routing protocol with lower priority than the static routes (i.e.,
users can insert routes via Ipv4StaticRouting API and they will take precedence
over routes found by global routing).</p>
<section id="global-unicast-routing-api">
<h6><span class="section-number">16.4.2.2.1. </span>Global Unicast Routing API<a class="headerlink" href="#global-unicast-routing-api" title="Link to this heading">¶</a></h6>
<p>The public API is very minimal. User scripts include the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ns3/internet-module.h&quot;</span>
</pre></div>
</div>
<p>If the default InternetStackHelper is used, then an instance of global routing
will be aggregated to each node.  After IP addresses are configured, the
following function call will cause all of the nodes that have an Ipv4 interface
to receive forwarding tables entered automatically by the GlobalRouteManager:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv4GlobalRoutingHelper</span><span class="o">::</span><span class="n">PopulateRoutingTables</span><span class="p">();</span>
</pre></div>
</div>
<p><em>Note:</em> A reminder that the wifi NetDevice will work but does not take any
wireless effects into account. For wireless, we recommend OLSR dynamic routing
described below.</p>
<p>It is possible to call this function again in the midst of a simulation using
the following additional public function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv4GlobalRoutingHelper</span><span class="o">::</span><span class="n">RecomputeRoutingTables</span><span class="p">();</span>
</pre></div>
</div>
<p>which flushes the old tables, queries the nodes for new interface information,
and rebuilds the routes.</p>
<p>For instance, this scheduling call will cause the tables to be rebuilt
at time 5 seconds:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Simulator</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="w">                    </span><span class="o">&amp;</span><span class="n">Ipv4GlobalRoutingHelper</span><span class="o">::</span><span class="n">RecomputeRoutingTables</span><span class="p">);</span>
</pre></div>
</div>
<p>There are two attributes that govern the behavior. The first is
Ipv4GlobalRouting::RandomEcmpRouting. If set to true, packets are randomly
routed across equal-cost multipath routes. If set to false (default), only one
route is consistently used. The second is
Ipv4GlobalRouting::RespondToInterfaceEvents. If set to true, dynamically
recompute the global routes upon Interface notification events (up/down, or
add/remove address). If set to false (default), routing may break unless the
user manually calls RecomputeRoutingTables() after such events. The default is
set to false to preserve legacy <em>ns-3</em> program behavior.</p>
</section>
<section id="global-routing-implementation">
<h6><span class="section-number">16.4.2.2.2. </span>Global Routing Implementation<a class="headerlink" href="#global-routing-implementation" title="Link to this heading">¶</a></h6>
<p>This section is for those readers who care about how this is implemented.  A
singleton object (GlobalRouteManager) is responsible for populating the static
routes on each node, using the public Ipv4 API of that node.  It queries each
node in the topology for a “globalRouter” interface.  If found, it uses the API
of that interface to obtain a “link state advertisement (LSA)” for the router.
Link State Advertisements are used in OSPF routing, and we follow their
formatting.</p>
<p>It is important to note that all of these computations are done before
packets are flowing in the network.  In particular, there are no
overhead or control packets being exchanged when using this implementation.
Instead, this global route manager just walks the list of nodes to
build the necessary information and configure each node’s routing table.</p>
<p>The GlobalRouteManager populates a link state database with LSAs gathered from
the entire topology. Then, for each router in the topology, the
GlobalRouteManager executes the OSPF shortest path first (SPF) computation on
the database, and populates the routing tables on each node.</p>
<p>The quagga (<a class="reference external" href="http://www.quagga.net">http://www.quagga.net</a>) OSPF implementation was used as the
basis for the routing computation logic. One benefit of following an existing
OSPF SPF implementation is that OSPF already has defined link state
advertisements for all common types of network links:</p>
<ul class="simple">
<li><p>point-to-point (serial links)</p></li>
<li><p>point-to-multipoint (Frame Relay, ad hoc wireless)</p></li>
<li><p>non-broadcast multiple access (ATM)</p></li>
<li><p>broadcast (Ethernet)</p></li>
</ul>
<p>Therefore, we think that enabling these other link types will be more
straightforward now that the underlying OSPF SPF framework is in place.</p>
<p>Presently, we can handle IPv4 point-to-point, numbered links, as well as shared
broadcast (CSMA) links.  Equal-cost multipath is also supported.  Although
wireless link types are supported by the implementation, note that due
to the nature of this implementation, any channel effects will not be
considered and the routing tables will assume that every node on the
same shared channel is reachable from every other node (i.e. it will
be treated like a broadcast CSMA link).</p>
<p>The GlobalRouteManager first walks the list of nodes and aggregates
a GlobalRouter interface to each one as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">Iterator</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NodeList</span><span class="o">::</span><span class="n">Begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NodeList</span><span class="o">::</span><span class="n">End</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">GlobalRouter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">globalRouter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">GlobalRouter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">    </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">AggregateObject</span><span class="p">(</span><span class="n">globalRouter</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>This interface is later queried and used to generate a Link State
Advertisement for each router, and this link state database is
fed into the OSPF shortest path computation logic. The Ipv4 API
is finally used to populate the routes themselves.</p>
</section>
</section>
<section id="rip-and-ripng">
<h5><span class="section-number">16.4.2.3. </span>RIP and RIPng<a class="headerlink" href="#rip-and-ripng" title="Link to this heading">¶</a></h5>
<p>The RIPv2 protocol for IPv4 is described in the <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>, and it consolidates
a number of improvements over the base protocol defined in <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1058.html"><strong>RFC 1058</strong></a>.</p>
<p>This IPv6 routing protocol (<span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a>) is the evolution of the well-known
RIPv1 (see <span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1058.html"><strong>RFC 1058</strong></a> and <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1723.html"><strong>RFC 1723</strong></a>) routing protocol for IPv4.</p>
<p>The protocols are very simple, and are normally suitable for flat, simple
network topologies.</p>
<p>RIPv1, RIPv2, and RIPng have the very same goals and limitations.
In particular, RIP considers any route with a metric equal or greater
than 16 as unreachable. As a consequence, the maximum number of hops is the
network must be less than 15 (the number of routers is not set).
Users are encouraged to read <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> and <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1058.html"><strong>RFC 1058</strong></a> to fully understand
RIP behaviour and limitations.</p>
<section id="routing-convergence">
<h6><span class="section-number">16.4.2.3.1. </span>Routing convergence<a class="headerlink" href="#routing-convergence" title="Link to this heading">¶</a></h6>
<p>RIP uses a Distance-Vector algorithm, and routes are updated according to
the Bellman-Ford algorithm (sometimes known as Ford-Fulkerson algorithm).
The algorithm has a convergence time of O(|V|*|E|) where |V| and |E|
are the number of vertices (routers) and edges (links) respectively.
It should be stressed that the convergence time is the number of steps in
the algorithm, and each step is triggered by a message.
Since Triggered Updates (i.e., when a route is changed) have a 1-5 seconds
cooldown, the topology can require some time to be stabilized.</p>
<p>Users should be aware that, during routing tables construction, the routers
might drop packets. Data traffic should be sent only after a time long
enough to allow RIP to build the network topology.
Usually 80 seconds should be enough to have a suboptimal (but working)
routing setup. This includes the time needed to propagate the routes to the
most distant router (16 hops) with Triggered Updates.</p>
<p>If the network topology is changed (e.g., a link is broken), the recovery
time might be quite high, and it might be even higher than the initial
setup time. Moreover, the network topology recovery is affected by
the Split Horizoning strategy.</p>
<p>The examples <code class="docutils literal notranslate"><span class="pre">examples/routing/ripng-simple-network.cc</span></code> and
<code class="docutils literal notranslate"><span class="pre">examples/routing/rip-simple-network.cc</span></code>
shows both the network setup and network recovery phases.</p>
</section>
<section id="split-horizoning">
<h6><span class="section-number">16.4.2.3.2. </span>Split Horizoning<a class="headerlink" href="#split-horizoning" title="Link to this heading">¶</a></h6>
<p>Split Horizon is a strategy to prevent routing instability.
Three options are possible:</p>
<ul class="simple">
<li><p>No Split Horizon</p></li>
<li><p>Split Horizon</p></li>
<li><p>Poison Reverse</p></li>
</ul>
<p>In the first case, routes are advertised on all the router’s interfaces.
In the second case, routers will not advertise a route on the interface
from which it was learned.
Poison Reverse will advertise the route on the interface from which it
was learned, but with a metric of 16 (infinity).
For a full analysis of the three techniques, see <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1058.html"><strong>RFC 1058</strong></a>, section 2.2.</p>
<p>The examples are based on the network topology
described in the RFC, but it does not show the effect described there.</p>
<p>The reason are the Triggered Updates, together with the fact that when a
router invalidates a route, it will immediately propagate the route
unreachability, thus preventing most of the issues described in the RFC.</p>
<p>However, with complex topologies, it is still possible to have route
instability phenomena similar to the one described in the RFC after a
link failure. As a consequence, all the considerations about Split Horizon
remains valid.</p>
</section>
<section id="default-routes">
<h6><span class="section-number">16.4.2.3.3. </span>Default routes<a class="headerlink" href="#default-routes" title="Link to this heading">¶</a></h6>
<p>RIP protocol should be installed <em>only</em> on routers. As a consequence,
nodes will not know what is the default router.</p>
<p>To overcome this limitation, users should either install the default route
manually (e.g., by resorting to Ipv4StaticRouting or Ipv6StaticRouting), or
by using RADVd (in case of IPv6).
RADVd is available in <em>ns-3</em> in the Applications module, and it is strongly
suggested.</p>
</section>
<section id="protocol-parameters-and-options">
<h6><span class="section-number">16.4.2.3.4. </span>Protocol parameters and options<a class="headerlink" href="#protocol-parameters-and-options" title="Link to this heading">¶</a></h6>
<p>The RIP <em>ns-3</em> implementations allow to change all the timers associated
with route updates and routes lifetime.</p>
<p>Moreover, users can change the interface metrics on a per-node basis.</p>
<p>The type of Split Horizoning (to avoid routes back-propagation) can be
selected on a per-node basis, with the choices being “no split horizon”,
“split horizon” and “poison reverse”. See <span class="target" id="index-12"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> for further details,
and <span class="target" id="index-13"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1058.html"><strong>RFC 1058</strong></a> for a complete discussion on the split horizoning strategies.</p>
<p>Moreover, it is possible to use a non-standard value for Link Down Value (i.e.,
the value after which a link is considered down). The default is value is 16.</p>
</section>
<section id="limitations">
<h6><span class="section-number">16.4.2.3.5. </span>Limitations<a class="headerlink" href="#limitations" title="Link to this heading">¶</a></h6>
<p>There is no support for the Next Hop option (<span class="target" id="index-14"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a>, Section 2.1.1).
The Next Hop option is useful when RIP is not being run on all of the
routers on a network.
Support for this option may be considered in the future.</p>
<p>There is no support for CIDR prefix aggregation. As a result, both routing
tables and route advertisements may be larger than necessary.
Prefix aggregation may be added in the future.</p>
</section>
</section>
<section id="other-routing-protocols">
<h5><span class="section-number">16.4.2.4. </span>Other routing protocols<a class="headerlink" href="#other-routing-protocols" title="Link to this heading">¶</a></h5>
<p>Other routing protocols documentation can be found under the respective
modules sections, e.g.:</p>
<ul class="simple">
<li><p>AODV</p></li>
<li><p>Click</p></li>
<li><p>DSDV</p></li>
<li><p>DSR</p></li>
<li><p>NixVectorRouting</p></li>
<li><p>OLSR</p></li>
<li><p>etc.</p></li>
</ul>
</section>
</section>
<section id="multicast-routing">
<span id="id4"></span><h4><span class="section-number">16.4.3. </span>Multicast routing<a class="headerlink" href="#multicast-routing" title="Link to this heading">¶</a></h4>
<p>The following function is used to add a static multicast route
to a node:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Ipv4StaticRouting::AddMulticastRoute</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">Ipv4Address</span><span class="w"> </span><span class="n">group</span><span class="p">,</span>
<span class="w">                                     </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">inputInterface</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputInterfaces</span><span class="p">);</span>
</pre></div>
</div>
<p>A multicast route must specify an origin IP address, a multicast group and an
input network interface index as conditions and provide a vector of output
network interface indices over which packets matching the conditions are sent.</p>
<p>Typically there are two main types of multicast routes:</p>
<ul class="simple">
<li><p>Routes used during forwarding, and</p></li>
<li><p>Routes used in the originator node.</p></li>
</ul>
<p>In the first case all the conditions must be explicitly
provided.</p>
<p>In the second case, the route is equivalent to a unicast route, and must be added
through <cite>Ipv4StaticRouting::AddHostRouteTo</cite>.</p>
<p>Another command sets the default multicast route:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Ipv4StaticRouting::SetDefaultMulticastRoute</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">outputInterface</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the multicast equivalent of the unicast version SetDefaultRoute. We
tell the routing system what to do in the case where a specific route to a
destination multicast group is not found. The system forwards packets out the
specified interface in the hope that “something out there” knows better how to
route the packet. This method is only used in initially sending packets off of a
host. The default multicast route is not consulted during forwarding – exact
routes must be specified using AddMulticastRoute for that case.</p>
<p>Since we’re basically sending packets to some entity we think may know better
what to do, we don’t pay attention to “subtleties” like origin address, nor do
we worry about forwarding out multiple  interfaces. If the default multicast
route is set, it is returned as the selected route from LookupStatic
irrespective of origin or multicast group if another specific route is not
found.</p>
<p>Finally, a number of additional functions are provided to fetch and remove
multicast routes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">GetNMulticastRoutes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="n">Ipv4MulticastRoute</span><span class="w"> </span><span class="o">*</span><span class="nf">GetMulticastRoute</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="n">Ipv4MulticastRoute</span><span class="w"> </span><span class="o">*</span><span class="nf">GetDefaultMulticastRoute</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">RemoveMulticastRoute</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span>
<span class="w">                          </span><span class="n">Ipv4Address</span><span class="w"> </span><span class="n">group</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">inputInterface</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">RemoveMulticastRoute</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<span id="document-tcp"></span><section id="tcp-models-in-ns-3">
<h3><span class="section-number">16.5. </span>TCP models in ns-3<a class="headerlink" href="#tcp-models-in-ns-3" title="Link to this heading">¶</a></h3>
<p>This chapter describes the TCP models available in <em>ns-3</em>.</p>
<section id="overview-of-support-for-tcp">
<h4><span class="section-number">16.5.1. </span>Overview of support for TCP<a class="headerlink" href="#overview-of-support-for-tcp" title="Link to this heading">¶</a></h4>
<p><em>ns-3</em> was written to support multiple TCP implementations. The implementations
inherit from a few common header classes in the <code class="docutils literal notranslate"><span class="pre">src/network</span></code> directory, so that
user code can swap out implementations with minimal changes to the scripts.</p>
<p>There are three important abstract base classes:</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocket</span></code>: This is defined in
<code class="docutils literal notranslate"><span class="pre">src/internet/model/tcp-socket.{cc,h}</span></code>. This class exists for hosting TcpSocket
attributes that can be reused across different implementations. For instance,
the attribute <code class="docutils literal notranslate"><span class="pre">InitialCwnd</span></code> can be used for any of the implementations
that derive from class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocket</span></code>.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocketFactory</span></code>: This is used by the layer-4 protocol
instance to create TCP sockets of the right type.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpCongestionOps</span></code>: This supports different variants of
congestion control– a key topic of simulation-based TCP research.</p></li>
</ul>
<p>There are presently two active implementations of TCP available for <em>ns-3</em>.</p>
<ul class="simple">
<li><p>a natively implemented TCP for ns-3</p></li>
<li><p>support for kernel implementations via <a class="reference external" href="https://www.nsnam.org/overview/projects/direct-code-execution/">Direct Code Execution (DCE)</a></p></li>
</ul>
<p>Direct Code Execution is limited in its support for newer kernels; at
present, only Linux kernel 4.4 is supported.  However, the TCP implementations
in kernel 4.4 can still be used for ns-3 validation or for specialized
simulation use cases.</p>
<p>It should also be mentioned that various ways of combining virtual machines
with <em>ns-3</em> makes available also some additional TCP implementations, but
those are out of scope for this chapter.</p>
</section>
<section id="ns-3-tcp">
<h4><span class="section-number">16.5.2. </span>ns-3 TCP<a class="headerlink" href="#ns-3-tcp" title="Link to this heading">¶</a></h4>
<p>In brief, the native <em>ns-3</em> TCP model supports a full bidirectional TCP with
connection setup and close logic. Several congestion control algorithms
are supported, with CUBIC the default, and NewReno, Westwood, Hybla, HighSpeed,
Vegas, Scalable, Veno, Binary Increase Congestion Control (BIC), Yet Another
HighSpeed TCP (YeAH), Illinois, H-TCP, Low Extra Delay Background Transport
(LEDBAT), TCP Low Priority (TCP-LP), Data Center TCP (DCTCP) and Bottleneck
Bandwidth and RTT (BBR) also supported. The model also supports Selective
Acknowledgements (SACK), Proportional Rate Reduction (PRR) and Explicit
Congestion Notification (ECN). Multipath-TCP is not yet supported in the <em>ns-3</em>
releases.</p>
<section id="model-history">
<h5><span class="section-number">16.5.2.1. </span>Model history<a class="headerlink" href="#model-history" title="Link to this heading">¶</a></h5>
<p>Until the ns-3.10 release, <em>ns-3</em> contained a port of the TCP model from <a class="reference external" href="http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/index.html">GTNetS</a>,
developed initially by George Riley and ported to <em>ns-3</em> by Raj Bhattacharjea.
This implementation was substantially rewritten by Adriam Tam for ns-3.10.
In 2015, the TCP module was redesigned in order to create a better
environment for creating and carrying out automated tests. One of the main
changes involves congestion control algorithms, and how they are implemented.</p>
<p>Before the ns-3.25 release, a congestion control was considered as a stand-alone TCP
through an inheritance relation: each congestion control (e.g. TcpNewReno) was
a subclass of TcpSocketBase, reimplementing some inherited methods. The
architecture was redone to avoid this inheritance,
by making each congestion control a separate class, and defining an interface
to exchange important data between TcpSocketBase and the congestion modules.
The Linux <code class="docutils literal notranslate"><span class="pre">tcp_congestion_ops</span></code> interface was used as the design reference.</p>
<p>Along with congestion control, Fast Retransmit and Fast Recovery algorithms
have been modified; in previous releases, these algorithms were delegated to
TcpSocketBase subclasses. Starting from ns-3.25, they have been merged inside
TcpSocketBase. In future releases, they can be extracted as separate modules,
following the congestion control design.</p>
<p>As of the ns-3.31 release, the default initial window was set to 10 segments
(in previous releases, it was set to 1 segment).  This aligns with current
Linux default, and is discussed further in <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6928.html"><strong>RFC 6928</strong></a>.</p>
<p>In the ns-3.32 release, the default recovery algorithm was set to
Proportional Rate Reduction (PRR) from the classic ack-clocked Fast
Recovery algorithm.</p>
<p>In the ns-3.34 release, the default congestion control algorithm was set
to CUBIC from NewReno.</p>
</section>
<section id="acknowledgments">
<h5><span class="section-number">16.5.2.2. </span>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Link to this heading">¶</a></h5>
<p>As mentioned above, <em>ns-3</em> TCP has had multiple authors and maintainers over
the years. Several publications exist on aspects of <em>ns-3</em> TCP, and users
of <em>ns-3</em> TCP are requested to cite one of the applicable papers when
publishing new work.</p>
<p>A general reference on the current architecture is found in the following paper:</p>
<ul class="simple">
<li><p>Maurizio Casoni, Natale Patriciello, Next-generation TCP for ns-3 simulator, Simulation Modelling Practice and Theory, Volume 66, 2016, Pages 81-93. (<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1569190X15300939">http://www.sciencedirect.com/science/article/pii/S1569190X15300939</a>)</p></li>
</ul>
<p>For an academic peer-reviewed paper on the SACK implementation in ns-3,
please refer to:</p>
<ul class="simple">
<li><p>Natale Patriciello. 2017. A SACK-based Conservative Loss Recovery Algorithm for ns-3 TCP: a Linux-inspired Proposal. In Proceedings of the Workshop on ns-3 (WNS3 ‘17). ACM, New York, NY, USA, 1-8. (<a class="reference external" href="https://dl.acm.org/citation.cfm?id=3067666">https://dl.acm.org/citation.cfm?id=3067666</a>)</p></li>
</ul>
</section>
<section id="usage">
<h5><span class="section-number">16.5.2.3. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h5>
<p>In many cases, usage of TCP is set at the application layer by telling
the <em>ns-3</em> application which kind of socket factory to use.</p>
<p>Using the helper functions defined in <code class="docutils literal notranslate"><span class="pre">src/applications/helper</span></code> and
<code class="docutils literal notranslate"><span class="pre">src/network/helper</span></code>, here is how one would create a TCP receiver:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a packet sink on the star &quot;hub&quot; to receive these packets</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50000</span><span class="p">;</span>
<span class="n">Address</span><span class="w"> </span><span class="nf">sinkLocalAddress</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="n">port</span><span class="p">));</span>
<span class="n">PacketSinkHelper</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sinkLocalAddress</span><span class="p">);</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">sinkApp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">serverNode</span><span class="p">);</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Similarly, the below snippet configures OnOffApplication traffic source to use
TCP:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the OnOff applications to send TCP to the server</span>
<span class="n">OnOffHelper</span><span class="w"> </span><span class="n">clientHelper</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="p">());</span>
</pre></div>
</div>
<p>The careful reader will note above that we have specified the TypeId of an
abstract base class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocketFactory</span></code>. How does the script tell
<em>ns-3</em> that it wants the native <em>ns-3</em> TCP vs. some other one? Well, when
internet stacks are added to the node, the default TCP implementation that is
aggregated to the node is the <em>ns-3</em> TCP.  So, by default, when using the <em>ns-3</em>
helper API, the TCP that is aggregated to nodes with an Internet stack is the
native <em>ns-3</em> TCP.</p>
<p>To configure behavior of TCP, a number of parameters are exported through the
<em>ns-3</em> attribute system. These are documented in the <a class="reference external" href="https://www.nsnam.org/docs/doxygen/d3/dea/classns3_1_1_tcp_socket.html">Doxygen</a> for class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpSocket</span></code>. For example, the maximum segment size is a
settable attribute.</p>
<p>To set the default socket type before any internet stack-related objects are
created, one may put the following statement at the top of the simulation
program:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>For users who wish to have a pointer to the actual socket (so that
socket operations like Bind(), setting socket options, etc. can be
done on a per-socket basis), Tcp sockets can be created by using the
<code class="docutils literal notranslate"><span class="pre">Socket::CreateSocket()</span></code> method. The TypeId passed to CreateSocket()
must be of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::SocketFactory</span></code>, so configuring the underlying
socket type must be done by twiddling the attribute associated with the
underlying TcpL4Protocol object. The easiest way to get at this would be
through the attribute configuration system. In the below example,
the Node container “n0n1” is accessed to get the zeroth element, and a socket is
created on this node:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create and bind the socket...</span>
<span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeId</span><span class="o">::</span><span class="n">LookupByName</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">);</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/*/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">tid</span><span class="p">));</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">localSocket</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">Socket</span><span class="o">::</span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">n0n1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TcpSocketFactory</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">());</span>
</pre></div>
</div>
<p>Above, the “*” wild card for node number is passed to the attribute
configuration system, so that all future sockets on all nodes are set to
NewReno, not just on node ‘n0n1.Get (0)’. If one wants to limit it to just
the specified node, one would have to do something like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create and bind the socket...</span>
<span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeId</span><span class="o">::</span><span class="n">LookupByName</span><span class="p">(</span><span class="s">&quot;ns3::TcpNewReno&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span>
<span class="n">nodeId</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n0n1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetId</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">specificNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;/NodeList/&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nodeId</span><span class="p">.</span><span class="n">str</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">;</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="n">specificNode</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">tid</span><span class="p">));</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">localSocket</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">Socket</span><span class="o">::</span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">n0n1</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TcpSocketFactory</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">());</span>
</pre></div>
</div>
<p>Once a TCP socket is created, one will want to follow conventional socket logic
and either connect() and send() (for a TCP client) or bind(), listen(), and
accept() (for a TCP server).
Please note that applications usually create the sockets they use automatically,
and so is not straightforward to connect directly to them using pointers. Please
refer to the source code of your preferred application to discover how and when
it creates the socket.</p>
<section id="tcp-socket-interaction-and-interface-with-application-layer">
<h6><span class="section-number">16.5.2.3.1. </span>TCP Socket interaction and interface with Application layer<a class="headerlink" href="#tcp-socket-interaction-and-interface-with-application-layer" title="Link to this heading">¶</a></h6>
<p>In the following there is an analysis on the public interface of the TCP socket,
and how it can be used to interact with the socket itself. An analysis of the
callback fired by the socket is also carried out. Please note that, for
the sake of clarity, we will use the terminology “Sender” and “Receiver” to clearly
divide the functionality of the socket. However, in TCP these two roles can be
applied at the same time (i.e. a socket could be a sender and a receiver at the
same time): our distinction does not lose generality, since the following
definition can be applied to both sockets in case of full-duplex mode.</p>
<hr class="docutils" />
<p><strong>TCP state machine (for commodity use)</strong></p>
<figure class="align-center" id="id5">
<span id="fig-tcp-state-machine"></span><img alt="_images/tcp-state-machine.png" src="_images/tcp-state-machine.png" />
<figcaption>
<p><span class="caption-text">TCP State machine</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In ns-3 we are fully compliant with the state machine depicted in
Figure <a class="reference internal" href="#fig-tcp-state-machine"><span class="std std-ref">TCP State machine</span></a>.</p>
<hr class="docutils" />
<p><strong>Public interface for receivers (e.g. servers receiving data)</strong></p>
<dl class="simple">
<dt><em>Bind()</em></dt><dd><p>Bind the socket to an address, or to a general endpoint. A general endpoint
is an endpoint with an ephemeral port allocation (that is, a random port
allocation) on the 0.0.0.0 IP address. For instance, in current applications,
data senders usually binds automatically after a <em>Connect()</em> over a random
port. Consequently, the connection will start from this random port towards
the well-defined port of the receiver. The IP 0.0.0.0 is then translated by
lower layers into the real IP of the device.</p>
</dd>
<dt><em>Bind6()</em></dt><dd><p>Same as <em>Bind()</em>, but for IPv6.</p>
</dd>
<dt><em>BindToNetDevice()</em></dt><dd><p>Bind the socket to the specified NetDevice, creating a general endpoint.</p>
</dd>
<dt><em>Listen()</em></dt><dd><p>Listen on the endpoint for an incoming connection. Please note that this
function can be called only in the TCP CLOSED state, and transit in the
LISTEN state. When an incoming request for connection is detected (i.e. the
other peer invoked <em>Connect()</em>) the application will be signaled with the
callback <em>NotifyConnectionRequest</em> (set in <em>SetAcceptCallback()</em> beforehand).
If the connection is accepted (the default behavior, when the associated
callback is a null one) the Socket will fork itself, i.e. a new socket is
created to handle the incoming data/connection, in the state SYN_RCVD. Please
note that this newly created socket is not connected anymore to the callbacks
on the “father” socket (e.g. DataSent, Recv); the pointer of the newly
created socket is provided in the Callback <em>NotifyNewConnectionCreated</em> (set
beforehand in <em>SetAcceptCallback</em>), and should be used to connect new
callbacks to interesting events (e.g. Recv callback). After receiving the ACK
of the SYN-ACK, the socket will set the congestion control, move into
ESTABLISHED state, and then notify the application with
<em>NotifyNewConnectionCreated</em>.</p>
</dd>
<dt><em>ShutdownSend()</em></dt><dd><p>Signal a termination of send, or in other words prevents data from being added
to the buffer. After this call, if buffer is already empty, the socket
will send a FIN, otherwise FIN will go when buffer empties. Please note
that this is useful only for modeling “Sink” applications. If you have
data to transmit, please refer to the <em>Send()</em> / <em>Close()</em> combination of
API.</p>
</dd>
<dt><em>GetRxAvailable()</em></dt><dd><p>Get the amount of data that could be returned by the Socket in one or multiple
call to Recv or RecvFrom. Please use the Attribute system to configure the
maximum available space on the receiver buffer (property “RcvBufSize”).</p>
</dd>
<dt><em>Recv()</em></dt><dd><p>Grab data from the TCP socket. Please remember that TCP is a stream socket,
and it is allowed to concatenate multiple packets into bigger ones. If no data
is present (i.e. <em>GetRxAvailable</em> returns 0) an empty packet is returned.
Set the callback <em>RecvCallback</em> through <em>SetRecvCallback()</em> in order to have
the application automatically notified when some data is ready to be read.
It’s important to connect that callback to the newly created socket in case
of forks.</p>
</dd>
<dt><em>RecvFrom()</em></dt><dd><p>Same as Recv, but with the source address as parameter.</p>
</dd>
</dl>
<hr class="docutils" />
<p><strong>Public interface for senders (e.g. clients uploading data)</strong></p>
<dl class="simple">
<dt><em>Connect()</em></dt><dd><p>Set the remote endpoint, and try to connect to it. The local endpoint should
be set before this call, or otherwise an ephemeral one will be created. The
TCP then will be in the SYN_SENT state. If a SYN-ACK is received, the TCP will
setup the congestion control, and then call the callback
<em>ConnectionSucceeded</em>.</p>
</dd>
<dt><em>GetTxAvailable()</em></dt><dd><p>Return the amount of data that can be stored in the TCP Tx buffer. Set this
property through the Attribute system (“SndBufSize”).</p>
</dd>
<dt><em>Send()</em></dt><dd><p>Send the data into the TCP Tx buffer. From there, the TCP rules will decide
if, and when, this data will be transmitted. Please note that, if the tx
buffer has enough data to fill the congestion (or the receiver) window, dynamically
varying the rate at which data is injected in the TCP buffer does not have any
noticeable effect on the amount of data transmitted on the wire, that will
continue to be decided by the TCP rules.</p>
</dd>
<dt><em>SendTo()</em></dt><dd><p>Same as <em>Send()</em>.</p>
</dd>
<dt><em>Close()</em></dt><dd><p>Terminate the local side of the connection, by sending a FIN (after all data
in the tx buffer has been transmitted). This does not prevent the socket in
receiving data, and employing retransmit mechanism if losses are detected. If
the application calls <em>Close()</em> with unread data in its rx buffer, the socket
will send a reset. If the socket is in the state SYN_SENT, CLOSING, LISTEN,
FIN_WAIT_2, or LAST_ACK, after that call the application will be notified with
<em>NotifyNormalClose()</em>. In other cases, the notification is delayed
(see <em>NotifyNormalClose()</em>).</p>
</dd>
</dl>
<hr class="docutils" />
<p><strong>Public callbacks</strong></p>
<p>These callbacks are called by the TCP socket to notify the application of
interesting events. We will refer to these with the protected name used in
socket.h, but we will provide the API function to set the pointers to these
callback as well.</p>
<dl class="simple">
<dt><em>NotifyConnectionSucceeded</em>: <em>SetConnectCallback</em>, 1st argument</dt><dd><p>Called in the SYN_SENT state, before moving to ESTABLISHED. In other words, we
have sent the SYN, and we received the SYN-ACK: the socket prepares the
sequence numbers, sends the ACK for the SYN-ACK, tries to send out more data (in
another segment) and then invokes this callback. After this callback, it
invokes the NotifySend callback.</p>
</dd>
<dt><em>NotifyConnectionFailed</em>: <em>SetConnectCallback</em>, 2nd argument</dt><dd><p>Called after the SYN retransmission count goes to 0. SYN packet is lost
multiple times, and the socket gives up.</p>
</dd>
<dt><em>NotifyNormalClose</em>: <em>SetCloseCallbacks</em>, 1st argument</dt><dd><p>A normal close is invoked. A rare case is when we receive an RST segment (or a
segment with bad flags) in normal states. All other cases are:
- The application tries to <em>Connect()</em> over an already connected socket
- Received an ACK for the FIN sent, with or without the FIN bit set (we are in LAST_ACK)
- The socket reaches the maximum amount of retries in retransmitting the SYN (*)
- We receive a timeout in the LAST_ACK state
- Upon entering the TIME_WAIT state, before waiting the 2*Maximum Segment Lifetime seconds to finally deallocate the socket.</p>
</dd>
<dt><em>NotifyErrorClose</em>: <em>SetCloseCallbacks</em>, 2nd argument</dt><dd><p>Invoked when we send an RST segment (for whatever reason) or we reached the
maximum amount of data retries.</p>
</dd>
<dt><em>NotifyConnectionRequest</em>: <em>SetAcceptCallback</em>, 1st argument</dt><dd><p>Invoked in the LISTEN state, when we receive a SYN. The return value indicates
if the socket should accept the connection (return true) or should ignore it
(return false).</p>
</dd>
<dt><em>NotifyNewConnectionCreated</em>: <em>SetAcceptCallback</em>, 2nd argument</dt><dd><p>Invoked when from SYN_RCVD the socket passes to ESTABLISHED, and after setting
up the congestion control, the sequence numbers, and processing the incoming
ACK. If there is some space in the buffer, <em>NotifySend</em> is called shortly
after this callback. The Socket pointer, passed with this callback, is the
newly created socket, after a Fork().</p>
</dd>
<dt><em>NotifyDataSent</em>: <em>SetDataSentCallback</em></dt><dd><p>The Socket notifies the application that some bytes have been transmitted on
the IP level. These bytes could still be lost in the node (traffic control
layer) or in the network.</p>
</dd>
<dt><em>NotifySend</em>: <em>SetSendCallback</em></dt><dd><p>Invoked if there is some space in the tx buffer when entering the ESTABLISHED
state (e.g. after the ACK for SYN-ACK is received), after the connection
succeeds (e.g. after the SYN-ACK is received) and after each new ACK (i.e.
that advances SND.UNA).</p>
</dd>
<dt><em>NotifyDataRecv</em>: <em>SetRecvCallback</em></dt><dd><p>Called when in the receiver buffer there are in-order bytes, and when in
FIN_WAIT_1 or FIN_WAIT_2 the socket receive a in-sequence FIN (that can carry
data).</p>
</dd>
</dl>
</section>
</section>
<section id="congestion-control-algorithms">
<h5><span class="section-number">16.5.2.4. </span>Congestion Control Algorithms<a class="headerlink" href="#congestion-control-algorithms" title="Link to this heading">¶</a></h5>
<p>Here follows a list of supported TCP congestion control algorithms. For an
academic paper on many of these congestion control algorithms, see
<a class="reference external" href="http://dl.acm.org/citation.cfm?id=2756518">http://dl.acm.org/citation.cfm?id=2756518</a> .</p>
<section id="newreno">
<h6><span class="section-number">16.5.2.4.1. </span>NewReno<a class="headerlink" href="#newreno" title="Link to this heading">¶</a></h6>
<p>NewReno algorithm introduces partial ACKs inside the well-established Reno
algorithm. This and other modifications are described in RFC 6582. We have two
possible congestion window increment strategy: slow start and congestion
avoidance. Taken from RFC 5681:</p>
<blockquote>
<div><p>During slow start, a TCP increments cwnd by at most SMSS bytes for
each ACK received that cumulatively acknowledges new data. Slow
start ends when cwnd exceeds ssthresh (or, optionally, when it
reaches it, as noted above) or when congestion is observed. While
traditionally TCP implementations have increased cwnd by precisely
SMSS bytes upon receipt of an ACK covering new data, we RECOMMEND
that TCP implementations increase cwnd, per Equation <a class="reference internal" href="#equation-newrenocongavoid">(1)</a>,
where N is the number of previously unacknowledged bytes acknowledged
in the incoming ACK.</p>
</div></blockquote>
<div class="math" id="equation-newrenocongavoid">
<p><span class="eqno">(1)<a class="headerlink" href="#equation-newrenocongavoid" title="Link to this equation">¶</a></span><img src="_images/math/e090bca2a574182b62f610602f2023f40aa4aa1b.png" alt="cwnd += min (N, SMSS)"/></p>
</div><p>During congestion avoidance, cwnd is incremented by roughly 1 full-sized
segment per round-trip time (RTT), and for each congestion event, the slow
start threshold is halved.</p>
</section>
<section id="cubic">
<h6><span class="section-number">16.5.2.4.2. </span>CUBIC<a class="headerlink" href="#cubic" title="Link to this heading">¶</a></h6>
<p>CUBIC (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpCubic</span></code>) is the default TCP congestion control
in Linux, macOS (since 2014), and Microsoft Windows (since 2017).
CUBIC has two main differences with respect to
a more classic TCP congestion control such as NewReno.  First, during the
congestion avoidance phase, the window size grows according to a cubic
function (concave, then convex) with the latter convex portion designed
to allow for bandwidth probing.  Second, a hybrid slow start (HyStart)
algorithm uses observations of delay increases in the slow start
phase of window growth to try to exit slow start before window growth
causes queue overflow.</p>
<p>CUBIC is documented in <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8312.html"><strong>RFC 8312</strong></a>, and the <em>ns-3</em> implementation is based
on the RFC more so than the Linux implementation, although the Linux 4.4
kernel implementation (through the Direct Code Execution environment) has
been used to validate the behavior and is fairly well aligned (see below
section on validation).</p>
</section>
<section id="linux-reno">
<h6><span class="section-number">16.5.2.4.3. </span>Linux Reno<a class="headerlink" href="#linux-reno" title="Link to this heading">¶</a></h6>
<p>TCP Linux Reno (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpLinuxReno</span></code>) is designed to provide a
Linux-like implementation of
TCP NewReno. The implementation of class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpNewReno</span></code> in ns-3
follows RFC standards, and increases cwnd more conservatively than does Linux Reno.
Linux Reno modifies slow start and congestion avoidance algorithms to
increase cwnd based on the number of bytes being acknowledged by each
arriving ACK, rather than by the number of ACKs that arrive.  Another major
difference in implementation is that Linux maintains the congestion window
in units of segments, while the RFCs define the congestion window in units of
bytes.</p>
<p>In slow start phase, on each incoming ACK at the TCP sender side cwnd
is increased by the number of previously unacknowledged bytes ACKed by the
incoming acknowledgment. In contrast, in ns-3 NewReno, cwnd is increased
by one segment per acknowledgment.  In standards terminology, this
difference is referred to as Appropriate Byte Counting (RFC 3465); Linux
follows Appropriate Byte Counting while ns-3 NewReno does not.</p>
<div class="math" id="equation-linuxrenoslowstart">
<p><span class="eqno">(2)<a class="headerlink" href="#equation-linuxrenoslowstart" title="Link to this equation">¶</a></span><img src="_images/math/cbeaede37c37a58a465004520beda7057a7edf79.png" alt="cwnd += segAcked * segmentSize"/></p>
</div><div class="math" id="equation-newrenoslowstart">
<p><span class="eqno">(3)<a class="headerlink" href="#equation-newrenoslowstart" title="Link to this equation">¶</a></span><img src="_images/math/67689f3a602dea7bd4a43581b48853408d6dba45.png" alt="cwnd += segmentSize"/></p>
</div><p>In congestion avoidance phase, the number of bytes that have been ACKed at
the TCP sender side are stored in a ‘bytes_acked’ variable in the TCP control
block. When ‘bytes_acked’ becomes greater than or equal to the value of the
cwnd, ‘bytes_acked’ is reduced by the value of cwnd. Next, cwnd is incremented
by a full-sized segment (SMSS).  In contrast, in ns-3 NewReno, cwnd is increased
by (1/cwnd) with a rounding off due to type casting into int.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Linux Reno <cite>cwnd</cite> update</span><a class="headerlink" href="#id6" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_cWndCnt</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_cWndCnt</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>

<span class="w">   </span><span class="n">m_cWndCnt</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">   </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_segmentSize</span><span class="p">;</span>
<span class="w">   </span><span class="n">NS_LOG_DEBUG</span><span class="p">(</span><span class="s">&quot;Subtracting delta * w from m_cWndCnt &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">New Reno <cite>cwnd</cite> update</span><a class="headerlink" href="#id7" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">segmentsAcked</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_segmentSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_segmentSize</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>
<span class="w">   </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">adder</span><span class="p">);</span>
<span class="w">   </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">adder</span><span class="p">);</span>
<span class="w">   </span><span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;In CongAvoid, updated to cwnd &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_cWnd</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">                </span><span class="s">&quot; ssthresh &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">m_ssThresh</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>So, there are two main difference between the TCP Linux Reno and TCP NewReno
in ns-3:
1) In TCP Linux Reno, delayed acknowledgement configuration does not affect
congestion window growth, while in TCP NewReno, delayed acknowledgments cause
a slower congestion window growth.
2) In congestion avoidance phase, the arithmetic for counting the number of
segments acked and deciding when to increment the cwnd is different for TCP
Linux Reno and TCP NewReno.</p>
<p>Following graphs shows the behavior of window growth in TCP Linux Reno and
TCP NewReno with delayed acknowledgement of 2 segments:</p>
<figure class="align-center" id="id8">
<span id="fig-ns3-new-reno-vs-ns3-linux-reno"></span><a class="reference internal image-reference" href="_images/ns3-new-reno-vs-ns3-linux-reno.png"><img alt="_images/ns3-new-reno-vs-ns3-linux-reno.png" src="_images/ns3-new-reno-vs-ns3-linux-reno.png" style="width: 560.0px; height: 420.0px;" /></a>
<figcaption>
<p><span class="caption-text">ns-3 TCP NewReno vs. ns-3 TCP Linux Reno</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="highspeed">
<h6><span class="section-number">16.5.2.4.4. </span>HighSpeed<a class="headerlink" href="#highspeed" title="Link to this heading">¶</a></h6>
<p>TCP HighSpeed is designed for high-capacity channels or, in general, for
TCP connections with large congestion windows.
Conceptually, with respect to the standard TCP, HighSpeed makes the
cWnd grow faster during the probing phases and accelerates the
cWnd recovery from losses.
This behavior is executed only when the window grows beyond a
certain threshold, which allows TCP HighSpeed to be friendly with standard
TCP in environments with heavy congestion, without introducing new dangers
of congestion collapse.</p>
<p>Mathematically:</p>
<div class="math" id="equation-highspeedcwndincrement">
<p><span class="eqno">(4)<a class="headerlink" href="#equation-highspeedcwndincrement" title="Link to this equation">¶</a></span><img src="_images/math/b4c10b6ae1eda1878aa0f738e3caddede323f59d.png" alt="cWnd = cWnd + \frac{a(cWnd)}{cWnd}"/></p>
</div><p>The function a() is calculated using a fixed RTT the value 100 ms (the
lookup table for this function is taken from RFC 3649). For each congestion
event, the slow start threshold is decreased by a value that depends on the
size of the slow start threshold itself. Then, the congestion window is set
to such value.</p>
<div class="math" id="equation-highspeedcwnddecrement">
<p><span class="eqno">(5)<a class="headerlink" href="#equation-highspeedcwnddecrement" title="Link to this equation">¶</a></span><img src="_images/math/4e6a6fae0ae7fc738227a941fdf617b9ddaa2908.png" alt="cWnd = (1 - b(cWnd)) \cdot cWnd"/></p>
</div><p>The lookup table for the function b() is taken from the same RFC.
More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=2756518">http://dl.acm.org/citation.cfm?id=2756518</a></p>
</section>
<section id="hybla">
<h6><span class="section-number">16.5.2.4.5. </span>Hybla<a class="headerlink" href="#hybla" title="Link to this heading">¶</a></h6>
<p>The key idea behind TCP Hybla is to obtain for long RTT connections the same
instantaneous transmission rate of a reference TCP connection with lower RTT.
With analytical steps, it is shown that this goal can be achieved by
modifying the time scale, in order for the throughput to be independent from
the RTT. This independence is obtained through the use of a coefficient rho.</p>
<p>This coefficient is used to calculate both the slow start threshold
and the congestion window when in slow start and in congestion avoidance,
respectively.</p>
<p>More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=2756518">http://dl.acm.org/citation.cfm?id=2756518</a></p>
</section>
<section id="westwood">
<h6><span class="section-number">16.5.2.4.6. </span>Westwood<a class="headerlink" href="#westwood" title="Link to this heading">¶</a></h6>
<p>Westwood and Westwood+ employ the AIAD (Additive Increase/Adaptive Decrease)
congestion control paradigm. When a congestion episode happens,
instead of halving the cwnd, these protocols try to estimate the network’s
bandwidth and use the estimated value to adjust the cwnd.
While Westwood performs the bandwidth sampling every ACK reception,
Westwood+ samples the bandwidth every RTT.</p>
<p>The TCP Westwood model has been removed in ns-3.38 due to bugs that are impossible
to fix without modifying the original Westwood model as presented in the published papers.
For further info refer to <a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/579">https://gitlab.com/nsnam/ns-3-dev/-/issues/579</a></p>
<p>The Westwood+ model does not have such issues, and is still available.</p>
<p>WARNING: this TCP model lacks validation and regression tests; use with caution.</p>
<p>More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=381704">http://dl.acm.org/citation.cfm?id=381704</a> and
<a class="reference external" href="http://dl.acm.org/citation.cfm?id=2512757">http://dl.acm.org/citation.cfm?id=2512757</a></p>
</section>
<section id="vegas">
<h6><span class="section-number">16.5.2.4.7. </span>Vegas<a class="headerlink" href="#vegas" title="Link to this heading">¶</a></h6>
<p>TCP Vegas is a pure delay-based congestion control algorithm implementing a
proactive scheme that tries to prevent packet drops by maintaining a small
backlog at the bottleneck queue. Vegas continuously samples the RTT and computes
the actual throughput a connection achieves using Equation <a class="reference internal" href="#equation-vegasactual">(6)</a> and compares it
with the expected throughput calculated in Equation <a class="reference internal" href="#equation-vegasexpected">(7)</a>. The difference between
these 2 sending rates in Equation <a class="reference internal" href="#equation-vegasdiff">(8)</a> reflects the amount of extra packets being
queued at the bottleneck.</p>
<div class="math" id="equation-vegasactual">
<p><span class="eqno">(6)<a class="headerlink" href="#equation-vegasactual" title="Link to this equation">¶</a></span><img src="_images/math/8b29760ba8889dec84ff7f4ffcf262f62a7e7e3a.png" alt="actual &amp;= \frac{cWnd}{RTT}"/></p>
</div><div class="math" id="equation-vegasexpected">
<p><span class="eqno">(7)<a class="headerlink" href="#equation-vegasexpected" title="Link to this equation">¶</a></span><img src="_images/math/bf06f1681b7d351b89ab3ab6b1408250cb7995c9.png" alt="expected &amp;= \frac{cWnd}{BaseRTT}"/></p>
</div><div class="math" id="equation-vegasdiff">
<p><span class="eqno">(8)<a class="headerlink" href="#equation-vegasdiff" title="Link to this equation">¶</a></span><img src="_images/math/170f36671c6f7f789a46bc098bd6ac941a182771.png" alt="diff &amp;= expected - actual"/></p>
</div><p>To avoid congestion, Vegas linearly increases/decreases its congestion window
to ensure the diff value falls between the two predefined thresholds, alpha and
beta. diff and another threshold, gamma, are used to determine when Vegas
should change from its slow-start mode to linear increase/decrease mode.
Following the implementation of Vegas in Linux, we use 2, 4, and 1 as the
default values of alpha, beta, and gamma, respectively, but they can be
modified through the Attribute system.</p>
<p>More information at: <a class="reference external" href="http://dx.doi.org/10.1109/49.464716">http://dx.doi.org/10.1109/49.464716</a></p>
</section>
<section id="scalable">
<h6><span class="section-number">16.5.2.4.8. </span>Scalable<a class="headerlink" href="#scalable" title="Link to this heading">¶</a></h6>
<p>Scalable improves TCP performance to better utilize the available bandwidth of
a highspeed wide area network by altering NewReno congestion window adjustment
algorithm. When congestion has not been detected, for each ACK received in an
RTT, Scalable increases its cwnd per:</p>
<div class="math" id="equation-scalablecwndincrement">
<p><span class="eqno">(9)<a class="headerlink" href="#equation-scalablecwndincrement" title="Link to this equation">¶</a></span><img src="_images/math/1d34609834fb8d613c00ccf858b6076db5889661.png" alt="cwnd = cwnd + 0.01"/></p>
</div><p>Following Linux implementation of Scalable, we use 50 instead of 100 to account
for delayed ACK.</p>
<p>On the first detection of congestion in a given RTT, cwnd is reduced based on
the following equation:</p>
<div class="math" id="equation-scalablecwnddecrement">
<p><span class="eqno">(10)<a class="headerlink" href="#equation-scalablecwnddecrement" title="Link to this equation">¶</a></span><img src="_images/math/71f3cfa2d94c13a419d51466fce33c13b49764a5.png" alt="cwnd = cwnd - ceil(0.125 \cdot cwnd)"/></p>
</div><p>More information at: <a class="reference external" href="http://dl.acm.org/citation.cfm?id=956989">http://dl.acm.org/citation.cfm?id=956989</a></p>
</section>
<section id="veno">
<h6><span class="section-number">16.5.2.4.9. </span>Veno<a class="headerlink" href="#veno" title="Link to this heading">¶</a></h6>
<p>TCP Veno enhances Reno algorithm for more effectively dealing with random
packet loss in wireless access networks by employing Vegas’s method in
estimating the backlog at the bottleneck queue to distinguish between
congestive and non-congestive states.</p>
<p>The backlog (the number of packets accumulated at the bottleneck queue) is
calculated using Equation <a class="reference internal" href="#equation-venon">(11)</a>:</p>
<div class="math" id="equation-venon">
<p><span class="eqno">(11)<a class="headerlink" href="#equation-venon" title="Link to this equation">¶</a></span><img src="_images/math/a5e35f9d7217bc23dfaef6ecb5f82237ca3f9a09.png" alt="N &amp;= Actual \cdot (RTT - BaseRTT) \\
  &amp;= Diff \cdot BaseRTT"/></p>
</div><p>where:</p>
<div class="math" id="equation-venodiff">
<p><span class="eqno">(12)<a class="headerlink" href="#equation-venodiff" title="Link to this equation">¶</a></span><img src="_images/math/504b7638197b5c209fb7b2b13bffe494740a07c3.png" alt="Diff &amp;= Expected - Actual \\
     &amp;= \frac{cWnd}{BaseRTT} - \frac{cWnd}{RTT}"/></p>
</div><p>Veno makes decision on cwnd modification based on the calculated N and its
predefined threshold beta.</p>
<p>Specifically, it refines the additive increase algorithm of Reno so that the
connection can stay longer in the stable state by incrementing cwnd by
1/cwnd for every other new ACK received after the available bandwidth has
been fully utilized, i.e. when N exceeds beta. Otherwise, Veno increases
its cwnd by 1/cwnd upon every new ACK receipt as in Reno.</p>
<p>In the multiplicative decrease algorithm, when Veno is in the non-congestive
state, i.e. when N is less than beta, Veno decrements its cwnd by only 1/5
because the loss encountered is more likely a corruption-based loss than a
congestion-based. Only when N is greater than beta, Veno halves its sending
rate as in Reno.</p>
<p>More information at: <a class="reference external" href="http://dx.doi.org/10.1109/JSAC.2002.807336">http://dx.doi.org/10.1109/JSAC.2002.807336</a></p>
</section>
<section id="bic">
<h6><span class="section-number">16.5.2.4.10. </span>BIC<a class="headerlink" href="#bic" title="Link to this heading">¶</a></h6>
<p>BIC (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpBic</span></code>) is a predecessor of TCP CUBIC.
In TCP BIC the congestion control problem is viewed as a search
problem. Taking as a starting point the current window value
and as a target point the last maximum window value
(i.e. the cWnd value just before the loss event) a binary search
technique can be used to update the cWnd value at the midpoint between
the two, directly or using an additive increase strategy if the distance from
the current window is too large.</p>
<p>This way, assuming a no-loss period, the congestion window logarithmically
approaches the maximum value of cWnd until the difference between it and cWnd
falls below a preset threshold. After reaching such a value (or the maximum
window is unknown, i.e. the binary search does not start at all) the algorithm
switches to probing the new maximum window with a ‘slow start’ strategy.</p>
<p>If a loss occur in either these phases, the current window (before the loss)
can be treated as the new maximum, and the reduced (with a multiplicative
decrease factor Beta) window size can be used as the new minimum.</p>
<p>More information at: <a class="reference external" href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672</a></p>
</section>
<section id="yeah">
<h6><span class="section-number">16.5.2.4.11. </span>YeAH<a class="headerlink" href="#yeah" title="Link to this heading">¶</a></h6>
<p>YeAH-TCP (Yet Another HighSpeed TCP) is a heuristic designed to balance various
requirements of a state-of-the-art congestion control algorithm:</p>
<ol class="arabic simple">
<li><p>fully exploit the link capacity of high BDP networks while inducing a small number of congestion events</p></li>
<li><p>compete friendly with Reno flows</p></li>
<li><p>achieve intra and RTT fairness</p></li>
<li><p>robust to random losses</p></li>
<li><p>achieve high performance regardless of buffer size</p></li>
</ol>
<p>YeAH operates between 2 modes: Fast and Slow mode. In the Fast mode when the queue
occupancy is small and the network congestion level is low, YeAH increments
its congestion window according to the aggressive HSTCP rule. When the number of packets
in the queue grows beyond a threshold and the network congestion level is high, YeAH enters
its Slow mode, acting as Reno with a decongestion algorithm. YeAH employs Vegas’ mechanism
for calculating the backlog as in Equation <a class="reference internal" href="#equation-q-yeah">(13)</a>. The estimation of the network congestion
level is shown in Equation <a class="reference internal" href="#equation-l-yeah">(14)</a>.</p>
<div class="math" id="equation-q-yeah">
<p><span class="eqno">(13)<a class="headerlink" href="#equation-q-yeah" title="Link to this equation">¶</a></span><img src="_images/math/e4932613eb31adb0529ed55839362d0819ba6b9a.png" alt="Q = (RTT - BaseRTT) \cdot \frac{cWnd}{RTT}"/></p>
</div><div class="math" id="equation-l-yeah">
<p><span class="eqno">(14)<a class="headerlink" href="#equation-l-yeah" title="Link to this equation">¶</a></span><img src="_images/math/bd11d8b588af30b71a574a0bbe61cc5ee281a46b.png" alt="L = \frac{RTT - BaseRTT}{BaseRTT}"/></p>
</div><p>To ensure TCP friendliness, YeAH also implements an algorithm to detect the presence of legacy
Reno flows. Upon the receipt of 3 duplicate ACKs, YeAH decreases its slow start threshold
according to Equation <a class="reference internal" href="#equation-yeahssthresh">(15)</a> if it’s not competing with Reno flows. Otherwise, the ssthresh is
halved as in Reno:</p>
<div class="math" id="equation-yeahssthresh">
<p><span class="eqno">(15)<a class="headerlink" href="#equation-yeahssthresh" title="Link to this equation">¶</a></span><img src="_images/math/1547db882efefba10a5b5478296da38c6cee0774.png" alt="ssthresh = min(max(\frac{cWnd}{8}, Q), \frac{cWnd}{2})"/></p>
</div><p>More information: <a class="reference external" href="http://www.csc.lsu.edu/~sjpark/cs7601/4-YeAH_TCP.pdf">http://www.csc.lsu.edu/~sjpark/cs7601/4-YeAH_TCP.pdf</a></p>
</section>
<section id="illinois">
<h6><span class="section-number">16.5.2.4.12. </span>Illinois<a class="headerlink" href="#illinois" title="Link to this heading">¶</a></h6>
<p>TCP Illinois is a hybrid congestion control algorithm designed for
high-speed networks. Illinois implements a Concave-AIMD (or C-AIMD)
algorithm that uses packet loss as the primary congestion signal to
determine the direction of window update and queueing delay as the
secondary congestion signal to determine the amount of change.</p>
<p>The additive increase and multiplicative decrease factors (denoted as
alpha and beta, respectively) are functions of the current average queueing
delay da as shown in Equations <a class="reference internal" href="#equation-illinoisalpha">(16)</a> and <a class="reference internal" href="#equation-illinoisbeta">(17)</a>. To improve the protocol
robustness against sudden fluctuations in its delay sampling,
Illinois allows the increment of alpha to alphaMax
only if da stays below d1 for a some (theta) amount of time.</p>
<div class="math" id="equation-illinoisalpha">
<p><span class="eqno">(16)<a class="headerlink" href="#equation-illinoisalpha" title="Link to this equation">¶</a></span><img src="_images/math/8f205d4ecda4891fb1c9b94fc106d8c272c0ec00.png" alt="alpha &amp;=
\begin{cases}
   \quad alphaMax              &amp; \quad \text{if } da &lt;= d1 \\
   \quad k1 / (k2 + da)        &amp; \quad \text{otherwise} \\
\end{cases}"/></p>
</div><div class="math" id="equation-illinoisbeta">
<p><span class="eqno">(17)<a class="headerlink" href="#equation-illinoisbeta" title="Link to this equation">¶</a></span><img src="_images/math/f08c85ef621a3445a318c7f3e0be863acd615b2e.png" alt="beta &amp;=
\begin{cases}
   \quad betaMin               &amp; \quad \text{if } da &lt;= d2 \\
   \quad k3 + k4 \, da         &amp; \quad \text{if } d2 &lt; da &lt; d3 \\
   \quad betaMax               &amp; \quad \text{otherwise}
\end{cases}"/></p>
</div><p>where the calculations of k1, k2, k3, and k4 are shown in the following:</p>
<div class="math" id="equation-illinoisk1">
<p><span class="eqno">(18)<a class="headerlink" href="#equation-illinoisk1" title="Link to this equation">¶</a></span><img src="_images/math/44f928900c289fcfc50cc42aa67fb3a507f5dfd6.png" alt="k1 &amp;= \frac{(dm - d1) \cdot alphaMin \cdot alphaMax}{alphaMax - alphaMin}"/></p>
</div><div class="math" id="equation-illinoisk2">
<p><span class="eqno">(19)<a class="headerlink" href="#equation-illinoisk2" title="Link to this equation">¶</a></span><img src="_images/math/f0fe5722801ec37ae27818d45c186961b8718e52.png" alt="k2 &amp;= \frac{(dm - d1) \cdot alphaMin}{alphaMax - alphaMin} - d1"/></p>
</div><div class="math" id="equation-illinoisk3">
<p><span class="eqno">(20)<a class="headerlink" href="#equation-illinoisk3" title="Link to this equation">¶</a></span><img src="_images/math/fbcef6da880f984cf7d047c82d4b848df197e875.png" alt="k3 &amp;= \frac{alphaMin \cdot d3 - alphaMax \cdot d2}{d3 - d2}"/></p>
</div><div class="math" id="equation-illinoisk4">
<p><span class="eqno">(21)<a class="headerlink" href="#equation-illinoisk4" title="Link to this equation">¶</a></span><img src="_images/math/bcbcc4a406bb181759111343bfeebdc481447c1a.png" alt="k4 &amp;= \frac{alphaMax - alphaMin}{d3 - d2}"/></p>
</div><p>Other parameters include da (the current average queueing delay), and
Ta (the average RTT, calculated as sumRtt / cntRtt in the implementation) and
Tmin (baseRtt in the implementation) which is the minimum RTT ever seen.
dm is the maximum (average) queueing delay, and Tmax (maxRtt in the
implementation) is the maximum RTT ever seen.</p>
<div class="math" id="equation-illinoisda">
<p><span class="eqno">(22)<a class="headerlink" href="#equation-illinoisda" title="Link to this equation">¶</a></span><img src="_images/math/aad2cfcefe704282e534e940f672723c3f2e56ac.png" alt="da &amp;= Ta - Tmin"/></p>
</div><div class="math" id="equation-illinoisdm">
<p><span class="eqno">(23)<a class="headerlink" href="#equation-illinoisdm" title="Link to this equation">¶</a></span><img src="_images/math/73ac4dd7e67448cc9688add2fc1dadfcdbc79e33.png" alt="dm &amp;= Tmax - Tmin"/></p>
</div><div class="math" id="equation-illinoisdi">
<p><span class="eqno">(24)<a class="headerlink" href="#equation-illinoisdi" title="Link to this equation">¶</a></span><img src="_images/math/a29fa246d3629a41507aea5e1e538db406a963bc.png" alt="d_i &amp;= eta_i \cdot dm"/></p>
</div><p>Illinois only executes its adaptation of alpha and beta when cwnd exceeds a threshold
called winThresh. Otherwise, it sets alpha and beta to the base values of 1 and 0.5,
respectively.</p>
<p>Following the implementation of Illinois in the Linux kernel, we use the following
default parameter settings:</p>
<ul class="simple">
<li><p>alphaMin = 0.3      (0.1 in the Illinois paper)</p></li>
<li><p>alphaMax = 10.0</p></li>
<li><p>betaMin = 0.125</p></li>
<li><p>betaMax = 0.5</p></li>
<li><p>winThresh = 15      (10 in the Illinois paper)</p></li>
<li><p>theta = 5</p></li>
<li><p>eta1 = 0.01</p></li>
<li><p>eta2 = 0.1</p></li>
<li><p>eta3 = 0.8</p></li>
</ul>
<p>More information: <a class="reference external" href="http://www.doi.org/10.1145/1190095.1190166">http://www.doi.org/10.1145/1190095.1190166</a></p>
</section>
<section id="h-tcp">
<h6><span class="section-number">16.5.2.4.13. </span>H-TCP<a class="headerlink" href="#h-tcp" title="Link to this heading">¶</a></h6>
<p>H-TCP has been designed for high BDP (Bandwidth-Delay Product) paths. It is
a dual mode protocol. In normal conditions, it works like traditional TCP
with the same rate of increment and decrement for the congestion window.
However, in high BDP networks, when it finds no congestion on the path
after <code class="docutils literal notranslate"><span class="pre">deltal</span></code> seconds, it increases the window size based on the alpha
function in the following:</p>
<div class="math" id="equation-htcpalpha">
<p><span class="eqno">(25)<a class="headerlink" href="#equation-htcpalpha" title="Link to this equation">¶</a></span><img src="_images/math/1ceda851ee1572f05925c3c5d43a3dd30edee4c3.png" alt="alpha(delta)=1+10(delta-deltal)+0.5(delta-deltal)^2"/></p>
</div><p>where <code class="docutils literal notranslate"><span class="pre">deltal</span></code> is a threshold in seconds for switching between the modes and
<code class="docutils literal notranslate"><span class="pre">delta</span></code> is the elapsed time from the last congestion. During congestion,
it reduces the window size by multiplying by beta function provided
in the reference paper. The calculated throughput between the last two
consecutive congestion events is considered for beta calculation.</p>
<p>The transport <code class="docutils literal notranslate"><span class="pre">TcpHtcp</span></code> can be selected in the program
<code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-variants-comparison.cc</span></code> to perform an experiment with H-TCP,
although it is useful to increase the bandwidth in this example (e.g.
to 20 Mb/s) to create a higher BDP link, such as</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">ns3</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="s">&quot;tcp-variants-comparison --transport_prot=TcpHtcp --bandwidth=20Mbps --duration=10&quot;</span>
</pre></div>
</div>
<p>More information (paper): <a class="reference external" href="http://www.hamilton.ie/net/htcp3.pdf">http://www.hamilton.ie/net/htcp3.pdf</a></p>
<p>More information (Internet Draft): <a class="reference external" href="https://tools.ietf.org/html/draft-leith-tcp-htcp-06">https://tools.ietf.org/html/draft-leith-tcp-htcp-06</a></p>
</section>
<section id="ledbat">
<h6><span class="section-number">16.5.2.4.14. </span>LEDBAT<a class="headerlink" href="#ledbat" title="Link to this heading">¶</a></h6>
<p>Low Extra Delay Background Transport (LEDBAT) is an experimental delay-based
congestion control algorithm that seeks to utilize the available bandwidth on
an end-to-end path while limiting the consequent increase in queueing delay
on that path. LEDBAT uses changes in one-way delay measurements to limit
congestion that the flow itself induces in the network.</p>
<p>As a first approximation, the LEDBAT sender operates as shown below:</p>
<p>On receipt of an ACK:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">currentdelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">acknowledgement</span><span class="p">.</span><span class="n">delay</span>
<span class="n">basedelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">basedelay</span><span class="p">,</span><span class="w"> </span><span class="n">currentdelay</span><span class="p">)</span>
<span class="n">queuingdelay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentdelay</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">basedelay</span>
<span class="n">offtarget</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="n">TARGET</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">queuingdelay</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">TARGET</span>
<span class="n">cWnd</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">GAIN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offtarget</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bytesnewlyacked</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MSS</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cWnd</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TARGET</span></code> is the maximum queueing delay that LEDBAT itself may introduce in the
network, and <code class="docutils literal notranslate"><span class="pre">GAIN</span></code> determines the rate at which the cwnd responds to changes in
queueing delay; <code class="docutils literal notranslate"><span class="pre">offtarget</span></code> is a normalized value representing the difference between
the measured current queueing delay and the predetermined TARGET delay. offtarget can
be positive or negative; consequently, cwnd increases or decreases in proportion to
offtarget.</p>
<p>Following the recommendation of RFC 6817, the default values of the parameters are:</p>
<ul class="simple">
<li><p>TargetDelay = 100</p></li>
<li><p>baseHistoryLen = 10</p></li>
<li><p>noiseFilterLen = 4</p></li>
<li><p>Gain = 1</p></li>
</ul>
<p>To enable LEDBAT on all TCP sockets, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpLedbat</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>To enable LEDBAT on a chosen TCP socket, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpLedbat</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>The following unit tests have been written to validate the implementation of LEDBAT:</p>
<ul class="simple">
<li><p>LEDBAT should operate same as NewReno during slow start</p></li>
<li><p>LEDBAT should operate same as NewReno if timestamps are disabled</p></li>
<li><p>Test to validate cwnd increment in LEDBAT</p></li>
</ul>
<p>In comparison to RFC 6817, the scope and limitations of the current LEDBAT
implementation are:</p>
<ul class="simple">
<li><p>It assumes that the clocks on the sender side and receiver side are synchronised</p></li>
<li><p>In line with Linux implementation, the one-way delay is calculated at the sender side by using the timestamps option in TCP header</p></li>
<li><p>Only the MIN function is used for noise filtering</p></li>
</ul>
<p>More information about LEDBAT is available in RFC 6817: <a class="reference external" href="https://tools.ietf.org/html/rfc6817">https://tools.ietf.org/html/rfc6817</a></p>
</section>
<section id="tcp-lp">
<h6><span class="section-number">16.5.2.4.15. </span>TCP-LP<a class="headerlink" href="#tcp-lp" title="Link to this heading">¶</a></h6>
<p>TCP-Low Priority (TCP-LP) is a delay based congestion control protocol in which the low
priority data utilizes only the excess bandwidth available on an end-to-end path.
TCP-LP uses one way delay measurements as an indicator of congestion as it does
not influence cross-traffic in the reverse direction.</p>
<p>On receipt of an ACK:</p>
<div class="math">
<p><img src="_images/math/64405a2f4e1fc124d0b06e41d4c6660aee9d9953.png" alt="One way delay = Receiver timestamp - Receiver timestamp echo reply
Smoothed one way delay = 7/8 * Old Smoothed one way delay + 1/8 * one way delay
If smoothed one way delay &gt; owdMin + 15 * (owdMax - owdMin) / 100
  if LP_WITHIN_INF
    cwnd = 1
  else
    cwnd = cwnd / 2
  Inference timer is set"/></p>
</div><p>where owdMin and owdMax are the minimum and maximum one way delays experienced
throughout the connection, LP_WITHIN_INF indicates if TCP-LP is in inference
phase or not</p>
<p>More information (paper): <a class="reference external" href="http://cs.northwestern.edu/~akuzma/rice/doc/TCP-LP.pdf">http://cs.northwestern.edu/~akuzma/rice/doc/TCP-LP.pdf</a></p>
</section>
<section id="data-center-tcp-dctcp">
<h6><span class="section-number">16.5.2.4.16. </span>Data Center TCP (DCTCP)<a class="headerlink" href="#data-center-tcp-dctcp" title="Link to this heading">¶</a></h6>
<p>DCTCP, specified in RFC 8257 and implemented in Linux, is a TCP congestion
control algorithm for data center networks.  It leverages Explicit Congestion
Notification (ECN) to provide more fine-grained congestion
feedback to the end hosts, and is intended to work with routers that
implement a shallow congestion marking threshold (on the order of a
few milliseconds) to achieve high throughput and low latency in the
datacenter.  However, because DCTCP does not react in the same way to
notification of congestion experienced, there are coexistence (fairness)
issues between it and legacy TCP congestion controllers, which is why it
is recommended to only be used in controlled networking environments such
as within data centers.</p>
<p>DCTCP extends the Explicit Congestion Notification signal
to estimate the fraction of bytes that encounter congestion, rather than simply
detecting that the congestion has occurred. DCTCP then scales the congestion
window based on this estimate. This approach achieves high burst tolerance, low
latency, and high throughput with shallow-buffered switches.</p>
<ul class="simple">
<li><p><em>Receiver functionality:</em> If CE is observed in the IP header of an incoming
packet at the TCP receiver, the receiver sends congestion notification to
the sender by setting ECE in TCP header. This processing is different
from standard receiver ECN processing which sets and holds the ECE bit
for every ACK until it observes a CWR signal from the TCP sender.</p></li>
<li><p><em>Sender functionality:</em> The sender makes use of the modified receiver
ECE semantics to maintain an estimate of the fraction of packets marked
(<img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/>) by using the exponential weighted moving average (EWMA) as
shown below:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/8b5026eab360e4cdc72d8a71db4490c352d741df.png" alt="\alpha = (1 - g) * \alpha + g * F"/></p>
</div><p>In the above EWMA:</p>
<ul class="simple">
<li><p><em>g</em> is the estimation gain (between 0 and 1)</p></li>
<li><p><em>F</em> is the fraction of packets marked in current RTT.</p></li>
</ul>
<p>For send windows in which at least one ACK was received with ECE set,
the sender should respond by reducing the congestion
window as follows, once for every window of data:</p>
<div class="math">
<p><img src="_images/math/c07d5a2b0d23280b2dbf48992f7e476633398869.png" alt="cwnd = cwnd * (1 - \alpha / 2)"/></p>
</div><p>Following the recommendation of RFC 8257, the default values of the parameters are:</p>
<div class="math">
<p><img src="_images/math/00962736150bbfc10cf5f7127c273a83c252a671.png" alt="g = 0.0625 (i.e., 1/16)

initial alpha (\alpha) = 1"/></p>
</div><p>To enable DCTCP on all TCP sockets, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpDctcp</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>To enable DCTCP on a selected node, one can set the “SocketType” attribute
on the TcpL4Protocol object of that node to the TcpDctcp TypeId.</p>
<p>The ECN is enabled automatically when DCTCP is used, even if the user
has not explicitly enabled it.</p>
<p>DCTCP depends on a simple queue management algorithm in routers / switches to
mark packets. The current implementation of DCTCP in ns-3 can use RED with
a simple
configuration to achieve the behavior of desired queue management algorithm.</p>
<p>To configure RED router for DCTCP:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::UseEcn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::QW&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::MinTh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::MaxTh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
</pre></div>
</div>
<p>There is also the option, when running CoDel or FqCoDel, to enable ECN
on the queue and to set the “CeThreshold” value to a low value such as 1ms.
The following example uses CoDel:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::CoDelQueueDisc::UseEcn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::CoDelQueueDisc::CeThreshold&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">MilliSeconds</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
</pre></div>
</div>
<p>The following unit tests have been written to validate the implementation of DCTCP:</p>
<ul class="simple">
<li><p>ECT flags should be set for SYN, SYN+ACK, ACK and data packets for DCTCP traffic</p></li>
<li><p>ECT flags should not be set for SYN, SYN+ACK and pure ACK packets, but should be set on data packets for ECN enabled traditional TCP flows</p></li>
<li><p>ECE should be set only when CE flags are received at receiver and even if sender doesn’t send CWR, receiver should not send ECE if it doesn’t receive packets with CE flags</p></li>
</ul>
<p>An example program, <code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-validation.cc</span></code>, can be used to
experiment with DCTCP for long-running flows with different bottleneck
link bandwidth, base RTTs, and queuing disciplines.  A variant of this
program has also been run using the <em>ns-3</em> Direct Code Execution
environment using DCTCP from Linux kernel 4.4, and the results were
compared against <em>ns-3</em> results.</p>
<p>An example program based on an experimental topology found in the original
DCTCP SIGCOMM paper is provided in <code class="docutils literal notranslate"><span class="pre">examples/tcp/dctcp-example.cc</span></code>.
This example uses a simple topology consisting of forty DCTCP senders
and receivers and two ECN-enabled switches to examine throughput,
fairness, and queue delay properties of the network.</p>
<p>This implementation was tested extensively against a version of DCTCP in
the Linux kernel version 4.4 using the ns-3 direct code execution (DCE)
environment. Some differences were noted:</p>
<ul class="simple">
<li><p>Linux maintains its congestion window in segments and not bytes, and
the arithmetic is not floating point, so small differences in the
evolution of congestion window have been observed.</p></li>
<li><p>Linux uses pacing, where packets to be sent are paced out at regular
intervals. However, if at any instant the number of segments that can
be sent are less than two, Linux does not pace them and instead sends
them back-to-back. Currently, ns-3 paces out all packets eligible to
be sent in the same manner.</p></li>
</ul>
<p>More information about DCTCP is available in the RFC 8257:
<a class="reference external" href="https://tools.ietf.org/html/rfc8257">https://tools.ietf.org/html/rfc8257</a></p>
</section>
<section id="bbr">
<h6><span class="section-number">16.5.2.4.17. </span>BBR<a class="headerlink" href="#bbr" title="Link to this heading">¶</a></h6>
<p>BBR (class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpBbr</span></code>) is a congestion control algorithm that
regulates the sending rate by deriving an estimate of the bottleneck’s
available bandwidth and RTT of the path. It seeks to operate at an optimal
point where sender experiences maximum delivery rate with minimum RTT. It
creates a network model comprising maximum delivery rate with minimum RTT
observed so far, and then estimates BDP (maximum bandwidth * minimum RTT)
to control the maximum amount of inflight data. BBR controls congestion by
limiting the rate at which packets are sent. It caps the cwnd to one BDP
and paces out packets at a rate which is adjusted based on the latest estimate
of delivery rate. BBR algorithm is agnostic to packet losses and ECN marks.</p>
<p>pacing_gain controls the rate of sending data and cwnd_gain controls the amount
of data to send.</p>
<p>The following is a high level overview of BBR congestion control algorithm:</p>
<p>On receiving an ACK:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">rtt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">packet</span><span class="p">.</span><span class="n">sent_time</span>
<span class="n">update_minimum_rtt</span><span class="p">(</span><span class="n">rtt</span><span class="p">)</span>
<span class="n">delivery_rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_delivery_rate</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="n">update_maximum_bandwidth</span><span class="p">(</span><span class="n">delivery_rate</span><span class="p">)</span>
</pre></div>
</div>
<p>After transmitting a data packet:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">bdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_bandwidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">min_rtt</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cwnd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bdp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inflight</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nextSendTime</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">transmit</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="w">    </span><span class="n">nextSendTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">packet</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="p">(</span><span class="n">pacing_gain</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">max_bandwidth</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="k">return</span>
<span class="n">Schedule</span><span class="p">(</span><span class="n">nextSendTime</span><span class="p">,</span><span class="w"> </span><span class="n">Send</span><span class="p">)</span>
</pre></div>
</div>
<p>To enable BBR on all TCP sockets, the following configuration can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpL4Protocol::SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpBbr</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>To enable BBR on a chosen TCP socket, the following configuration can be used
(note that an appropriate Node ID must be used instead of 1):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TypeIdValue</span><span class="p">(</span><span class="n">TcpBbr</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">()));</span>
</pre></div>
</div>
<p>The ns-3 implementation of BBR is based on its Linux implementation. Linux 5.4
kernel implementation has been used to validate the behavior of ns-3
implementation of BBR (See below section on Validation).</p>
<p>In addition, the following unit tests have been written to validate the
implementation of BBR in ns-3:</p>
<ul class="simple">
<li><p>BBR should enable (if not already done) TCP pacing feature.</p></li>
<li><p>Test to validate the values of pacing_gain and cwnd_gain in different phases
of BBR.</p></li>
</ul>
<p>An example program, examples/tcp/tcp-bbr-example.cc, is provided to experiment
with BBR for one long running flow. This example uses a simple topology
consisting of one sender, one receiver and two routers to examine congestion
window, throughput and queue control. A program similar to this has been run
using the Network Stack Tester (NeST) using BBR from Linux kernel 5.4, and the
results were compared against ns-3 results.</p>
<p>More information about BBR is available in the following Internet Draft:
<a class="reference external" href="https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00">https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00</a></p>
<p>More information about Delivery Rate Estimation is in the following draft:
<a class="reference external" href="https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00">https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00</a></p>
<p>For an academic peer-reviewed paper on the BBR implementation in ns-3,
please refer to:</p>
<ul class="simple">
<li><p>Vivek Jain, Viyom Mittal and Mohit P. Tahiliani. “Design and Implementation of TCP BBR in ns-3.” In Proceedings of the 10th Workshop on ns-3, pp. 16-22. 2018. (<a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3199902.3199911">https://dl.acm.org/doi/abs/10.1145/3199902.3199911</a>)</p></li>
</ul>
</section>
</section>
<section id="support-for-explicit-congestion-notification-ecn">
<h5><span class="section-number">16.5.2.5. </span>Support for Explicit Congestion Notification (ECN)<a class="headerlink" href="#support-for-explicit-congestion-notification-ecn" title="Link to this heading">¶</a></h5>
<p>ECN provides end-to-end notification of network congestion without dropping
packets. It uses two bits in the IP header: ECN Capable Transport (ECT bit)
and Congestion Experienced (CE bit), and two bits in the TCP header: Congestion
Window Reduced (CWR) and ECN Echo (ECE).</p>
<p>More information is available in RFC 3168: <a class="reference external" href="https://tools.ietf.org/html/rfc3168">https://tools.ietf.org/html/rfc3168</a></p>
<p>The following ECN states are declared in <code class="docutils literal notranslate"><span class="pre">src/internet/model/tcp-socket-state.h</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ECN_DISABLED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">//!&lt; ECN disabled traffic</span>
<span class="w">    </span><span class="n">ECN_IDLE</span><span class="p">,</span><span class="w">         </span><span class="c1">//!&lt; ECN is enabled but currently there is no action pertaining to ECE or CWR to be taken</span>
<span class="w">    </span><span class="n">ECN_CE_RCVD</span><span class="p">,</span><span class="w">      </span><span class="c1">//!&lt; Last packet received had CE bit set in IP header</span>
<span class="w">    </span><span class="n">ECN_SENDING_ECE</span><span class="p">,</span><span class="w">  </span><span class="c1">//!&lt; Receiver sends an ACK with ECE bit set in TCP header</span>
<span class="w">    </span><span class="n">ECN_ECE_RCVD</span><span class="p">,</span><span class="w">     </span><span class="c1">//!&lt; Last ACK received had ECE bit set in TCP header</span>
<span class="w">    </span><span class="n">ECN_CWR_SENT</span><span class="w">      </span><span class="c1">//!&lt; Sender has reduced the congestion window, and sent a packet with CWR bit set in TCP header. This is used for tracing.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">EcnStates_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Current implementation of ECN is based on RFC 3168 and is referred as Classic ECN.</p>
<p>The following enum represents the mode of ECN:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ClassicEcn</span><span class="p">,</span><span class="w">  </span><span class="c1">//!&lt; ECN functionality as described in RFC 3168.</span>
<span class="w">    </span><span class="n">DctcpEcn</span><span class="p">,</span><span class="w">    </span><span class="c1">//!&lt; ECN functionality as described in RFC 8257. Note: this mode is specific to DCTCP.</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">EcnMode_t</span><span class="p">;</span>
</pre></div>
</div>
<p>The following are some important ECN parameters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ECN parameters</span>
<span class="n">EcnMode_t</span><span class="w">              </span><span class="n">m_ecnMode</span><span class="w"> </span><span class="p">{</span><span class="n">ClassicEcn</span><span class="p">};</span><span class="w"> </span><span class="c1">//!&lt; ECN mode</span>
<span class="n">UseEcn_t</span><span class="w">               </span><span class="n">m_useEcn</span><span class="w"> </span><span class="p">{</span><span class="n">Off</span><span class="p">};</span><span class="w">         </span><span class="c1">//!&lt; Socket ECN capability</span>
</pre></div>
</div>
<section id="enabling-ecn">
<h6><span class="section-number">16.5.2.5.1. </span>Enabling ECN<a class="headerlink" href="#enabling-ecn" title="Link to this heading">¶</a></h6>
<p>By default, support for ECN is disabled in TCP sockets. To enable, change
the value of the attribute <code class="docutils literal notranslate"><span class="pre">ns3::TcpSocketBase::UseEcn</span></code> to <code class="docutils literal notranslate"><span class="pre">On</span></code>.
Following are supported values for the same, this functionality is aligned with
Linux: <a class="reference external" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt</a></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">Off</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="c1">//!&lt; Disable</span>
<span class="w">    </span><span class="n">On</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="c1">//!&lt; Enable</span>
<span class="w">    </span><span class="n">AcceptOnly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="c1">//!&lt; Enable only when the peer endpoint is ECN capable</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="p">;</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::TcpSocketBase::UseEcn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;On&quot;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="ecn-negotiation">
<h6><span class="section-number">16.5.2.5.2. </span>ECN negotiation<a class="headerlink" href="#ecn-negotiation" title="Link to this heading">¶</a></h6>
<p>ECN capability is negotiated during the three-way TCP handshake:</p>
<ol class="arabic simple">
<li><p>Sender sends SYN + CWR + ECE</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_useEcn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="o">::</span><span class="n">On</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_DISABLED</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Receiver sends SYN + ACK + ECE</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_useEcn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="o">::</span><span class="n">Off</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">tcpHeader</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ACK</span><span class="w"> </span><span class="o">|</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_IDLE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">SendEmptyPacket</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ACK</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_DISABLED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Sender sends ACK</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_useEcn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">UseEcn_t</span><span class="o">::</span><span class="n">Off</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">tcpHeader</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">CWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">ECE</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_IDLE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">m_ecnState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ECN_DISABLED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Once the ECN-negotiation is successful, the sender sends data packets with ECT
bits set in the IP header.</p>
<p>Note: As mentioned in <a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.1">Section 6.1.1 of RFC 3168</a>, ECT bits should not be set
during ECN negotiation. The ECN negotiation implemented in <em>ns-3</em> follows
this guideline.</p>
</section>
<section id="ecn-state-transitions">
<h6><span class="section-number">16.5.2.5.3. </span>ECN State Transitions<a class="headerlink" href="#ecn-state-transitions" title="Link to this heading">¶</a></h6>
<ol class="arabic simple">
<li><p>Initially both sender and receiver have their m_ecnState set as ECN_DISABLED</p></li>
<li><p>Once the ECN negotiation is successful, their states are set to ECN_IDLE</p></li>
<li><p>The receiver’s state changes to ECN_CE_RCVD when it receives a packet with
CE bit set. The state then moves to ECN_SENDING_ECE when the receiver sends
an ACK with ECE set. This state is retained until a CWR is received
, following which, the state changes to ECN_IDLE.</p></li>
<li><p>When the sender receives an ACK with ECE bit set from receiver, its state
is set as ECN_ECE_RCVD</p></li>
<li><p>The sender’s state changes to ECN_CWR_SENT when it sends a packet with
CWR bit set. It remains in this state until an ACK with valid ECE is received
(i.e., ECE is received for a packet that belongs to a new window),
following which, its state changes to ECN_ECE_RCVD.</p></li>
</ol>
</section>
<section id="rfc-3168-compliance">
<h6><span class="section-number">16.5.2.5.4. </span>RFC 3168 compliance<a class="headerlink" href="#rfc-3168-compliance" title="Link to this heading">¶</a></h6>
<p>Based on the suggestions provided in RFC 3168, the following behavior has
been implemented:</p>
<ol class="arabic simple">
<li><p>Pure ACK packets should not have the ECT bit set (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.4">Section 6.1.4</a>).</p></li>
<li><p>In the current implementation, the sender only sends ECT(0) in the IP header.</p></li>
<li><p>The sender should should reduce the congestion window only once in each
window (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.2">Section 6.1.2</a>).</p></li>
<li><p>The receiver should ignore the CE bits set in a packet arriving out of
window (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.5">Section 6.1.5</a>).</p></li>
<li><p>The sender should ignore the ECE bits set in the packet arriving out of
window (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.2">Section 6.1.2</a>).</p></li>
</ol>
</section>
<section id="open-issues">
<h6><span class="section-number">16.5.2.5.5. </span>Open issues<a class="headerlink" href="#open-issues" title="Link to this heading">¶</a></h6>
<p>The following issues are yet to be addressed:</p>
<ol class="arabic simple">
<li><p>Retransmitted packets should not have the CWR bit set (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.5">Section 6.1.5</a>).</p></li>
<li><p>Despite the congestion window size being 1 MSS, the sender should reduce its
congestion window by half when it receives a packet with the ECE bit set. The
sender must reset the retransmit timer on receiving the ECN-Echo packet when
the congestion window is one. The sending TCP will then be able to send a
new packet only when the retransmit timer expires (<a class="reference external" href="https://tools.ietf.org/html/rfc3168#section-6.1.2">Section 6.1.2</a>).</p></li>
<li><p>Support for separately handling the enabling of ECN on the incoming and
outgoing TCP sessions (e.g. a TCP may perform ECN echoing but not set the
ECT codepoints on its outbound data segments).</p></li>
</ol>
</section>
</section>
<section id="support-for-dynamic-pacing">
<h5><span class="section-number">16.5.2.6. </span>Support for Dynamic Pacing<a class="headerlink" href="#support-for-dynamic-pacing" title="Link to this heading">¶</a></h5>
<p>TCP pacing refers to the sender-side practice of scheduling the transmission
of a burst of eligible TCP segments across a time interval such as
a TCP RTT, to avoid or reduce bursts.  Historically,
TCP used the natural ACK clocking mechanism to pace segments, but some
network paths introduce aggregation (bursts of ACKs arriving) or ACK
thinning, either of which disrupts ACK clocking.
Some latency-sensitive congestion controls under development (Prague, BBR)
require pacing to operate effectively.</p>
<p>Until recently, the state of the art in Linux was to support pacing in one
of two ways:</p>
<ol class="arabic simple">
<li><p>fq/pacing with sch_fq</p></li>
<li><p>TCP internal pacing</p></li>
</ol>
<p>The presentation by Dumazet and Cheng at IETF 88 summarizes:
<a class="reference external" href="https://www.ietf.org/proceedings/88/slides/slides-88-tcpm-9.pdf">https://www.ietf.org/proceedings/88/slides/slides-88-tcpm-9.pdf</a></p>
<p>The first option was most often used when offloading (TSO) was enabled and
when the sch_fq scheduler was used at the traffic control (qdisc) sublayer.  In
this case, TCP was responsible for setting the socket pacing rate, but
the qdisc sublayer would enforce it.  When TSO was enabled, the kernel
would break a large burst into smaller chunks, with dynamic sizing based
on the pacing rate, and hand off the segments to the fq qdisc for
pacing.</p>
<p>The second option was used if sch_fq was not enabled; TCP would be
responsible for internally pacing.</p>
<p>In 2018, Linux switched to an Early Departure Model (EDM): <a class="reference external" href="https://lwn.net/Articles/766564/">https://lwn.net/Articles/766564/</a>.</p>
<p>TCP pacing in Linux was added in kernel 3.12, and authors chose to allow
a pacing rate of 200% against the current rate, to allow probing for
optimal throughput even during slow start phase.  Some refinements were
added in <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=43e122b014c9">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=43e122b014c9</a>,
in which Google reported that it was better to apply
a different ratio (120%) in Congestion Avoidance phase.  Furthermore,
authors found that after cwnd reduction, it was helpful to become more
conservative and switch to the conservative ratio (120%) as soon as
cwnd &gt;= ssthresh/2, as the initial ramp up (when ssthresh is infinite) still
allows doubling cwnd every other RTT.  Linux also does not pace the initial
window (IW), typically 10 segments in practice.</p>
<p>Linux has also been observed to not pace if the number of eligible segments
to be sent is exactly two; they will be sent back to back.  If three or
more, the first two are sent immediately, and additional segments are paced
at the current pacing rate.</p>
<p>In ns-3, the model is as follows.  There is no TSO/sch_fq model; only
internal pacing according to current Linux policy.</p>
<p>Pacing may be enabled for any TCP congestion control, and a maximum
pacing rate can be set.  Furthermore, dynamic pacing is enabled for
all TCP variants, according to the following guidelines.</p>
<ul class="simple">
<li><p>Pacing of the initial window (IW) is not done by default but can be
separately enabled.</p></li>
<li><p>Pacing of the initial slow start, after IW, is done according to the
pacing rate of 200% of the current rate, to allow for window growth
This pacing rate can be configured to a different value than 200%.</p></li>
<li><p>Pacing of congestion avoidance phase is done at a pacing rate of 120% of
current rate.  This can be configured to a different value than 120%.</p></li>
<li><p>Pacing of subsequent slow start is done according to the following
heuristic.  If cwnd &lt; ssthresh/2, such as after a timeout or idle period,
pace at the slow start rate (200%).  Otherwise, pace at the congestion
avoidance rate.</p></li>
</ul>
<p>Dynamic pacing is demonstrated by the example program <code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-pacing.cc</span></code>.</p>
</section>
<section id="validation">
<h5><span class="section-number">16.5.2.7. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h5>
<p>The following tests are found in the <code class="docutils literal notranslate"><span class="pre">src/internet/test</span></code> directory. In
general, TCP tests inherit from a class called <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TcpGeneralTest</span></code>,
which provides common operations to set up test scenarios involving TCP
objects. For more information on how to write new tests, see the
section below on <a class="reference internal" href="#writing-tcp-tests"><span class="std std-ref">Writing TCP tests</span></a>.</p>
<ul class="simple">
<li><p><strong>tcp:</strong> Basic transmission of string of data from client to server</p></li>
<li><p><strong>tcp-bytes-in-flight-test:</strong> TCP correctly estimates bytes in flight under loss conditions</p></li>
<li><p><strong>tcp-cong-avoid-test:</strong> TCP congestion avoidance for different packet sizes</p></li>
<li><p><strong>tcp-datasentcb:</strong> Check TCP’s ‘data sent’ callback</p></li>
<li><p><strong>tcp-endpoint-bug2211-test:</strong> A test for an issue that was causing stack overflow</p></li>
<li><p><strong>tcp-fast-retr-test:</strong> Fast Retransmit testing</p></li>
<li><p><strong>tcp-header:</strong> Unit tests on the TCP header</p></li>
<li><p><strong>tcp-highspeed-test:</strong> Unit tests on the HighSpeed congestion control</p></li>
<li><p><strong>tcp-htcp-test:</strong> Unit tests on the H-TCP congestion control</p></li>
<li><p><strong>tcp-hybla-test:</strong> Unit tests on the Hybla congestion control</p></li>
<li><p><strong>tcp-vegas-test:</strong> Unit tests on the Vegas congestion control</p></li>
<li><p><strong>tcp-veno-test:</strong> Unit tests on the Veno congestion control</p></li>
<li><p><strong>tcp-scalable-test:</strong> Unit tests on the Scalable congestion control</p></li>
<li><p><strong>tcp-bic-test:</strong> Unit tests on the BIC congestion control</p></li>
<li><p><strong>tcp-yeah-test:</strong> Unit tests on the YeAH congestion control</p></li>
<li><p><strong>tcp-illinois-test:</strong> Unit tests on the Illinois congestion control</p></li>
<li><p><strong>tcp-ledbat-test:</strong> Unit tests on the LEDBAT congestion control</p></li>
<li><p><strong>tcp-lp-test:</strong> Unit tests on the TCP-LP congestion control</p></li>
<li><p><strong>tcp-dctcp-test:</strong> Unit tests on the DCTCP congestion control</p></li>
<li><p><strong>tcp-bbr-test:</strong> Unit tests on the BBR congestion control</p></li>
<li><p><strong>tcp-option:</strong> Unit tests on TCP options</p></li>
<li><p><strong>tcp-pkts-acked-test:</strong> Unit test the number of time that PktsAcked is called</p></li>
<li><p><strong>tcp-rto-test:</strong> Unit test behavior after a RTO occurs</p></li>
<li><p><strong>tcp-rtt-estimation-test:</strong> Check RTT calculations, including retransmission cases</p></li>
<li><p><strong>tcp-slow-start-test:</strong> Check behavior of slow start</p></li>
<li><p><strong>tcp-timestamp:</strong> Unit test on the timestamp option</p></li>
<li><p><strong>tcp-wscaling:</strong> Unit test on the window scaling option</p></li>
<li><p><strong>tcp-zero-window-test:</strong> Unit test persist behavior for zero window conditions</p></li>
<li><p><strong>tcp-close-test:</strong> Unit test on the socket closing: both receiver and sender have to close their socket when all bytes are transferred</p></li>
<li><p><strong>tcp-ecn-test:</strong> Unit tests on Explicit Congestion Notification</p></li>
<li><p><strong>tcp-pacing-test:</strong> Unit tests on dynamic TCP pacing rate</p></li>
</ul>
<p>Several tests have dependencies outside of the <code class="docutils literal notranslate"><span class="pre">internet</span></code> module, so they
are located in a system test directory called <code class="docutils literal notranslate"><span class="pre">src/test/ns3tcp</span></code>.</p>
<ul class="simple">
<li><p><strong>ns3-tcp-loss:</strong> Check behavior of ns-3 TCP upon packet losses</p></li>
<li><p><strong>ns3-tcp-no-delay:</strong> Check that ns-3 TCP Nagle’s algorithm works correctly and that it can be disabled</p></li>
<li><p><strong>ns3-tcp-socket:</strong> Check that ns-3 TCP successfully transfers an application data write of various sizes</p></li>
<li><p><strong>ns3-tcp-state:</strong> Check the operation of the TCP state machine for several cases</p></li>
</ul>
<p>Several TCP validation test results can also be found in the
<a class="reference external" href="http://www.nsnam.org/wiki/New_TCP_Socket_Architecture">wiki page</a>
describing this implementation.</p>
<p>The ns-3 implementation of TCP Linux Reno was validated against the NewReno
implementation of Linux kernel 4.4.0 using ns-3 Direct Code Execution (DCE).
DCE is a framework which allows the users to run kernel space protocol inside
ns-3 without changing the source code.</p>
<p>In this validation, cwnd traces of DCE Linux <code class="docutils literal notranslate"><span class="pre">reno</span></code> were compared to those of
ns-3 Linux Reno and NewReno for a delayed acknowledgement configuration of 1
segment (in the ns-3 implementation; Linux does not allow direct configuration
of this setting). It can be observed that cwnd traces for ns-3 Linux Reno are
closely overlapping with DCE <code class="docutils literal notranslate"><span class="pre">reno</span></code>, while
for ns-3 NewReno there was deviation in the congestion avoidance phase.</p>
<figure class="align-center" id="id9">
<span id="fig-dce-linux-reno-vs-ns3-linux-reno"></span><a class="reference internal image-reference" href="_images/dce-linux-reno-vs-ns3-linux-reno.png"><img alt="_images/dce-linux-reno-vs-ns3-linux-reno.png" src="_images/dce-linux-reno-vs-ns3-linux-reno.png" style="width: 560.0px; height: 420.0px;" /></a>
<figcaption>
<p><span class="caption-text">DCE Linux Reno vs. ns-3 Linux Reno</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id10">
<span id="fig-dce-linux-reno-vs-ns3-new-reno"></span><a class="reference internal image-reference" href="_images/dce-linux-reno-vs-ns3-new-reno.png"><img alt="_images/dce-linux-reno-vs-ns3-new-reno.png" src="_images/dce-linux-reno-vs-ns3-new-reno.png" style="width: 560.0px; height: 420.0px;" /></a>
<figcaption>
<p><span class="caption-text">DCE Linux Reno vs. ns-3 NewReno</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The difference in the cwnd in the early stage of this flow is because of the
way cwnd is plotted.  As ns-3 provides a trace source for cwnd, an ns-3 Linux
Reno cwnd simple is obtained every time the cwnd value changes, whereas for
DCE Linux Reno, the kernel does not have a corresponding trace source.
Instead, we use the “ss” command of the Linux kernel to obtain
cwnd values. The “ss” samples cwnd at an interval of 0.5 seconds.</p>
<p>Figure <a class="reference internal" href="#fig-dctcp-10ms-50mbps-tcp-throughput"><span class="std std-ref">DCTCP throughput for 10ms/50Mbps bottleneck, 1ms CE threshold</span></a> shows a long-running
file transfer using DCTCP over a 50 Mbps bottleneck (running CoDel queue
disc with a 1ms CE threshold setting) with a 10 ms base RTT.  The figure
shows that DCTCP reaches link capacity very quickly and stays there for
the duration with minimal change in throughput.  In contrast, Figure
<a class="reference internal" href="#fig-dctcp-80ms-50mbps-tcp-throughput"><span class="std std-ref">DCTCP throughput for 80ms/50Mbps bottleneck, 1ms CE threshold</span></a> plots the throughput for
the same configuration except with an 80 ms base RTT.  In this case,
the DCTCP exits slow start early and takes a long time to build the
flow throughput to the bottleneck link capacity.  DCTCP is not intended
to be used at such a large base RTT, but this figure highlights the
sensitivity to RTT (and can be reproduced using the Linux implementation).</p>
<figure class="align-center" id="id11">
<span id="fig-dctcp-10ms-50mbps-tcp-throughput"></span><a class="reference internal image-reference" href="_images/dctcp-10ms-50mbps-tcp-throughput.png"><img alt="_images/dctcp-10ms-50mbps-tcp-throughput.png" src="_images/dctcp-10ms-50mbps-tcp-throughput.png" style="width: 460.8px; height: 345.6px;" /></a>
<figcaption>
<p><span class="caption-text">DCTCP throughput for 10ms/50Mbps bottleneck, 1ms CE threshold</span><a class="headerlink" href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id12">
<span id="fig-dctcp-80ms-50mbps-tcp-throughput"></span><a class="reference internal image-reference" href="_images/dctcp-80ms-50mbps-tcp-throughput.png"><img alt="_images/dctcp-80ms-50mbps-tcp-throughput.png" src="_images/dctcp-80ms-50mbps-tcp-throughput.png" style="width: 460.8px; height: 345.6px;" /></a>
<figcaption>
<p><span class="caption-text">DCTCP throughput for 80ms/50Mbps bottleneck, 1ms CE threshold</span><a class="headerlink" href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Similar to DCTCP, TCP CUBIC has been tested against the Linux kernel version
4.4 implementation.  Figure <a class="reference internal" href="#fig-cubic-50ms-50mbps-tcp-cwnd-no-ecn"><span class="std std-ref">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, no ECN</span></a>
compares the congestion window evolution between ns-3 and Linux for a single
flow operating over a 50 Mbps link with 50 ms base RTT and the CoDel AQM.
Some differences can be observed between the peak of slow start window
growth (ns-3 exits slow start earlier due to its HyStart implementation),
and the window growth is a bit out-of-sync (likely due to different
implementations of the algorithm), but the cubic concave/convex window
pattern, and the signs of TCP CUBIC fast convergence algorithm
(alternating patterns of cubic and concave window growth) can be observed.
The <em>ns-3</em> congestion window is maintained in bytes (unlike Linux which uses
segments) but has been normalized to segments for these plots.
Figure <a class="reference internal" href="#fig-cubic-50ms-50mbps-tcp-cwnd-ecn"><span class="std std-ref">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, with ECN</span></a> displays the outcome of
a similar scenario but with ECN enabled throughout.</p>
<figure class="align-center" id="id13">
<span id="fig-cubic-50ms-50mbps-tcp-cwnd-no-ecn"></span><a class="reference internal image-reference" href="_images/cubic-50ms-50mbps-tcp-cwnd-no-ecn.png"><img alt="_images/cubic-50ms-50mbps-tcp-cwnd-no-ecn.png" src="_images/cubic-50ms-50mbps-tcp-cwnd-no-ecn.png" style="width: 368.8px; height: 276.8px;" /></a>
<figcaption>
<p><span class="caption-text">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, no ECN</span><a class="headerlink" href="#id13" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id14">
<span id="fig-cubic-50ms-50mbps-tcp-cwnd-ecn"></span><a class="reference internal image-reference" href="_images/cubic-50ms-50mbps-tcp-cwnd-ecn.png"><img alt="_images/cubic-50ms-50mbps-tcp-cwnd-ecn.png" src="_images/cubic-50ms-50mbps-tcp-cwnd-ecn.png" style="width: 368.8px; height: 276.8px;" /></a>
<figcaption>
<p><span class="caption-text">CUBIC cwnd evolution for 50ms/50Mbps bottleneck, with ECN</span><a class="headerlink" href="#id14" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>TCP ECN operation is tested in the ARED and RED tests that are documented in the traffic-control
module documentation.</p>
<p>Like DCTCP and TCP CUBIC, the ns-3 implementation of TCP BBR was validated
against the BBR implementation of Linux kernel 5.4 using Network Stack Tester
(NeST). NeST is a python package which allows the users to emulate kernel space
protocols using Linux network namespaces. Figure <a class="reference internal" href="#fig-ns3-bbr-vs-linux-bbr"><span class="std std-ref">Congestion window evolution: ns-3 BBR vs. Linux BBR (using NeST)</span></a>
compares the congestion window evolution between ns-3 and Linux for a single
flow operating over a 10 Mbps link with 10 ms base RTT and FIFO queue
discipline.</p>
<figure class="align-center" id="id15">
<span id="fig-ns3-bbr-vs-linux-bbr"></span><a class="reference internal image-reference" href="_images/ns3-bbr-vs-linux-bbr.png"><img alt="_images/ns3-bbr-vs-linux-bbr.png" src="_images/ns3-bbr-vs-linux-bbr.png" style="width: 512.0px; height: 384.0px;" /></a>
<figcaption>
<p><span class="caption-text">Congestion window evolution: ns-3 BBR vs. Linux BBR (using NeST)</span><a class="headerlink" href="#id15" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>It can be observed that the congestion window traces for ns-3 BBR closely
overlap with Linux BBR. The periodic drops in congestion window every 10
seconds depict the PROBE_RTT phase of the BBR algorithm. In this phase, BBR
algorithm keeps the congestion window fixed to 4 segments.</p>
<p>The example program, examples/tcp-bbr-example.cc has been used to obtain the
congestion window curve shown in Figure <a class="reference internal" href="#fig-ns3-bbr-vs-linux-bbr"><span class="std std-ref">Congestion window evolution: ns-3 BBR vs. Linux BBR (using NeST)</span></a>. The
detailed instructions to reproduce ns-3 plot and NeST plot can be found at:
<a class="reference external" href="https://github.com/mohittahiliani/BBR-Validation">https://github.com/mohittahiliani/BBR-Validation</a></p>
</section>
<section id="writing-a-new-congestion-control-algorithm">
<h5><span class="section-number">16.5.2.8. </span>Writing a new congestion control algorithm<a class="headerlink" href="#writing-a-new-congestion-control-algorithm" title="Link to this heading">¶</a></h5>
<p>Writing (or porting) a congestion control algorithms from scratch (or from
other systems) is a process completely separated from the internals of
TcpSocketBase.</p>
<p>All operations that are delegated to a congestion control are contained in
the class TcpCongestionOps. It mimics the structure tcp_congestion_ops of
Linux, and the following operations are defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">GetName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">GetSsThresh</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">IncreaseWindow</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">segmentsAcked</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">PktsAcked</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">segmentsAcked</span><span class="p">,</span><span class="k">const</span><span class="w"> </span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rtt</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpCongestionOps</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Fork</span><span class="p">();</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">CwndEvent</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">::</span><span class="n">TcpCaEvent_t</span><span class="w"> </span><span class="n">event</span><span class="p">);</span>
</pre></div>
</div>
<p>The most interesting methods to write are GetSsThresh and IncreaseWindow.
The latter is called when TcpSocketBase decides that it is time to increase
the congestion window. Much information is available in the Transmission
Control Block, and the method should increase cWnd and/or ssThresh based
on the number of segments acked.</p>
<p>GetSsThresh is called whenever the socket needs an updated value of the
slow start threshold. This happens after a loss; congestion control algorithms
are then asked to lower such value, and to return it.</p>
<p>PktsAcked is used in case the algorithm needs timing information (such as
RTT), and it is called each time an ACK is received.</p>
<p>CwndEvent is used in case the algorithm needs the state of socket during different
congestion window event.</p>
</section>
<section id="tcp-sack-and-non-sack">
<h5><span class="section-number">16.5.2.9. </span>TCP SACK and non-SACK<a class="headerlink" href="#tcp-sack-and-non-sack" title="Link to this heading">¶</a></h5>
<p>To avoid code duplication and the effort of maintaining two different versions
of the TCP core, namely RFC 6675 (TCP-SACK) and RFC 5681 (TCP congestion control),
we have merged RFC 6675 in the current code base. If the receiver supports the
option, the sender bases its retransmissions over the received SACK information.
However, in the absence of that option, the best it can do is to follow the RFC
5681 specification (on Fast Retransmit/Recovery) and employing NewReno
modifications in case of partial ACKs.</p>
<p>A similar concept is used in Linux with the function tcp_add_reno_sack.
Our implementation resides in the TcpTxBuffer class that implements a scoreboard
through two different lists of segments. TcpSocketBase actively uses the API
provided by TcpTxBuffer to query the scoreboard; please refer to the Doxygen
documentation (and to in-code comments) if you want to learn more about this
implementation.</p>
<p>For an academic peer-reviewed paper on the SACK implementation in ns-3,
please refer to <a class="reference external" href="https://dl.acm.org/citation.cfm?id=3067666">https://dl.acm.org/citation.cfm?id=3067666</a>.</p>
</section>
<section id="loss-recovery-algorithms">
<h5><span class="section-number">16.5.2.10. </span>Loss Recovery Algorithms<a class="headerlink" href="#loss-recovery-algorithms" title="Link to this heading">¶</a></h5>
<p>The following loss recovery algorithms are supported in ns-3 TCP.  The current
default (as of ns-3.32 release) is Proportional Rate Reduction (PRR), while
the default for ns-3.31 and earlier was Classic Recovery.</p>
<section id="classic-recovery">
<h6><span class="section-number">16.5.2.10.1. </span>Classic Recovery<a class="headerlink" href="#classic-recovery" title="Link to this heading">¶</a></h6>
<p>Classic Recovery refers to the combination of NewReno algorithm described in
RFC 6582 along with SACK based loss recovery algorithm mentioned in RFC 6675.
SACK based loss recovery is used when sender and receiver support SACK options.
In the case when SACK options are disabled, the NewReno modification handles
the recovery.</p>
<p>At the start of recovery phase the congestion window is reduced diffently for
NewReno and SACK based recovery. For NewReno the reduction is done as given below:</p>
<div class="math">
<p><img src="_images/math/373e3e96ffe78616f0be7b8f850cb0aab389a575.png" alt="cWnd = ssThresh"/></p>
</div><p>For SACK based recovery, this is done as follows:</p>
<div class="math">
<p><img src="_images/math/b03b1d0d3702d0b132fc8c5069257ee011cf3a76.png" alt="cWnd = ssThresh + (dupAckCount * segmentSize)"/></p>
</div><p>While in the recovery phase, the congestion window is inflated by segmentSize
on arrival of every ACK when NewReno is used. The congestion window is kept
same when SACK based loss recovery is used.</p>
</section>
<section id="proportional-rate-reduction">
<h6><span class="section-number">16.5.2.10.2. </span>Proportional Rate Reduction<a class="headerlink" href="#proportional-rate-reduction" title="Link to this heading">¶</a></h6>
<p>Proportional Rate Reduction (PRR) is a loss recovery algorithm described in
RFC 6937 and currently used in Linux. The design of PRR helps in avoiding
excess window adjustments and aims to keep the congestion window as close as
possible to ssThresh.</p>
<p>PRR updates the congestion window by comparing the values of bytesInFlight and
ssThresh. If the value of bytesInFlight is greater than ssThresh, congestion window
is updated as shown below:</p>
<div class="math">
<p><img src="_images/math/24b0a7d5c50f3b631649b066bb146be623028e07.png" alt="sndcnt = CEIL(prrDelivered * ssThresh / RecoverFS) - prrOut"/></p>
</div><div class="math">
<p><img src="_images/math/6dc20e3e199e3bd8ad3079d594497d37c9438a2f.png" alt="cWnd = pipe + sndcnt"/></p>
</div><p>where <code class="docutils literal notranslate"><span class="pre">RecoverFS</span></code> is the value of bytesInFlight at the start of recovery phase,
<code class="docutils literal notranslate"><span class="pre">prrDelivered</span></code> is the total bytes delivered during recovery phase,
<code class="docutils literal notranslate"><span class="pre">prrOut</span></code> is the total bytes sent during recovery phase and
<code class="docutils literal notranslate"><span class="pre">sndcnt</span></code> represents the number of bytes to be sent in response to each ACK.</p>
<p>Otherwise, the congestion window is updated by either using Conservative Reduction
Bound (CRB) or Slow Start Reduction Bound (SSRB) with SSRB being the default
Reduction Bound. Each Reduction Bound calculates a maximum data sending limit.
For CRB, the limit is calculated as shown below:</p>
<div class="math">
<p><img src="_images/math/94f0ecd5a3d49bd6ac2705c7a43cbbb89f8f4a8e.png" alt="limit = prrDelivered - prr out"/></p>
</div><p>For SSRB, it is calculated as:</p>
<div class="math">
<p><img src="_images/math/0239723cb98b74a08a1f279edf6d074749e623a3.png" alt="limit = MAX(prrDelivered - prrOut, DeliveredData) + MSS"/></p>
</div><p>where <code class="docutils literal notranslate"><span class="pre">DeliveredData</span></code> represents the total number of bytes delivered to the
receiver as indicated by the current ACK and <code class="docutils literal notranslate"><span class="pre">MSS</span></code> is the maximum segment size.</p>
<p>After limit calculation, the cWnd is updated as given below:</p>
<div class="math">
<p><img src="_images/math/62defe9fb8e84a0fedf0187e8673a726cdac6959.png" alt="sndcnt = MIN (ssThresh - pipe, limit)"/></p>
</div><div class="math">
<p><img src="_images/math/6dc20e3e199e3bd8ad3079d594497d37c9438a2f.png" alt="cWnd = pipe + sndcnt"/></p>
</div><p>More information (paper): <a class="reference external" href="https://dl.acm.org/citation.cfm?id=2068832">https://dl.acm.org/citation.cfm?id=2068832</a></p>
<p>More information (RFC): <a class="reference external" href="https://tools.ietf.org/html/rfc6937">https://tools.ietf.org/html/rfc6937</a></p>
</section>
</section>
<section id="adding-a-new-loss-recovery-algorithm-in-ns-3">
<h5><span class="section-number">16.5.2.11. </span>Adding a new loss recovery algorithm in ns-3<a class="headerlink" href="#adding-a-new-loss-recovery-algorithm-in-ns-3" title="Link to this heading">¶</a></h5>
<p>Writing (or porting) a loss recovery algorithms from scratch (or from
other systems) is a process completely separated from the internals of
TcpSocketBase.</p>
<p>All operations that are delegated to a loss recovery are contained in
the class TcpRecoveryOps and are given below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">GetName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnterRecovery</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">unAckDataCount</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">bool</span><span class="w"> </span><span class="n">isSackEnabled</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dupAckCount</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lastDeliveredBytes</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DoRecovery</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">unAckDataCount</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">bool</span><span class="w"> </span><span class="n">isSackEnabled</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dupAckCount</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lastDeliveredBytes</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">ExitRecovery</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesInFlight</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">UpdateBytesSent</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesSent</span><span class="p">);</span>
<span class="k">virtual</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpRecoveryOps</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Fork</span><span class="p">();</span>
</pre></div>
</div>
<p>EnterRecovery is called when packet loss is detected and recovery is triggered.
While in recovery phase, each time when an ACK arrives, DoRecovery is called which
performs the necessary congestion window changes as per the recovery algorithm.
ExitRecovery is called just prior to exiting recovery phase in order to perform the
required congestion window adjustments. UpdateBytesSent is used to keep track of
bytes sent and is called whenever a data packet is sent during recovery phase.</p>
</section>
<section id="delivery-rate-estimation">
<h5><span class="section-number">16.5.2.12. </span>Delivery Rate Estimation<a class="headerlink" href="#delivery-rate-estimation" title="Link to this heading">¶</a></h5>
<p>Current TCP implementation measures the approximate value of the delivery rate of
inflight data based on Delivery Rate Estimation.</p>
<p>As high level idea, keep in mind that the algorithm keeps track of 2 variables:</p>
<ol class="arabic simple">
<li><p><cite>delivered</cite>: Total amount of data delivered so far.</p></li>
<li><p><cite>deliveredStamp</cite>: Last time <cite>delivered</cite> was updated.</p></li>
</ol>
<p>When a packet is transmitted, the value of <cite>delivered (d0)</cite> and <cite>deliveredStamp (t0)</cite>
is stored in its respective TcpTxItem.</p>
<p>When an acknowledgement comes for this packet, the value of <cite>delivered</cite> and <cite>deliveredStamp</cite>
is updated to <cite>d1</cite> and <cite>t1</cite> in the same TcpTxItem.</p>
<p>After processing the acknowledgement, the rate sample is calculated and then passed
to a congestion avoidance algorithm:</p>
<div class="math">
<p><img src="_images/math/e637312558069d005426da7a12b385ca54b20742.png" alt="delivery_rate = (d1 - d0)/(t1 - t0)"/></p>
</div><p>The implementation to estimate delivery rate is a joint work between TcpTxBuffer and TcpRateOps.
For more information, please take a look at their Doxygen documentation.</p>
<p>The implementation follows the Internet draft (Delivery Rate Estimation):
<a class="reference external" href="https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00">https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00</a></p>
</section>
<section id="current-limitations">
<h5><span class="section-number">16.5.2.13. </span>Current limitations<a class="headerlink" href="#current-limitations" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>TcpCongestionOps interface does not contain every possible Linux operation</p></li>
</ul>
</section>
<section id="writing-tcp-tests">
<span id="id4"></span><h5><span class="section-number">16.5.2.14. </span>Writing TCP tests<a class="headerlink" href="#writing-tcp-tests" title="Link to this heading">¶</a></h5>
<p>The TCP subsystem supports automated test
cases on both socket functions and congestion control algorithms. To show
how to write tests for TCP, here we explain the process of creating a test
case that reproduces the <a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=1571">Bug #1571</a>.</p>
<p>The bug concerns the zero window situation, which happens when the receiver
cannot handle more data. In this case, it advertises a zero window, which causes
the sender to pause transmission and wait for the receiver to increase the
window.</p>
<p>The sender has a timer to periodically check the receiver’s window: however, in
modern TCP implementations, when the receiver has freed a “significant” amount
of data, the receiver itself sends an “active” window update, meaning that
the transmission could be resumed. Nevertheless, the sender timer is still
necessary because window updates can be lost.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>During the text, we will assume some knowledge about the general design
of the TCP test infrastructure, which is explained in detail into the
Doxygen documentation. As a brief summary, the strategy is to have a class
that sets up a TCP connection, and that calls protected members of itself.
In this way, subclasses can implement the necessary members, which will
be called by the main TcpGeneralTest class when events occur. For example,
after processing an ACK, the method ProcessedAck will be invoked. Subclasses
interested in checking some particular things which must have happened during
an ACK processing, should implement the ProcessedAck method and check
the interesting values inside the method. To get a list of available methods,
please check the Doxygen documentation.</p>
</div>
<p>We describe the writing of two test cases, covering both situations: the
sender’s zero-window probing and the receiver “active” window update. Our focus
will be on dealing with the reported problems, which are:</p>
<ul class="simple">
<li><p>an ns-3 receiver does not send “active” window update when its receive buffer
is being freed;</p></li>
<li><p>even if the window update is artificially crafted, the transmission does not
resume.</p></li>
</ul>
<p>However, other things should be checked in the test:</p>
<ul class="simple">
<li><p>Persistent timer setup</p></li>
<li><p>Persistent timer teardown if rWnd increases</p></li>
</ul>
<p>To construct the test case, one first derives from the TcpGeneralTest class:</p>
<p>The code is the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TcpZeroWindowTest</span><span class="o">::</span><span class="n">TcpZeroWindowTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">)</span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">TcpGeneralTest</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, one should define the general parameters for the TCP connection, which
will be one-sided (one node is acting as SENDER, while the other is acting as
RECEIVER):</p>
<ul class="simple">
<li><p>Application packet size set to 500, and 20 packets in total (meaning a stream
of 10k bytes)</p></li>
<li><p>Segment size for both SENDER and RECEIVER set to 500 bytes</p></li>
<li><p>Initial slow start threshold set to UINT32_MAX</p></li>
<li><p>Initial congestion window for the SENDER set to 10 segments (5000 bytes)</p></li>
<li><p>Congestion control: NewReno</p></li>
</ul>
<p>We have also to define the link properties, because the above definition does
not work for every combination of propagation delay and sender application behavior.</p>
<ul class="simple">
<li><p>Link one-way propagation delay: 50 ms</p></li>
<li><p>Application packet generation interval: 10 ms</p></li>
<li><p>Application starting time: 20 s after the starting point</p></li>
</ul>
<p>To define the properties of the environment (e.g. properties which should be
set before the object creation, such as propagation delay) one next implements
the method ConfigureEnvironment:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::ConfigureEnvironment</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TcpGeneralTest</span><span class="o">::</span><span class="n">ConfigureEnvironment</span><span class="p">();</span>
<span class="w">  </span><span class="n">SetAppPktCount</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="n">SetMTU</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="w">  </span><span class="n">SetTransmitStart</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
<span class="w">  </span><span class="n">SetPropagationDelay</span><span class="p">(</span><span class="n">MilliSeconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For other properties, set after the object creation, one can use
ConfigureProperties ().
The difference is that some values, such as initial congestion window
or initial slow start threshold, are applicable only to a single instance, not
to every instance we have. Usually, methods that requires an id and a value
are meant to be called inside ConfigureProperties (). Please see the Doxygen
documentation for an exhaustive list of the tunable properties.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::ConfigureProperties</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TcpGeneralTest</span><span class="o">::</span><span class="n">ConfigureProperties</span><span class="p">();</span>
<span class="w">  </span><span class="n">SetInitialCwnd</span><span class="p">(</span><span class="n">SENDER</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To see the default value for the experiment, please see the implementation of
both methods inside TcpGeneralTest class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If some configuration parameters are missing, add a method called
“SetSomeValue” which takes as input the value only (if it is meant to be
called inside ConfigureEnvironment) or the socket and the value (if it is
meant to be called inside ConfigureProperties).</p>
</div>
<p>To define a zero-window situation, we choose (by design) to initiate the connection
with a 0-byte rx buffer. This implies that the RECEIVER, in its first SYN-ACK,
advertises a zero window. This can be accomplished by implementing the method
CreateReceiverSocket, setting an Rx buffer value of 0 bytes (at line 6 of the
following code):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketMsgBase</span><span class="o">&gt;</span>
<span class="linenos"> 2</span><span class="n">TcpZeroWindowTest</span><span class="o">::</span><span class="n">CreateReceiverSocket</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span>
<span class="linenos"> 3</span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">TcpSocketMsgBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpGeneralTest</span><span class="o">::</span><span class="n">CreateReceiverSocket</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="linenos"> 5</span>
<span class="hll"><span class="linenos"> 6</span><span class="w">  </span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;RcvBufSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class="hll"><span class="linenos"> 7</span><span class="w">  </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
</span><span class="hll"><span class="linenos"> 8</span><span class="w">                      </span><span class="o">&amp;</span><span class="n">TcpZeroWindowTest</span><span class="o">::</span><span class="n">IncreaseBufSize</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
</span><span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">socket</span><span class="p">;</span>
<span class="linenos">11</span><span class="p">}</span>
</pre></div>
</div>
<p>Even so, to check the active window update, we should schedule an increase
of the buffer size. We do this at line 7 and 8, scheduling the function
IncreaseBufSize.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::IncreaseBufSize</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">SetRcvBufSize</span><span class="p">(</span><span class="n">RECEIVER</span><span class="p">,</span><span class="w"> </span><span class="mi">2500</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Which utilizes the SetRcvBufSize method to edit the RxBuffer object of the
RECEIVER. As said before, check the Doxygen documentation for class TcpGeneralTest
to be aware of the various possibilities that it offers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By design, we choose to maintain a close relationship between TcpSocketBase
and TcpGeneralTest: they are connected by a friendship relation. Since
friendship is not passed through inheritance, if one discovers that one
needs to access or to modify a private (or protected) member of TcpSocketBase,
one can do so by adding a method in the class TcpGeneralSocket. An example
of such method is SetRcvBufSize, which allows TcpGeneralSocket subclasses
to forcefully set the RxBuffer size.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpGeneralTest::SetRcvBufSize</span><span class="p">(</span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENDER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_senderSocket</span><span class="o">-&gt;</span><span class="n">SetRcvBufSize</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RECEIVER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_receiverSocket</span><span class="o">-&gt;</span><span class="n">SetRcvBufSize</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">NS_FATAL_ERROR</span><span class="p">(</span><span class="s">&quot;Not defined&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Next, we can start to follow the TCP connection:</p>
<ol class="arabic simple">
<li><p>At time 0.0 s the connection is opened sender side, with a SYN packet sent from
SENDER to RECEIVER</p></li>
<li><p>At time 0.05 s the RECEIVER gets the SYN and replies with a SYN-ACK</p></li>
<li><p>At time 0.10 s the SENDER gets the SYN-ACK and replies with a SYN.</p></li>
</ol>
<p>While the general structure is defined, and the connection is started,
we need to define a way to check the rWnd field on the segments. To this aim,
we can implement the methods Rx and Tx in the TcpGeneralTest subclass,
checking each time the actions of the RECEIVER and the SENDER. These methods are
defined in TcpGeneralTest, and they are attached to the Rx and Tx traces in the
TcpSocketBase. One should write small tests for every detail that one wants to ensure during the
connection (it will prevent the test from changing over the time, and it ensures
that the behavior will stay consistent through releases). We start by ensuring that
the first SYN-ACK has 0 as advertised window size:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::Tx</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TcpHeader</span><span class="w"> </span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RECEIVER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">RECEIVER TX &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">GetSize</span><span class="p">());</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                </span><span class="s">&quot;RECEIVER window size is not 0 in the SYN-ACK&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">....</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Practically, we are checking that every SYN packet sent by the RECEIVER has the
advertised window set to 0. The same thing is done also by checking, in the Rx
method, that each SYN received by SENDER has the advertised window set to 0.
Thanks to the log subsystem, we can print what is happening through messages.
If we run the experiment, enabling the logging, we can see the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>shell
gdb<span class="w"> </span>--args<span class="w"> </span>./build/utils/ns3-dev-test-runner-debug<span class="w"> </span>--test-name<span class="o">=</span>tcp-zero-window-test<span class="w"> </span>--stop-on-failure<span class="w"> </span>--fullness<span class="o">=</span>QUICK<span class="w"> </span>--assert-on-failure<span class="w"> </span>--verbose
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>run

<span class="m">0</span>.00s<span class="w"> </span>TcpZeroWindowTestSuite:Tx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.00<span class="w">  </span>SENDER<span class="w"> </span>TX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>SYN<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">0</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">36</span>
<span class="m">0</span>.05s<span class="w"> </span>TcpZeroWindowTestSuite:Rx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.05<span class="w">  </span>RECEIVER<span class="w"> </span>RX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>SYN<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">0</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionEnd<span class="o">(</span>EOL<span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">0</span>
<span class="m">0</span>.05s<span class="w"> </span>TcpZeroWindowTestSuite:Tx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.05<span class="w">  </span>RECEIVER<span class="w"> </span>TX<span class="w"> </span><span class="m">4477</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">49153</span><span class="w"> </span><span class="o">[</span>SYN<span class="p">|</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">0</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">50</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">36</span>
<span class="m">0</span>.10s<span class="w"> </span>TcpZeroWindowTestSuite:Rx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.10<span class="w">  </span>SENDER<span class="w"> </span>RX<span class="w"> </span><span class="m">4477</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">49153</span><span class="w"> </span><span class="o">[</span>SYN<span class="p">|</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">0</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">0</span><span class="w"> </span>ns3::TcpOptionWinScale<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">50</span><span class="p">;</span><span class="m">0</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionEnd<span class="o">(</span>EOL<span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">0</span>
<span class="m">0</span>.10s<span class="w"> </span>TcpZeroWindowTestSuite:Tx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.10<span class="w">  </span>SENDER<span class="w"> </span>TX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">100</span><span class="p">;</span><span class="m">50</span><span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">32</span>
<span class="m">0</span>.15s<span class="w"> </span>TcpZeroWindowTestSuite:Rx<span class="o">()</span>:<span class="w"> </span><span class="m">0</span>.15<span class="w">  </span>RECEIVER<span class="w"> </span>RX<span class="w"> </span><span class="m">49153</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">4477</span><span class="w"> </span><span class="o">[</span>ACK<span class="o">]</span><span class="w"> </span><span class="nv">Seq</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Ack</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">Win</span><span class="o">=</span><span class="m">32768</span><span class="w"> </span>ns3::TcpOptionTS<span class="o">(</span><span class="m">100</span><span class="p">;</span><span class="m">50</span><span class="o">)</span><span class="w"> </span>ns3::TcpOptionEnd<span class="o">(</span>EOL<span class="o">)</span><span class="w"> </span>size<span class="w"> </span><span class="m">0</span>
<span class="o">(</span>...<span class="o">)</span>
</pre></div>
</div>
<p>The output is cut to show the threeway handshake. As we can see from the headers,
the rWnd of RECEIVER is set to 0, and thankfully our tests are not failing.
Now we need to test for the persistent timer, which should be started by
the SENDER after it receives the SYN-ACK. Since the Rx method is called before
any computation on the received packet, we should utilize another method, namely
ProcessedAck, which is the method called after each processed ACK. In the
following, we show how to check if the persistent event is running after the
processing of the SYN-ACK:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::ProcessedAck</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tcb</span><span class="p">,</span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENDER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetFlags</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TcpHeader</span><span class="o">::</span><span class="n">SYN</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">EventId</span><span class="w"> </span><span class="n">persistentEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetPersistentEvent</span><span class="p">(</span><span class="n">SENDER</span><span class="p">);</span>
<span class="w">          </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">persistentEvent</span><span class="p">.</span><span class="n">IsRunning</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                                </span><span class="s">&quot;Persistent event not started&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Since we programmed the increase of the buffer size after 10 simulated seconds,
we expect the persistent timer to fire before any rWnd changes. When it fires,
the SENDER should send a window probe, and the receiver should reply reporting
again a zero window situation. At first, we investigates on what the sender sends:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="linenos"> 1</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">6.0</span><span class="p">)</span>
</span><span class="linenos"> 2</span><span class="w">  </span><span class="p">{</span>
<span class="linenos"> 3</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">GetSize</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">GetSerializedSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos"> 4</span><span class="w">                          </span><span class="s">&quot;Data packet sent anyway&quot;</span><span class="p">);</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="p">}</span>
<span class="hll"><span class="linenos"> 6</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">6.0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
</span><span class="hll"><span class="linenos"> 7</span><span class="w">         </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">7.0</span><span class="p">)</span>
</span><span class="linenos"> 8</span><span class="w">  </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_zeroWindowProbe</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Sent another probe&quot;</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="hll"><span class="linenos">11</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">m_zeroWindowProbe</span><span class="p">)</span>
</span><span class="linenos">12</span><span class="w">      </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">        </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">GetSize</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">GetSerializedSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="linenos">14</span><span class="w">                              </span><span class="s">&quot;Data packet sent instead of window probe&quot;</span><span class="p">);</span>
<span class="linenos">15</span><span class="w">        </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetSequenceNumber</span><span class="p">(),</span><span class="w"> </span><span class="n">SequenceNumber32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="linenos">16</span><span class="w">                              </span><span class="s">&quot;Data packet sent instead of window probe&quot;</span><span class="p">);</span>
<span class="linenos">17</span><span class="w">        </span><span class="n">m_zeroWindowProbe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos">18</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">19</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>We divide the events by simulated time. At line 1, we check everything that
happens before the 6.0 seconds mark; for instance, that no data packets are sent,
and that the state remains OPEN for both sender and receiver.</p>
<p>Since the persist timeout is initialized at 6 seconds (exercise left for the
reader: edit the test, getting this value from the Attribute system), we need
to check (line 6) between 6.0 and 7.0 simulated seconds that the probe is sent.
Only one probe is allowed, and this is the reason for the check at line 11.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">6.0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="linenos">2</span><span class="w">    </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">7.0</span><span class="p">)</span>
<span class="linenos">3</span><span class="w">  </span><span class="p">{</span>
<span class="linenos">4</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetSequenceNumber</span><span class="p">(),</span><span class="w"> </span><span class="n">SequenceNumber32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="linenos">5</span><span class="w">                          </span><span class="s">&quot;Data packet sent instead of window probe&quot;</span><span class="p">);</span>
<span class="hll"><span class="linenos">6</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">7</span><span class="w">                          </span><span class="s">&quot;No zero window advertised by RECEIVER&quot;</span><span class="p">);</span>
</span><span class="linenos">8</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>For the RECEIVER, the interval between 6 and 7 seconds is when the zero-window
segment is sent.</p>
<p>Other checks are redundant; the safest approach is to deny any other packet
exchange between the 7 and 10 seconds mark.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">7.0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">         </span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">10.0</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">NS_FATAL_ERROR</span><span class="p">(</span><span class="s">&quot;No packets should be sent before the window update&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>The state checks are performed at the end of the methods, since they are valid
in every condition:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">GetCongStateFrom</span><span class="p">(</span><span class="n">GetTcb</span><span class="p">(</span><span class="n">SENDER</span><span class="p">)),</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">::</span><span class="n">CA_OPEN</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;Sender State is not OPEN&quot;</span><span class="p">);</span>
<span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">GetCongStateFrom</span><span class="p">(</span><span class="n">GetTcb</span><span class="p">(</span><span class="n">RECEIVER</span><span class="p">)),</span><span class="w"> </span><span class="n">TcpSocketState</span><span class="o">::</span><span class="n">CA_OPEN</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;Receiver State is not OPEN&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, the interesting part in the Tx method is to check that after the 10.0
seconds mark (when the RECEIVER sends the active window update) the value of
the window should be greater than zero (and precisely, set to 2500):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">2500</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;Receiver window not updated&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>To be sure that the sender receives the window update, we can use the Rx
method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Simulator</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">GetSeconds</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">)</span>
<span class="linenos">2</span><span class="w">  </span><span class="p">{</span>
<span class="linenos">3</span><span class="w">    </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">GetWindowSize</span><span class="p">(),</span><span class="w"> </span><span class="mi">2500</span><span class="p">,</span>
<span class="linenos">4</span><span class="w">                          </span><span class="s">&quot;Receiver window not updated&quot;</span><span class="p">);</span>
<span class="hll"><span class="linenos">5</span><span class="w">    </span><span class="n">m_windowUpdated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</span><span class="linenos">6</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>We check every packet after the 10 seconds mark to see if it has the
window updated. At line 5, we also set to true a boolean variable, to check
that we effectively reach this test.</p>
<p>Last but not least, we implement also the NormalClose() method, to check that
the connection ends with a success:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::NormalClose</span><span class="p">(</span><span class="n">SocketWho</span><span class="w"> </span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENDER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_senderFinished</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">who</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RECEIVER</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">m_receiverFinished</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The method is called only if all bytes are transmitted successfully. Then, in
the method FinalChecks(), we check all variables, which should be true (which
indicates that we have perfectly closed the connection).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">TcpZeroWindowTest::FinalChecks</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_zeroWindowProbe</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Zero window probe not sent&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_windowUpdated</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Window has not updated during the connection&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_senderFinished</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Connection not closed successfully(SENDER)&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">NS_TEST_ASSERT_MSG_EQ</span><span class="p">(</span><span class="n">m_receiverFinished</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;Connection not closed successfully(RECEIVER)&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To run the test, the usual way is</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./test.py<span class="w"> </span>-s<span class="w"> </span>tcp-zero-window-test

PASS:<span class="w"> </span>TestSuite<span class="w"> </span>tcp-zero-window-test
<span class="m">1</span><span class="w"> </span>of<span class="w"> </span><span class="m">1</span><span class="w"> </span>tests<span class="w"> </span>passed<span class="w"> </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>passed,<span class="w"> </span><span class="m">0</span><span class="w"> </span>skipped,<span class="w"> </span><span class="m">0</span><span class="w"> </span>failed,<span class="w"> </span><span class="m">0</span><span class="w"> </span>crashed,<span class="w"> </span><span class="m">0</span><span class="w"> </span>valgrind<span class="w"> </span>errors<span class="o">)</span>
</pre></div>
</div>
<p>To see INFO messages, use a combination of ./ns3 shell and gdb (really useful):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>shell<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>gdb<span class="w"> </span>--args<span class="w"> </span>./build/utils/ns3-dev-test-runner-debug<span class="w"> </span>--test-name<span class="o">=</span>tcp-zero-window-test<span class="w"> </span>--stop-on-failure<span class="w"> </span>--fullness<span class="o">=</span>QUICK<span class="w"> </span>--assert-on-failure<span class="w"> </span>--verbose
</pre></div>
</div>
<p>and then, hit “Run”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This code magically runs without any reported errors; however, in real cases,
when you discover a bug you should expect the existing test to fail (this
could indicate a well-written test and a bad-written model, or a bad-written
test; hopefully the first situation). Correcting bugs is an iterative
process. For instance, commits created to make this test case running without
errors are 11633:6b74df04cf44, (others to be merged).</p>
</div>
</section>
</section>
</section>
<span id="document-udp"></span><section id="udp-model-in-ns-3">
<h3><span class="section-number">16.6. </span>UDP model in ns-3<a class="headerlink" href="#udp-model-in-ns-3" title="Link to this heading">¶</a></h3>
<p>This chapter describes the UDP model available in <em>ns-3</em>.</p>
<section id="generic-support-for-udp">
<h4><span class="section-number">16.6.1. </span>Generic support for UDP<a class="headerlink" href="#generic-support-for-udp" title="Link to this heading">¶</a></h4>
<p><em>ns-3</em> supports a native implementation of UDP. It provides a connectionless,
unreliable datagram packet service. Packets may be reordered or duplicated before
they arrive. UDP calculates and checks checksums to catch transmission errors.</p>
<p>This implementation inherits from a few common header classes in the <code class="docutils literal notranslate"><span class="pre">src/network</span></code>
directory, so that user code can swap out implementations with minimal changes to
the scripts.</p>
<p>Here are the important abstract base classes:</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocket</span></code>: This is defined in:
<code class="docutils literal notranslate"><span class="pre">src/internet/model/udp-socket.{cc,h}</span></code>
This is an abstract base class of all UDP sockets. This class exists solely
for hosting <code class="docutils literal notranslate"><span class="pre">UdpSocket</span></code> attributes that can be reused across different
implementations, and for declaring UDP-specific multicast API.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocketImpl</span></code>: This class subclasses <code class="docutils literal notranslate"><span class="pre">UdpSocket</span></code>, and
provides a socket interface to ns-3’s implementation of UDP.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocketFactory</span></code>: This is used by the layer-4 protocol
instance to create UDP sockets.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpSocketFactoryImpl</span></code>: This class is derived from <code class="docutils literal notranslate"><span class="pre">SocketFactory</span></code>
and implements the API for creating UDP sockets.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpHeader</span></code>: This class contains fields corresponding to those
in a network UDP header (port numbers, payload size, checksum) as well as methods
for serialization to and deserialization from a byte buffer.</p></li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UdpL4Protocol</span></code>: This is a subclass of <code class="docutils literal notranslate"><span class="pre">IpL4Protocol</span></code> and
provides an implementation of the UDP protocol.</p></li>
</ul>
</section>
<section id="ns-3-udp">
<h4><span class="section-number">16.6.2. </span>ns-3 UDP<a class="headerlink" href="#ns-3-udp" title="Link to this heading">¶</a></h4>
<p>This is an implementation of the User Datagram Protocol described in RFC 768.
UDP uses a simple connectionless communication model with a minimum of protocol
mechanism. The implementation provides checksums for data integrity, and port
numbers for addressing different functions at the source and destination of the
datagram. It has no handshaking dialogues, and thus exposes the user’s data to
any unreliability of the underlying network. There is no guarantee of data delivery,
ordering, or duplicate protection.</p>
<section id="usage">
<h5><span class="section-number">16.6.2.1. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h5>
<p>In many cases, usage of UDP is set at the application layer by telling
the <em>ns-3</em> application which kind of socket factory to use.</p>
<p>Using the helper functions defined in <code class="docutils literal notranslate"><span class="pre">src/applications/helper</span></code>, here
is how one would create a UDP receiver:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a packet sink on the receiver</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50000</span><span class="p">;</span>
<span class="n">Address</span><span class="w"> </span><span class="nf">sinkLocalAddress</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="n">port</span><span class="p">));</span>
<span class="n">PacketSinkHelper</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">(</span><span class="s">&quot;ns3::UdpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sinkLocalAddress</span><span class="p">);</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">sinkApp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinkHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">serverNode</span><span class="p">);</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">sinkApp</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Similarly, the below snippet configures OnOffApplication traffic source to use
UDP:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the OnOff applications to send data to the UDP receiver</span>
<span class="n">OnOffHelper</span><span class="w"> </span><span class="n">clientHelper</span><span class="p">(</span><span class="s">&quot;ns3::UdpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Address</span><span class="p">());</span>
<span class="n">clientHelper</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Remote&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">remoteAddress</span><span class="p">);</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">clientApps</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="n">clientHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">clientNode</span><span class="p">);</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
<span class="n">clientApps</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">9.0</span><span class="p">));</span>
</pre></div>
</div>
<p>For users who wish to have a pointer to the actual socket(so that
socket operations like <code class="docutils literal notranslate"><span class="pre">Bind()</span></code>, setting socket options, etc. can be
done on a per-socket basis), UDP sockets can be created by using the
<code class="docutils literal notranslate"><span class="pre">Socket::CreateSocket()</span></code> method as given below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">internet</span><span class="p">;</span>
<span class="n">internet</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">SocketFactory</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socketFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">UdpSocketFactory</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socketFactory</span><span class="o">-&gt;</span><span class="n">CreateSocket</span><span class="p">();</span>
<span class="n">socket</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">InetSocketAddress</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="o">::</span><span class="n">GetAny</span><span class="p">(),</span><span class="w"> </span><span class="mi">80</span><span class="p">));</span>
</pre></div>
</div>
<p>Once a UDP socket is created, we do not need an explicit connection setup before
sending and receiving data. Being a connectionless protocol, all we need to do
is to create a socket and bind it to a known port. For a client, simply create a
socket and start sending data. The <code class="docutils literal notranslate"><span class="pre">Bind()</span></code> call allows an application to specify
a port number and an address on the local machine. It allocates a local IPv4
endpoint for this socket.</p>
<p>At the end of data transmission, the socket is closed using the <code class="docutils literal notranslate"><span class="pre">Socket::Close()</span></code>.
It returns a 0 on success and -1 on failure.</p>
<p>Please note that applications usually create the sockets automatically. Please
refer to the source code of your preferred application to discover how and
when it creates the socket.</p>
<section id="udp-socket-interaction-and-interface-with-application-layer">
<h6><span class="section-number">16.6.2.1.1. </span>UDP Socket interaction and interface with Application layer<a class="headerlink" href="#udp-socket-interaction-and-interface-with-application-layer" title="Link to this heading">¶</a></h6>
<p>The following is the description of the public interface of the UDP socket,
and how the interface is used to interact with the socket itself.</p>
<p><strong>Socket APIs for UDP connections</strong>:</p>
<dl class="simple">
<dt><em>Connect()</em></dt><dd><p>This is called when <code class="docutils literal notranslate"><span class="pre">Send()</span></code> is used instead of <code class="docutils literal notranslate"><span class="pre">SendTo()</span></code> by the user.
It sets the address of the remote endpoint which is used by <code class="docutils literal notranslate"><span class="pre">Send()</span></code>. If the
remote address is valid, this method makes a callback to <em>ConnectionSucceeded</em>.</p>
</dd>
<dt><em>Bind()</em></dt><dd><p>Bind the socket to an address, or to a general endpoint. A general endpoint
is an endpoint with an ephemeral port allocation (that is, a random port
allocation) on the 0.0.0.0 IP address. For instance, in current applications,
data senders usually bind automatically after a <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> over a random
port. Consequently, the connection will start from this random port towards
the well-defined port of the receiver. The IP 0.0.0.0 is then translated by
lower layers into the real IP of the device.</p>
</dd>
<dt><em>Bind6()</em></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">Bind()</span></code>, but for IPv6.</p>
</dd>
<dt><em>BindToNetDevice()</em></dt><dd><p>Bind the socket to the specified <code class="docutils literal notranslate"><span class="pre">NetDevice</span></code>. If set on a socket, this option
will force packets to leave the bound device regardless of the device that IP
routing would naturally choose. In the receive direction, only packets received
from the bound interface will be delivered.</p>
</dd>
<dt><em>ShutdownSend()</em></dt><dd><p>Signals the termination of send, or in other words, prevents data from being added
to the buffer.</p>
</dd>
<dt><em>Recv()</em></dt><dd><p>Grabs data from the UDP socket and forwards it to the application layer. If no
data is present (i.e. <code class="docutils literal notranslate"><span class="pre">m_deliveryQueue.empty()</span></code> returns 0), an empty packet is
returned.</p>
</dd>
<dt><em>RecvFrom()</em></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">Recv()</span></code>, but with the source address as parameter.</p>
</dd>
<dt><em>SendTo()</em></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">SendTo()</span></code> API is the UDP counterpart of the TCP API <code class="docutils literal notranslate"><span class="pre">Send()</span></code>. It
additionally specifies the address to which the message is to be sent
because no prior connection is established in UDP communication. It returns
the number of bytes sent or -1 in case of failure.</p>
</dd>
<dt><em>Close()</em></dt><dd><p>The close API closes a socket and terminates the connection. This
results in freeing all the data structures previously allocated.</p>
</dd>
</dl>
<hr class="docutils" />
<p><strong>Public callbacks</strong></p>
<p>These callbacks are called by the UDP socket to notify the application of
interesting events. We will refer to these with the protected name used in
<code class="docutils literal notranslate"><span class="pre">socket.h</span></code>, but we will provide the API function to set the pointers to these
callback as well.</p>
<dl class="simple">
<dt><em>NotifyConnectionSucceeded</em>: <em>SetConnectCallback</em>, 1st argument</dt><dd><p>Called when the <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> succeeds and the remote address is validated.</p>
</dd>
<dt><em>NotifyConnectionFailed</em>: <em>SetConnectCallback</em>, 2nd argument</dt><dd><p>Called in <code class="docutils literal notranslate"><span class="pre">Connect()</span></code> when the the remote address validation fails.</p>
</dd>
<dt><em>NotifyDataSent</em>: <em>SetDataSentCallback</em></dt><dd><p>The socket notifies the application that some bytes have been transmitted at
the IP layer. These bytes could still be lost in the node (traffic control
layer) or in the network.</p>
</dd>
<dt><em>NotifySend</em>: <em>SetSendCallback</em></dt><dd><p>Invoked to get the space available in the tx buffer when a packet (that carries
data) is sent.</p>
</dd>
<dt><em>NotifyDataRecv</em>: <em>SetRecvCallback</em></dt><dd><p>Called when the socket receives a packet (that carries data) in the receiver
buffer.</p>
</dd>
</dl>
</section>
</section>
<section id="validation">
<h5><span class="section-number">16.6.2.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h5>
<p>The following test cases have been provided for UDP implementation in the
<code class="docutils literal notranslate"><span class="pre">src/internet/test/udp-test.cc</span></code> file.</p>
<ul class="simple">
<li><p><strong>UdpSocketImplTest:</strong> Checks data received via UDP Socket over IPv4.</p></li>
<li><p><strong>UdpSocketLoopbackTest:</strong> Checks data received via UDP Socket Loopback over IPv4.</p></li>
<li><p><strong>Udp6SocketImplTest :</strong> Checks data received via UDP Socket over IPv6.</p></li>
<li><p><strong>Udp6SocketLoopbackTest :</strong> Checks data received via UDP Socket Loopback over IPv6 Test.</p></li>
</ul>
</section>
<section id="limitations">
<h5><span class="section-number">16.6.2.3. </span>Limitations<a class="headerlink" href="#limitations" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>UDP_CORK is presently not the part of this implementation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NotifyNormalClose</span></code>, <code class="docutils literal notranslate"><span class="pre">NotifyErrorClose</span></code>, <code class="docutils literal notranslate"><span class="pre">NotifyConnectionRequest</span></code> and
<code class="docutils literal notranslate"><span class="pre">NotifyNewConnectionCreated</span></code> socket API callbacks are not supported.</p></li>
</ul>
</section>
</section>
</section>
</div>
</section>
<span id="document-internet-apps"></span><section id="internet-applications-module-documentation">
<h2><span class="section-number">17. </span>Internet Applications Module Documentation<a class="headerlink" href="#internet-applications-module-documentation" title="Link to this heading">¶</a></h2>
<p>The goal of this module is to hold all the Internet-specific applications,
and most notably some very specific applications (e.g., ping) or daemons (e.g., radvd).  Other non-Internet-specific applications such as packet generators
are contained in other modules.</p>
<p>The source code for the new module lives in the directory <code class="docutils literal notranslate"><span class="pre">src/internet-apps</span></code>.</p>
<p>Each application has its own goals, limitations and scope, which are briefly explained
in the following.</p>
<p>All the applications are extensively used in the top-level <code class="docutils literal notranslate"><span class="pre">examples</span></code>
directories. The users are encouraged to check the scripts therein to have a
clear overview of the various options and usage tricks.</p>
<section id="ping">
<h3><span class="section-number">17.1. </span>Ping<a class="headerlink" href="#ping" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Ping</span></code> application supports both IPv4 and IPv6 and replaces earlier
<em>ns-3</em> implementations called <code class="docutils literal notranslate"><span class="pre">v4Ping</span></code> and <code class="docutils literal notranslate"><span class="pre">Ping6</span></code> that were
address family dependent.  <code class="docutils literal notranslate"><span class="pre">Ping</span></code> was introduced in the ns-3.38 release cycle.</p>
<section id="model-description">
<h4><span class="section-number">17.1.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>This application behaves similarly to the Unix <code class="docutils literal notranslate"><span class="pre">ping</span></code> application, although
with fewer options supported.  <code class="docutils literal notranslate"><span class="pre">Ping</span></code> sends ICMP Echo Request messages to
a remote address, and collects statistics and reports on the ICMP Echo
Reply responses that are received.  The application can be used to send
ICMP echo requests to unicast, broadcast, and multicast IPv4 and IPv6
addresses.  The application can produce a verbose output similar to the real
application, and can also export statistics and results via trace sources.
The following can be controlled via attributes of this class:</p>
<ul class="simple">
<li><p>Destination address</p></li>
<li><p>Local address (sender address)</p></li>
<li><p>Packet size (default 56 bytes)</p></li>
<li><p>Packet interval  (default 1 second)</p></li>
<li><p>Timeout value (default 1 second)</p></li>
<li><p>The count, or maximum number of packets to send</p></li>
<li><p>Verbose mode</p></li>
</ul>
<p>In practice, the real-world <code class="docutils literal notranslate"><span class="pre">ping</span></code> application behavior varies slightly
depending on the operating system (Linux, macOS, Windows, etc.).  Most
implementations also support a very large number of options.  The <em>ns-3</em>
model is intended to handle the most common use cases of testing for
reachability.</p>
<section id="design">
<h5><span class="section-number">17.1.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>The aim of <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Ping</span></code> application is to mimic the built-in application
found in most operating systems.  In practice, <code class="docutils literal notranslate"><span class="pre">ping</span></code> is usually used to
check reachability of a destination, but additional options have been
added over time and the tool can be used in different ways to gather
statistics about reachability and round trip times (RTT).  Since <em>ns-3</em> is
mainly used for performance studies and not for operational forensics,
some options of real <code class="docutils literal notranslate"><span class="pre">ping</span></code> implementations may not be useful for simulations.
However, the <em>ns-3</em> application can deliver output and RTT samples similar
to how the real application operates.</p>
<p><code class="docutils literal notranslate"><span class="pre">Ping</span></code> is usually installed on a source node and does not require any
<em>ns-3</em> application installation on the destination node.  <code class="docutils literal notranslate"><span class="pre">Ping</span></code> is an
<code class="docutils literal notranslate"><span class="pre">Application</span></code> that can be started and stopped using the base class
Application APIs.</p>
</section>
<section id="behavior">
<h5><span class="section-number">17.1.1.2. </span>Behavior<a class="headerlink" href="#behavior" title="Link to this heading">¶</a></h5>
<p>The behavior of real <code class="docutils literal notranslate"><span class="pre">ping</span></code> applications varies across operating systems.  For
example, on Linux, the first ICMP sequence number sent is one, while on
macOS, the first sequence number is zero.  The behavior when pinging
non-existent hosts also can differ (Linux is quiet while macOS is verbose).
Windows and other operating systems like Cisco routers also can behave
slightly differently.</p>
<p>This implementation tries to generally follow the Linux behavior, except
that it will print out a verbose ‘request timed out’ message when an
echo request is sent and no reply arrives in a timely manner.  The timeout
value (time that ping waits for a response to return) defaults to one
second, but once there are RTT samples available, the timeout is set
to twice the observed RTT.  In contrast to Linux (but aligned with macOS),
the first sequence number sent is zero.</p>
</section>
<section id="scope-and-limitations">
<h5><span class="section-number">17.1.1.3. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">ping</span></code> implementations have a lot of command-line options.  The <em>ns-3</em>
implementation only supports a few of the most commonly-used options;
patches to add additional options would be welcome.</p>
<p>At the present time, fragmentation (sending an ICMP Echo Request larger
than the path MTU) is not handled correctly during Echo Response reassembly.</p>
</section>
</section>
<section id="usage">
<h4><span class="section-number">17.1.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>Users may create and install <code class="docutils literal notranslate"><span class="pre">Ping</span></code> applications on nodes on a one-by-one
basis using <code class="docutils literal notranslate"><span class="pre">CreateObject</span></code> or by using the <code class="docutils literal notranslate"><span class="pre">PingHelper</span></code>.  For
<code class="docutils literal notranslate"><span class="pre">CreateObject</span></code>, the following can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ping</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Ping</span><span class="o">&gt;</span><span class="w"> </span><span class="p">();</span>
<span class="c1">// Configure ping as needed...</span>
<span class="n">n</span><span class="o">-&gt;</span><span class="n">AddApplication</span><span class="w"> </span><span class="p">(</span><span class="n">ping</span><span class="p">);</span>
</pre></div>
</div>
<p>Users should be aware of how this application stops.  For most <em>ns-3</em>
applications, <code class="docutils literal notranslate"><span class="pre">StopApplication()</span></code> should be called before the simulation
is stopped.  If the <code class="docutils literal notranslate"><span class="pre">Count</span></code> attribute of this application is set to
a positive integer, the application will stop (and a report will be printed)
either when <code class="docutils literal notranslate"><span class="pre">Count</span></code> responses have been received or when <code class="docutils literal notranslate"><span class="pre">StopApplication()</span></code>
is called, whichever comes first.  If <code class="docutils literal notranslate"><span class="pre">Count</span></code> is zero, meaning infinite
pings, then <code class="docutils literal notranslate"><span class="pre">StopApplication()</span></code> should be used to eventually stop the
application and generate the report.  If <code class="docutils literal notranslate"><span class="pre">StopApplication()</span></code> is called
while a packet (echo request) is in-flight, the response cannot be
received and the packet will be treated as lost in the report– real
ping applications work this way as well.  To avoid this, it is recommended
to call <code class="docutils literal notranslate"><span class="pre">StopApplication()</span></code> at a time when an Echo Request or Echo Response
packet is not expected to be in flight.</p>
<section id="helpers">
<h5><span class="section-number">17.1.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">PingHelper</span></code> supports the typical <code class="docutils literal notranslate"><span class="pre">Install</span></code> usage pattern in <em>ns-3</em>.
The following sample code is from the program <code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-validation.cc</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PingHelper</span><span class="w"> </span><span class="n">pingHelper</span><span class="p">(</span><span class="n">Ipv4Address</span><span class="p">(</span><span class="s">&quot;192.168.1.2&quot;</span><span class="p">));</span>
<span class="n">pingHelper</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Interval&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">pingInterval</span><span class="p">));</span>
<span class="n">pingHelper</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;Size&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="n">pingSize</span><span class="p">));</span>
<span class="n">pingHelper</span><span class="p">.</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;VerboseMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">EnumValue</span><span class="p">(</span><span class="n">Ping</span><span class="o">::</span><span class="n">VerboseMode</span><span class="o">::</span><span class="n">SILENT</span><span class="p">));</span>
<span class="n">ApplicationContainer</span><span class="w"> </span><span class="n">pingContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pingHelper</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">pingServer</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Ping</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pingContainer</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">Ping</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">ping</span><span class="o">-&gt;</span><span class="n">TraceConnectWithoutContext</span><span class="p">(</span><span class="s">&quot;Rtt&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBoundCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TracePingRtt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pingOfStream</span><span class="p">));</span>
<span class="n">pingContainer</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">pingContainer</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span><span class="n">stopTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>The first statement sets the remote address (destination) for all application
instances created with this helper.  The second and third statements perform
further configuration.  The fourth statement configures the verbosity to
be totally silent.  The fifth statement is a typical <code class="docutils literal notranslate"><span class="pre">Install()</span></code>
method that returns an ApplicationContainer (in this case, of size 1).
The sixth and seventh statements fetch the application instance created and
configure a trace sink (<code class="docutils literal notranslate"><span class="pre">TracePingRtt</span></code>) for the <code class="docutils literal notranslate"><span class="pre">Rtt</span></code> trace source.
The eighth and ninth statements configure the start and stop time,
respectively.</p>
<p>The helper is most useful when there are many similarly configured
applications to install on a collection of nodes (a NodeContainer).
When there is only one Ping application to configure in a program,
or when the configuration between different instances is different,
it may be more straightforward to directly create the Ping applications
without the PingHelper.</p>
</section>
<section id="attributes">
<h5><span class="section-number">17.1.2.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The following attributes can be configured:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Destination</span></code>: The IPv4 or IPv6 address of the machine we want to ping</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VerboseMode</span></code>: Configure verbose, quiet, or silent output</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Interval</span></code>: Time interval between sending each packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The number of data bytes to be sent, before ICMP and IP headers are added</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Count</span></code>: The maximum number of packets the application will send</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InterfaceAddress</span></code>: Local address of the sender</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Timeout</span></code>: Time to wait for response if no RTT samples are available</p></li>
</ul>
</section>
<section id="output">
<h5><span class="section-number">17.1.2.3. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>If <code class="docutils literal notranslate"><span class="pre">VerboseMode</span></code> mode is set to <code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>, ping will output the results of
ICMP Echo Reply responses to <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> output stream.  If the mode is
set to <code class="docutils literal notranslate"><span class="pre">QUIET</span></code>, only the initial statement and summary are printed.  If the
mode is set to <code class="docutils literal notranslate"><span class="pre">SILENT</span></code>, no output will be printed to <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>.  These
behavioral differences can be seen with the <code class="docutils literal notranslate"><span class="pre">ping-example.cc</span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>--no-build<span class="w"> </span><span class="s1">&#39;ping-example --ns3::Ping::VerboseMode=Verbose&#39;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>--no-build<span class="w"> </span><span class="s1">&#39;ping-example --ns3::Ping::VerboseMode=Quiet&#39;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>--no-build<span class="w"> </span><span class="s1">&#39;ping-example --ns3::Ping::VerboseMode=Silent&#39;</span>
</pre></div>
</div>
<p>Additional output can be gathered by using the four trace sources provided
by Ping:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tx</span></code>: This trace executes when a new packet is sent, and returns the sequence number and full packet (including ICMP header).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Rtt</span></code>:  Each time an ICMP echo reply is received, this trace is called and reports the sequence number and RTT.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Drop</span></code>:  If an ICMP error is returned instead of an echo reply, the sequence number and reason for reported drop are returned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Report</span></code>: When ping completes and exits, it prints output statistics to the terminal.  These values are copied to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">PingReport</span></code> and returned in this trace source.</p></li>
</ul>
</section>
<section id="example">
<h5><span class="section-number">17.1.2.4. </span>Example<a class="headerlink" href="#example" title="Link to this heading">¶</a></h5>
<p>A basic <code class="docutils literal notranslate"><span class="pre">ping-example.cc</span></code> program is provided to highlight the following
usage.  The topology has three nodes interconnected by two point-to-point links.
Each link has 5 ms one-way delay, for a round-trip propagation delay
of 20 ms.  The transmission rate on each link is 100 Mbps.  The routing
between links is enabled by ns-3’s NixVector routing.</p>
<p>By default, this program will send 5 pings from node A to node C.
When using the default IPv6, the output will look like this:</p>
<p>The example program will also produce four pcap traces (one for each
NetDevice in the scenario) that can be viewed using tcpdump or Wireshark.</p>
<p>Other program options include options to change the destination and
source addresses, number of packets (count), packet size, interval,
and whether to enable logging (if logging is enabled in the build).
These program options will override any corresponding attribute settings.</p>
<p>Finally, the program has some code that can be enabled to selectively
force packet drops to check such behavior.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">17.1.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The following test cases have been added for regression testing:</p>
<ol class="arabic simple">
<li><p>Unlimited pings, no losses, StopApplication () with no packets in flight</p></li>
<li><p>Unlimited pings, no losses, StopApplication () with one packet in flight</p></li>
<li><p>Test for operation of count attribute and exit time after all pings are received, for IPv4”</p></li>
<li><p>Test the operation of interval attribute, for IPv4</p></li>
<li><p>Test for behavior of pinging an unreachable host when the network does not send an ICMP unreachable message</p></li>
<li><p>Test pinging to IPv4 broadcast address and IPv6 all nodes multicast address</p></li>
<li><p>Test behavior of first reply lost in a count-limited configuration</p></li>
<li><p>Test behavior of second reply lost in a count-limited configuration</p></li>
<li><p>Test behavior of last reply lost in a count-limited configuration.</p></li>
</ol>
</section>
</section>
<section id="radvd">
<h3><span class="section-number">17.2. </span>Radvd<a class="headerlink" href="#radvd" title="Link to this heading">¶</a></h3>
<p>This app mimics a “RADVD” daemon. I.e., the daemon responsible for IPv6 routers
advertisements. All the IPv6 routers should have a RADVD daemon installed.</p>
<p>The configuration of the Radvd application mimics the one of the radvd Linux program.</p>
</section>
<section id="dhcpv4">
<h3><span class="section-number">17.3. </span>DHCPv4<a class="headerlink" href="#dhcpv4" title="Link to this heading">¶</a></h3>
<p>The <em>ns-3</em> implementation of Dynamic Host Configuration Protocol (DHCP)
follows the specifications of <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2131.html"><strong>RFC 2131</strong></a> and <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2132.html"><strong>RFC 2132</strong></a>.</p>
<p>The source code for DHCP is located in <code class="docutils literal notranslate"><span class="pre">src/internet-apps/model</span></code> and consists of the
following 6 files:</p>
<ul class="simple">
<li><p>dhcp-server.h,</p></li>
<li><p>dhcp-server.cc,</p></li>
<li><p>dhcp-client.h,</p></li>
<li><p>dhcp-client.cc,</p></li>
<li><p>dhcp-header.h and</p></li>
<li><p>dhcp-header.cc</p></li>
</ul>
<section id="id1">
<h4><span class="section-number">17.3.1. </span>Helpers<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<p>The following two files have been added to <code class="docutils literal notranslate"><span class="pre">src/internet-apps/helper</span></code> for DHCP:</p>
<ul class="simple">
<li><p>dhcp-helper.h and</p></li>
<li><p>dhcp-helper.cc</p></li>
</ul>
</section>
<section id="tests">
<h4><span class="section-number">17.3.2. </span>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h4>
<p>The tests for DHCP can be found at <code class="docutils literal notranslate"><span class="pre">src/internet-apps/test/dhcp-test.cc</span></code></p>
</section>
<section id="examples">
<h4><span class="section-number">17.3.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The examples for DHCP can be found at <code class="docutils literal notranslate"><span class="pre">src/internet-apps/examples/dhcp-example.cc</span></code></p>
</section>
<section id="id2">
<h4><span class="section-number">17.3.4. </span>Scope and Limitations<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<p>The server should be provided with a network address, mask and a range of address
for the pool. One client application can be installed on only one netdevice in a
node, and can configure address for only that netdevice.</p>
<p>The following five basic DHCP messages are supported:</p>
<ul class="simple">
<li><p>DHCP DISCOVER</p></li>
<li><p>DHCP OFFER</p></li>
<li><p>DHCP REQUEST</p></li>
<li><p>DHCP ACK</p></li>
<li><p>DHCP NACK</p></li>
</ul>
<p>Also, the following eight options of BootP are supported:</p>
<ul class="simple">
<li><p>1 (Mask)</p></li>
<li><p>50 (Requested Address)</p></li>
<li><p>51 (Address Lease Time)</p></li>
<li><p>53 (DHCP message type)</p></li>
<li><p>54 (DHCP server identifier)</p></li>
<li><p>58 (Address renew time)</p></li>
<li><p>59 (Address rebind time)</p></li>
<li><p>255 (end)</p></li>
</ul>
<p>The client identifier option (61) can be implemented in near future.</p>
<p>In the current implementation, a DHCP client can obtain IPv4 address dynamically
from the DHCP server, and can renew it within a lease time period.</p>
<p>Multiple DHCP servers can be configured, but the implementation does not support
the use of a DHCP Relay yet.</p>
</section>
</section>
<section id="v4traceroute">
<h3><span class="section-number">17.4. </span>V4TraceRoute<a class="headerlink" href="#v4traceroute" title="Link to this heading">¶</a></h3>
<p>Documentation is missing for this application.</p>
</section>
</section>
<span id="document-lorawan"></span><section id="lorawan-module">
<h2><span class="section-number">18. </span>LoRaWAN Module<a class="headerlink" href="#lorawan-module" title="Link to this heading">¶</a></h2>
<p>This module contains a series of classes and examples aimed at modeling the
modulation and medium access technology of a LoRaWAN network. Thanks to a simple
underlying physical layer model and to the regulations imposed on traffic in the
unlicensed bands this technology operates on, this module can support
simulations featuring a large number of devices that access the wireless channel
infrequently.</p>
<p>The following parts of this documentation first outline how the technology works
and then describe how it was translated into a system of classes in order to
simulate a LoRaWAN system.</p>
<section id="technology">
<h3><span class="section-number">18.1. </span>Technology<a class="headerlink" href="#technology" title="Link to this heading">¶</a></h3>
<p>LoRaWAN is a Low Power Wide Area Network (LPWAN) technology built on the LoRa
modulation. This technology allows a large number of devices to communicate
wirelessly over long distances (in the order of 5-15 km, depending on the
propagation environment) at low data rates. The typical scenario in which this
technology is expected to be employed is that of an IoT network, where devices
need to communicate sparsely and only need short payloads to transmit
some information coming from, typically, a sensor.</p>
<section id="lora">
<h4><span class="section-number">18.1.1. </span>LoRa<a class="headerlink" href="#lora" title="Link to this heading">¶</a></h4>
<p>The basis of LoRaWAN is the proprietary Long Range (LoRa) modulation, owned by
Semtech. This modulation, based on Chirp Spread Spectrum (CSS), spreads a signal
over a certain band by leveraging a chirp signal that scans the available
bandwidth linearly.</p>
<p>One of the key parameters of the modulation is the Spreading Factor (SF): this
value, ranging from 7 to 12, expresses how much a packet is spread in time
(i.e., how long it takes for a chirp to complete a complete scan of the
available bandwidth). Transmissions using a low SF need a lower Time on Air
(ToA) (assuming the same bandwidth) than packets using SF values closer to 12.
The advantage of using higher SFs is in the increased sensitivity of the
receiver: as an example, a transmission using SF7 that cannot be detected by a
LoRa receiver may be correctly demodulated if performed using SF12. Another
key feature of the modulation is the quasi-orthogonality between transmissions
using different SF values: even if two packets overlap in time, a receiver may
still be able to demodulate one of the packets, assuming that they are using
different SF and that some restrictions on their reciprocal power are respected.</p>
<p>More details on how the modulation works can be found in
<a class="reference internal" href="index.html#semtech2015modulation" id="id1"><span>[semtech2015modulation]</span></a> (an official document explaining the modulation) and in
<a class="reference internal" href="index.html#knight2016reversing" id="id2"><span>[knight2016reversing]</span></a> (a reverse engineering of the modulation by Matt Knight).</p>
</section>
<section id="lorawan">
<h4><span class="section-number">18.1.2. </span>LoRaWAN<a class="headerlink" href="#lorawan" title="Link to this heading">¶</a></h4>
<p>The LoRa Alliance first defined the LoRaWAN standard in <a class="reference internal" href="index.html#lorawanstandard" id="id3"><span>[lorawanstandard]</span></a>,
with the objective of creating a medium access scheme and a set of network
management policies that leverage the properties of the modulation to achieve
good network performance at a low price in the complexity of the devices.</p>
<p>The topology of a LoRaWAN network is represented in the figure
<a class="reference internal" href="#lorawan-topology"><span class="std std-ref">Topology of the LoRaWAN architecture.</span></a>, where dotted lines represent a LoRa wireless link while
solid lines are other kinds of high throughput, high reliability connections. It
can be seen that there are three kinds of devices in a LoRaWAN network: End
Devices (EDs), Gateways (GWs) and a Network Server (NS). End Devices are basic
network nodes: typically inexpensive, they are constrained by low computational
capabilities and are usually powered by a battery. Gateways are high-end, mains
powered devices that are tasked with collecting the data transmitted by End
Devices leveraging the LoRa modulation. After a packet is correctly received, it
is forwarded to the Network Server via a link with high reliability and speed.
The Network Server functions as a sink for data coming from all devices, and as
a controller of the network that can leverage some MAC commands to change
transmission settings in the End Devices.</p>
<p>End Devices of the most basic type are defined as Class A devices, and are
currently the only kind of device supported by this module. Class A devices
perform transmission in a totally asynchronous way, and open two receive windows
of fixed duration after each transmission to allow the Network Server to
transmit acknowledgments or MAC commands.</p>
<p>Another important characteristic of the standard is that it is defined to work
on unlicensed bands in various regions, which usually subject transmitters to
regulations on duty cycle. This fact will be explained in greater detail in the
MAC layer model section of this document.</p>
<figure class="align-default" id="id8">
<span id="lorawan-topology"></span><img alt="figures/LoRaWANTopology.*" src="figures/LoRaWANTopology.*" />
<figcaption>
<p><span class="caption-text">Topology of the LoRaWAN architecture.</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="module-design">
<h3><span class="section-number">18.2. </span>Module design<a class="headerlink" href="#module-design" title="Link to this heading">¶</a></h3>
<p>This module comprises two main models: one for the LoRa PHY layer that needs to
represent LoRa chips and the behavior of LoRa transmissions, and one for the
LoRaWAN MAC layer, that needs to behave according to the official
specifications.</p>
<p>To represent these two models, the module features two generic <code class="docutils literal notranslate"><span class="pre">LoraPhy</span></code> and
<code class="docutils literal notranslate"><span class="pre">LorawanMac</span></code> base classes. These classes are then extended by classes that
model the peculiarities of the two wireless network devices: the End Device (ED)
and the Gateway (GW). So, the PHY layers can be modeled by use of
<code class="docutils literal notranslate"><span class="pre">EndDeviceLoraPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">GatewayLoraPhy</span></code> classes, while objects of class
<code class="docutils literal notranslate"><span class="pre">EndDeviceLorawanMac</span></code>, <code class="docutils literal notranslate"><span class="pre">ClassAEndDeviceLorawanMac</span></code>, and <code class="docutils literal notranslate"><span class="pre">GatewayLorawanMac</span></code>
are used to represent the MAC layer. A <code class="docutils literal notranslate"><span class="pre">NetworkServer</span></code> application can also be
installed on a node that will then administer the wireless network through the
GW’s forwarding application, <code class="docutils literal notranslate"><span class="pre">Forwarder</span></code>, which leverages the gateway’s LoRa
communication capabilities to forward to End Devices the Network Server’s
packets.</p>
<section id="phy-layer-model">
<h4><span class="section-number">18.2.1. </span>PHY layer model<a class="headerlink" href="#phy-layer-model" title="Link to this heading">¶</a></h4>
<p>The model for the PHY layer needs to take into account the two key factors of
LoRa, sensitivity and orthogonality, to decide whether a transmission is
received correctly or not. Besides, it also needs to be aware of how the chips
implementing the modulation work, and of their architecture.</p>
<section id="link-model">
<h5><span class="section-number">18.2.1.1. </span>Link model<a class="headerlink" href="#link-model" title="Link to this heading">¶</a></h5>
<p>The link model takes into account three main components to determine the
performance of a LoRa transmission:</p>
<ul class="simple">
<li><p>Data about device sensitivity taken from device datasheets;</p></li>
<li><p>A model to account for the interference between different LoRa transmissions;</p></li>
<li><p>A series of assumptions regarding this interference model.</p></li>
</ul>
<p>In this section, we will describe each portion of the model with a particular
focus on its implementation in the code.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LoraChannel</span></code> class is used to interconnect the LoRa PHY layers of all
devices wishing to communicate using this technology. The class holds a list of
connected PHY layers, and notifies them about incoming transmissions, following
the same paradigm of other <code class="docutils literal notranslate"><span class="pre">Channel</span></code> classes in <em>ns-3</em>.</p>
<p>PHY layers that are connected to the channel expose a public <code class="docutils literal notranslate"><span class="pre">StartReceive</span></code>
method that allows the channel to start reception at a certain PHY. At this
point, these PHY classes rely on a <code class="docutils literal notranslate"><span class="pre">LoraInterferenceHelper</span></code> object to keep
track of all incoming packets, both as potentially desirable packets and as
interference. Once the channel notifies the PHY layer of the incoming packet,
the PHY informs its <code class="docutils literal notranslate"><span class="pre">LoraInterferenceHelper</span></code> right away of the incoming
transmission. After this, if a PHY fills certain prerequisites, it can lock on
the incoming packet for reception. In order to do so:</p>
<ol class="arabic simple">
<li><p>The receiver must be idle (in STANDBY state) when the <code class="docutils literal notranslate"><span class="pre">StartReceive</span></code>
function is called;</p></li>
<li><p>The packet receive power must be above a sensitivity threshold;</p></li>
<li><p>The receiver must be listening on the correct frequency;</p></li>
<li><p>The receiver must be listening for the correct SF.</p></li>
</ol>
<p>The sensitivity threshold that is currently implemented can be seen below
(values in dBm):</p>
<div class="math">
<p><img src="_images/math/32916788b8291d81c99b3aa76502bbabadf4490a.png" alt="\begin{matrix}
\scriptstyle{\rm SF7} &amp; \scriptstyle{\rm SF8} &amp; \scriptstyle{\rm SF9} &amp; \scriptstyle{\rm SF10} &amp; \scriptstyle{\rm SF11} &amp; \scriptstyle{\rm SF12}\\
-124 &amp; -127 &amp; -130 &amp; -133 &amp; -135 &amp; -137 \\
\end{matrix}"/></p>
</div><p>After the PHY layer locks on the incoming packet, it schedules an <code class="docutils literal notranslate"><span class="pre">EndReceive</span></code>
function call after the packet duration. The reception power is considered to be
constant throughout the packet reception process. When reception ends,
<code class="docutils literal notranslate"><span class="pre">EndReceive</span></code> calls the <code class="docutils literal notranslate"><span class="pre">IsDestroyedByInterference</span></code> method of the PHY’s
instance of <code class="docutils literal notranslate"><span class="pre">LoraInterferenceHelper</span></code> to determine whether the packet is lost
due to interference.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">IsDestroyedByInterference</span></code> function compares the desired packet’s
reception power with the interference energy of packets that overlap with it on
a SF basis, and compares the obtained SIR value against the isolation matrix
that was tabulated in <a class="reference internal" href="index.html#goursaud2015dedicated" id="id4"><span>[goursaud2015dedicated]</span></a> and reproduced below. For
example, if the desired packet is using SF7, and it is (even partially)
overlapped to two packets using SF10, the desired signal’s energy (computed as
the product of reception power and signal duration) is compared to the summed
energy of the two interferers (computed as the product of the interferer’s power
at the receiver and overlap time). The ratio between the desired and the
interference energy from each spreading factor (considered separately) is then
compared to the table below, in which rows identify the desired signal’s SF,
while columns represent the interfering SF that is currently being considered.
If the SIR is above the tabulated threshold, the packet is received correctly
and forwarded to the MAC layer.</p>
<div class="math">
<p><img src="_images/math/4e4fd11ad062170342cef13aa8f35f72e9b9362d.png" alt="\begin{matrix}
 &amp; \scriptstyle{\rm SF7 } &amp; \scriptstyle{\rm SF8 }&amp; \scriptstyle{\rm SF9 }&amp; \scriptstyle{\rm SF10} &amp; \scriptstyle{\rm SF11} &amp; \scriptstyle{\rm SF12}\\
\scriptstyle{\rm SF7 }&amp; 6    &amp;-16    &amp;-18    &amp;-19    &amp;-19    &amp;-20\\
\scriptstyle{\rm SF8 }&amp; -24  &amp;6  &amp;-20    &amp;-22    &amp;-22    &amp;-22\\
\scriptstyle{\rm SF9 }&amp; -27  &amp;-27    &amp;6  &amp;-23    &amp;-25    &amp;-25\\
\scriptstyle{\rm SF10} &amp; -30 &amp;-30    &amp;-30    &amp;6  &amp;-26    &amp;-28\\
\scriptstyle{\rm SF11} &amp; -33 &amp;-33    &amp;-33    &amp;-33    &amp;6  &amp;-29\\
\scriptstyle{\rm SF12} &amp; -36 &amp;-36    &amp;-36    &amp;-36    &amp;-36    &amp;6\\
\end{matrix}"/></p>
</div><p>A full description of the link layer model can also be found in
<a class="reference internal" href="index.html#magrin2017performance" id="id5"><span>[magrin2017performance]</span></a> and in <a class="reference internal" href="index.html#magrin2017thesis" id="id6"><span>[magrin2017thesis]</span></a>.</p>
</section>
<section id="gateway-model">
<h5><span class="section-number">18.2.1.2. </span>Gateway model<a class="headerlink" href="#gateway-model" title="Link to this heading">¶</a></h5>
<p>The chip installed on LoRa GWs needs special attention because of its
architecture: since it is characterized by the presence of 8 parallel <em>receive
paths</em>, it can receive multiple packets in parallel <a class="reference internal" href="index.html#sx1301" id="id7"><span>[sx1301]</span></a>. This
behavior is represented in the simulator through a <code class="docutils literal notranslate"><span class="pre">ReceptionPath</span></code> object that
behaves as an <code class="docutils literal notranslate"><span class="pre">EndDeviceLoraPhy</span></code>, locking into incoming packets and comparing
them to others to determine correct reception by using the gateway’s
<code class="docutils literal notranslate"><span class="pre">LoraInterferenceHelper</span></code> instance. A <code class="docutils literal notranslate"><span class="pre">GatewayLoraPhy</span></code>, then, is essentially
a manager of this collection of <code class="docutils literal notranslate"><span class="pre">ReceptionPath</span></code> objects. Upon arrival of a
packet, the gateway picks a free reception path (if there are any), marks it as
occupied and locks it into the incoming packet. Once the scheduled
<code class="docutils literal notranslate"><span class="pre">EndReceive</span></code> method is executed, the gateway’s <code class="docutils literal notranslate"><span class="pre">LoraInterferenceHelper</span></code>
(which contains information used by all <code class="docutils literal notranslate"><span class="pre">ReceptionPaths</span></code>) is queried, and it
is decided whether the packet is correctly received or not.</p>
<p>Some further assumptions on the collaboration behavior of these reception paths
were made to establish a consistent model despite the SX1301 gateway chip
datasheet not going into full detail on how the chip administers the available
reception paths:</p>
<ul class="simple">
<li><p>Receive paths can be configured to listen for incoming packets on any
frequency;</p></li>
<li><p>Receive paths can be allocated freely on the available frequencies;</p></li>
<li><p>Receive paths don’t need to be pre-configured to listen for a certain
spreading factor (thus, point 4 of the prerequisites stated above for End
Devices doesn’t apply);</p></li>
<li><p>If a packet is incoming and multiple receive paths are listening for the same
channel, only one locks into the incoming packet;</p></li>
<li><p>If all reception paths listening on a channel are locked into an incoming
packet and another packet arrives, the new packet is immediately marked as
lost.</p></li>
</ul>
</section>
</section>
<section id="mac-layer-model">
<h4><span class="section-number">18.2.2. </span>MAC layer model<a class="headerlink" href="#mac-layer-model" title="Link to this heading">¶</a></h4>
<p>The MAC models contained in this module aim at implementing the LoRaWAN
standard. To facilitate this task, a series of side classes were created to
handle headers, MAC commands, logical channels and duty cycle computations.
Furthermore, a simplified version of a Network Server (NS) is also provided in
the form of an application that can be installed on a <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">Node</span></code> and
connected to the GWs via a <code class="docutils literal notranslate"><span class="pre">PointToPoint</span></code> link to also simulate a backbone
channel.</p>
<section id="headers-mac-commands-and-addressing-system">
<h5><span class="section-number">18.2.2.1. </span>Headers, MAC commands and addressing system<a class="headerlink" href="#headers-mac-commands-and-addressing-system" title="Link to this heading">¶</a></h5>
<p>The packet structure defined by the LoRaWAN standard is implemented through two
classes that extend the <code class="docutils literal notranslate"><span class="pre">Header</span></code> class: <code class="docutils literal notranslate"><span class="pre">LorawanMacHeader</span></code> and
<code class="docutils literal notranslate"><span class="pre">LoraFrameHeader</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">LoraFrameHeader</span></code> can include MAC commands
by leveraging the <code class="docutils literal notranslate"><span class="pre">MacCommand</span></code> and <code class="docutils literal notranslate"><span class="pre">LoraDeviceAddress</span></code> classes, that are
used to make serialization, deserialization and interpretation of MAC commands
and the LoRaWAN address system easier.</p>
<p>MAC commands are implemented by extending the <code class="docutils literal notranslate"><span class="pre">MacCommand</span></code> class. Each child
class is used to define a set of command variables, methods to serialize and
deserialize the commands inside a <code class="docutils literal notranslate"><span class="pre">LoraFrameHeader</span></code>, and callbacks to the MAC
layer to perform actions. This structure can facilitate the implementation and
testing of custom MAC commands, as allowed by the specification.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LoraDeviceAddress</span></code> class is used to represent the address of a LoRaWAN
ED, and to handle serialization and deserialization.</p>
</section>
<section id="logical-channels-and-duty-cycle">
<h5><span class="section-number">18.2.2.2. </span>Logical channels and duty cycle<a class="headerlink" href="#logical-channels-and-duty-cycle" title="Link to this heading">¶</a></h5>
<p>Since LoRaWAN operates in unlicensed bands that are subject to restrictions on
duty cycle, a series of objects were created to keep track of available
transmission time and limit transmission at the MAC layer in case the layers
above aren’t aware of these limitations. A <code class="docutils literal notranslate"><span class="pre">LogicalLoraChannelHelper</span></code> is
assigned to each <code class="docutils literal notranslate"><span class="pre">LorawanMac</span></code> instance, and is tasked with keeping track of all
available logical channels (which can be added and modified with MAC commands,
and are represented by the <code class="docutils literal notranslate"><span class="pre">LogicalLoraChannel</span></code> class) and is aware of the
sub-band they are in (through instances of the <code class="docutils literal notranslate"><span class="pre">SubBand</span></code> class).</p>
<p>Additionally, in order to enforce duty cycle limitations, this object also
registers all transmissions that are performed on each channel, and can be
queried by the <code class="docutils literal notranslate"><span class="pre">LorawanMac</span></code> instance to know the next time in which transmission
will be possible according to the regulation. If a transmission of duration
<img class="math" src="_images/math/a648c6f443fd90cf72197076a615956506aa19c8.png" alt="t_{\rm air}"/> is performed by the device on a channel where the duty cycle
expressed in fractional form is <img class="math" src="_images/math/ec31009297265e6724a791aa785acf3346731ecd.png" alt="\rm dc"/>, the time the device needs to
stay off is computed according to the following formula:</p>
<div class="math">
<p><img src="_images/math/95ccaa7303a4220a0079a6e7275a68d66e1e6fe3.png" alt="t_{\rm off} = \frac{t_{\rm air}}{\rm dc} - t_{\rm air}"/></p>
</div><p>This time is kept track of on a sub band basis, so that if two channels are
under the same regulation, a transmission on one of them will also block the
other one.</p>
</section>
</section>
<section id="the-network-server">
<h4><span class="section-number">18.2.3. </span>The Network Server<a class="headerlink" href="#the-network-server" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">NetworkServer</span></code> is an application which is running on a node that is
connected to the simulation GWs. The GWs forward incoming LoRa packets to the
NS, and expect to be given packets to transmit in the downlink to EDs by the NS.
In order to keep track of all players in the network, the NS keeps two lists of
<code class="docutils literal notranslate"><span class="pre">DeviceStatus</span></code> and <code class="docutils literal notranslate"><span class="pre">GatewayStatus</span></code> objects, which represent the current
status of each ED and GW in the network, respectively. These objects are used to
keep track of downlink packets that will need to be sent during the ED’s receive
windows, and they also hold pointers to the Mac layer instances of each GW. This
is done in order to be able to perform queries on the gateway’s current duty
cycle limitations and always forward downlink packets to gateways that will be
able to transmit the packet in the LoRa network. The current iteration of the
Network Server only sends downlink packets to devices that require an
acknowledgment, ignoring the contents of the packet and of MAC commands it may
contain. Transmission is performed on the first receive window whenever
possible, and the second receive window is used only when no more resources are
available to leverage the first chance to respond to the device. More complex
and realistic NS behaviors are definitely possible, however they also come at a
complexity cost that is non-negligible.</p>
</section>
</section>
<section id="scope-and-limitations">
<h3><span class="section-number">18.3. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h3>
<p>Since this is still a first version of the module, a few caveats are listed
below.</p>
<section id="inter-protocol-interference">
<h4><span class="section-number">18.3.1. </span>Inter-protocol interference<a class="headerlink" href="#inter-protocol-interference" title="Link to this heading">¶</a></h4>
<p>Since the <code class="docutils literal notranslate"><span class="pre">LoraChannel</span></code> class can only be connected to LoRa PHY layers, the
model is currently unable to account for interference by other technologies.</p>
<p>It’s expected that it will become possible, in the future, to handle
inter-protocol interference by leveraging the <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code> class, once
more accurate models of how interference affects LoRa signals become available.</p>
</section>
<section id="inter-channel-interference">
<h4><span class="section-number">18.3.2. </span>Inter-channel interference<a class="headerlink" href="#inter-channel-interference" title="Link to this heading">¶</a></h4>
<p>Interference between partially overlapping channels is not checked for.
Furthermore, there currently is no model to account for interference between
signals using different bandwidths.</p>
</section>
<section id="network-server">
<h4><span class="section-number">18.3.3. </span>Network Server<a class="headerlink" href="#network-server" title="Link to this heading">¶</a></h4>
<p>The current implementation of the Network Server tries to provide a general
structure to handle EDs and GWs in a network, but still lacks some possibly
complex code to simulate advanced features like different Adaptive Data Rate
(ADR) algorithms, responding to the ED’s MAC commands and supporting join
procedures. Other limitations of the Network Server is that it doesn’t employ a
protocol to communicate with the Gateways (since no official ones exist), and
that it informs the gateway in real time about downlink messages it needs to
send (in other words, no “booking” of the gateway resource is done in advance,
and downlink packets take priority over incoming packets at the gateway).</p>
<p>As of now, the Network Server implementation should be considered as an
experimental feature, prone to yet undiscovered bugs.</p>
</section>
<section id="device-classes">
<h4><span class="section-number">18.3.4. </span>Device Classes<a class="headerlink" href="#device-classes" title="Link to this heading">¶</a></h4>
<p>Currently, only Class A End Devices are supported.</p>
</section>
<section id="regional-parameters">
<h4><span class="section-number">18.3.5. </span>Regional parameters<a class="headerlink" href="#regional-parameters" title="Link to this heading">¶</a></h4>
<p>Since LoRaWAN parameters like default channel lineup and MAC command
interpretations vary based on the operational region of the network,
<code class="docutils literal notranslate"><span class="pre">LorawanMacHelper</span></code> includes methods to specify the region. While the current
implementation is predisposed to support different configurations of the network
based on the region it’s meant to be operating in, currently only the EU region
using the 868 MHz sub band is supported.</p>
</section>
<section id="mac-layer-details">
<h4><span class="section-number">18.3.6. </span>MAC layer details<a class="headerlink" href="#mac-layer-details" title="Link to this heading">¶</a></h4>
<p>Some details that are not crucial for the evaluation of the system performance
of a network still need to be implemented. These include:</p>
<ul class="simple">
<li><p>Frame counters, both at the End Devices and at the Network Server’s
DeviceStatus</p></li>
<li><p>Proper setting of ADR flags (no ADR mechanism is implemented still)</p></li>
<li><p>Join procedure management (both at the NS and at the EDs)</p></li>
</ul>
</section>
</section>
<section id="usage">
<h3><span class="section-number">18.4. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>A typical usage of the model follows some typical <em>ns-3</em> paradigms, like the
usage of helpers to configure a complex network. This section illustrates the
setup of a LoRaWAN network using the module and some other side classes that
weren’t described in the previous sections because they are mainly used to
configure the network.</p>
<section id="helpers">
<h4><span class="section-number">18.4.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">lorawan</span></code> module features helpers to configure the PHY and MAC layers on a
large number of devices. The two layers are split in two different classes,
<code class="docutils literal notranslate"><span class="pre">LorawanMacHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">LoraPhyHelper</span></code>, which can be leveraged by a
<code class="docutils literal notranslate"><span class="pre">LoraHelper</span></code> object to fully configure a LoRa device (both for EDs and for
GWs). Since the helpers are general purpose (i.e., they can be used both for ED
and GW configuration), it is necessary to specify the device type via the
<code class="docutils literal notranslate"><span class="pre">SetDeviceType</span></code> method before the <code class="docutils literal notranslate"><span class="pre">Install</span></code> method can be called.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LorawanMacHelper</span></code> also exposes a method to set up the Spreading Factors used
by the devices participating in the network automatically, based on the channel
conditions and on the placement of devices and gateways. This procedure is
contained in the static method <code class="docutils literal notranslate"><span class="pre">SetSpreadingFactorsUp</span></code>, and works by trying to
minimize the time-on-air of packets, thus assigning the lowest possible
spreading factor such that reception by at least one gateway is still possible.
It should be noted that this is an heuristic, and that it doesn’t guarantee that
the SF distribution is optimal for the best possible operation of the network.
In fact, finding such a distribution based on the network scenario is still an
open challenge.</p>
</section>
<section id="attributes">
<h4><span class="section-number">18.4.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<p>Currently, the following attributes are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Interval</span></code> and <code class="docutils literal notranslate"><span class="pre">PacketSize</span></code> in <code class="docutils literal notranslate"><span class="pre">PeriodicSender</span></code> determine the interval
between packet sends of the application, and the size of the packets that are
generated by the application.</p></li>
</ul>
</section>
<section id="trace-sources">
<h4><span class="section-number">18.4.3. </span>Trace Sources<a class="headerlink" href="#trace-sources" title="Link to this heading">¶</a></h4>
<p>Various trace sources can be used to keep track of events throughout the
simulation, mainly regarding the lifetime of a packet. At the PHY layer, the
following trace sources are exposed:</p>
<ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">LoraPhy</span></code> (both <code class="docutils literal notranslate"><span class="pre">EndDeviceLoraPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">GatewayLoraPhy</span></code>):</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">StartSending</span></code>, fired when a PHY layer begins transmitting a packet;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PhyRxBegin</span></code>, fired when a PHY layer becomes locked on a packet;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PhyRxEnd</span></code>, fired when a PHY’s reception of a packet ends;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReceivedPacket</span></code>, fired when a packet is correctly received;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LostPacketBecauseInterference</span></code>, fired when a packet is lost because of
interference from other transmissions;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LostPacketBecauseUnderSensitivity</span></code>, fired when a PHY cannot lock on a
packet because it’s being received with a power below the device sensitivity;</p></li>
</ul>
</li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">EndDeviceLoraPhy</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">LoraPacketBecauseWrongFrequency</span></code> is fired when an incoming packet is
using a frequency that is different from that on which the PHY is listening;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LoraPacketBecauseWrongSpreadingFactor</span></code> is fired when an incoming packet
is using a SF that is different from that for which the PHY is listening;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EndDeviceState</span></code> is used to keep track of the state of the device’s PHY
layer.</p></li>
</ul>
</li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">GatewayLoraPhy</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">LostPacketBecauseNoMoreReceivers</span></code> is fired when a packet is lost because
no more receive paths are available to lock onto the incoming packet;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OccupiedReceptionPaths</span></code> is used to keep track of the number of occupied
reception paths out of the 8 that are available at the gateway;</p></li>
</ul>
</li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">LorawanMac</span></code> (both <code class="docutils literal notranslate"><span class="pre">EndDeviceLorawanMac</span></code> and <code class="docutils literal notranslate"><span class="pre">GatewayLorawanMac</span></code>):</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">CannotSendBecauseDutyCycle</span></code> is used to keep track of the number of when a
packet coming from the application layer cannot be sent on any of the
available channels because of duty cycle limitations;</p></li>
</ul>
</li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">EndDeviceLorawanMac</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">DataRate</span></code> keeps track of the data rate that is employed by the device;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LastKnownLinkMargin</span></code> keeps track of the last link margin of this device’s
uplink transmissions; This information is gathered through the <code class="docutils literal notranslate"><span class="pre">LinkCheck</span></code>
MAC commands;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LastKnownGatewayCount</span></code> keeps track of the last known number of gateways
that this device is able to reach; This information is gathered through the
<code class="docutils literal notranslate"><span class="pre">LinkCheck</span></code> MAC commands;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AggregatedDutyCycle</span></code> keeps track of the currently set aggregated duty
cycle limitations;</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PacketSent</span></code> in <code class="docutils literal notranslate"><span class="pre">LoraChannel</span></code> is fired when a packet is sent on the channel;</p></li>
</ul>
</section>
</section>
<section id="examples">
<h3><span class="section-number">18.5. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h3>
<section id="simple-lorawan-network-example">
<h4><span class="section-number">18.5.1. </span>simple-lorawan-network-example<a class="headerlink" href="#simple-lorawan-network-example" title="Link to this heading">¶</a></h4>
<p>This example is used to showcase how wireless communication between a device and
a gateway happens: one LoRa ED is configured to send a packet, and a GW receives
it. When logging is enabled, the various steps that are needed to send a packet
from the APP layer of an ED to the MAC layer of a GW can be observed.</p>
</section>
<section id="network-server-example">
<h4><span class="section-number">18.5.2. </span>network-server-example<a class="headerlink" href="#network-server-example" title="Link to this heading">¶</a></h4>
<p>This example builds on the <code class="docutils literal notranslate"><span class="pre">simple-lorawan-network-example</span></code> to add a Network
Server and multiple EDs and GWs to the scenario. This example works as a
showcase for how communication between the End Devices and the Network Server
happens.</p>
</section>
<section id="complete-lorawan-network-example">
<h4><span class="section-number">18.5.3. </span>complete-lorawan-network-example<a class="headerlink" href="#complete-lorawan-network-example" title="Link to this heading">¶</a></h4>
<p>This example shows how to configure a whole LoRaWAN network using the <em>ns-3</em>
<code class="docutils literal notranslate"><span class="pre">lorawan</span></code> module. A big network featuring several thousand devices and tens of
gateways is built, and each device is equipped with a <code class="docutils literal notranslate"><span class="pre">PeriodicSender</span></code>
application that periodically sends a packet to the NetworkServer through the
Gateways. The example keeps track of the sent and received packets, and computes
some statistics at the end of the simulation. No Network Server is used in this
simulation, since performance metrics are collected through the GW trace sources
and packets don’t require an acknowledgment.</p>
</section>
</section>
<section id="tests">
<h3><span class="section-number">18.6. </span>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h3>
<p>Tests are contained in the <code class="docutils literal notranslate"><span class="pre">lorawan-test-suite.cc</span></code> file. The tests currently
cover the following classes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LoraInterferenceHelper</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LoraDeviceAddress</span></code> and <code class="docutils literal notranslate"><span class="pre">LoraDeviceAddressHelper</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LoraFrameHeader</span></code> and <code class="docutils literal notranslate"><span class="pre">LorawanMacHeader</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReceivePath</span></code> and <code class="docutils literal notranslate"><span class="pre">GatewayLoraPhy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LogicalLoraChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">LogicalLoraChannelHelper</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LoraPhy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EndDeviceLoraPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">LoraChannel</span></code></p></li>
</ul>
</section>
<section id="references">
<h3><span class="section-number">18.7. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="magrin2017performance" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">magrin2017performance</a><span class="fn-bracket">]</span></span>
<p>D. Magrin, M. Centenaro and L. Vangelista,
<em>Performance Evaluation of LoRa Networks in a Smart
City Scenario</em>, in Proc. of the IEEE International
Conference on Communications, May 2017.</p>
</div>
<div class="citation" id="magrin2017thesis" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">magrin2017thesis</a><span class="fn-bracket">]</span></span>
<p>D. Magrin, <em>Network level performances of a LoRa system</em>,
December 2016. Available:
<a class="reference external" href="http://tesi.cab.unipd.it/53740/">http://tesi.cab.unipd.it/53740/</a></p>
</div>
<div class="citation" id="sx1301" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">sx1301</a><span class="fn-bracket">]</span></span>
<p>Semtech, SX1301 Datasheet.</p>
</div>
<div class="citation" id="goursaud2015dedicated" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">goursaud2015dedicated</a><span class="fn-bracket">]</span></span>
<p>C. Goursaud, J. M. Gorce, <em>Dedicated networks for
IoT: PHY/MAC state of the art and challenges</em>, EAI
endorsed transactions on Internet of Things, 2015.</p>
</div>
<div class="citation" id="semtech2015modulation" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">semtech2015modulation</a><span class="fn-bracket">]</span></span>
<p>Semtech Corporation, <em>AN1200.22 LoRa Modulation
Basics</em>, May 2015, Online. Available:
<a class="reference external" href="http://www.semtech.com/images/datasheet/an1200.22.pdf">http://www.semtech.com/images/datasheet/an1200.22.pdf</a></p>
</div>
<div class="citation" id="knight2016reversing" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">knight2016reversing</a><span class="fn-bracket">]</span></span>
<p>M. Knight, <em>Reversing LoRa</em>, Online. Available:
<a class="reference external" href="https://github.com/matt-knight/research">https://github.com/matt-knight/research</a></p>
</div>
<div class="citation" id="lorawanstandard" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">lorawanstandard</a><span class="fn-bracket">]</span></span>
<p>N. Sornin, M. Luis, T. Eirich, T. Kramp, and O. Hersent,
<em>LoRaWAN Specifications</em>, LoRa Alliance, Tech. Rep., 2015.</p>
</div>
</div>
</section>
</section>
<span id="document-lr-wpan"></span><p>PageBreak</p>
<section id="low-rate-wireless-personal-area-network-lr-wpan">
<h2><span class="section-number">19. </span>Low-Rate Wireless Personal Area Network (LR-WPAN)<a class="headerlink" href="#low-rate-wireless-personal-area-network-lr-wpan" title="Link to this heading">¶</a></h2>
<p>This chapter describes the implementation of <em>ns-3</em> models for the
low-rate, wireless personal area network (LR-WPAN) as specified by
IEEE standard 802.15.4 (2003,2006,2011).</p>
<section id="model-description">
<h3><span class="section-number">19.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<section id="design">
<h4><span class="section-number">19.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>The model design closely follows the standard from an architectural standpoint.</p>
<figure class="align-default" id="id1">
<span id="fig-lr-wpan-arch"></span><img alt="_images/lr-wpan-arch.png" src="_images/lr-wpan-arch.png" />
<figcaption>
<p><span class="caption-text">Architecture and scope of lr-wpan models</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The grey areas in the figure (adapted from Fig 3. of IEEE Std. 802.15.4-2006)
show the scope of the model.</p>
<p>The Spectrum NetDevice from Nicola Baldo is the basis for the implementation.</p>
<p>The implementation also borrows some ideas from the ns-2 models developed by
Zheng and Lee.</p>
<section id="apis">
<h5><span class="section-number">19.1.1.1. </span>APIs<a class="headerlink" href="#apis" title="Link to this heading">¶</a></h5>
<p>The APIs closely follow the standard, adapted for <em>ns-3</em> naming conventions
and idioms.  The APIs are organized around the concept of service primitives
as shown in the following figure adapted from Figure 14 of
IEEE Std. 802.15.4-2006.</p>
<figure class="align-default" id="id2">
<span id="fig-lr-wpan-primitives"></span><img alt="_images/lr-wpan-primitives.png" src="_images/lr-wpan-primitives.png" />
<figcaption>
<p><span class="caption-text">Service primitives</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The APIs are organized around four conceptual services and service access
points (SAP):</p>
<ul class="simple">
<li><p>MAC data service (MCPS)</p></li>
<li><p>MAC management service  (MLME)</p></li>
<li><p>PHY data service (PD)</p></li>
<li><p>PHY management service (PLME)</p></li>
</ul>
<p>In general, primitives are standardized as follows (e.g. Sec 7.1.1.1.1
of IEEE 802.15.4-2006)::</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>MCPS-DATA.request<span class="o">(</span>
<span class="w">                  </span>SrcAddrMode,
<span class="w">                  </span>DstAddrMode,
<span class="w">                  </span>DstPANId,
<span class="w">                  </span>DstAddr,
<span class="w">                  </span>msduLength,
<span class="w">                  </span>msdu,
<span class="w">                  </span>msduHandle,
<span class="w">                  </span>TxOptions,
<span class="w">                  </span>SecurityLevel,
<span class="w">                  </span>KeyIdMode,
<span class="w">                  </span>KeySource,
<span class="w">                  </span>KeyIndex
<span class="w">                 </span><span class="o">)</span>
</pre></div>
</div>
<p>This maps to <em>ns-3</em> classes and methods such as::</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>struct<span class="w"> </span>McpsDataRequestParameters
<span class="o">{</span>
<span class="w">  </span>uint8_t<span class="w"> </span>m_srcAddrMode<span class="p">;</span>
<span class="w">  </span>uint8_t<span class="w"> </span>m_dstAddrMode<span class="p">;</span>
<span class="w">  </span>...
<span class="o">}</span><span class="p">;</span>

void
LrWpanMac::McpsDataRequest<span class="o">(</span>McpsDataRequestParameters<span class="w"> </span>params<span class="o">)</span>
<span class="o">{</span>
...
<span class="o">}</span>
</pre></div>
</div>
<p>The primitives currently supported by the <em>ns-3</em> model are:</p>
<section id="mac-primitives">
<h6><span class="section-number">19.1.1.1.1. </span>MAC Primitives<a class="headerlink" href="#mac-primitives" title="Link to this heading">¶</a></h6>
<ul class="simple">
<li><p>MCPS-DATA.Request</p></li>
<li><p>MCPS-DATA.Confirm</p></li>
<li><p>MCPS-DATA.Indication</p></li>
<li><p>MLME-START.Request</p></li>
<li><p>MLME-START.Confirm</p></li>
<li><p>MLME-SCAN.Request</p></li>
<li><p>MLME-SCAN.Confirm</p></li>
<li><p>MLME-BEACON-NOFIFY.Indication</p></li>
<li><p>MLME-ASSOCIATE.Request</p></li>
<li><p>MLME-ASSOCIATE.Confirm</p></li>
<li><p>MLME-ASSOCIATE.Response</p></li>
<li><p>MLME-ASSOCIATE.Indication</p></li>
<li><p>MLME-POLL.Confirm</p></li>
<li><p>MLME-COMM-STATUS.Indication</p></li>
<li><p>MLME-SYNC.Request</p></li>
<li><p>MLME-SYNC-LOSS.Indication</p></li>
</ul>
</section>
<section id="phy-primitives">
<h6><span class="section-number">19.1.1.1.2. </span>PHY Primitives<a class="headerlink" href="#phy-primitives" title="Link to this heading">¶</a></h6>
<ul class="simple">
<li><p>PLME-CCA.Request</p></li>
<li><p>PLME-CCA.Confirm</p></li>
<li><p>PD-DATA.Request</p></li>
<li><p>PD-DATA.Confirm</p></li>
<li><p>PD-DATA.Indication</p></li>
<li><p>PLME-SET-TRX-STATE.Request</p></li>
<li><p>PLME-SET-TRX-STATE.Confirm</p></li>
</ul>
<p>For more information on primitives, See IEEE 802.15.4-2011, Table 8.</p>
</section>
</section>
<section id="mac">
<h5><span class="section-number">19.1.1.2. </span>MAC<a class="headerlink" href="#mac" title="Link to this heading">¶</a></h5>
<p>The MAC at present implements both, the unslotted CSMA/CA (non-beacon mode) and
the slotted CSMA/CA (beacon-enabled mode). The beacon-enabled mode supports only
direct transmissions. Indirect transmissions and Guaranteed Time Slots (GTS) are
currently not supported.</p>
<p>The present implementation supports a single PAN coordinator, support for additional
coordinators is under consideration for future releases.</p>
<p>The implemented MAC is similar to Contiki’s NullMAC, i.e., a MAC without sleep
features. The radio is assumed to be always active (receiving or transmitting),
of completely shut down. Frame reception is not disabled while performing the
CCA.</p>
<p>The main API supported is the data transfer API
(McpsDataRequest/Indication/Confirm).  CSMA/CA according to Stc 802.15.4-2006,
section 7.5.1.4 is supported. Frame reception and rejection according to
Std 802.15.4-2006, section 7.5.6.2 is supported, including acknowledgements.
Only short addressing completely implemented. Various trace sources are
supported, and trace sources can be hooked to sinks.</p>
<p>The implemented ns-3 MAC supports scanning. Typically, a scanning request is preceded
by an association request but these can be used independently.
IEEE 802.15.4 supports 4 types of scanning:</p>
<ul class="simple">
<li><p><em>Energy Detection (ED) Scan:</em> In an energy scan, a device or a coordinator scan a set number of channels looking for traces of energy. The maximum energy registered during a given amount of time is stored. Energy scan is typically used to measure the quality of a channel at any given time. For this reason, coordinators often use this scan before initiating a PAN on a channel.</p></li>
<li><p><em>Active Scan:</em> A device sends <code class="docutils literal notranslate"><span class="pre">beacon</span> <span class="pre">request</span> <span class="pre">commands</span></code> on a set number of channels looking for a PAN coordinator. The receiving coordinator must be configured on non-beacon mode. Coordinators on beacon-mode ignore these requests. The coordinators who accept the request, respond with a beacon. After an active scan take place, during the association process devices extract the information in the PAN descriptors from the collected beacons and based on this information (e.g. channel, LQI level), choose a coordinator to associate with.</p></li>
<li><p><em>Passive Scan:</em> In a passive scan, no <code class="docutils literal notranslate"><span class="pre">beacon</span> <span class="pre">requests</span> <span class="pre">commands</span></code> are sent. Devices scan a set number of channels looking for beacons currently being transmitted (coordinators in beacon-mode). Like in the active scan, the information from beacons is stored in PAN descriptors and used by the device to choose a coordinator to associate with.</p></li>
<li><p><em>Orphan Scan:</em> Orphan scan is used typically by device as a result of repeated communication failure attempts with a coordinator. In other words, an orphan scan represents the intent of a device to relocate its coordinator. In some situations, it can be used by devices higher layers to not only rejoin a network but also join a network for the first time. In an orphan scan, a device send a <code class="docutils literal notranslate"><span class="pre">orphan</span> <span class="pre">notification</span> <span class="pre">command</span></code> to a given list of channels. If a coordinator receives this notification, it responds to the device with a <code class="docutils literal notranslate"><span class="pre">coordinator</span> <span class="pre">realignment</span> <span class="pre">command</span></code>.</p></li>
</ul>
<p>In active and passive scans, the link quality indicator (LQI) is the main parameter used to
determine the optimal coordinator. LQI values range from 0 to 255. Where 255 is the highest quality link value and 0 the lowest. Typically, a link lower than 127 is considered a link with poor quality.</p>
<p>In LR-WPAN, association is used to join or leave PANs. All devices in LR-WPAN must belong to a PAN to communicate. <em>ns-3</em> uses a classic association procedure described in the standard. The standard also covers a more effective association procedure known as fast association (See IEEE 802.15.4-2015, fastA) but this association is currently not supported by <em>ns-3</em>. Alternatively, <em>ns-3</em> can do a “quick and dirty” association using either <code class="docutils literal notranslate"><span class="pre">`LrWpanHelper::AssociateToPan`</span></code> or <code class="docutils literal notranslate"><span class="pre">`LrWpanHelper::AssociateToBeaconPan`</span></code>. These functions are used when a preset association can be done. For example, when the relationships between existing nodes and coordinators are known and can be set before the beginning of the simulation. In other situations, like in many networks in real deployments or in large networks, it is desirable that devices “associate themselves” with the best possible available coordinator candidates. This is a process known as bootstrap, and simulating this process makes it possible to demonstrate the kind of situations a node would face in which large networks to associate in real environment.</p>
<p>Bootstrap (a.k.a. network initialization) is possible with a combination of scan and association MAC primitives. Details on the general process for this network initialization is described in the standard. Bootstrap is a complex process that not only requires the scanning networks, but also the exchange of command frames and the use of a pending transaction list (indirect transmissions) in the coordinator to store command frames. The following summarizes the whole process:</p>
<figure class="align-default" id="fig-lr-wpan-assocsequence">
<img alt="_images/lr-wpan-assocSequence.png" src="_images/lr-wpan-assocSequence.png" />
</figure>
<p>Bootstrap as whole depends on procedures that also take place on higher layers of devices and coordinators. These procedures are briefly described in the standard but out of its scope (See IEE 802.15.4-2011 Section 5.1.3.1.). However, these procedures are necessary for a “complete bootstrap” process. In the examples in <em>ns-3</em>, these high layer procedures are only briefly implemented to demonstrate a complete example that shows the use of scan and association. A full high layer (e.g. such as those found in Zigbee and Thread protocol stacks) should complete these procedures more robustly.</p>
<section id="mac-queues">
<h6><span class="section-number">19.1.1.2.1. </span>MAC queues<a class="headerlink" href="#mac-queues" title="Link to this heading">¶</a></h6>
<p>By default, <code class="docutils literal notranslate"><span class="pre">Tx</span> <span class="pre">queue</span></code> and <code class="docutils literal notranslate"><span class="pre">Ind</span> <span class="pre">Tx</span> <span class="pre">queue</span></code> (the pending transaction list) are not limited but they can configure to drop packets after they
reach a limit of elements (transaction overflow). Additionally, the <code class="docutils literal notranslate"><span class="pre">Ind</span> <span class="pre">Tx</span> <span class="pre">queue</span></code> drop packets when the packet has been longer than
<code class="docutils literal notranslate"><span class="pre">macTransactionPersistenceTime</span></code> (transaction expiration). Expiration of packets in the Tx queue is not supported.
Finally, packets in the <code class="docutils literal notranslate"><span class="pre">Tx</span> <span class="pre">queue</span></code> may be dropped due to excessive transmission retries or channel access failure.</p>
</section>
</section>
<section id="phy">
<h5><span class="section-number">19.1.1.3. </span>PHY<a class="headerlink" href="#phy" title="Link to this heading">¶</a></h5>
<p>The physical layer components consist of a Phy model, an error rate model,
and a loss model. The PHY state transitions are roughly model after
ATMEL’s AT86RF233.</p>
<figure class="align-default" id="id3">
<span id="fig-lr-wpan-phy"></span><img alt="_images/lr-wpan-phy.png" src="_images/lr-wpan-phy.png" />
<figcaption>
<p><span class="caption-text">Ns-3 lr-wpan PHY basic operating mode state diagram</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The error rate model presently models the error rate
for IEEE 802.15.4 2.4 GHz AWGN channel for OQPSK; the model description can
be found in IEEE Std 802.15.4-2006, section E.4.1.7.   The Phy model is
based on SpectrumPhy and it follows specification described in section 6
of IEEE Std 802.15.4-2006. It models PHY service specifications, PPDU
formats, PHY constants and PIB attributes. It currently only supports
the transmit power spectral density mask specified in 2.4 GHz per section
6.5.3.1. The noise power density assumes uniformly distributed thermal
noise across the frequency bands. The loss model can fully utilize all
existing simple (non-spectrum phy) loss models. The Phy model uses
the existing single spectrum channel model.
The physical layer is modeled on packet level, that is, no preamble/SFD
detection is done. Packet reception will be started with the first bit of the
preamble (which is not modeled), if the SNR is more than -5 dB, see IEEE
Std 802.15.4-2006, appendix E, Figure E.2. Reception of the packet will finish
after the packet was completely transmitted. Other packets arriving during
reception will add up to the interference/noise.</p>
<p>Rx sensitivity is defined as the weakest possible signal point at which a receiver can receive and decode a packet with a high success rate.
According to the standard (IEEE Std 802.15.4-2006, section 6.1.7), this
corresponds to the point where the packet error rate is under 1% for 20 bytes PSDU
reference packets (11 bytes MAC header + 7 bytes payload (MSDU) + FCS 2 bytes). Setting low Rx sensitivity values (increasing the radio hearing capabilities)
have the effect to receive more packets (and at a greater distance) but it raises the probability to have dropped packets at the
MAC layer or the probability of corrupted packets. By default, the receiver sensitivity is set to the maximum theoretical possible value of -106.58 dBm for the supported IEEE 802.15.4 O-QPSK 250kps.
This rx sensitivity is set for the “perfect radio” which only considers the floor noise, in essence, this do not include the noise factor (noise introduced by imperfections in the demodulator chip or external factors).
The receiver sensitivity can be changed to different values using <code class="docutils literal notranslate"><span class="pre">SetRxSensitivity</span></code> function in the PHY to simulate the hearing capabilities of different compliant radio transceivers (the standard minimum compliant Rx sensitivity is -85 dBm).:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="w">                                                           </span><span class="o">(</span>defined<span class="w"> </span>by<span class="w"> </span>the<span class="w"> </span>standard<span class="o">)</span>
NoiseFloor<span class="w">          </span>Max<span class="w"> </span>Sensitivity<span class="w">                          </span>Min<span class="w"> </span>Sensitivity
-106.987dBm<span class="w">          </span>-106.58dBm<span class="w">                                   </span>-85dBm
<span class="w"> </span><span class="p">|</span>-------------------------<span class="p">|</span>------------------------------------------<span class="p">|</span>
<span class="w">                       </span>Noise<span class="w"> </span><span class="nv">Factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>
<span class="w">                           </span><span class="p">|</span><span class="w"> </span>&lt;---------------------------------------&gt;<span class="p">|</span>
<span class="w">                                 </span>Acceptable<span class="w"> </span>sensitivity<span class="w"> </span>range
</pre></div>
</div>
<p>The example <code class="docutils literal notranslate"><span class="pre">lr-wpan-per-plot.cc`</span> <span class="pre">shows</span> <span class="pre">that</span> <span class="pre">at</span> <span class="pre">given</span> <span class="pre">Rx</span> <span class="pre">sensitiviy,</span> <span class="pre">packets</span> <span class="pre">are</span> <span class="pre">dropped</span> <span class="pre">regardless</span> <span class="pre">of</span> <span class="pre">their</span> <span class="pre">theoretical</span> <span class="pre">error</span> <span class="pre">probability.</span>
<span class="pre">This</span> <span class="pre">program</span> <span class="pre">outputs</span> <span class="pre">a</span> <span class="pre">file</span> <span class="pre">named</span> <span class="pre">``802.15.4-per-vs-rxSignal.plt</span></code>.
Loading this file into gnuplot yields a file <code class="docutils literal notranslate"><span class="pre">802.15.4-per-vs-rsSignal.eps</span></code>, which can
be converted to pdf or other formats. Packet payload size, Tx power and Rx sensitivity can be configurated.
The point where the blue line crosses with the PER indicates the Rx sensitivity. The default output is shown below.</p>
<figure class="align-default" id="id4">
<span id="fig-802-15-4-per-sens"></span><img alt="_images/802-15-4-per-sens.png" src="_images/802-15-4-per-sens.png" />
<figcaption>
<p><span class="caption-text">Default output of the program <code class="docutils literal notranslate"><span class="pre">lr-wpan-per-plot.cc</span></code></span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="netdevice">
<h5><span class="section-number">19.1.1.4. </span>NetDevice<a class="headerlink" href="#netdevice" title="Link to this heading">¶</a></h5>
<p>Although it is expected that other technology profiles (such as
6LoWPAN and ZigBee) will write their own NetDevice classes, a basic
LrWpanNetDevice is provided, which encapsulates the common operations
of creating a generic LrWpan device and hooking things together.</p>
<section id="mac-addresses">
<h6><span class="section-number">19.1.1.4.1. </span>MAC addresses<a class="headerlink" href="#mac-addresses" title="Link to this heading">¶</a></h6>
<p>Contrary to other technologies, a IEEE 802.15.4 has 2 different kind of addresses:</p>
<ul class="simple">
<li><p>Long addresses (64 bits)</p></li>
<li><p>Short addresses (16 bits)</p></li>
</ul>
<p>The 64-bit addresses are unique worldwide, and set by the device vendor (in a real device).
The 16-bit addresses are not guaranteed to be unique, and they are typically either assigned
during the devices deployment, or assigned dynamically during the device bootstrap.</p>
<p>The other relevant “address” to consider is the PanId (16 bits), which represents the PAN
the device is attached to.</p>
<p>Due to the limited number of available bytes in a packet, IEEE 802.15.4 tries to use short
addresses instead of long addresses, even though the two might be used at the same time.</p>
<p>For the sake of communicating with the upper layers, and in particular to generate auto-configured
IPv6 addresses, each NetDevice must identify itself with a MAC address. The MAC addresses are
also used during packet reception, so it is important to use them consistently.</p>
<p>Focusing on IPv6 Stateless address autoconfiguration (SLAAC), there are two relevant RFCs to
consider: RFC 4944 and RFC 6282, and the two differ on how to build the IPv6 address given
the NetDevice address.</p>
<p>RFC 4944 mandates that the IID part of the IPv6 address is calculated as <code class="docutils literal notranslate"><span class="pre">YYYY:00ff:fe00:XXXX</span></code>,
while RFC 6282 mandates that the IID part of the IPv6 address is calculated as <code class="docutils literal notranslate"><span class="pre">0000:00ff:fe00:XXXX</span></code>
where <code class="docutils literal notranslate"><span class="pre">XXXX</span></code> is the device short address, and <code class="docutils literal notranslate"><span class="pre">YYYY</span></code> is the PanId.
In both cases the U/L bit must be set to local, so in the RFC 4944 the PanId might have one bit flipped.</p>
<p>In order to facilitate interoperability, and to avoid unwanted module dependencies, the <em>ns-3</em>
implementation moves the IID calculation in the <code class="docutils literal notranslate"><span class="pre">LrWpanNetDevice::GetAddress</span> <span class="pre">()</span></code>, which will
return an <code class="docutils literal notranslate"><span class="pre">Address</span></code> formatted properly, i.e.:</p>
<ul class="simple">
<li><p>The Long address (a <code class="docutils literal notranslate"><span class="pre">Mac64Address</span></code>) if the Short address has not been set, or</p></li>
<li><p>A properly formatted 48-bit pseudo-address (a <code class="docutils literal notranslate"><span class="pre">Mac48Address</span></code>) if the short address has been set.</p></li>
</ul>
<p>The 48-bit pseudo-address is generated according to either RFC 4944 or RFC 6282 depending on the
configuration of an Attribute (<code class="docutils literal notranslate"><span class="pre">PseudoMacAddressMode</span></code>).</p>
<p>The default is to use RFC 6282 style addresses.</p>
<p>Note that, on reception, a packet might contain either a short or a long address. This is reflected
in the upper-layer notification callback, which can contain either the pseudo-address (48 bits) or
the long address (64 bit) of the sender.</p>
<p>Note also that RFC 4944 or RFC 6282 are the RFCs defining the IPv6 address compression formats
(HC1 and IPHC respectively). It is defintely not a good idea to either mix devices using different
pseudo-address format or compression types in the same network. This point is further discussed
in the <code class="docutils literal notranslate"><span class="pre">sixlowpan</span></code> module documentation.</p>
</section>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">19.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>Future versions of this document will contain a PICS proforma similar to
Appendix D of IEEE 802.15.4-2006. The current emphasis is on direct transmissions
running on both, slotted and unslotted mode (CSMA/CA) of 802.15.4 operation for use in Zigbee.</p>
<ul class="simple">
<li><p>Indirect data transmissions are not supported but planned for a future update.</p></li>
<li><p>Devices are capable of associating with a single PAN coordinator. Interference is modeled as AWGN but this is currently not thoroughly tested.</p></li>
<li><p>The standard describes the support of multiple PHY band-modulations but currently, only 250kbps O-QPSK (channel page 0) is supported.</p></li>
<li><p>Active and passive MAC scans are able to obtain a LQI value from a beacon frame, however, the scan primitives assumes LQI is correctly implemented and does not check the validity of its value.</p></li>
<li><p>Configuration of the ED thresholds are currently not supported.</p></li>
<li><p>Coordinator realignment command is only supported in orphan scans.</p></li>
<li><p>Disassociation primitives are not supported.</p></li>
<li><p>Security is not supported.</p></li>
<li><p>Beacon enabled mode GTS are not supported.</p></li>
</ul>
</section>
<section id="references">
<h4><span class="section-number">19.1.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Wireless Medium Access Control (MAC) and Physical Layer (PHY) Specifications for Low-Rate Wireless Personal Area Networks (WPANs), IEEE Computer Society, IEEE Std 802.15.4-2006, 8 September 2006.</p></li>
<li><p>IEEE Standard for Local and metropolitan area networks–Part 15.4: Low-Rate Wireless Personal Area Networks (LR-WPANs),” in IEEE Std 802.15.4-2011 (Revision of IEEE Std 802.15.4-2006) , vol., no., pp.1-314, 5 Sept. 2011, doi: 10.1109/IEEESTD.2011.6012487.</p></li>
<li><ol class="upperalpha simple" start="10">
<li><p>Zheng and Myung J. Lee, “A comprehensive performance study of IEEE 802.15.4,” Sensor Network Operations, IEEE Press, Wiley Interscience, Chapter 4, pp. 218-237, 2006.</p></li>
</ol>
</li>
<li><p>Alberto Gallegos Ramonet and Taku Noguchi. 2020. LR-WPAN: Beacon Enabled Direct Transmissions on Ns-3. In 2020 the 6th International Conference on Communication and Information Processing (ICCIP 2020). Association for Computing Machinery, New York, NY, USA, 115–122. <a class="reference external" href="https://doi.org/10.1145/3442555.3442574">https://doi.org/10.1145/3442555.3442574</a>.</p></li>
<li><p>Gallegos Ramonet, A.; Noguchi, T. Performance Analysis of IEEE 802.15.4 Bootstrap Process. Electronics 2022, 11, 4090. <a class="reference external" href="https://doi.org/10.3390/electronics11244090">https://doi.org/10.3390/electronics11244090</a>.</p></li>
</ul>
</section>
</section>
<section id="usage">
<h3><span class="section-number">19.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<section id="enabling-lr-wpan">
<h4><span class="section-number">19.2.1. </span>Enabling lr-wpan<a class="headerlink" href="#enabling-lr-wpan" title="Link to this heading">¶</a></h4>
<p>Add <code class="docutils literal notranslate"><span class="pre">lr-wpan</span></code> to the list of modules built with <em>ns-3</em>.</p>
</section>
<section id="helper">
<h4><span class="section-number">19.2.2. </span>Helper<a class="headerlink" href="#helper" title="Link to this heading">¶</a></h4>
<p>The helper is patterned after other device helpers.  In particular,
tracing (ascii and pcap) is enabled similarly, and enabling of all
lr-wpan log components is performed similarly.  Use of the helper
is exemplified in <code class="docutils literal notranslate"><span class="pre">examples/lr-wpan-data.cc</span></code>.  For ascii tracing,
the transmit and receive traces are hooked at the Mac layer.</p>
<p>The default propagation loss model added to the channel, when this helper
is used, is the LogDistancePropagationLossModel with default parameters.</p>
</section>
<section id="examples">
<h4><span class="section-number">19.2.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The following examples have been written, which can be found in <code class="docutils literal notranslate"><span class="pre">src/lr-wpan/examples/</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-data.cc</span></code>:  A simple example showing end-to-end data transfer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-error-distance-plot.cc</span></code>:  An example to plot variations of the packet success ratio as a function of distance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-per-plot.cc</span></code>: An example to plot the theoretical and experimental packet error rate (PER) as a function of receive signal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-error-model-plot.cc</span></code>:  An example to test the phy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-packet-print.cc</span></code>:  An example to print out the MAC header fields.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-phy-test.cc</span></code>:  An example to test the phy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-ed-scan.cc</span></code>:  Simple example showing the use of energy detection (ED) scan in the MAC.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-active-scan.cc</span></code>:  A simple example showing the use of an active scan in the MAC.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-mlme.cc</span></code>: Demonstrates the use of lr-wpan beacon mode. Nodes use a manual association (i.e. No bootstrap) in this example.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-bootstrap.cc</span></code>:  Demonstrates the use of scanning and association working together to initiate a PAN.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-orphan-scan.cc</span></code>: Demonstrates the use of an orphan scanning in a simple network joining procedure.</p></li>
</ul>
<p>In particular, the module enables a very simplified end-to-end data
transfer scenario, implemented in <code class="docutils literal notranslate"><span class="pre">lr-wpan-data.cc</span></code>.  The figure
shows a sequence of events that are triggered when the MAC receives
a DataRequest from the higher layer.  It invokes a Clear Channel
Assessment (CCA) from the PHY, and if successful, sends the frame
down to the PHY where it is transmitted over the channel and results
in a DataIndication on the peer node.</p>
<figure class="align-default" id="id5">
<span id="fig-lr-wpan-data"></span><img alt="_images/lr-wpan-data-example.png" src="_images/lr-wpan-data-example.png" />
<figcaption>
<p><span class="caption-text">Data example for simple LR-WPAN data transfer end-to-end</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The example <code class="docutils literal notranslate"><span class="pre">lr-wpan-error-distance-plot.cc</span></code> plots the packet success
ratio (PSR) as a function of distance, using the default LogDistance
propagation loss model and the 802.15.4 error model.  The channel (default 11),
packet size (default PSDU 20 bytes = 11 bytes MAC header + data payload), transmit power (default 0 dBm)
and Rx sensitivity (default -106.58 dBm) can be varied by command line arguments.
The program outputs a file named <code class="docutils literal notranslate"><span class="pre">802.15.4-psr-distance.plt</span></code>.
Loading this file into gnuplot yields a file <code class="docutils literal notranslate"><span class="pre">802.15.4-psr-distance.eps</span></code>, which can
be converted to pdf or other formats.  The following image shows the output
of multiple runs using different Rx sensitivity values. A higher Rx sensitivity (lower dBm) results
in a increased communication distance but also makes the radio suceptible to more interference from
surronding devices.</p>
<figure class="align-default" id="id6">
<span id="fig-802-15-4-psr-distance"></span><img alt="_images/802-15-4-psr-distance.png" src="_images/802-15-4-psr-distance.png" />
<figcaption>
<p><span class="caption-text">Default output of the program <code class="docutils literal notranslate"><span class="pre">lr-wpan-error-distance-plot.cc</span></code></span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="tests">
<h4><span class="section-number">19.2.4. </span>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h4>
<p>The following tests have been written, which can be found in <code class="docutils literal notranslate"><span class="pre">src/lr-wpan/tests/</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-ack-test.cc</span></code>:  Check that acknowledgments are being used and issued in the correct order.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-collision-test.cc</span></code>:  Test correct reception of packets with interference and collisions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-error-model-test.cc</span></code>:  Check that the error model gives predictable values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-packet-test.cc</span></code>:  Test the 802.15.4 MAC header/trailer classes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-pd-plme-sap-test.cc</span></code>:  Test the PLME and PD SAP per IEEE 802.15.4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-spectrum-value-helper-test.cc</span></code>:  Test that the conversion between power (expressed as a scalar quantity) and spectral power, and back again, falls within a 25% tolerance across the range of possible channels and input powers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-ifs-test.cc</span></code>:  Check that the Intraframe Spaces (IFS) are being used and issued in the correct order.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr-wpan-slotted-csmaca-test.cc</span></code>:  Test the transmission and deferring of data packets in the Contention Access Period (CAP) for the slotted CSMA/CA (beacon-enabled mode).</p></li>
</ul>
</section>
</section>
<section id="validation">
<h3><span class="section-number">19.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The model has not been validated against real hardware.  The error model
has been validated against the data in IEEE Std 802.15.4-2006,
section E.4.1.7 (Figure E.2). The MAC behavior (CSMA backoff) has been
validated by hand against expected behavior.  The below plot is an example
of the error model validation and can be reproduced by running
<code class="docutils literal notranslate"><span class="pre">lr-wpan-error-model-plot.cc</span></code>:</p>
<figure class="align-default" id="id7">
<span id="fig-802-15-4-ber"></span><img alt="_images/802-15-4-ber.png" src="_images/802-15-4-ber.png" />
<figcaption>
<p><span class="caption-text">Default output of the program <code class="docutils literal notranslate"><span class="pre">lr-wpan-error-model-plot.cc</span></code></span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<span id="document-lte"></span><section id="lte-module">
<h2><span class="section-number">20. </span>LTE Module<a class="headerlink" href="#lte-module" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-lte-design"></span><section id="design-documentation">
<h3><span class="section-number">20.1. </span>Design Documentation<a class="headerlink" href="#design-documentation" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4><span class="section-number">20.1.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>An overview of the  LTE-EPC simulation model is depicted in
the figure <a class="reference internal" href="#fig-epc-topology"><span class="std std-ref">Overview of the LTE-EPC simulation model</span></a>. There are two main components:</p>
<blockquote>
<div><ul class="simple">
<li><p>the LTE Model. This model includes the LTE Radio Protocol
stack (RRC, PDCP, RLC, MAC, PHY). These entities reside entirely within the
UE and the eNB nodes.</p></li>
<li><p>the EPC Model. This model includes core network
interfaces, protocols and entities. These entities and protocols
reside within the SGW, PGW and MME nodes, and partially within the
eNB nodes.</p></li>
</ul>
</div></blockquote>
<figure class="align-center" id="id143">
<span id="fig-epc-topology"></span><img alt="_images/epc-topology-with-split.png" src="_images/epc-topology-with-split.png" />
<figcaption>
<p><span class="caption-text">Overview of the LTE-EPC simulation model</span><a class="headerlink" href="#id143" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="design-criteria">
<span id="sec-design-criteria"></span><h4><span class="section-number">20.1.2. </span>Design Criteria<a class="headerlink" href="#design-criteria" title="Link to this heading">¶</a></h4>
<section id="lte-model">
<h5><span class="section-number">20.1.2.1. </span>LTE Model<a class="headerlink" href="#lte-model" title="Link to this heading">¶</a></h5>
<p>The LTE model has been designed to support the evaluation of the following aspects of LTE systems:</p>
<blockquote>
<div><ul class="simple">
<li><p>Radio Resource Management</p></li>
<li><p>QoS-aware Packet Scheduling</p></li>
<li><p>Inter-cell Interference Coordination</p></li>
<li><p>Dynamic Spectrum Access</p></li>
</ul>
</div></blockquote>
<p>In order to model LTE systems to a level of detail that is sufficient to allow a
correct evaluation of the above mentioned aspects, the following requirements
have been considered:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>At the radio level, the granularity of the model should be at least that
of the Resource Block (RB). In fact, this is the fundamental unit being used for
resource allocation. Without this minimum level of granularity, it is not
possible to model accurately packet scheduling and
inter-cell-interference.
The reason is that, since packet scheduling is done on
a per-RB basis, an eNB might transmit on a subset only of all the available
RBs, hence interfering with other eNBs only on those RBs where it is
transmitting.
Note that this requirement rules out the adoption of a system level simulation
approach, which evaluates resource allocation only at the granularity of
call/bearer establishment.</p></li>
<li><p>The simulator should scale up to tens of eNBs and hundreds of User
Equipment (UEs). This
rules out the use of a link level simulator, i.e., a simulator whose radio
interface is modeled with a granularity up to the symbol level. This is because
to have a symbol level model it is necessary to implement all the PHY
layer signal processing, whose huge computational complexity severely limits
simulation. In fact, link-level simulators are normally limited to a single eNB
and one or a few UEs.</p></li>
<li><p>It should be possible within the simulation to configure different cells
so that they use different carrier frequencies and system bandwidths. The
bandwidth used by different cells should be allowed to overlap, in order to
support dynamic spectrum licensing solutions such as those described
in <a class="reference internal" href="index.html#ofcom2600mhz" id="id1"><span>[Ofcom2600MHz]</span></a> and <a class="reference internal" href="index.html#realwireless" id="id2"><span>[RealWireless]</span></a>. The calculation of interference should
handle appropriately this case.</p></li>
<li><p>To be more representative of the LTE standard, as well as to be as
close as possible to real-world implementations, the simulator
should support the MAC Scheduler API published by the FemtoForum
<a class="reference internal" href="index.html#ffapi" id="id3"><span>[FFAPI]</span></a>. This interface is expected to be used by femtocell manufacturers
for the implementation of scheduling and Radio Resource Management
(RRM) algorithms. By introducing support for this interface in the
simulator, we make it possible for LTE equipment vendors and
operators to test in a simulative environment exactly the same
algorithms that would be deployed in a real system.</p></li>
<li><p>The LTE simulation model should contain its own implementation of
the API defined in <a class="reference internal" href="index.html#ffapi" id="id4"><span>[FFAPI]</span></a>. Neither
binary nor data structure compatibility with vendor-specific implementations
of the same interface are expected; hence, a compatibility layer should be
interposed whenever a vendor-specific MAC scheduler is to be used
with the simulator. This requirement is necessary to allow the
simulator to be independent from vendor-specific implementations of this
interface specification. We note that <a class="reference internal" href="index.html#ffapi" id="id5"><span>[FFAPI]</span></a> is a logical
specification only, and its implementation (e.g., translation to some specific
programming language) is left to the vendors.</p></li>
<li><p>The model is to be used to simulate the transmission of IP packets
by the upper layers. With this respect, it shall be considered
that in LTE the Scheduling and Radio Resource Management do not
work with IP packets directly, but rather with RLC PDUs, which are
obtained by segmentation and concatenation of IP packets done by
the RLC entities. Hence, these functionalities of the RLC layer
should be modeled accurately.</p></li>
</ol>
</div></blockquote>
</section>
<section id="epc-model">
<h5><span class="section-number">20.1.2.2. </span>EPC Model<a class="headerlink" href="#epc-model" title="Link to this heading">¶</a></h5>
<p>The main objective of the EPC model is to provides means for the
simulation of end-to-end IP connectivity over the LTE model.
To this aim, it supports for the
interconnection of multiple UEs to the Internet, via a radio access
network of multiple eNBs connected to the core network, as shown
in Figure <a class="reference internal" href="#fig-epc-topology"><span class="std std-ref">Overview of the LTE-EPC simulation model</span></a>.</p>
<p>The following design choices have been made for the EPC model:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The Packet Data Network (PDN) type supported is both IPv4 and IPv6.
In other words, the end-to-end connections between the UEs and the remote
hosts can be IPv4 and IPv6. However, the networks between the core network
elements (MME, SGWs and PGWs) are IPv4-only.</p></li>
<li><p>The SGW and PGW functional entities are implemented in different
nodes, which are hence referred to as the SGW node and PGW node,
respectively.</p></li>
<li><p>The MME functional entities is implemented as a network node,
which is hence referred to as the MME node.</p></li>
<li><p>The scenarios with inter-SGW mobility are not of interest. But
several SGW nodes may be present in simulations scenarios.</p></li>
<li><p>A requirement for the EPC model is that it can be used to simulate the
end-to-end performance of realistic applications. Hence, it should
be possible to use with the EPC model any regular ns-3 application
working on top of TCP or UDP.</p></li>
<li><p>Another requirement is the possibility of simulating network topologies
with the presence of multiple eNBs, some of which might be
equipped with a backhaul connection with limited capabilities. In
order to simulate such scenarios, the user data plane
protocols being used between the eNBs and the SGW should be
modeled accurately.</p></li>
<li><p>It should be possible for a single UE to use different applications
with different QoS profiles. Hence, multiple EPS bearers should be
supported for each UE. This includes the necessary classification
of TCP/UDP traffic over IP done at the UE in the uplink and at the
PGW in the downlink.</p></li>
<li><p>The initial focus of the EPC model is mainly on the EPC data plane.
The accurate modeling of the EPC control plane is,
for the time being, not a requirement; however, the necessary control
plane interactions among the different network nodes of the core network
are realized by implementing control protocols/messages among them.
Direct interaction among the different simulation objects via the
provided helper objects should be avoided as much as possible.</p></li>
<li><p>The focus of the EPC model is on simulations of active users in ECM
connected mode. Hence, all the functionality that is only relevant
for ECM idle mode (in particular, tracking area update and paging)
are not modeled at all.</p></li>
<li><p>The model should allow the possibility to perform an X2-based
handover between two eNBs.</p></li>
</ol>
</div></blockquote>
</section>
</section>
<section id="architecture">
<span id="sec-overall-architecture"></span><h4><span class="section-number">20.1.3. </span>Architecture<a class="headerlink" href="#architecture" title="Link to this heading">¶</a></h4>
<section id="id6">
<h5><span class="section-number">20.1.3.1. </span>LTE Model<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h5>
<section id="ue-architecture">
<h6><span class="section-number">20.1.3.1.1. </span>UE architecture<a class="headerlink" href="#ue-architecture" title="Link to this heading">¶</a></h6>
<p>The architecture of the LTE radio protocol stack model of the UE is
represented in the figures <a class="reference internal" href="#fig-lte-arch-ue-data"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the data plane</span></a> and
<a class="reference internal" href="#fig-lte-arch-ue-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the control plane</span></a> which highlight respectively the data
plane and the control plane.</p>
<figure class="align-center" id="id144">
<span id="fig-lte-arch-ue-data"></span><img alt="_images/lte-arch-ue-data.png" src="_images/lte-arch-ue-data.png" />
<figcaption>
<p><span class="caption-text">LTE radio protocol stack architecture for the UE on the data plane</span><a class="headerlink" href="#id144" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id145">
<span id="fig-lte-arch-ue-ctrl"></span><img alt="_images/lte-arch-ue-ctrl.png" src="_images/lte-arch-ue-ctrl.png" />
<figcaption>
<p><span class="caption-text">LTE radio protocol stack architecture for the UE on the control plane</span><a class="headerlink" href="#id145" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The architecture of the PHY/channel model of the UE is represented in figure <a class="reference internal" href="#fig-lte-ue-phy"><span class="std std-ref">PHY and channel model architecture for the UE</span></a>.</p>
<figure class="align-center" id="id146">
<span id="fig-lte-ue-phy"></span><img alt="_images/lte-ue-phy.png" src="_images/lte-ue-phy.png" />
<figcaption>
<p><span class="caption-text">PHY and channel model architecture for the UE</span><a class="headerlink" href="#id146" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="enb-architecture">
<h6><span class="section-number">20.1.3.1.2. </span>eNB architecture<a class="headerlink" href="#enb-architecture" title="Link to this heading">¶</a></h6>
<p>The architecture of the LTE radio protocol stack model of the eNB is
represented in the figures <a class="reference internal" href="#fig-lte-arch-enb-data"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the data plane</span></a> and
<a class="reference internal" href="#fig-lte-arch-enb-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the control plane</span></a> which highlight respectively the data plane
and the control plane.</p>
<figure class="align-center" id="id147">
<span id="fig-lte-arch-enb-data"></span><img alt="_images/lte-arch-enb-data.png" src="_images/lte-arch-enb-data.png" />
<figcaption>
<p><span class="caption-text">LTE radio protocol stack architecture for the eNB on the data plane</span><a class="headerlink" href="#id147" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id148">
<span id="fig-lte-arch-enb-ctrl"></span><img alt="_images/lte-arch-enb-ctrl.png" src="_images/lte-arch-enb-ctrl.png" />
<figcaption>
<p><span class="caption-text">LTE radio protocol stack architecture for the eNB on the control plane</span><a class="headerlink" href="#id148" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The architecture of the PHY/channel model of the eNB is represented in figure <a class="reference internal" href="#fig-lte-enb-phy"><span class="std std-ref">PHY and channel model architecture for the eNB</span></a>.</p>
<figure class="align-center" id="id149">
<span id="fig-lte-enb-phy"></span><img alt="_images/lte-enb-phy.png" src="_images/lte-enb-phy.png" />
<figcaption>
<p><span class="caption-text">PHY and channel model architecture for the eNB</span><a class="headerlink" href="#id149" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="id7">
<h5><span class="section-number">20.1.3.2. </span>EPC Model<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h5>
<section id="epc-data-plane">
<h6><span class="section-number">20.1.3.2.1. </span>EPC data plane<a class="headerlink" href="#epc-data-plane" title="Link to this heading">¶</a></h6>
<p>In Figure <a class="reference internal" href="#fig-lte-epc-e2e-data-protocol-stack-with-split"><span class="std std-ref">LTE-EPC data plane protocol stack</span></a>, we represent the
end-to-end LTE-EPC data plane protocol stack as it is modeled in the
simulator. The figure shows all nodes in the data path, i.e. UE, eNB,
SGW, PGW and a remote host in the Internet. All protocol stacks
(S5 protocol stack, S1-U protocol stack and the LTE radio protocol stack)
specified by 3GPP are present.</p>
<figure class="align-center" id="id150">
<span id="fig-lte-epc-e2e-data-protocol-stack-with-split"></span><img alt="_images/lte-epc-e2e-data-protocol-stack-with-split.png" src="_images/lte-epc-e2e-data-protocol-stack-with-split.png" />
<figcaption>
<p><span class="caption-text">LTE-EPC data plane protocol stack</span><a class="headerlink" href="#id150" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="epc-control-plane">
<h6><span class="section-number">20.1.3.2.2. </span>EPC control plane<a class="headerlink" href="#epc-control-plane" title="Link to this heading">¶</a></h6>
<p>The architecture of the implementation of the control plane model is
shown in figure <a class="reference internal" href="#fig-lte-epc-e2e-control-protocol-stack-with-split"><span class="std std-ref">LTE-EPC control plane protocol stack</span></a>.
The control interfaces that are modeled explicitly are the S1-MME, the S11, and the S5
interfaces. The X2 interface is also modeled explicitly and it is described in more
detail in section <a class="reference internal" href="#sec-x2"><span class="std std-ref">X2</span></a></p>
<p>The S1-MME, the S11 and the S5 interfaces are modeled using procotol data units sent
over its respective links. These interfaces use the SCTP protocol as transport protocol
but currently, the SCTP protocol is not modeled in the ns-3 simulator, so the
UDP protocol is used instead of the SCTP protocol.</p>
<figure class="align-center" id="id151">
<span id="fig-lte-epc-e2e-control-protocol-stack-with-split"></span><img alt="_images/lte-epc-e2e-control-protocol-stack-with-split.png" src="_images/lte-epc-e2e-control-protocol-stack-with-split.png" />
<figcaption>
<p><span class="caption-text">LTE-EPC control plane protocol stack</span><a class="headerlink" href="#id151" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="channel-and-propagation">
<h4><span class="section-number">20.1.4. </span>Channel and Propagation<a class="headerlink" href="#channel-and-propagation" title="Link to this heading">¶</a></h4>
<p>For channel modeling purposes, the LTE module uses the <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code>
interface provided by the spectrum module. At the time of this
writing, two implementations of such interface are available:
<code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code>, and the
LTE module requires the use of the <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> in
order to work properly. This is because of the need to support
different frequency and bandwidth configurations. All the
propagation models supported by <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> can be
used within the LTE module.</p>
<section id="use-of-the-buildings-model-with-lte">
<h5><span class="section-number">20.1.4.1. </span>Use of the Buildings model with LTE<a class="headerlink" href="#use-of-the-buildings-model-with-lte" title="Link to this heading">¶</a></h5>
<p>The recommended propagation model to be used with the LTE
module is the one provided by the Buildings module, which was in fact
designed specifically with LTE (though it can be used with other
wireless technologies as well). Please refer to the documentation of
the Buildings module for generic information on the propagation model
it provides.</p>
<p>In this section we will highlight some considerations that
specifically apply when the Buildings module is used together with the
LTE module.</p>
<p>The naming convention used in the following will be:</p>
<blockquote>
<div><ul class="simple">
<li><p>User equipment:  UE</p></li>
<li><p>Macro Base Station: MBS</p></li>
<li><p>Small cell Base Station (e.g., pico/femtocell): SC</p></li>
</ul>
</div></blockquote>
<p>The LTE module considers FDD only, and implements downlink and uplink propagation separately. As a consequence, the following pathloss computations are performed</p>
<blockquote>
<div><ul class="simple">
<li><p>MBS &lt;-&gt; UE (indoor and outdoor)</p></li>
<li><p>SC (indoor and outdoor) &lt;-&gt; UE (indoor and outdoor)</p></li>
</ul>
</div></blockquote>
<p>The LTE model does not provide the following pathloss computations:</p>
<blockquote>
<div><ul class="simple">
<li><p>UE &lt;-&gt; UE</p></li>
<li><p>MBS &lt;-&gt; MBS</p></li>
<li><p>MBS &lt;-&gt; SC</p></li>
<li><p>SC &lt;-&gt; SC</p></li>
</ul>
</div></blockquote>
<p>The Buildings model does not know the actual type of the node; i.e.,
it is not aware of whether a transmitter node is a UE, a MBS, or a
SC. Rather, the Buildings model only cares about the position of the
node: whether it is indoor and outdoor, and what is its z-axis respect
to the rooftop level. As a consequence, for an eNB node that is placed
outdoor and at a z-coordinate above the rooftop level, the propagation
models typical of MBS will be used by the Buildings
module. Conversely, for an eNB that is placed outdoor but below the
rooftop,  or indoor, the propagation models typical of pico and
femtocells will be used.</p>
<p>For communications involving at least one indoor node, the
corresponding wall penetration losses will be calculated by the
Buildings model. This covers the following use cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>MBS &lt;-&gt; indoor UE</p></li>
<li><p>outdoor SC &lt;-&gt; indoor UE</p></li>
<li><p>indoor SC &lt;-&gt; indoor UE</p></li>
<li><p>indoor SC &lt;-&gt; outdoor UE</p></li>
</ul>
</div></blockquote>
<p>Please refer to the documentation of the Buildings module for details
on the actual models used in each case.</p>
</section>
<section id="fading-model">
<span id="sec-fading-model"></span><h5><span class="section-number">20.1.4.2. </span>Fading Model<a class="headerlink" href="#fading-model" title="Link to this heading">¶</a></h5>
<p>The LTE module includes a trace-based fading model derived from the one developed during the GSoC 2010 <a class="reference internal" href="index.html#piro2011" id="id8"><span>[Piro2011]</span></a>. The main characteristic of this model is the fact that the fading evaluation during simulation run-time is based on per-calculated traces. This is done to limit the computational complexity of the simulator. On the other hand, it needs huge structures for storing the traces; therefore, a trade-off between the number of possible parameters and the memory occupancy has to be found. The most important ones are:</p>
<blockquote>
<div><ul class="simple">
<li><p>users’ speed: relative speed between users (affects the Doppler frequency, which in turns affects the time-variance property of the fading)</p></li>
<li><p>number of taps (and relative power): number of multiple paths considered, which affects the frequency property of the fading.</p></li>
<li><p>time granularity of the trace: sampling time of the trace.</p></li>
<li><p>frequency granularity of the trace: number of values in frequency to be evaluated.</p></li>
<li><p>length of trace: ideally large as the simulation time, might be reduced by windowing mechanism.</p></li>
<li><p>number of users: number of independent traces to be used (ideally one trace per user).</p></li>
</ul>
</div></blockquote>
<p>With respect to the mathematical channel propagation model, we suggest the one provided by the <code class="docutils literal notranslate"><span class="pre">rayleighchan</span></code> function of Matlab, since it provides a well accepted channel modelization both in time and frequency domain. For more information, the reader is referred to  <a class="reference internal" href="index.html#mathworks" id="id9"><span>[mathworks]</span></a>.</p>
<p>The simulator provides a matlab script (<code class="docutils literal notranslate"><span class="pre">src/lte/model/fading-traces/fading-trace-generator.m</span></code>) for generating traces based on the format used by the simulator.
In detail, the channel object created with the rayleighchan function is used for filtering a discrete-time impulse signal in order to obtain the channel impulse response. The filtering is repeated for different TTI, thus yielding subsequent time-correlated channel responses (one per TTI). The channel response is then processed with the <code class="docutils literal notranslate"><span class="pre">pwelch</span></code> function for obtaining its power spectral density values, which are then saved in a file with the proper format compatible with the simulator model.</p>
<p>Since the number of variable it is pretty high, generate traces considering all of them might produce a high number of traces of huge size. On this matter, we considered the following assumptions of the parameters based on the 3GPP fading propagation conditions (see Annex B.2 of <a class="reference internal" href="index.html#ts36104" id="id10"><span>[TS36104]</span></a>):</p>
<blockquote>
<div><ul class="simple">
<li><p>users’ speed: typically only a few discrete values are considered, i.e.:</p>
<ul>
<li><p>0 and 3 kmph for pedestrian scenarios</p></li>
<li><p>30 and 60 kmph for vehicular scenarios</p></li>
<li><p>0, 3, 30 and 60 for urban scenarios</p></li>
</ul>
</li>
<li><p>channel taps: only a limited number of sets of channel taps are normally considered, for example three models are mentioned in Annex B.2 of <a class="reference internal" href="index.html#ts36104" id="id11"><span>[TS36104]</span></a>.</p></li>
<li><p>time granularity: we need one fading value per TTI, i.e., every 1 ms (as this is the granularity in time of the ns-3 LTE PHY model).</p></li>
<li><p>frequency granularity: we need one fading value per RB (which is the frequency granularity of the spectrum model used by the ns-3 LTE model).</p></li>
<li><p>length of the trace: the simulator includes the windowing mechanism implemented during the GSoC 2011, which consists of picking up a window of the trace each window length in a random fashion.</p></li>
<li><p>per-user fading process: users share the same fading trace, but for each user a different starting point in the trace is randomly picked up. This choice was made to avoid the need to provide one fading trace per user.</p></li>
</ul>
</div></blockquote>
<p>According to the parameters we considered, the following formula express in detail the total size <img class="math" src="_images/math/7e8fc2514e47c89474c09f0e60bc4347ff27a86f.png" alt="S_{traces}"/> of the fading traces:</p>
<div class="math">
<p><img src="_images/math/e2b5a5ab300c497a9a0fd80fff9f1a4efe80e388.png" alt="S_{traces} = S_{sample} \times N_{RB} \times \frac{T_{trace}}{T_{sample}} \times N_{scenarios} \mbox{ [bytes]}"/></p>
</div><p>where <img class="math" src="_images/math/792331b81b1f05472af9f2609963de330f87f6ce.png" alt="S_{sample}"/> is the size in bytes of the sample (e.g., 8 in case of double precision, 4 in case of float precision), <img class="math" src="_images/math/049f11949db10818eace89509bc5e593b87cb37a.png" alt="N_{RB}"/> is the number of RB or set of RBs to be considered, <img class="math" src="_images/math/6951ccb723a9067235d9624fdb210b33c55ded54.png" alt="T_{trace}"/> is the total length of the trace, <img class="math" src="_images/math/b0aefca274fa376e150a65fa40a36f1d2f50dd3e.png" alt="T_{sample}"/> is the time resolution of the trace (1 ms), and <img class="math" src="_images/math/2ef05794582db9d0f9d63b2f18c9364084c98313.png" alt="N_{scenarios}"/> is the number of fading scenarios that are desired (i.e., combinations of different sets of channel taps and user speed values). We provide traces for 3 different scenarios one for each taps configuration defined in Annex B.2 of <a class="reference internal" href="index.html#ts36104" id="id12"><span>[TS36104]</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Pedestrian: with nodes’ speed of 3 kmph.</p></li>
<li><p>Vehicular: with nodes’ speed of 60 kmph.</p></li>
<li><p>Urban: with nodes’ speed of 3 kmph.</p></li>
</ul>
</div></blockquote>
<p>hence <img class="math" src="_images/math/527d42178112aecc8f53d09e873d34644e199c9d.png" alt="N_{scenarios} = 3"/>. All traces have <img class="math" src="_images/math/726fc6789f8ccce116bb761beaf87942248b063a.png" alt="T_{trace} = 10"/> s and <img class="math" src="_images/math/61624b56a435c045834ad77eef63bd8cbfe764be.png" alt="RB_{NUM} = 100"/>. This results in a total 24 MB bytes of traces.</p>
</section>
<section id="antennas">
<h5><span class="section-number">20.1.4.3. </span>Antennas<a class="headerlink" href="#antennas" title="Link to this heading">¶</a></h5>
<p>Being based on the <code class="docutils literal notranslate"><span class="pre">SpectrumPhy</span></code>, the LTE PHY model supports antenna
modeling via the ns-3 <code class="docutils literal notranslate"><span class="pre">AntennaModel</span></code> class. Hence, any model based on
this class can be associated with any eNB or UE instance. For
instance, the use of the <code class="docutils literal notranslate"><span class="pre">CosineAntennaModel</span></code> associated with an eNB
device allows to model one sector of a macro base station. By default,
the <code class="docutils literal notranslate"><span class="pre">IsotropicAntennaModel</span></code> is used for both eNBs and UEs.</p>
</section>
</section>
<section id="phy">
<h4><span class="section-number">20.1.5. </span>PHY<a class="headerlink" href="#phy" title="Link to this heading">¶</a></h4>
<section id="id13">
<h5><span class="section-number">20.1.5.1. </span>Overview<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h5>
<p>The physical layer model provided in this LTE simulator is based on
the one described in <a class="reference internal" href="index.html#piro2011" id="id14"><span>[Piro2011]</span></a>, with the following modifications.  The model now includes the
inter cell interference calculation and the simulation of uplink traffic, including both packet transmission and CQI generation.</p>
</section>
<section id="subframe-structure">
<h5><span class="section-number">20.1.5.2. </span>Subframe Structure<a class="headerlink" href="#subframe-structure" title="Link to this heading">¶</a></h5>
<p>The subframe is divided into control and data part as described in Figure <a class="reference internal" href="#fig-lte-subframe-structure"><span class="std std-ref">LTE subframe division.</span></a>.</p>
<figure class="align-center" id="id152">
<span id="fig-lte-subframe-structure"></span><a class="reference internal image-reference" href="_images/lte-subframe-structure.png"><img alt="_images/lte-subframe-structure.png" src="_images/lte-subframe-structure.png" style="width: 300px;" /></a>
<figcaption>
<p><span class="caption-text">LTE subframe division.</span><a class="headerlink" href="#id152" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Considering the granularity of the simulator based on RB, the control and the reference signaling have to be consequently modeled considering this constraint.  According to the standard <a class="reference internal" href="index.html#ts36211" id="id15"><span>[TS36211]</span></a>, the downlink control frame starts at the beginning of each subframe and lasts up to three symbols across the whole system bandwidth, where the actual duration is provided by the Physical Control Format Indicator Channel (PCFICH). The information on the allocation are then mapped in the remaining resource up to the duration defined by the PCFICH, in the so called Physical Downlink Control Channel (PDCCH). A PDCCH transports a single message called Downlink Control Information (DCI) coming from the MAC layer, where the scheduler indicates the resource allocation for a specific user.
The PCFICH and PDCCH are modeled with the transmission of the control frame of a fixed duration of 3/14 of milliseconds spanning in the whole available bandwidth, since the scheduler does not estimate the size of the control region. This implies that a single transmission block models the entire control frame with a fixed power (i.e., the one used for the PDSCH) across all the available RBs. According to this feature, this transmission represents also a valuable support for the Reference Signal (RS). This allows of having every TTI an evaluation of the interference scenario since all the eNB are transmitting (simultaneously) the control frame over the respective available bandwidths. We note that, the model does not include the power boosting since it does not reflect any improvement in the implemented model of the channel estimation.</p>
<p>The Sounding Reference Signal (SRS) is modeled similar to the downlink control frame. The SRS is periodically placed in the last symbol of the subframe in the whole system bandwidth. The RRC module already includes an algorithm for dynamically assigning the periodicity as function of the actual number of UEs attached to a eNB according to the UE-specific procedure (see Section 8.2 of <a class="reference internal" href="index.html#ts36213" id="id16"><span>[TS36213]</span></a>).</p>
</section>
<section id="mac-to-channel-delay">
<h5><span class="section-number">20.1.5.3. </span>MAC to Channel delay<a class="headerlink" href="#mac-to-channel-delay" title="Link to this heading">¶</a></h5>
<p>To model the latency of real MAC and PHY implementations, the PHY model simulates a MAC-to-channel delay in multiples of TTIs (1ms). The transmission of both data and control packets are delayed by this amount.</p>
</section>
<section id="cqi-feedback">
<span id="sec-cqi-feedback"></span><h5><span class="section-number">20.1.5.4. </span>CQI feedback<a class="headerlink" href="#cqi-feedback" title="Link to this heading">¶</a></h5>
<p>The generation of CQI feedback is done accordingly to what specified in <a class="reference internal" href="index.html#ffapi" id="id17"><span>[FFAPI]</span></a>. In detail, we considered the generation
of periodic wideband CQI (i.e., a single value of channel state that is deemed representative of all RBs
in use) and inband CQIs (i.e., a set of value representing the channel state for each RB).</p>
<p>The CQI index to be reported is obtained by first obtaining a SINR measurement and then passing this SINR measurement to the <a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a> module which will map it to the CQI index.</p>
<p>In downlink, the SINR used to generate CQI feedback can be calculated in two different ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><em>Ctrl</em> method: SINR is calculated combining the signal power from the reference signals (which in the simulation is equivalent to the PDCCH) and the interference power from the PDCCH. This approach results in considering any neighboring eNB as an interferer, regardless of whether this eNB is actually performing any PDSCH transmission, and regardless of the power and RBs used for eventual interfering PDSCH transmissions.</p></li>
<li><p><em>Mixed</em> method: SINR is calculated combining the signal power from the reference signals (which in the simulation is equivalent to the PDCCH) and the interference power from the PDSCH. This approach results in considering as interferers only those neighboring eNBs that are actively transmitting data on the PDSCH, and allows to generate inband CQIs that account for different amounts of interference on different RBs according to the actual interference level. In the case that no PDSCH transmission is performed by any eNB, this method consider that interference is zero, i.e., the SINR will be calculated as the ratio of signal to noise only.</p></li>
</ol>
</div></blockquote>
<p>To switch between this two CQI generation approaches, <code class="docutils literal notranslate"><span class="pre">LteHelper::UsePdschForCqiGeneration</span></code> needs to be configured: false for first approach and true for second approach (true is default value):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteHelper::UsePdschForCqiGeneration&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>In uplink, two types of CQIs are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p>SRS based, periodically sent by the UEs.</p></li>
<li><p>PUSCH based, calculated from the actual transmitted data.</p></li>
</ul>
</div></blockquote>
<p>The scheduler interface include an attribute system called <code class="docutils literal notranslate"><span class="pre">UlCqiFilter</span></code> for managing the filtering of the CQIs according to their nature, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SRS_UL_CQI</span></code> for storing only SRS based CQIs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PUSCH_UL_CQI</span></code> for storing only PUSCH based CQIs.</p></li>
</ul>
</div></blockquote>
<p>It has to be noted that, the <code class="docutils literal notranslate"><span class="pre">FfMacScheduler</span></code> provides only the interface and it is matter of the actual scheduler implementation to include the code for managing these attributes (see scheduler related section for more information on this matter).</p>
</section>
<section id="interference-model">
<h5><span class="section-number">20.1.5.5. </span>Interference Model<a class="headerlink" href="#interference-model" title="Link to this heading">¶</a></h5>
<p>The PHY model is based on the well-known Gaussian interference models, according to which the powers of interfering signals (in linear units) are summed up together to determine the overall interference power.</p>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-phy-interference"><span class="std std-ref">Sequence diagram of the PHY interference calculation procedure</span></a> shows how interfering signals are processed to calculate the SINR, and how SINR is then used for the generation of CQI feedback.</p>
<figure class="align-center" id="id153">
<span id="fig-lte-phy-interference"></span><img alt="_images/lte-phy-interference.png" src="_images/lte-phy-interference.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the PHY interference calculation procedure</span><a class="headerlink" href="#id153" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="lte-spectrum-model">
<h5><span class="section-number">20.1.5.6. </span>LTE Spectrum Model<a class="headerlink" href="#lte-spectrum-model" title="Link to this heading">¶</a></h5>
<p>The usage of the radio spectrum by eNBs and UEs in LTE is described in
<a class="reference internal" href="index.html#ts36101" id="id18"><span>[TS36101]</span></a>. In the simulator, radio spectrum usage is modeled as follows.
Let <img class="math" src="_images/math/f3c754ede5a325f045a10fe57b2f387ad53341c4.png" alt="f_c"/> denote the  LTE Absolute Radio Frequency Channel Number, which
identifies the carrier frequency on a 100 kHz raster; furthermore, let <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> be
the Transmission Bandwidth Configuration in number of Resource Blocks. For every
pair <img class="math" src="_images/math/9d866536d78f493deb5e76b2a90cb76e6f034bff.png" alt="(f_c,B)"/> used in the simulation we define a corresponding SpectrumModel using
the functionality provided by the <a class="reference internal" href="index.html#sec-spectrum-module"><span class="std std-ref">Spectrum Module</span></a> .
model using the Spectrum framework described
in <a class="reference internal" href="index.html#baldo2009" id="id19"><span>[Baldo2009]</span></a>.  <img class="math" src="_images/math/f3c754ede5a325f045a10fe57b2f387ad53341c4.png" alt="f_c"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> can be configured for every eNB instantiated
in the simulation; hence, each eNB can use a different spectrum model. Every UE
will automatically use the spectrum model of the eNB it is attached to. Using
the MultiModelSpectrumChannel described in <a class="reference internal" href="index.html#baldo2009" id="id20"><span>[Baldo2009]</span></a>, the interference
among eNBs that use different spectrum models is properly accounted for.
This allows to simulate dynamic spectrum access policies, such as for
example the spectrum licensing policies that are
discussed in <a class="reference internal" href="index.html#ofcom2600mhz" id="id21"><span>[Ofcom2600MHz]</span></a>.</p>
</section>
<section id="data-phy-error-model">
<h5><span class="section-number">20.1.5.7. </span>Data PHY Error Model<a class="headerlink" href="#data-phy-error-model" title="Link to this heading">¶</a></h5>
<p>The simulator includes an error model of the data plane (i.e., PDSCH and PUSCH) according to the standard link-to-system mapping (LSM) techniques. The choice is aligned with the standard system simulation methodology of OFDMA  radio transmission technology. Thanks to LSM we are able to maintain a good level of accuracy and at the same time limiting the computational complexity increase. It is based on the mapping of single link layer performance obtained by means of link level simulators to system (in our case network) simulators. In particular link the layer simulator is used for generating the performance of a single link from a PHY layer perspective, usually in terms of code block error rate (BLER), under specific static conditions. LSM allows the usage of these parameters in more complex scenarios, typical of system/network simulators, where we have more links, interference and “colored” channel propagation phenomena (e.g., frequency selective fading).</p>
<p>To do this the Vienna LTE Simulator <a class="reference internal" href="index.html#viennaltesim" id="id22"><span>[ViennaLteSim]</span></a> has been used for what concerns the extraction of link layer performance and the Mutual Information Based Effective SINR (MIESM) as LSM mapping function using part of the work recently published by the Signet Group of University of Padua <a class="reference internal" href="index.html#paduapem" id="id23"><span>[PaduaPEM]</span></a>.</p>
<section id="miesm">
<h6><span class="section-number">20.1.5.7.1. </span>MIESM<a class="headerlink" href="#miesm" title="Link to this heading">¶</a></h6>
<p>The specific LSM method adopted is the one based on the usage of a mutual information metric, commonly referred to as the mutual information per per coded bit (MIB or MMIB when a mean of multiples MIBs is involved). Another option would be represented by the Exponential ESM (EESM); however, recent studies demonstrate that MIESM outperforms EESM in terms of accuracy <a class="reference internal" href="index.html#lozanocost" id="id24"><span>[LozanoCost]</span></a>.</p>
<figure class="align-center" id="id154">
<span id="fig-miesm-architecture"></span><img alt="_images/miesm_scheme.png" src="_images/miesm_scheme.png" />
<figcaption>
<p><span class="caption-text">MIESM computational procedure diagram</span><a class="headerlink" href="#id154" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The mutual information (MI) is dependent on the constellation mapping and can be calculated per transport block (TB) basis, by evaluating the MI over the symbols and the subcarrier. However, this would be too complex for a network simulator. Hence, in our implementation a flat channel response within the RB has been considered; therefore the overall MI of a TB is calculated averaging the MI evaluated per each RB used in the TB. In detail, the implemented scheme is depicted in Figure <a class="reference internal" href="#fig-miesm-architecture"><span class="std std-ref">MIESM computational procedure diagram</span></a>, where we see that the model starts by evaluating the MI value for each RB, represented in the figure by the SINR samples. Then the equivalent MI is evaluated per TB basis by averaging the MI values. Finally, a further step has to be done since the link level simulator returns the performance of the link in terms of block error rate (BLER) in a addive white gaussian noise  (AWGN) channel, where the blocks are the code blocks (CBs) independently encoded/decoded by the turbo encoder. On this matter the
standard 3GPP segmentation scheme has been used for estimating the actual CB size (described in section 5.1.2 of <a class="reference internal" href="index.html#ts36212" id="id25"><span>[TS36212]</span></a>). This scheme divides the TB in <img class="math" src="_images/math/91a52beabdbbbb318c05716194b3b6f6581ce5e7.png" alt="N_{K_-}"/> blocks of size <img class="math" src="_images/math/a4d98c7cad89d97267f3ec34aaf27a35e0f8a032.png" alt="K_-"/> and <img class="math" src="_images/math/26d4e2b3ccb1618508c6f10a00b0cf5c7889184e.png" alt="N_{K+}"/> blocks of size <img class="math" src="_images/math/8a4e09d5c1186bc46049ce9a6d8ec5d7696f8fe9.png" alt="K_+"/>. Therefore the overall TB BLER (TBLER) can be expressed as</p>
<div class="math">
<p><img src="_images/math/fe7293472e5205c1b13e543d1006cb7dd197a548.png" alt="TBLER = 1- \prod\limits_{i=1}^{C}(1-CBLER_i)"/></p>
</div><p>where the <img class="math" src="_images/math/4cbd4f61ccd1be0720110cc6007829810d0bdf9b.png" alt="CBLER_i"/> is the BLER of the CB <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> obtained according to the link level simulator CB BLER curves.
For estimating the <img class="math" src="_images/math/4cbd4f61ccd1be0720110cc6007829810d0bdf9b.png" alt="CBLER_i"/>, the MI evaluation has been implemented according to its numerical approximation defined in <a class="reference internal" href="index.html#wimaxemd" id="id26"><span>[wimaxEmd]</span></a>. Moreover, for reducing the complexity of the computation, the approximation has been converted into lookup tables. In detail, Gaussian cumulative model has been used for approximating the AWGN BLER curves with three parameters which provides a close fit to the standard AWGN performances, in formula:</p>
<div class="math">
<p><img src="_images/math/5034a67ad4e058559b1cda84ee267f88424357b7.png" alt="CBLER_i = \frac{1}{2}\left[1-erf\left(\frac{x-b_{ECR}}{\sqrt{2}c_{ECR}} \right) \right]"/></p>
</div><p>where <img class="math" src="_images/math/888f7c323ac0341871e867220ae2d76467d74d6e.png" alt="x"/> is the MI of the TB, <img class="math" src="_images/math/732a9df735b4b869d7460fd53b1947bad95eeab0.png" alt="b_{ECR}"/> represents the “transition center” and <img class="math" src="_images/math/9f8e2bfac108f33753d7f02507b123124d517e1a.png" alt="c_{ECR}"/> is related to the “transition width” of the Gaussian cumulative distribution for each Effective Code Rate (ECR) which is the actual transmission rate according to the channel coding and MCS. For limiting the computational complexity of the model we considered only a subset of the possible ECRs in fact we would have potentially 5076 possible ECRs (i.e., 27 MCSs and 188 CB sizes). On this respect, we will limit the CB sizes to some representative values (i.e., 40, 140, 160, 256, 512, 1024, 2048, 4032, 6144), while for the others the worst one approximating the real one will be used (i.e., the smaller CB size value available respect to the real one). This choice is aligned to the typical performance of turbo codes, where the CB size is not strongly impacting on the BLER. However, it is to be notes that for CB sizes lower than 1000 bits the effect might be relevant (i.e., till 2 dB); therefore, we adopt
this unbalanced sampling interval for having more precision where it is necessary. This behaviour is confirmed by the figures presented in the Annes Section.</p>
</section>
<section id="bler-curves">
<h6><span class="section-number">20.1.5.7.2. </span>BLER Curves<a class="headerlink" href="#bler-curves" title="Link to this heading">¶</a></h6>
<p>On this respect, we reused part of the curves obtained within <a class="reference internal" href="index.html#paduapem" id="id27"><span>[PaduaPEM]</span></a>. In detail, we introduced the CB size dependency to the CB BLER curves with the support of the developers of <a class="reference internal" href="index.html#paduapem" id="id28"><span>[PaduaPEM]</span></a> and of the LTE Vienna Simulator. In fact, the module released provides the link layer performance only for what concerns the MCSs (i.e, with a given fixed ECR). In detail the new error rate curves for each has been evaluated with a simulation campaign with the link layer simulator for a single link with AWGN noise and for CB size of 104, 140, 256, 512, 1024, 2048, 4032 and 6144. These curves has been mapped with the Gaussian cumulative model formula presented above for obtaining the correspondents <img class="math" src="_images/math/732a9df735b4b869d7460fd53b1947bad95eeab0.png" alt="b_{ECR}"/> and <img class="math" src="_images/math/9f8e2bfac108f33753d7f02507b123124d517e1a.png" alt="c_{ECR}"/> parameters.</p>
<p>The BLER performance of all MCS obtained with the link level simulator are plotted in the following figures (blue lines) together with their correspondent mapping to the Gaussian cumulative distribution (red dashed lines).</p>
<figure class="align-center" id="id155">
<span id="fig-mcs-1-4-ber"></span><img alt="_images/MCS_1_4.png" src="_images/MCS_1_4.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 1, 2, 3 and 4.</span><a class="headerlink" href="#id155" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id156">
<span id="fig-mcs-5-8-ber"></span><img alt="_images/MCS_5_8.png" src="_images/MCS_5_8.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 5, 6, 7 and 8.</span><a class="headerlink" href="#id156" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id157">
<span id="fig-mcs-9-12-ber"></span><img alt="_images/MCS_9_12.png" src="_images/MCS_9_12.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 9, 10, 11 and 12.</span><a class="headerlink" href="#id157" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id158">
<span id="fig-mcs-13-16-ber"></span><img alt="_images/MCS_13_16.png" src="_images/MCS_13_16.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 13, 14, 15 and 16.</span><a class="headerlink" href="#id158" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id159">
<span id="fig-mcs-17-20-ber"></span><img alt="_images/MCS_17_20.png" src="_images/MCS_17_20.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 17, 17, 19 and 20.</span><a class="headerlink" href="#id159" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id160">
<span id="fig-mcs-21-24-ber"></span><img alt="_images/MCS_21_24.png" src="_images/MCS_21_24.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 21, 22, 23 and 24.</span><a class="headerlink" href="#id160" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id161">
<span id="fig-mcs-25-28-ber"></span><img alt="_images/MCS_25_28.png" src="_images/MCS_25_28.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 25, 26, 27 and 28.</span><a class="headerlink" href="#id161" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id162">
<span id="fig-mcs-29-29-ber"></span><img alt="_images/MCS_29_29.png" src="_images/MCS_29_29.png" />
<figcaption>
<p><span class="caption-text">BLER for MCS 29.</span><a class="headerlink" href="#id162" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="integration-of-the-bler-curves-in-the-ns-3-lte-module">
<h6><span class="section-number">20.1.5.7.3. </span>Integration of the BLER curves in the ns-3 LTE module<a class="headerlink" href="#integration-of-the-bler-curves-in-the-ns-3-lte-module" title="Link to this heading">¶</a></h6>
<p>The model implemented uses the curves for the LSM of the recently LTE PHY Error Model released in the ns3 community by the Signet Group <a class="reference internal" href="index.html#paduapem" id="id29"><span>[PaduaPEM]</span></a> and the new ones generated for different CB sizes. The <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> class is in charge of evaluating the TB BLER thanks to the methods provided by the <code class="docutils literal notranslate"><span class="pre">LteMiErrorModel</span></code> class, which is in charge of evaluating the TB BLER according to the vector of the perceived SINR per RB, the MCS and the size in order to proper model the segmentation of the TB in CBs. In order to obtain the vector of the perceived SINRs for data and control signals, two instances of <code class="docutils literal notranslate"><span class="pre">LteChunkProcessor</span></code> (dedicated to evaluate the SINR for obtaining physical error performance) have been attached to UE downlink and eNB uplink <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> modules for evaluating the error model distribution of PDSCH (UE side) and ULSCH (eNB side).</p>
<p>The model can be disabled for working with a zero-losses channel by setting the <code class="docutils literal notranslate"><span class="pre">DataErrorModelEnabled</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> class (by default is active). This can be done according to the standard ns3 attribute system procedure, that is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteSpectrumPhy::DataErrorModelEnabled&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<section id="control-channels-phy-error-model">
<span id="sec-control-channels-phy-error-model"></span><h5><span class="section-number">20.1.5.8. </span>Control Channels PHY Error Model<a class="headerlink" href="#control-channels-phy-error-model" title="Link to this heading">¶</a></h5>
<p>The simulator includes the error model for downlink control channels (PCFICH and PDCCH), while in uplink it is assumed and ideal error-free channel. The model is based on the MIESM approach presented before for considering the effects of the frequency selective channel since most of the control channels span the whole available bandwidth.</p>
<section id="pcfich-pdcch-error-model">
<h6><span class="section-number">20.1.5.8.1. </span>PCFICH + PDCCH Error Model<a class="headerlink" href="#pcfich-pdcch-error-model" title="Link to this heading">¶</a></h6>
<p>The model adopted for the error distribution of these channels is based on an evaluation study carried out in the RAN4 of 3GPP, where different vendors investigated the demodulation performance of the PCFICH jointly with PDCCH. This is due to the fact that the PCFICH is the channel in charge of communicating to the UEs the actual dimension of the PDCCH (which spans between 1 and 3 symbols); therefore the correct decodification of the DCIs  depends on the correct interpretation of both ones. In 3GPP this problem have been evaluated for improving the cell-edge performance <a class="reference internal" href="index.html#fujitsuwhitepaper" id="id30"><span>[FujitsuWhitePaper]</span></a>, where the interference among neighboring cells can be relatively high due to signal degradation. A similar problem has been notices in femto-cell scenario and, more in general, in HetNet scenarios the bottleneck has been detected mainly as the PCFICH channel <a class="reference internal" href="index.html#bharucha2011" id="id31"><span>[Bharucha2011]</span></a>, where in case of many eNBs are deployed in the same service area, this channel may collide in frequency, making impossible the correct detection of
the PDCCH channel, too.</p>
<p>In the simulator, the SINR perceived during the reception has been estimated according to the MIESM model presented above in order to evaluate the error distribution of PCFICH and PDCCH. In detail, the SINR samples of all the RBs are included in the evaluation of the MI associated to the control frame and, according to this values, the effective SINR (eSINR) is obtained by inverting the MI evaluation process. It has to be noted that, in case of MIMO transmission, both PCFICH and the PDCCH use always the transmit diversity mode as defined by the standard. According to the eSINR perceived the decodification error probability can be estimated as function of the results presented in <a class="reference internal" href="index.html#r4-081920" id="id32"><span>[R4-081920]</span></a>. In case an error occur, the DCIs discarded and therefore the UE will be not able to receive the correspondent Tbs, therefore resulting lost.</p>
</section>
</section>
<section id="mimo-model">
<h5><span class="section-number">20.1.5.9. </span>MIMO Model<a class="headerlink" href="#mimo-model" title="Link to this heading">¶</a></h5>
<p>The use of multiple antennas both at transmitter and receiver side, known as multiple-input and multiple-output (MIMO), is a problem well studied in literature during the past years. Most of the work concentrate on evaluating analytically the gain that the different MIMO schemes might have in term of capacity; however someones provide also information of the gain in terms of received power <a class="reference internal" href="index.html#catreuxmimo" id="id33"><span>[CatreuxMIMO]</span></a>.</p>
<p>According to the considerations above, a model more flexible can be obtained considering the gain that MIMO schemes bring in the system from a statistical point of view. As highlighted before, <a class="reference internal" href="index.html#catreuxmimo" id="id34"><span>[CatreuxMIMO]</span></a> presents the statistical gain of several MIMO solutions respect to the SISO one in case of no correlation between the antennas. In the work the gain is presented as the cumulative distribution function (CDF) of the output SINR for what concern SISO, MIMO-Alamouti, MIMO-MMSE, MIMO-OSIC-MMSE and MIMO-ZF schemes. Elaborating the results, the output SINR distribution can be approximated with a log-normal one with different mean and variance as function of the scheme considered. However, the variances are not so different and they are approximately equal to the one of the SISO mode already included in the shadowing component of the <code class="docutils literal notranslate"><span class="pre">BuildingsPropagationLossModel</span></code>, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p>SISO: <img class="math" src="_images/math/438b4c7487e88fedc8ad2f9727e252f099dc4cf9.png" alt="\mu = 13.5"/> and <img class="math" src="_images/math/79e07f025929a14eec7bb2ddfc761665e165699f.png" alt="\sigma = 20"/> [dB].</p></li>
<li><p>MIMO-Alamouti: <img class="math" src="_images/math/280aeca1cf310bbaba6efdab9f59dd9ea6086091.png" alt="\mu = 17.7"/> and <img class="math" src="_images/math/a31fb712d3c1c1a9a30143b90cee8fd93bb082f3.png" alt="\sigma = 11.1"/> [dB].</p></li>
<li><p>MIMO-MMSE: <img class="math" src="_images/math/aca71798f302343aaaa038942afe6f32230eb6ea.png" alt="\mu = 10.7"/> and <img class="math" src="_images/math/062d4950a41ff8323aeb7db28e87e5e388e9bf54.png" alt="\sigma = 16.6"/> [dB].</p></li>
<li><p>MIMO-OSIC-MMSE: <img class="math" src="_images/math/7d62ee9cd1ec616b6e42912cb5ee41810b66dac5.png" alt="\mu = 12.6"/> and <img class="math" src="_images/math/505213c79a60fc0f9b5e11ae021ae9548a2f44b2.png" alt="\sigma = 15.5"/> [dB].</p></li>
<li><p>MIMO-ZF: <img class="math" src="_images/math/5a257340e112ef3c73eaeaa810938bde195940d5.png" alt="\mu = 10.3"/> and <img class="math" src="_images/math/af37942808cd165511f8e57a3f03eed1b6ce394c.png" alt="\sigma = 12.6"/> [dB].</p></li>
</ul>
</div></blockquote>
<p>Therefore the PHY layer implements the MIMO model as the gain perceived by the receiver when using a MIMO scheme respect to the one obtained using SISO one. We note that, these gains referred to a case where there is no correlation between the antennas in MIMO scheme; therefore do not model degradation due to paths correlation.</p>
</section>
<section id="ue-phy-measurements-model">
<span id="sec-phy-ue-measurements"></span><h5><span class="section-number">20.1.5.10. </span>UE PHY Measurements Model<a class="headerlink" href="#ue-phy-measurements-model" title="Link to this heading">¶</a></h5>
<p>According to <a class="reference internal" href="index.html#ts36214" id="id35"><span>[TS36214]</span></a>, the UE has to report a set of measurements of the eNBs that the device is able to perceive: the reference signal received power (RSRP) and the reference signal received quality (RSRQ). The former is a measure of the received power of a specific eNB, while the latter includes also channel interference and thermal noise.
The UE has to report the measurements jointly with the physical cell identity (PCI) of the cell. Both the RSRP and RSRQ measurements are performed during the reception of the RS, while the PCI is obtained with the Primary Synchronization Signal (PSS). The PSS is sent by the eNB each 5 subframes and in detail in the subframes 1 and 6. In real systems, only 504 distinct PCIs are available, and hence it could occur that two nearby eNBs use the same PCI; however, in the simulator we model PCIs using simulation metadata, and we allow up to 65535 distinct PCIs, thereby avoiding PCI collisions provided that less that 65535 eNBs are simulated in the same scenario.</p>
<p>According to <a class="reference internal" href="index.html#ts36133" id="id36"><span>[TS36133]</span></a> sections 9.1.4 and 9.1.7, RSRP is reported by PHY layer in dBm while RSRQ in dB. The values of RSRP and RSRQ are provided to higher layers through the C-PHY SAP (by means of <code class="docutils literal notranslate"><span class="pre">UeMeasurementsParameters</span></code> struct) every 200 ms as defined in <a class="reference internal" href="index.html#ts36331" id="id37"><span>[TS36331]</span></a>. Layer 1 filtering is performed by averaging the all the measurements collected during the last window slot. The periodicity of reporting can be adjusted for research purposes by means of the <code class="docutils literal notranslate"><span class="pre">LteUePhy::UeMeasurementsFilterPeriod</span></code> attribute.</p>
<p>The formulas of the RSRP and RSRQ can be simplified considering the assumption of the PHY layer that the channel is flat within the RB, the finest level of accuracy. In fact, this implies that all the REs within a RB have the same power, therefore:</p>
<div class="math">
<p><img src="_images/math/29197196e4466e201741558622769695435e5aee.png" alt="RSRP = \frac{\sum_{k=0}^{K-1}\frac{\sum_{m=0}^{M-1}(P(k,m))}{M}}{K}
     = \frac{\sum_{k=0}^{K-1}\frac{(M \times P(k))}{M}}{K}
     = \frac{\sum_{k=0}^{K-1}(P(k))}{K}"/></p>
</div><p>where <img class="math" src="_images/math/c4de3b06a294154e6505ff9e622a73b127bd8b52.png" alt="P(k,m)"/> represents the signal power of the RE <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> within the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, which, as observed before, is constant within the same RB and equal to <img class="math" src="_images/math/24a70eb4b8eb2a2d8b616964a01e42f3e5e47476.png" alt="P(k)"/>, <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> is the number of REs carrying the RS in a RB and <img class="math" src="_images/math/52ddc0cde6d632f631533173562fe3ca375b1f32.png" alt="K"/> is the number of RBs. It is to be noted that <img class="math" src="_images/math/24a70eb4b8eb2a2d8b616964a01e42f3e5e47476.png" alt="P(k)"/>, and in general all the powers defined in this section, is obtained in the simulator from the PSD of the RB (which is provided by  the <code class="docutils literal notranslate"><span class="pre">LteInterferencePowerChunkProcessor</span></code>), in detail:</p>
<div class="math">
<p><img src="_images/math/6fa85ae014937b470d89d87bc01c5d68db2fb0ad.png" alt="P(k) = PSD_{RB}(k)*180000/12"/></p>
</div><p>where <img class="math" src="_images/math/96bae5028d0e9bbbf2bd72891903f7857efbea63.png" alt="PSD_{RB}(k)"/> is the power spectral density of the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, <img class="math" src="_images/math/4f8829c93a607985838dc4157a922a0f8898b418.png" alt="180000"/> is the bandwidth in Hz of the RB and <img class="math" src="_images/math/d147c12ac411feac5293f9328d82ee96665a8a9d.png" alt="12"/> is the number of REs per RB in an OFDM symbol.
Similarly, for RSSI we have</p>
<div class="math">
<p><img src="_images/math/1cb764562d1856d031e3e0593fedea30162a1ccc.png" alt="RSSI = \sum_{k=0}^{K-1} \frac{\sum_{s=0}^{S-1} \sum_{r=0}^{R-1}( P(k,s,r) + I(k,s,r) + N(k,s,r))}{S}"/></p>
</div><p>where <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> is the number of OFDM symbols carrying RS in a RB and <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is the number of REs carrying a RS in a OFDM symbol (which is fixed to <img class="math" src="_images/math/d94997a2318fec7e8e5bc4d8d79bb633675f9411.png" alt="2"/>) while <img class="math" src="_images/math/530a421607e7f1f771aaca2dcf0f727192aceec5.png" alt="P(k,s,r)"/>, <img class="math" src="_images/math/0c757ec90f351192094c259f8c5837886311a0f4.png" alt="I(k,s,r)"/> and <img class="math" src="_images/math/f67b6744a58e20dc47a96f67b56c52c5b761cbb1.png" alt="N(k,s,r)"/> represent respectively the perceived power of the serving cell, the interference power and the noise power of the RE <img class="math" src="_images/math/79a3d439d28652c547386f39b555d90d3aaf102d.png" alt="r"/> in symbol <img class="math" src="_images/math/106b04b320e75010b1d8029e59244f234f75e6f9.png" alt="s"/>. As for RSRP, the measurements within a RB are always equals among each others according to the PHY model; therefore <img class="math" src="_images/math/29b6ca01ebb393aca4fe4381287e7b06d9443118.png" alt="P(k,s,r) = P(k)"/>, <img class="math" src="_images/math/bef1eb9f85de27fc4c3f74ef8514c385d868f86f.png" alt="I(k,s,r) = I(k)"/> and <img class="math" src="_images/math/24a05fb376f90e41c02d06a15b46e98dceebe369.png" alt="N(k,s,r) = N(k)"/>, which implies that the RSSI can be calculated as:</p>
<div class="math">
<p><img src="_images/math/d70b8cb3902117511f5ad7202505ce3b37d1ef48.png" alt="RSSI = \sum_{k=0}^{K-1} \frac{S \times 2 \times ( P(k) + I(k) + N(k))}{S}
     = \sum_{k=0}^{K-1} 2 \times ( P(k) + I(k) + N (k))"/></p>
</div><p>Considering the constraints of the PHY reception chain implementation, and in order to maintain the level of computational complexity low, only RSRP can be directly obtained for all the cells. This is due to the fact that <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> is designed for evaluating the interference only respect to the signal of the serving eNB. This implies that the PHY layer is optimized for managing the power signals information with the serving eNB as a reference. However, RSRP and RSRQ of neighbor cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> can be extracted by the current information available of the serving cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> as detailed in the following:</p>
<div class="math">
<p><img src="_images/math/207385573feb57ddbd6cdf86af59f4a281b593c9.png" alt="RSRP_i = \frac{\sum_{k=0}^{K-1}(P_i(k))}{K}

RSSI_i = RSSI_j = \sum_{k=0}^{K-1} 2 \times ( I_j(k) + P_j(k) + N_j(k) )

RSRQ_i^j = K \times RSRP_i / RSSI_j"/></p>
</div><p>where <img class="math" src="_images/math/0d8bfdd3ec778a86ed2879f86d200f427557de4a.png" alt="RSRP_i"/> is the RSRP of the neighbor cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>, <img class="math" src="_images/math/592b22b544e4ce5265863554d8c9c25f3f97be53.png" alt="P_i(k)"/> is the power perceived at any RE within the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, <img class="math" src="_images/math/52ddc0cde6d632f631533173562fe3ca375b1f32.png" alt="K"/> is the total number of RBs, <img class="math" src="_images/math/af17ea1920c1cae040d8b90bb8dea0b45295df97.png" alt="RSSI_i"/> is the RSSI of the neighbor cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> when the UE is attached to cell  <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> (which, since it is the sum of all the received powers, coincides with <img class="math" src="_images/math/b3c5b0100d6e0f5eb3ee08eeb88895b4e223c13c.png" alt="RSSI_j"/>), <img class="math" src="_images/math/b4c0872c10c62bcc8f4999e1cbf2ecd1d09abd07.png" alt="I_j(k)"/> is the total interference perceived by UE in any RE of RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> when attached to cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> (obtained by the <code class="docutils literal notranslate"><span class="pre">LteInterferencePowerChunkProcessor</span></code>), <img class="math" src="_images/math/15fa8b1c0746439f2b80e17432d797f4bc579790.png" alt="P_j(k)"/> is the power perceived of cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> in any RE of the RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> and <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> is the power noise spectral density in any RE. The sample is considered as valid in case of the RSRQ evaluated is above the <code class="docutils literal notranslate"><span class="pre">LteUePhy::RsrqUeMeasThreshold</span></code> attribute.</p>
</section>
</section>
<section id="harq">
<h4><span class="section-number">20.1.6. </span>HARQ<a class="headerlink" href="#harq" title="Link to this heading">¶</a></h4>
<p>The HARQ scheme implemented is based on a incremental redundancy (IR) solutions combined with multiple stop-and-wait processes for enabling a continuous data flow. In detail, the solution adopted is the <em>soft combining hybrid IR Full incremental redundancy</em> (also called IR Type II), which implies that the retransmissions contain only new information respect to the previous ones. The resource allocation algorithm of the HARQ has been implemented within the respective scheduler classes (i.e., <code class="docutils literal notranslate"><span class="pre">RrFfMacScheduler</span></code> and <code class="docutils literal notranslate"><span class="pre">PfFfMacScheduler</span></code>, refer to their correspondent sections for more info), while the decodification part of the HARQ has been implemented in the <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">LteHarqPhy</span></code> classes which will be detailed in this section.</p>
<p>According to the standard, the UL retransmissions are synchronous and therefore are allocated 7 ms after the original transmission. On the other hand, for the DL, they are asynchronous and therefore can be allocated in a more flexible way starting from 7 ms and it is a matter of the specific scheduler implementation. The HARQ processes behavior is depicted in Figure:ref:<cite>fig-harq-processes-scheme</cite>.</p>
<p>At the MAC layer, the HARQ entity residing in the scheduler is in charge of controlling the 8 HARQ processes for generating new packets and managing the retransmissions both for the DL and the UL. The scheduler collects the HARQ feedback from eNB and UE PHY layers (respectively for UL and DL connection) by means of the FF API primitives <code class="docutils literal notranslate"><span class="pre">SchedUlTriggerReq</span></code> and <code class="docutils literal notranslate"><span class="pre">SchedUlTriggerReq</span></code>. According to the HARQ feedback and the RLC buffers status, the scheduler generates a set of DCIs including both retransmissions of HARQ blocks received erroneous and new transmissions, in general, giving priority to the former. On this matter, the scheduler has to take into consideration one constraint when allocating the resource for HARQ retransmissions, it must use the same modulation order of the first transmission attempt (i.e., QPSK for MCS <img class="math" src="_images/math/51913cbad6eefab53a57ad4bdfec4d1a5054cef2.png" alt="\in [0..9]"/>, 16QAM for MCS <img class="math" src="_images/math/c03ac97eb57c0557d82b81ed6c4ee76571252483.png" alt="\in [10..16]"/> and 64QAM for MCS <img class="math" src="_images/math/6c1e8861452e52ec6f4b2c3e1eb53ed89966a66e.png" alt="\in [17..28]"/>). This restriction comes from the specification of the rate matcher in the 3GPP standard [
TS36212]_, where the algorithm fixes the modulation order for generating the different blocks of the redundancy versions.</p>
<p>The PHY Error Model model (i.e., the <code class="docutils literal notranslate"><span class="pre">LteMiErrorModel</span></code> class already presented before) has been extended for considering IR HARQ according to <a class="reference internal" href="index.html#wimaxemd" id="id38"><span>[wimaxEmd]</span></a>, where the parameters for the AWGN curves mapping for MIESM mapping in case of retransmissions are given by:</p>
<div class="math">
<p><img src="_images/math/979e205c9e325a22173b86d31c3758ce3c14bb6c.png" alt="R_{eff} = \frac{X}{\sum\limits_{i=1}^q C_i}

M_{I eff} = \frac{\sum\limits_{i=1}^q C_i M_i}{\sum\limits_{i=1}^q C_i}"/></p>
</div><p>where <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/> is the number of original information bits, <img class="math" src="_images/math/113ecc79d1fabbf0ca98becf9d3728be649e9cc7.png" alt="C_i"/> are number of coded bits, <img class="math" src="_images/math/86810cecefe160a038ea1bf18596df24b14c6731.png" alt="M_i"/> are the mutual information per HARQ block received on the total number of <img class="math" src="_images/math/a5fa84b363f309ebc8fe7db38304541732c7de9a.png" alt="q"/> retransmissions. Therefore, in order to be able to return the error probability with the error model implemented in the simulator evaluates the <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/> and the <img class="math" src="_images/math/1761d6b5623f20b3521b0542b81144ee7a4c90d6.png" alt="MI_{I eff}"/> and return the value of error probability of the ECR of the same modulation with closest lower rate respect to the <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/>. In order to consider the effect of HARQ retransmissions a new sets of curves have been integrated respect to the standard one used for the original MCS. The new curves are intended for covering the cases when the most conservative MCS of a modulation is used which implies the generation of <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/> lower respect to the one of standard MCSs. On this matter the curves for 1, 2 and 3 retransmissions have been evaluated for 10 and 17. For MCS 0 we considered only the first retransmission since the
produced code rate is already very conservative (i.e., 0.04) and returns an error rate enough robust for the reception (i.e., the downturn of the BLER is centered around -18 dB).
It is to be noted that, the size of first TB transmission has been assumed as containing all the information bits to be coded; therefore <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/> is equal to the size of the first TB sent of a an HARQ process. The model assumes that the eventual presence of parity bits in the codewords is already considered in the link level curves. This implies that as soon as the minimum <img class="math" src="_images/math/31c5f0169611b314214e7582f687278c75070de7.png" alt="R_{eff}"/> is reached the model is not including the gain due to the transmission of further parity bits.</p>
<figure class="align-center" id="id163">
<span id="fig-harq-processes-scheme"></span><img alt="_images/lte-harq-processes-scheme.png" src="_images/lte-harq-processes-scheme.png" />
<figcaption>
<p><span class="caption-text">HARQ processes behavior in LTE</span><a class="headerlink" href="#id163" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The part of HARQ devoted to manage the decodification of the HARQ blocks has been implemented in the <code class="docutils literal notranslate"><span class="pre">LteHarqPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">LteSpectrumPhy</span></code> classes. The former is in charge of maintaining the HARQ information for each active process . The latter interacts with <code class="docutils literal notranslate"><span class="pre">LteMiErrorModel</span></code> class for evaluating the correctness of the blocks received and includes the messaging algorithm in charge of communicating to the HARQ entity in the scheduler the result of the decodifications. These messages are encapsulated in the <code class="docutils literal notranslate"><span class="pre">dlInfoListElement</span></code> for DL and <code class="docutils literal notranslate"><span class="pre">ulInfoListElement</span></code> for UL and sent through the PUCCH and the PHICH respectively with an ideal error free model according to the assumptions in their implementation. A sketch of the iteration between HARQ and LTE protocol stack in represented in Figure:ref:<cite>fig-harq-architecture</cite>.</p>
<p>Finally, the HARQ engine is always active both at MAC and PHY layer; however, in case of the scheduler does not support HARQ the system will continue to work with the HARQ functions inhibited (i.e., buffers are filled but not used). This implementation characteristic gives backward compatibility with schedulers implemented before HARQ integration.</p>
<figure class="align-center" id="id164">
<span id="fig-harq-architecture"></span><img alt="_images/lte-harq-architecture.png" src="_images/lte-harq-architecture.png" />
<figcaption>
<p><span class="caption-text">Interaction between HARQ and LTE protocol stack</span><a class="headerlink" href="#id164" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="mac">
<h4><span class="section-number">20.1.7. </span>MAC<a class="headerlink" href="#mac" title="Link to this heading">¶</a></h4>
<section id="resource-allocation-model">
<h5><span class="section-number">20.1.7.1. </span>Resource Allocation Model<a class="headerlink" href="#resource-allocation-model" title="Link to this heading">¶</a></h5>
<p>We now briefly describe how resource allocation is handled in LTE,
clarifying how it is modeled in the simulator. The scheduler is in
charge of generating specific structures called <em>Data Control Indication</em> (DCI)
which are then transmitted by the PHY of the eNB to the connected UEs, in order
to inform them of the resource allocation on a per subframe basis. In doing this
in the downlink direction, the scheduler has to fill some specific fields of the
DCI structure with all the information, such as: the Modulation and Coding
Scheme (MCS) to be used, the MAC Transport Block (TB) size, and the allocation
bitmap which identifies which RBs will contain the data
transmitted by the eNB to each user.</p>
<p>For the mapping of resources to
physical RBs, we adopt a <em>localized mapping</em> approach
(see <a class="reference internal" href="index.html#sesia2009" id="id39"><span>[Sesia2009]</span></a>, Section 9.2.2.1);
hence in a given subframe each RB is always allocated to the same user in both
slots.
The allocation bitmap can be coded in
different formats; in this implementation, we considered the <em>Allocation
Type 0</em> defined in <a class="reference internal" href="index.html#ts36213" id="id40"><span>[TS36213]</span></a>, according to which the RBs are grouped in
Resource Block Groups (RBG) of different size determined as a function of the
Transmission Bandwidth Configuration in use.</p>
<p>For certain bandwidth
values not all the RBs are usable, since the
group size is not a common divisor of the group. This is for instance the case
when the bandwidth is equal to 25 RBs, which results in a RBG size of 2 RBs, and
therefore 1 RB will result not addressable.
In uplink the format of the DCIs is different, since only adjacent RBs
can be used because of the SC-FDMA modulation. As a consequence, all
RBs can be allocated by the eNB regardless of the bandwidth
configuration.</p>
</section>
<section id="adaptive-modulation-and-coding">
<span id="sec-lte-amc"></span><h5><span class="section-number">20.1.7.2. </span>Adaptive Modulation and Coding<a class="headerlink" href="#adaptive-modulation-and-coding" title="Link to this heading">¶</a></h5>
<p>The simulator provides two Adaptive Modulation and Coding (AMC) models: one based on the GSoC model <a class="reference internal" href="index.html#piro2011" id="id41"><span>[Piro2011]</span></a> and one based on the physical error model (described in the following sections).</p>
<p>The former model is a modified version of the model described in <a class="reference internal" href="index.html#piro2011" id="id42"><span>[Piro2011]</span></a>,
which in turn is inspired from <a class="reference internal" href="index.html#seo2004" id="id43"><span>[Seo2004]</span></a>. Our version is described in the
following. Let <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> denote the
generic user, and let <img class="math" src="_images/math/668b300393b9de22a5da2a6017ec36d8605f1ed7.png" alt="\gamma_i"/> be its SINR. We get the spectral efficiency
<img class="math" src="_images/math/c8696d0ccdce0a389e624bb720fccd288da119d7.png" alt="\eta_i"/> of user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> using the following equations:</p>
<div class="math">
<p><img src="_images/math/a27b050a8956bf65967cc8482e348b8c12fb345a.png" alt="\mathrm{BER} = 0.00005

\Gamma = \frac{ -\ln{ (5 * \mathrm{BER}) } }{ 1.5}

\eta_i = \log_2 { \left( 1 + \frac{ {\gamma}_i }{ \Gamma } \right)}"/></p>
</div><p>The procedure described in <a class="reference internal" href="index.html#r1-081483" id="id44"><span>[R1-081483]</span></a> is used to get
the corresponding MCS scheme. The spectral efficiency is quantized based on the
channel quality indicator (CQI), rounding to the lowest value, and is mapped to the corresponding MCS
scheme.</p>
<p>Finally, we note that there are some discrepancies between the MCS index
in <a class="reference internal" href="index.html#r1-081483" id="id45"><span>[R1-081483]</span></a>
and that indicated by the standard:  <a class="reference internal" href="index.html#ts36213" id="id46"><span>[TS36213]</span></a> Table
7.1.7.1-1 says that the MCS index goes from 0 to 31, and 0 appears to be a valid
MCS scheme (TB size is not 0) but in <a class="reference internal" href="index.html#r1-081483" id="id47"><span>[R1-081483]</span></a> the first useful MCS
index
is 1. Hence to get the value as intended by the standard we need to subtract 1
from the index reported in <a class="reference internal" href="index.html#r1-081483" id="id48"><span>[R1-081483]</span></a>.</p>
<p>The alternative model is based on the physical error model developed for this simulator and explained in the following subsections. This scheme is able to adapt the MCS selection to the actual PHY layer performance according to the specific CQI report. According to their definition, a CQI index is assigned when a single PDSCH TB with the modulation coding scheme and code rate correspondent to that CQI index in table 7.2.3-1 of <a class="reference internal" href="index.html#ts36213" id="id49"><span>[TS36213]</span></a> can be received with an error probability less than 0.1. In case of wideband CQIs, the reference TB includes all the RBGs available in order to have a reference based on the whole available resources; while, for subband CQIs, the reference TB is sized as the RBGs.</p>
</section>
<section id="transport-block-model">
<h5><span class="section-number">20.1.7.3. </span>Transport Block model<a class="headerlink" href="#transport-block-model" title="Link to this heading">¶</a></h5>
<p>The model of the MAC Transport Blocks (TBs) provided by the simulator
is simplified with respect to the 3GPP specifications. In particular,
a simulator-specific class (PacketBurst) is used to aggregate
MAC SDUs in order to achieve the simulator’s equivalent of a TB,
without the corresponding implementation complexity.
The multiplexing of different logical channels to and from the RLC
layer is performed using a dedicated packet tag (LteRadioBearerTag), which
performs a functionality which is partially equivalent to that of the
MAC headers specified by 3GPP.</p>
</section>
<section id="the-femtoforum-mac-scheduler-interface">
<span id="sec-ff-mac-scheduler"></span><h5><span class="section-number">20.1.7.4. </span>The FemtoForum MAC Scheduler Interface<a class="headerlink" href="#the-femtoforum-mac-scheduler-interface" title="Link to this heading">¶</a></h5>
<p>This section describes the ns-3 specific version of the LTE MAC
Scheduler Interface Specification published by the FemtoForum <a class="reference internal" href="index.html#ffapi" id="id50"><span>[FFAPI]</span></a>.</p>
<p>We implemented the ns-3 specific version of the FemtoForum MAC Scheduler
Interface <a class="reference internal" href="index.html#ffapi" id="id51"><span>[FFAPI]</span></a> as a set of C++ abstract
classes; in particular, each primitive is translated to a C++ method of a
given class. The term <em>implemented</em> here is used with the same
meaning adopted in <a class="reference internal" href="index.html#ffapi" id="id52"><span>[FFAPI]</span></a>, and hence refers to the process of translating
the logical interface specification to a particular programming language.
The primitives in <a class="reference internal" href="index.html#ffapi" id="id53"><span>[FFAPI]</span></a> are grouped in two groups: the CSCHED
primitives, which deal with scheduler configuration, and the SCHED primitives,
which deal with the execution of the scheduler. Furthermore, <a class="reference internal" href="index.html#ffapi" id="id54"><span>[FFAPI]</span></a>
defines primitives of two different kinds: those of type REQ go from the MAC to
the Scheduler, and those of type IND/CNF go from the scheduler to the MAC. To
translate these characteristics into C++, we define the following abstract
classes that implement Service Access Points (SAPs) to be used to issue the
primitives:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacSchedSapProvider</span></code> class defines all the C++ methods that
correspond to SCHED primitives of type REQ;</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacSchedSapUser</span></code> class defines all the C++ methods that
correspond to SCHED primitives of type CNF/IND;</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacCschedSapProvider</span></code> class defines all the C++ methods that
correspond to CSCHED primitives of type REQ;</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">FfMacCschedSapUser</span></code> class defines all the C++ methods that
correspond to CSCHED primitives of type CNF/IND;</p></li>
</ul>
</div></blockquote>
<p>There are 3 blocks involved in the MAC Scheduler interface: Control block,
Subframe block and Scheduler block. Each of these blocks provide one part of the
MAC Scheduler interface. The figure below shows the relationship
between the blocks and the SAPs defined in our implementation of the MAC
Scheduler Interface.</p>
<figure class="align-center">
<img alt="_images/ff-mac-saps.png" src="_images/ff-mac-saps.png" />
</figure>
<p>In addition to the above principles, the following design choices have been
taken:</p>
<blockquote>
<div><ul class="simple">
<li><p>The definition of the MAC Scheduler interface classes follows the naming
conventions of the <em>ns-3</em> Coding Style. In particular, we follow the
CamelCase convention for the primitive names. For example, the primitive
<code class="docutils literal notranslate"><span class="pre">CSCHED_CELL_CONFIG_REQ</span></code> is translated to <code class="docutils literal notranslate"><span class="pre">CschedCellConfigReq</span></code>
in the <em>ns-3</em> code.</p></li>
<li><p>The same naming conventions are followed for the primitive parameters. As
the primitive parameters are member variables of classes, they are also prefixed
with a <code class="docutils literal notranslate"><span class="pre">m_</span></code>.</p></li>
<li><p>regarding the use of vectors and lists in data structures, we note
that <a class="reference internal" href="index.html#ffapi" id="id55"><span>[FFAPI]</span></a> is a pretty much C-oriented API. However, considered that
C++ is used in ns-3, and that the use of C arrays is discouraged, we used STL
vectors (<code class="docutils literal notranslate"><span class="pre">std::vector</span></code>) for the implementation of the MAC Scheduler
Interface, instead of using C arrays as implicitly suggested by the
way <a class="reference internal" href="index.html#ffapi" id="id56"><span>[FFAPI]</span></a> is written.</p></li>
<li><p>In C++, members with constructors and destructors are not allow in
<code class="docutils literal notranslate"><span class="pre">unions</span></code>. Hence all those data structures that are said to be
<code class="docutils literal notranslate"><span class="pre">unions</span></code> in <a class="reference internal" href="index.html#ffapi" id="id57"><span>[FFAPI]</span></a> have been defined as <code class="docutils literal notranslate"><span class="pre">structs</span></code> in our code.</p></li>
</ul>
</div></blockquote>
<p>The figure below shows how the MAC Scheduler Interface is
used within the eNB.</p>
<figure class="align-center">
<img alt="_images/ff-example.png" src="_images/ff-example.png" />
</figure>
<p>The User side of both the CSCHED SAP and the SCHED SAP are
implemented within the eNB MAC, i.e., in the file <code class="docutils literal notranslate"><span class="pre">lte-enb-mac.cc</span></code>.
The eNB MAC can be used with different scheduler implementations without
modifications. The same figure also shows, as an example, how the Round Robin
Scheduler is implemented: to interact with the MAC of the eNB, the Round Robin
scheduler implements the Provider side of the SCHED SAP and CSCHED
SAP interfaces. A similar approach can be used to implement other schedulers as
well. A description of each of the scheduler implementations that we provide as
part of our LTE simulation module is provided in the following subsections.</p>
<section id="round-robin-rr-scheduler">
<h6><span class="section-number">20.1.7.4.1. </span>Round Robin (RR) Scheduler<a class="headerlink" href="#round-robin-rr-scheduler" title="Link to this heading">¶</a></h6>
<p>The Round Robin (RR) scheduler is probably the simplest scheduler found in the literature. It works by dividing the
available resources among the active flows, i.e., those logical channels which have a non-empty RLC queue. If the number of RBGs is greater than the number of active flows, all the flows can be allocated in the same subframe. Otherwise, if the number of active flows is greater than the number of RBGs, not all the flows can be scheduled in a given subframe; then, in the next subframe the allocation will start from the last flow that was not allocated.  The MCS to be adopted for each user is done according to the received wideband CQIs.</p>
<p>For what concern the HARQ, RR implements the non adaptive version, which implies that in allocating the retransmission attempts RR uses the same allocation configuration of the original block, which means maintaining the same RBGs and MCS. UEs that are allocated for HARQ retransmissions are not considered for the transmission of new data in case they have a transmission opportunity available in the same TTI. Finally, HARQ can be disabled with ns3 attribute system for maintaining backward compatibility with old test cases and code, in detail:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RrFfMacScheduler::HarqEnabled&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>The scheduler implements the filtering of the uplink CQIs according to their nature with <code class="docutils literal notranslate"><span class="pre">UlCqiFilter</span></code> attribute, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SRS_UL_CQI</span></code>: only SRS based CQI are stored in the internal attributes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PUSCH_UL_CQI</span></code>: only PUSCH based CQI are stored in the internal attributes.</p></li>
</ul>
</div></blockquote>
</section>
<section id="proportional-fair-pf-scheduler">
<h6><span class="section-number">20.1.7.4.2. </span>Proportional Fair (PF) Scheduler<a class="headerlink" href="#proportional-fair-pf-scheduler" title="Link to this heading">¶</a></h6>
<p>The Proportional Fair (PF) scheduler <a class="reference internal" href="index.html#sesia2009" id="id58"><span>[Sesia2009]</span></a> works by scheduling a user
when its
instantaneous channel quality is high relative to its own average channel
condition over time. Let <img class="math" src="_images/math/5183ea9096ac86aff6e13dd3d4389ae47617b059.png" alt="i,j"/> denote generic users; let <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> be the
subframe index, and <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> be the resource block index; let <img class="math" src="_images/math/5b56afc255250c48d60f4fad45bfb9b2d2879df5.png" alt="M_{i,k}(t)"/> be MCS
usable by user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> according to what reported by the AMC
model (see <a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a>); finally, let <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the TB
size in bits as defined in <a class="reference internal" href="index.html#ts36213" id="id59"><span>[TS36213]</span></a> for the case where a number <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> of
resource blocks is used. The achievable rate <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/> in bit/s for user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
on resource block group <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is defined as</p>
<div class="math">
<p><img src="_images/math/6a0c5c4fec6eb724c85f973484dcd1f836e52fe3.png" alt="R_{i}(k,t) =  \frac{S\left( M_{i,k}(t), 1\right)}{\tau}"/></p>
</div><p>where <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> is the TTI duration.
At the start of each subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>, each RBG is assigned to a certain user.
In detail, the index <img class="math" src="_images/math/529ae47506915b95a60656c7325b87513bf0858d.png" alt="\widehat{i}_{k}(t)"/> to which RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is assigned at time
<img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is determined as</p>
<div class="math">
<p><img src="_images/math/a5500173c1c4098c614da4f2181d3c4b3de14e4a.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ T_\mathrm{j}(t) } \right)"/></p>
</div><p>where <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> is the past throughput performance perceived by the
user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>.
According to the above scheduling algorithm, a user can be allocated to
different RBGs, which can be either adjacent or not, depending on the current
condition of the channel and the past throughput performance <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/>. The
latter is determined at the end of the subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> using the following
exponential moving average approach:</p>
<div class="math">
<p><img src="_images/math/290e8690afc5b85a80b1e9594009b27833f32f2c.png" alt="T_{j}(t) =
(1-\frac{1}{\alpha})T_{j}(t-1)
+\frac{1}{\alpha} \widehat{T}_{j}(t)"/></p>
</div><p>where <img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/> is the time constant (in number of subframes) of
the exponential moving average, and <img class="math" src="_images/math/d84d63215af51f74a3737b1ebbc4e3e4b24ce7b0.png" alt="\widehat{T}_{j}(t)"/> is the actual
throughput achieved by the user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> in the subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>. <img class="math" src="_images/math/d84d63215af51f74a3737b1ebbc4e3e4b24ce7b0.png" alt="\widehat{T}_{j}(t)"/>
is measured according to the following procedure. First we
determine the MCS <img class="math" src="_images/math/f67055e462b7d27afb83ad7f1ef4c4b1a13f3846.png" alt="\widehat{M}_j(t)"/> actually used by user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>:</p>
<div class="math">
<p><img src="_images/math/7bf955a2c223b9103317d127ebcedb766ee34588.png" alt="\widehat{M}_j(t) = \min_{k: \widehat{i}_{k}(t) = j}{M_{j,k}(t)}"/></p>
</div><p>then we determine the total number <img class="math" src="_images/math/51c44c8e4a605289d83736cf84d4b4cdd24becb0.png" alt="\widehat{B}_j(t)"/> of RBGs allocated to user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>:</p>
<div class="math">
<p><img src="_images/math/575735d17b97b7c5afc4b095a7eddb56d631a572.png" alt="\widehat{B}_j(t) = \left| \{ k :  \widehat{i}_{k}(t) = j \} \right|"/></p>
</div><p>where <img class="math" src="_images/math/98c3e1f8e7991b65e2e4f20e5dc8592c81a3fd74.png" alt="|\cdot|"/> indicates the cardinality of the set; finally,</p>
<div class="math">
<p><img src="_images/math/1eb93027b54850f8e9c2840f8a7bb05aa2cf2f83.png" alt="\widehat{T}_{j}(t) = \frac{S\left( \widehat{M}_j(t), \widehat{B}_j(t)
\right)}{\tau}"/></p>
</div><p>For what concern the HARQ, PF implements the non adaptive version, which implies that in allocating the retransmission attempts the scheduler uses the same allocation configuration of the original block, which means maintaining the same RBGs and MCS. UEs that are allocated for HARQ retransmissions are not considered for the transmission of new data in case they have a transmission opportunity available in the same TTI. Finally, HARQ can be disabled with ns3 attribute system for maintaining backward compatibility with old test cases and code, in detail:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::PfFfMacScheduler::HarqEnabled&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="maximum-throughput-mt-scheduler">
<h6><span class="section-number">20.1.7.4.3. </span>Maximum Throughput (MT) Scheduler<a class="headerlink" href="#maximum-throughput-mt-scheduler" title="Link to this heading">¶</a></h6>
<p>The Maximum Throughput (MT) scheduler <a class="reference internal" href="index.html#fcapo2012" id="id60"><span>[FCapo2012]</span></a> aims to maximize the overall throughput of eNB.
It allocates each RB to the user that can achieve the maximum achievable rate in the current TTI.
Currently, MT scheduler in NS-3 has two versions: frequency domain (FDMT) and time domain (TDMT).
In FDMT, every TTI, MAC scheduler allocates RBGs to the UE who has highest achievable rate calculated
by subband CQI. In TDMT, every TTI, MAC scheduler selects one UE which has highest achievable rate
calculated by wideband CQI. Then MAC scheduler allocates all RBGs to this UE in current TTI.
The calculation of achievable rate in FDMT and TDMT is as same as the one in PF.
Let <img class="math" src="_images/math/5183ea9096ac86aff6e13dd3d4389ae47617b059.png" alt="i,j"/> denote generic users; let <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> be the
subframe index, and <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> be the resource block index; let <img class="math" src="_images/math/5b56afc255250c48d60f4fad45bfb9b2d2879df5.png" alt="M_{i,k}(t)"/> be MCS
usable by user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> according to what reported by the AMC
model (see <a class="reference internal" href="#adaptive-modulation-and-coding">Adaptive Modulation and Coding</a>); finally, let <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the TB
size in bits as defined in <a class="reference internal" href="index.html#ts36213" id="id61"><span>[TS36213]</span></a> for the case where a number <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> of
resource blocks is used. The achievable rate <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/> in bit/s for user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is defined as</p>
<div class="math">
<p><img src="_images/math/6a0c5c4fec6eb724c85f973484dcd1f836e52fe3.png" alt="R_{i}(k,t) =  \frac{S\left( M_{i,k}(t), 1\right)}{\tau}"/></p>
</div><p>where <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> is the TTI duration.
At the start of each subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>, each RB is assigned to a certain user.
In detail, the index <img class="math" src="_images/math/529ae47506915b95a60656c7325b87513bf0858d.png" alt="\widehat{i}_{k}(t)"/> to which RB <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is assigned at time
<img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is determined as</p>
<div class="math">
<p><img src="_images/math/89e69353c75aa394020ad56e8931520bc89dc68a.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
    \left( { R_{j}(k,t) } \right)"/></p>
</div><p>When there are several UEs having the same achievable rate, current implementation always selects
the first UE created in script. Although MT can maximize cell throughput, it cannot provide
fairness to UEs in poor channel condition.</p>
</section>
<section id="throughput-to-average-tta-scheduler">
<h6><span class="section-number">20.1.7.4.4. </span>Throughput to Average (TTA) Scheduler<a class="headerlink" href="#throughput-to-average-tta-scheduler" title="Link to this heading">¶</a></h6>
<p>The Throughput to Average (TTA) scheduler <a class="reference internal" href="index.html#fcapo2012" id="id62"><span>[FCapo2012]</span></a> can be considered as an intermediate between MT and PF.
The metric used in TTA is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/238fd14047f8b0496e76c5cb1f54e1d5bea4ae6c.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ R_{j}(t) } \right)"/></p>
</div><p>Here, <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/> in bit/s represents the achievable rate for user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
on resource block <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>. The
calculation method already is shown in MT and PF. Meanwhile, <img class="math" src="_images/math/0440d3b5e8182a23e45c6d15ec5c2fb6f1006c40.png" alt="R_{i}(t)"/> in bit/s stands
for the achievable rate for <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> at subframe <img class="math" src="_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>. The difference between those two
achievable rates is how to get MCS. For <img class="math" src="_images/math/06f3569532dc9ab0111b64bc36cb3e93e4b570c8.png" alt="R_{i}(k,t)"/>, MCS is calculated by subband CQI while
<img class="math" src="_images/math/0440d3b5e8182a23e45c6d15ec5c2fb6f1006c40.png" alt="R_{i}(t)"/> is calculated by wideband CQI. TTA scheduler can only be implemented in frequency domain (FD) because
the achievable rate of particular RBG is only related to FD scheduling.</p>
</section>
<section id="blind-average-throughput-scheduler">
<h6><span class="section-number">20.1.7.4.5. </span>Blind Average Throughput Scheduler<a class="headerlink" href="#blind-average-throughput-scheduler" title="Link to this heading">¶</a></h6>
<p>The Blind Average Throughput scheduler <a class="reference internal" href="index.html#fcapo2012" id="id63"><span>[FCapo2012]</span></a> aims to provide equal throughput to all UEs under eNB. The metric
used in TTA is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/05a375c3c9c3fef82b1e97d7b069589df8dd5ea4.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ 1 }{ T_\mathrm{j}(t) } \right)"/></p>
</div><p>where <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> is the past throughput performance perceived by the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> and can be calculated by the
same method in PF scheduler. In the time domain blind average throughput (TD-BET), the scheduler selects the UE
with largest priority metric and allocates all RBGs to this UE. On the other hand, in the frequency domain blind
average throughput (FD-BET), every TTI, the scheduler first selects one UE with lowest pastAverageThroughput (largest
priority metric). Then scheduler assigns one RBG to this UE, it calculates expected throughput of this UE and uses it
to compare with past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> of other UEs. The scheduler continues
to allocate RBG to this UE until its expected throughput is not the smallest one among past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/>
of all UE. Then the scheduler will use the same way to allocate RBG for a new UE which has the
lowest past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> until all RBGs are allocated to UEs. The principle behind this is
that, in every TTI, the scheduler tries the best to achieve the equal throughput among all UEs.</p>
</section>
<section id="token-bank-fair-queue-scheduler">
<h6><span class="section-number">20.1.7.4.6. </span>Token Bank Fair Queue Scheduler<a class="headerlink" href="#token-bank-fair-queue-scheduler" title="Link to this heading">¶</a></h6>
<p>Token Bank Fair Queue (TBFQ) is a QoS aware scheduler which derives from the leaky-bucket mechanism. In TBFQ,
a traffic flow of user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> is characterized by following parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><img class="math" src="_images/math/f49b9947abf64a02da421bd28023a1084bb15f04.png" alt="t_{i}"/>: packet arrival rate (byte/sec )</p></li>
<li><p><img class="math" src="_images/math/3d74960049ac5c5fdcec12db9931429a19e32265.png" alt="r_{i}"/>: token generation rate (byte/sec)</p></li>
<li><p><img class="math" src="_images/math/eb0043fd60f5bc7448bb03170eaeb5b087d0bdf4.png" alt="p_{i}"/>: token pool size (byte)</p></li>
<li><p><img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/>: counter that records the number of token borrowed from or given to the token bank by flow <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> ;
<img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> can be smaller than zero</p></li>
</ul>
</div></blockquote>
<p>Each K bytes data consumes k tokens. Also, TBFQ maintains a shared token bank (<img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>) so as to balance the traffic
between different flows. If token generation rate <img class="math" src="_images/math/3d74960049ac5c5fdcec12db9931429a19e32265.png" alt="r_{i}"/> is bigger than packet arrival rate <img class="math" src="_images/math/f49b9947abf64a02da421bd28023a1084bb15f04.png" alt="t_{i}"/>, then tokens
overflowing from token pool are added to the token bank, and <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> is increased by the same amount. Otherwise,
flow <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> needs to withdraw tokens from token bank based on a priority metric <img class="math" src="_images/math/4a056ace77c1645dd1c76f927fb28797da2e92f6.png" alt="frac{E_{i}}{r_{i}}"/>, and <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> is decreased.
Obviously, the user contributes more on token bank has higher priority to borrow tokens; on the other hand, the
user borrows more tokens from bank has lower priority to continue to withdraw tokens. Therefore, in case of several
users having the same token generation rate, traffic rate and token pool size, user suffers from higher interference
has more opportunity to borrow tokens from bank. In addition, TBFQ can police the traffic by setting the token
generation rate to limit the throughput.  Additionally, TBFQ also maintains following three parameters for each flow:</p>
<blockquote>
<div><ul class="simple">
<li><p>Debt limit <img class="math" src="_images/math/72b95dbd3f98453253ee3012e4b7dccb86d55c2f.png" alt="d_{i}"/>: if <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> belows this threshold, user i cannot further borrow tokens from bank. This is for
preventing malicious UE to borrow too much tokens.</p></li>
<li><p>Credit limit <img class="math" src="_images/math/cb5448c62c69431617901ff76ecf95172e07d606.png" alt="c_{i}"/>: the maximum number of tokens UE i can borrow from the bank in one time.</p></li>
<li><p>Credit threshold <img class="math" src="_images/math/4db5b6e16e06f929ce3f675c5e535d06ffb02ff7.png" alt="C"/>: once <img class="math" src="_images/math/6dee1c45812cc81d4c0c16626aaad62ee2d6fc98.png" alt="E_{i}"/> reaches debt limit, UE i must store <img class="math" src="_images/math/4db5b6e16e06f929ce3f675c5e535d06ffb02ff7.png" alt="C"/> tokens to bank in order to further
borrow token from bank.</p></li>
</ul>
</div></blockquote>
<p>LTE in NS-3 has two versions of TBFQ scheduler: frequency domain TBFQ (FD-TBFQ) and time domain TBFQ (TD-TBFQ).
In FD-TBFQ, the scheduler always select UE with highest metric and allocates RBG with highest subband CQI until
there are no packets within UE’s RLC buffer or all RBGs are allocated <a class="reference internal" href="index.html#fabokhari2009" id="id64"><span>[FABokhari2009]</span></a>. In TD-TBFQ, after selecting
UE with maximum metric, it allocates all RBGs to this UE by using wideband CQI <a class="reference internal" href="index.html#wkwong2004" id="id65"><span>[WKWong2004]</span></a>.</p>
</section>
<section id="priority-set-scheduler">
<h6><span class="section-number">20.1.7.4.7. </span>Priority Set Scheduler<a class="headerlink" href="#priority-set-scheduler" title="Link to this heading">¶</a></h6>
<p>Priority set scheduler (PSS) is a QoS aware scheduler which combines time domain (TD) and frequency domain (FD)
packet scheduling operations into one scheduler <a class="reference internal" href="index.html#gmonghal2008" id="id66"><span>[GMonghal2008]</span></a>. It controls the fairness among UEs by a specified
Target Bit Rate (TBR).</p>
<p>In TD scheduler part, PSS first selects UEs with non-empty RLC buffer and then divide them into two sets based
on the TBR:</p>
<ul class="simple">
<li><p>set 1: UE whose past average throughput is smaller than TBR; TD scheduler calculates their priority metric in
Blind Equal Throughput (BET) style:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/05a375c3c9c3fef82b1e97d7b069589df8dd5ea4.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ 1 }{ T_\mathrm{j}(t) } \right)"/></p>
</div><ul class="simple">
<li><p>set 2: UE whose past average throughput is larger (or equal) than TBR; TD scheduler calculates their priority
metric in Proportional Fair (PF) style:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/a5500173c1c4098c614da4f2181d3c4b3de14e4a.png" alt="\widehat{i}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ T_\mathrm{j}(t) } \right)"/></p>
</div><p>UEs belonged to set 1 have higher priority than ones in set 2. Then PSS will select <img class="math" src="_images/math/0ba10651d1358dfecda6df5acaeef6b0bb6c4bdf.png" alt="N_{mux}"/> UEs with
highest metric in two sets and forward those UE to FD scheduler. In PSS, FD scheduler allocates RBG k to UE n
that maximums the chosen metric. Two PF schedulers are used in PF scheduler:</p>
<ul class="simple">
<li><p>Proportional Fair scheduled (PFsch)</p></li>
</ul>
<div class="math">
<p><img src="_images/math/b0f14685dd771a061f32a1642c77f1493ce8596d.png" alt="\widehat{Msch}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ R_{j}(k,t) }{ Tsch_\mathrm{j}(t) } \right)"/></p>
</div><ul class="simple">
<li><p>Carrier over Interference to Average (CoIta)</p></li>
</ul>
<div class="math">
<p><img src="_images/math/9bc37fb9dc9e089b88caff28daa0ff00e87c52ad.png" alt="\widehat{Mcoi}_{k}(t) = \underset{j=1,...,N}{\operatorname{argmax}}
 \left( \frac{ CoI[j,k] }{ \sum_{k=0}^{N_{RBG}} CoI[j,k] } \right)"/></p>
</div><p>where <img class="math" src="_images/math/dea73801bf14c41998f4dc5537647b4d2b3add38.png" alt="Tsch_{j}(t)"/> is similar past throughput performance perceived by the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, with the
difference that it is updated only when the i-th user is actually served. <img class="math" src="_images/math/93d721f1812648f6b2a991e1781d1714d824bfff.png" alt="CoI[j,k]"/> is an
estimation of the SINR on the RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> of UE <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>. Both PFsch and CoIta is for decoupling
FD metric from TD scheduler. In addition, PSS FD scheduler also provide a weight metric W[n] for helping
controlling fairness in case of low number of UEs.</p>
<div class="math">
<p><img src="_images/math/ca3fbfed2db469bba1852455d1db3bf534785610.png" alt="W[n] =  max (1, \frac{TBR}{ T_{j}(t) })"/></p>
</div><p>where <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> is the past throughput performance perceived by the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> . Therefore, on
RBG k, the FD scheduler selects the UE <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> that maximizes the product of the frequency domain
metric (<img class="math" src="_images/math/cae83948f0daac0ae9d9e8978a5061f8f89209f2.png" alt="Msch"/>, <img class="math" src="_images/math/be0d9c06d5708fa37aadc302cce45ea1ca4ea40c.png" alt="MCoI"/>) by weight <img class="math" src="_images/math/c9d18087ddac8b5a064ab652747bdc9dcac05205.png" alt="W[n]"/>. This strategy will guarantee the throughput of lower
quality UE tend towards the TBR.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::PfFfMacScheduler::HarqEnabled&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>The scheduler implements the filtering of the uplink CQIs according to their nature with <code class="docutils literal notranslate"><span class="pre">UlCqiFilter</span></code> attribute, in detail:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SRS_UL_CQI</span></code>: only SRS based CQI are stored in the internal attributes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PUSCH_UL_CQI</span></code>: only PUSCH based CQI are stored in the internal attributes.</p></li>
</ul>
</div></blockquote>
</section>
<section id="channel-and-qos-aware-scheduler">
<h6><span class="section-number">20.1.7.4.8. </span>Channel and QoS Aware Scheduler<a class="headerlink" href="#channel-and-qos-aware-scheduler" title="Link to this heading">¶</a></h6>
<p>The Channel and QoS Aware (CQA) Scheduler <a class="reference internal" href="index.html#bbojovic2014" id="id67"><span>[Bbojovic2014]</span></a> is an LTE
MAC downlink scheduling algorithm that considers the head of line
(HOL) delay, the GBR parameters and channel quality over
different subbands. The CQA scheduler is based on joint TD and FD
scheduling.</p>
<p>In the TD (at each TTI) the CQA scheduler groups users by
priority. The purpose of grouping is to enforce the FD scheduling to
consider first the flows with highest HOL delay. The grouping metric
<img class="math" src="_images/math/95044d4c8d88cf05346cb52b150be65e12771129.png" alt="m_{td}"/> for user <img class="math" src="_images/math/58eed65d8e2ecaa6ca7b646b43e67c1452ca3e8d.png" alt="j=1,...,N"/> is defined in the
following way:</p>
<div class="math">
<p><img src="_images/math/262953297cd242589199e5169c27d2d7dd39dab6.png" alt="m_{td}^{j}(t) = \lceil\frac{d_{hol}^{j}(t)}{g}\rceil \;,"/></p>
</div><p>where <img class="math" src="_images/math/9453de1404a4b08c1d98f1eb0d7740dd448e733b.png" alt="d_{hol}^{j}(t)"/> is the current value of HOL delay of flow
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, and <img class="math" src="_images/math/157ba5711de84b4c715a0478fd8ae440e596d96e.png" alt="g"/> is a grouping parameter that determines
granularity of the groups, i.e. the number of the flows that will be
considered in the FD scheduling iteration.</p>
<p>The groups of flows selected in the TD iteration are forwarded to the FD
scheduling starting from the flows with the highest value of the
<img class="math" src="_images/math/95044d4c8d88cf05346cb52b150be65e12771129.png" alt="m_{td}"/> metric until all RBGs are assigned in the corresponding
TTI.  In the FD, for each RBG <img class="math" src="_images/math/d110585cc973170f2776ad9b5403b213f4bce892.png" alt="k=1,...,K"/>, the CQA scheduler
assigns the current RBG to the user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> that has the maximum value of
the FD metric which we define in the following way:</p>
<div class="math">
<p><img src="_images/math/b7c31c7fd55172700595e02bac4d79b916b22064.png" alt="m_{fd}^{(k,j)}(t) = d_{HOL}^{j}(t) \cdot m_{GBR}^j(t) \cdot m_{ca}^{k,j}(t) \;,"/></p>
</div><p>where <img class="math" src="_images/math/e369538730674b9dae6189214229d041f235966b.png" alt="m_{GBR}^j(t)"/> is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/a3d7d25950dc8b9b749acc6c4242114e89b0ae82.png" alt="m_{GBR}^j(t)=\frac{GBR^j}{\overline{R^j}(t)}=\frac{GBR^j}{(1-\alpha)\cdot\overline{R^j}(t-1)+\alpha \cdot r^j(t)} \;,"/></p>
</div><p>where <img class="math" src="_images/math/a990c3dbbc585dc4a8898c7ac40be36799c4f2ba.png" alt="GBR^j"/> is the bit rate specified in EPS bearer of the
flow <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, <img class="math" src="_images/math/e8f7bf732b6e79bc9c09b2e3b898724f70e043fc.png" alt="\overline{R^j}(t)"/> is the past averaged throughput that is calculated with a
moving average, <img class="math" src="_images/math/ec6519a7e3688b7be939ac7c55b20c30004a5882.png" alt="r^{j}(t)"/> is the throughput achieved at the
time t, and <img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/> is a coefficient such that <img class="math" src="_images/math/56225237a759ac2ca9a716c653dd844d98eb1ab3.png" alt="0 \le \alpha
\le1"/>.</p>
<p>For <img class="math" src="_images/math/39c37098e41bcdba68593562a56215f6bf2f9530.png" alt="m_{ca}^{(k,j)}(t)"/> we consider two different
metrics: <img class="math" src="_images/math/7aa94467e9740f7195a6dee4e55858bcfa434d46.png" alt="m_{pf}^{(k,j)}(t)"/> and <img class="math" src="_images/math/4e00ef1b9d19afc22e5eed290cc4bf0ff39f2eef.png" alt="m_{ff}^{(k,j)}(t)"/>.
<img class="math" src="_images/math/f584781f9a1be2f51d4fb73882e1f5cd82055170.png" alt="m_{pf}"/> is the Proportional Fair metric which is defined as follows:</p>
<div class="math">
<p><img src="_images/math/e7595531392ecb3b4d7872206d7c4ed832a9a453.png" alt="m_{pf}^{(k,j)}(t) = \frac{R_e^{(k,j)}}{\overline{R^j}(t)} \;,"/></p>
</div><p>where <img class="math" src="_images/math/fef833d0d7b28bdf52287d8979a446d0e76ed662.png" alt="R_e^{(k,j)}(t)"/> is the estimated achievable throughput of user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> over RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> calculated by the Adaptive Modulation and Coding
(AMC) scheme that maps the channel quality indicator (CQI) value to
the transport block size in bits.</p>
<p>The other channel awareness metric that we consider is <img class="math" src="_images/math/973053008b49074a62ddc97445adeabfff3e68f8.png" alt="m_{ff}"/> which
is proposed in <a class="reference internal" href="index.html#gmonghal2008" id="id68"><span>[GMonghal2008]</span></a> and it represents the frequency
selective fading gains over RBG <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> for user <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> and is calculated in
the following way:</p>
<div class="math">
<p><img src="_images/math/e06cf048ec2cc63fd7a5cb867266e0a5eeb0f50c.png" alt="m_{ff}^{(k,j)}(t) = \frac{CQI^{(k,j)}(t)}{\sum_{k=1}^{K}CQI(t)^{(k,j)}} \;,"/></p>
</div><p>where <img class="math" src="_images/math/3d549acbde45b6d90d466601b00d51dc9f3610d4.png" alt="CQI^{(k,j)}(t)"/> is the last reported CQI value from user
<img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/> for the <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>-th RBG.</p>
<p>The user can select whether <img class="math" src="_images/math/f584781f9a1be2f51d4fb73882e1f5cd82055170.png" alt="m_{pf}"/> or <img class="math" src="_images/math/973053008b49074a62ddc97445adeabfff3e68f8.png" alt="m_{ff}"/> is used
by setting the attribute <code class="docutils literal notranslate"><span class="pre">ns3::CqaFfMacScheduler::CqaMetric</span></code>
respectively to <code class="docutils literal notranslate"><span class="pre">&quot;CqaPf&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;CqaFf&quot;</span></code>.</p>
</section>
</section>
<section id="random-access">
<span id="sec-random-access"></span><h5><span class="section-number">20.1.7.5. </span>Random Access<a class="headerlink" href="#random-access" title="Link to this heading">¶</a></h5>
<p>The LTE model includes a model of the Random Access procedure based on
some simplifying assumptions, which are detailed in the following for
each of the messages and signals described in the specs <a class="reference internal" href="index.html#ts36321" id="id69"><span>[TS36321]</span></a>.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Random Access (RA) preamble</strong>: in real LTE systems this
corresponds to a Zadoff-Chu (ZC)
sequence using one of several formats available and sent in the
PRACH slots which could in principle overlap with PUSCH.
PRACH Configuration Index 14 is assumed, i.e., preambles can be
sent on any system frame number and subframe number.
The RA preamble is modeled using the LteControlMessage class,
i.e., as an ideal message that does not consume any radio
resources. The collision of preamble transmission by multiple UEs
in the same cell are modeled using a protocol interference model,
i.e., whenever two or more identical preambles are transmitted in
same cell at the same TTI, no one of these identical preambles
will be received by the eNB. Other than this collision model, no
error model is associated with the reception of a RA preamble.</p></li>
<li><p><strong>Random Access Response (RAR)</strong>: in real LTE systems, this is a
special MAC PDU sent on the DL-SCH. Since MAC control elements are not
accurately modeled in the simulator (only RLC and above PDUs
are), the RAR is modeled as an LteControlMessage that does not
consume any radio resources. Still, during the RA procedure, the
LteEnbMac will request to the scheduler the allocation of
resources for the RAR using the FF MAC Scheduler primitive
SCHED_DL_RACH_INFO_REQ. Hence, an enhanced scheduler
implementation (not available at the moment) could allocate radio
resources for the RAR, thus modeling the consumption of Radio
Resources for the transmission of the RAR.</p></li>
<li><p><strong>Message 3</strong>:  in real LTE systems, this is an RLC TM
SDU sent over resources specified in the UL Grant in the RAR. In
the simulator, this is modeled as a real RLC TM RLC PDU
whose UL resources are allocated by the scheduler upon call to
SCHED_DL_RACH_INFO_REQ.</p></li>
<li><p><strong>Contention Resolution (CR)</strong>: in real LTE system, the CR phase
is needed to address the case where two or more UE sent the same
RA preamble in the same TTI, and the eNB was able to detect this
preamble in spite of the collision. Since this event does not
occur due to the protocol interference model used for the
reception of RA preambles, the CR phase is not modeled in the
simulator, i.e., the CR MAC CE is never sent by the eNB and the
UEs consider the RA to be successful upon reception of the
RAR. As a consequence, the radio resources consumed for the
transmission of the CR MAC CE are not modeled.</p></li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-mac-random-access-contention"><span class="std std-ref">Sequence diagram of the Contention-based MAC Random Access procedure</span></a> and
<a class="reference internal" href="#fig-mac-random-access-noncontention"><span class="std std-ref">Sequence diagram of the Non-contention-based MAC Random Access procedure</span></a> shows the sequence diagrams
of respectively the contention-based and non-contention-based MAC
random access procedure, highlighting the interactions between the MAC
and the other entities.</p>
<figure class="align-center" id="id165">
<span id="fig-mac-random-access-contention"></span><img alt="_images/mac-random-access-contention.png" src="_images/mac-random-access-contention.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the Contention-based MAC Random Access procedure</span><a class="headerlink" href="#id165" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id166">
<span id="fig-mac-random-access-noncontention"></span><img alt="_images/mac-random-access-noncontention.png" src="_images/mac-random-access-noncontention.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the Non-contention-based MAC Random Access procedure</span><a class="headerlink" href="#id166" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="rlc">
<h4><span class="section-number">20.1.8. </span>RLC<a class="headerlink" href="#rlc" title="Link to this heading">¶</a></h4>
<section id="id70">
<h5><span class="section-number">20.1.8.1. </span>Overview<a class="headerlink" href="#id70" title="Link to this heading">¶</a></h5>
<p>The RLC entity is specified in the 3GPP technical specification
<a class="reference internal" href="index.html#ts36322" id="id71"><span>[TS36322]</span></a>, and comprises three different types of RLC: Transparent
Mode (TM), Unacknowledged Mode (UM) and Acknowledged Mode (AM). The
simulator includes one model for each of these entities</p>
<p>The RLC entities provide the RLC service interface to the upper PDCP layer and the MAC service interface
to the lower MAC layer. The RLC entities use the PDCP service interface from the upper PDCP layer and
the MAC service interface from the lower MAC layer.</p>
<p>Figure <a class="reference internal" href="#fig-lte-rlc-implementation-model"><span class="std std-ref">Implementation Model of PDCP, RLC and MAC entities and SAPs</span></a> shows the
implementation model of the RLC entities and its relationship
with all the other entities and services in the protocol stack.</p>
<figure class="align-default" id="id167">
<span id="fig-lte-rlc-implementation-model"></span><img alt="_images/lte-rlc-implementation-model.png" src="_images/lte-rlc-implementation-model.png" />
<figcaption>
<p><span class="caption-text">Implementation Model of PDCP, RLC and MAC entities and SAPs</span><a class="headerlink" href="#id167" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="service-interfaces">
<h5><span class="section-number">20.1.8.2. </span>Service Interfaces<a class="headerlink" href="#service-interfaces" title="Link to this heading">¶</a></h5>
<section id="rlc-service-interface">
<h6><span class="section-number">20.1.8.2.1. </span>RLC Service Interface<a class="headerlink" href="#rlc-service-interface" title="Link to this heading">¶</a></h6>
<p>The RLC service interface is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">RlcSapProvider</span></code> part is provided by the RLC layer and used by the upper PDCP layer and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">RlcSapUser</span></code> part is provided by the upper PDCP layer and used by the RLC layer.</p></li>
</ul>
</div></blockquote>
<p>Both the UM and the AM RLC entities provide the same RLC service interface to the upper PDCP layer.</p>
<section id="rlc-service-primitives">
<h6 aria-level="7"><span class="section-number">20.1.8.2.1.1. </span>RLC Service Primitives<a class="headerlink" href="#rlc-service-primitives" title="Link to this heading">¶</a></h6>
<p>The following list specifies which service primitives are provided by the RLC service interfaces:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RlcSapProvider::TransmitPdcpPdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The PDCP entity uses this primitive to send a PDCP PDU to the lower RLC entity
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">RlcSapUser::ReceivePdcpPdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RLC entity uses this primitive to send a PDCP PDU to the upper PDCP entity
in the receiver peer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
</section>
<section id="mac-service-interface">
<h6><span class="section-number">20.1.8.2.2. </span>MAC Service Interface<a class="headerlink" href="#mac-service-interface" title="Link to this heading">¶</a></h6>
<p>The MAC service interface is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">MacSapProvider</span></code> part is provided by the MAC layer and used by the upper RLC layer and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">MacSapUser</span></code>  part is provided by the upper RLC layer and used by the MAC layer.</p></li>
</ul>
</div></blockquote>
<section id="mac-service-primitives">
<h6 aria-level="7"><span class="section-number">20.1.8.2.2.1. </span>MAC Service Primitives<a class="headerlink" href="#mac-service-primitives" title="Link to this heading">¶</a></h6>
<p>The following list specifies which service primitives are provided by the MAC service interfaces:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapProvider::TransmitPdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RLC entity uses this primitive to send a RLC PDU to the lower MAC entity
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapProvider::ReportBufferStatus</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RLC entity uses this primitive to report the MAC entity the size of pending buffers
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapUser::NotifyTxOpportunity</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The MAC entity uses this primitive to notify the RLC entity a transmission opportunity</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MacSapUser::ReceivePdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The MAC entity uses this primitive to send an RLC PDU to the upper RLC entity
in the receiver peer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
</section>
</section>
<section id="am-rlc">
<span id="sec-am-data-transfer"></span><h5><span class="section-number">20.1.8.3. </span>AM RLC<a class="headerlink" href="#am-rlc" title="Link to this heading">¶</a></h5>
<p>The processing of the data transfer in the Acknowledge Mode (AM) RLC entity is explained in section 5.1.3 of <a class="reference internal" href="index.html#ts36322" id="id72"><span>[TS36322]</span></a>.
In this section we describe some details of the implementation of the
RLC entity.</p>
<section id="buffers-for-the-transmit-operations">
<h6><span class="section-number">20.1.8.3.1. </span>Buffers for the transmit operations<a class="headerlink" href="#buffers-for-the-transmit-operations" title="Link to this heading">¶</a></h6>
<p>Our implementation of the AM RLC entity maintains 3 buffers for the
transmit operations:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Transmission Buffer</strong>: it is the RLC SDU queue.
When the AM RLC entity receives a SDU in the TransmitPdcpPdu service primitive from the
upper PDCP entity, it enqueues it in the Transmission Buffer. We
put a limit on the RLC buffer size and the LteRlc TxDrop trace source
is called when a drop due to a full buffer occurs.</p></li>
<li><p><strong>Transmitted PDUs Buffer</strong>: it is the queue of transmitted RLC PDUs for which an ACK/NACK has not
been received yet. When the AM RLC entity sends a PDU to the MAC
entity, it also puts a copy of the transmitted PDU in the Transmitted PDUs Buffer.</p></li>
<li><p><strong>Retransmission Buffer</strong>: it is the queue of RLC PDUs which are considered for retransmission
(i.e., they have been NACKed). The AM RLC entity moves this PDU to the Retransmission Buffer,
when it retransmits a PDU from the Transmitted Buffer.</p></li>
</ul>
</div></blockquote>
</section>
<section id="transmit-operations-in-downlink">
<span id="sec-rlc-am-tx-operations"></span><h6><span class="section-number">20.1.8.3.2. </span>Transmit operations in downlink<a class="headerlink" href="#transmit-operations-in-downlink" title="Link to this heading">¶</a></h6>
<p>The following sequence diagram shows the interactions between the
different entities (RRC, PDCP, AM RLC, MAC and MAC scheduler) of the
eNB in the downlink to perform data communications.</p>
<p>Figure <a class="reference internal" href="#fig-lte-rlc-data-txon-dl"><span class="std std-ref">Sequence diagram of data PDU transmission in downlink</span></a> shows how the upper layers send
data PDUs and how the data flow is processed by the different
entities/services of the LTE protocol stack.</p>
<figure class="align-default" id="id168">
<span id="fig-lte-rlc-data-txon-dl"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-txon-dl.png"><img alt="_images/lte-rlc-data-txon-dl.png" src="_images/lte-rlc-data-txon-dl.png" style="width: 550px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence diagram of data PDU transmission in downlink</span><a class="headerlink" href="#id168" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The PDCP entity calls the <code class="docutils literal notranslate"><span class="pre">Transmit_PDCP_PDU</span> <span class="pre">service</span> <span class="pre">primitive</span></code> in
order to send a data PDU. The AM RLC entity processes this service
primitive according to the AM data transfer procedures defined in
section 5.1.3 of <a class="reference internal" href="index.html#ts36322" id="id73"><span>[TS36322]</span></a>.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">Transmit_PDCP_PDU</span></code> service primitive is called, the AM RLC
entity performs the following operations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Put the data SDU in the Transmission Buffer.</p></li>
<li><p>Compute the size of the buffers (how the size of buffers is
computed will be explained afterwards).</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">Report_Buffer_Status</span></code> service primitive of the eNB
MAC entity in order to notify to the eNB MAC
entity the sizes of the buffers of the AM RLC entity. Then, the
eNB MAC entity updates the buffer status in the MAC scheduler
using the SchedDlRlcBufferReq service primitive of the FF MAC
Scheduler API.</p></li>
</ul>
</div></blockquote>
<p>Afterwards, when the MAC scheduler decides that some data can be sent,
the MAC entity notifies it to the RLC entity, i.e. it calls the
<code class="docutils literal notranslate"><span class="pre">Notify_Tx_Opportunity</span></code> service primitive, then the AM RLC entity
does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>Create a single data PDU by segmenting and/or concatenating the
SDUs in the Transmission Buffer.</p></li>
<li><p>Move the data PDU from the Transmission Buffer to the
Transmitted PDUs Buffer.</p></li>
<li><p>Update state variables according section 5.1.3.1.1 of
<a class="reference internal" href="index.html#ts36322" id="id74"><span>[TS36322]</span></a>.</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">Transmit_PDU</span></code> primitive in order to send the data
PDU to the MAC entity.</p></li>
</ul>
</div></blockquote>
</section>
<section id="retransmission-in-downlink">
<h6><span class="section-number">20.1.8.3.3. </span>Retransmission in downlink<a class="headerlink" href="#retransmission-in-downlink" title="Link to this heading">¶</a></h6>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-rlc-data-retx-dl"><span class="std std-ref">Sequence diagram of data PDU retransmission in downlink</span></a> shows
the interactions between the different entities (AM RLC, MAC and MAC
scheduler) of the eNB in downlink when data PDUs must be retransmitted
by the AM RLC entity.</p>
<figure class="align-default" id="id169">
<span id="fig-lte-rlc-data-retx-dl"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-retx-dl.png"><img alt="_images/lte-rlc-data-retx-dl.png" src="_images/lte-rlc-data-retx-dl.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence diagram of data PDU retransmission in downlink</span><a class="headerlink" href="#id169" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The transmitting AM RLC entity can receive STATUS PDUs from the peer AM RLC entity. STATUS PDUs are
sent according section 5.3.2 of <a class="reference internal" href="index.html#ts36322" id="id75"><span>[TS36322]</span></a> and the processing of reception is made according
section 5.2.1 of <a class="reference internal" href="index.html#ts36322" id="id76"><span>[TS36322]</span></a>.</p>
<p>When a data PDUs is retransmitted from the Transmitted PDUs Buffer, it is also moved to the
Retransmission Buffer.</p>
</section>
<section id="transmit-operations-in-uplink">
<h6><span class="section-number">20.1.8.3.4. </span>Transmit operations in uplink<a class="headerlink" href="#transmit-operations-in-uplink" title="Link to this heading">¶</a></h6>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-rlc-data-txon-ul"><span class="std std-ref">Sequence diagram of data PDU transmission in uplink</span></a> shows
the interactions between the different entities of the UE (RRC, PDCP,
RLC and MAC) and the eNB (MAC and Scheduler) in uplink when data PDUs
are sent by the upper layers.</p>
<figure class="align-default" id="id170">
<span id="fig-lte-rlc-data-txon-ul"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-txon-ul.png"><img alt="_images/lte-rlc-data-txon-ul.png" src="_images/lte-rlc-data-txon-ul.png" style="width: 550px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence diagram of data PDU transmission in uplink</span><a class="headerlink" href="#id170" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>It is similar to the sequence diagram in downlink; the main difference
is that in this case the Report_Buffer_Status is sent from the UE MAC
to the MAC Scheduler in the eNB over the air using the control
channel.</p>
</section>
<section id="retransmission-in-uplink">
<h6><span class="section-number">20.1.8.3.5. </span>Retransmission in uplink<a class="headerlink" href="#retransmission-in-uplink" title="Link to this heading">¶</a></h6>
<p>The sequence diagram of Figure <a class="reference internal" href="#fig-lte-rlc-data-retx-ul"><span class="std std-ref">Sequence diagram of data PDU retransmission in uplink</span></a> shows
the interactions between the different entities of the UE (AM RLC and
MAC) and the eNB (MAC) in uplink when data PDUs must be retransmitted
by the AM RLC entity.</p>
<figure class="align-default" id="id171">
<span id="fig-lte-rlc-data-retx-ul"></span><a class="reference internal image-reference" href="_images/lte-rlc-data-retx-ul.png"><img alt="_images/lte-rlc-data-retx-ul.png" src="_images/lte-rlc-data-retx-ul.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence diagram of data PDU retransmission in uplink</span><a class="headerlink" href="#id171" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="calculation-of-the-buffer-size">
<span id="sec-rlc-am-buffer-size"></span><h6><span class="section-number">20.1.8.3.6. </span>Calculation of the buffer size<a class="headerlink" href="#calculation-of-the-buffer-size" title="Link to this heading">¶</a></h6>
<p>The Transmission Buffer contains RLC SDUs. A RLC PDU is one or more SDU segments plus an RLC header.
The size of the RLC header of one RLC PDU depends on the number of SDU segments the PDU contains.</p>
<p>The 3GPP standard  (section 6.1.3.1 of <a class="reference internal" href="index.html#ts36321" id="id77"><span>[TS36321]</span></a>) says clearly that,
for the uplink, the RLC and MAC headers are not considered in the
buffer size that is to be report as part of the Buffer Status Report.
For the downlink, the behavior is not specified. Neither <a class="reference internal" href="index.html#ffapi" id="id78"><span>[FFAPI]</span></a> specifies
how to do it. Our RLC model works by assuming that the calculation of
the buffer size in the downlink is done exactly as in the uplink,
i.e., not considering the RLC and MAC header size.</p>
<p>We note that this choice affects the interoperation with the
MAC scheduler, since, in response to the
<code class="docutils literal notranslate"><span class="pre">Notify_Tx_Opportunity</span></code> service primitive, the RLC is expected to
create a PDU of no more than the size requested by the MAC, including
RLC overhead. Hence, unneeded fragmentation can occur if (for example)
the MAC notifies a transmission exactly equal to the buffer size
previously reported by the RLC. We assume that it is left to the Scheduler
to implement smart strategies for the selection of the size of the
transmission opportunity, in order to eventually avoid the inefficiency
of unneeded fragmentation.</p>
</section>
<section id="concatenation-and-segmentation">
<h6><span class="section-number">20.1.8.3.7. </span>Concatenation and Segmentation<a class="headerlink" href="#concatenation-and-segmentation" title="Link to this heading">¶</a></h6>
<p>The AM RLC entity generates and sends exactly one RLC PDU for each transmission opportunity even
if it is smaller than the size reported by the transmission opportunity. So for instance, if a
STATUS PDU is to be sent, then only this PDU will be sent in that transmission opportunity.</p>
<p>The segmentation and concatenation for the SDU queue of the AM RLC entity follows the same philosophy
as the same procedures of the UM RLC entity but there are new state
variables (see <a class="reference internal" href="index.html#ts36322" id="id79"><span>[TS36322]</span></a> section 7.1) only present in the AM RLC entity.</p>
<p>It is noted that, according to the 3GPP specs, there is no concatenation for the Retransmission Buffer.</p>
</section>
<section id="re-segmentation">
<h6><span class="section-number">20.1.8.3.8. </span>Re-segmentation<a class="headerlink" href="#re-segmentation" title="Link to this heading">¶</a></h6>
<p>The current model of the AM RLC entity does not support the
re-segmentation of the retransmission buffer. Rather, the AM RLC
entity just waits to receive a big enough transmission
opportunity.</p>
</section>
<section id="unsupported-features">
<h6><span class="section-number">20.1.8.3.9. </span>Unsupported features<a class="headerlink" href="#unsupported-features" title="Link to this heading">¶</a></h6>
<p>We do not support the following procedures of <a class="reference internal" href="index.html#ts36322" id="id80"><span>[TS36322]</span></a> :</p>
<blockquote>
<div><ul class="simple">
<li><p>“Send an indication of successful delivery of RLC SDU” (See section 5.1.3.1.1)</p></li>
<li><p>“Indicate to upper layers that max retransmission has been reached” (See section 5.2.1)</p></li>
<li><p>“SDU discard procedures” (See section 5.3)</p></li>
<li><p>“Re-establishment procedure” (See section 5.4)</p></li>
</ul>
</div></blockquote>
<p>We do not support any of the additional primitives of RLC SAP for AM RLC entity. In particular:</p>
<blockquote>
<div><ul class="simple">
<li><p>no SDU discard notified by PDCP</p></li>
<li><p>no notification of successful / failed delivery by AM RLC entity to PDCP entity</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="um-rlc">
<h5><span class="section-number">20.1.8.4. </span>UM RLC<a class="headerlink" href="#um-rlc" title="Link to this heading">¶</a></h5>
<p>In this section we describe the implementation of the Unacknowledged Mode (UM) RLC entity.</p>
<section id="id81">
<h6><span class="section-number">20.1.8.4.1. </span>Transmit operations in downlink<a class="headerlink" href="#id81" title="Link to this heading">¶</a></h6>
<p>The transmit operations of the UM RLC are similar to those of the AM
RLC previously described in Section <a class="reference internal" href="#sec-rlc-am-tx-operations"><span class="std std-ref">Transmit operations in downlink</span></a>,
with the difference that, following the specifications of <a class="reference internal" href="index.html#ts36322" id="id82"><span>[TS36322]</span></a>,
retransmission are not performed, and there are no STATUS PDUs.</p>
</section>
<section id="id83">
<h6><span class="section-number">20.1.8.4.2. </span>Transmit operations in uplink<a class="headerlink" href="#id83" title="Link to this heading">¶</a></h6>
<p>The transmit operations in the uplink are similar to those of the
downlink, with the main difference that the Report_Buffer_Status is
sent from the UE MAC to the MAC Scheduler in the eNB over the air
using the control channel.</p>
</section>
<section id="id84">
<h6><span class="section-number">20.1.8.4.3. </span>Calculation of the buffer size<a class="headerlink" href="#id84" title="Link to this heading">¶</a></h6>
<p>The calculation of the buffer size for the UM RLC is done using the
same approach of the AM RLC, please refer to section
<a class="reference internal" href="#sec-rlc-am-buffer-size"><span class="std std-ref">Calculation of the buffer size</span></a> for the corresponding description.</p>
</section>
</section>
<section id="tm-rlc">
<h5><span class="section-number">20.1.8.5. </span>TM RLC<a class="headerlink" href="#tm-rlc" title="Link to this heading">¶</a></h5>
<p>In this section we describe the implementation of the Transparent Mode (TM) RLC entity.</p>
<section id="id85">
<h6><span class="section-number">20.1.8.5.1. </span>Transmit operations in downlink<a class="headerlink" href="#id85" title="Link to this heading">¶</a></h6>
<p>In the simulator, the TM RLC still provides to the upper layers the
same service interface provided by the AM and UM RLC
entities to the PDCP layer; in practice, this interface is used by an RRC
entity (not a PDCP entity) for the transmission of RLC SDUs. This
choice is motivated by the fact that the services provided by the TM
RLC to the upper layers, according to <a class="reference internal" href="index.html#ts36322" id="id86"><span>[TS36322]</span></a>, is a subset of those
provided by the UM and AM RLC entities to the PDCP layer; hence,
we reused the same interface for simplicity.</p>
<p>The transmit operations in the downlink are performed as follows. When
the <code class="docutils literal notranslate"><span class="pre">Transmit_PDCP_PDU</span> <span class="pre">service</span> <span class="pre">primitive</span></code> is called by the upper
layers, the TM RLC does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>put the SDU in the Transmission Buffer</p></li>
<li><p>compute the size of the Transmission Buffer</p></li>
<li><p>call the <code class="docutils literal notranslate"><span class="pre">Report_Buffer_Status</span></code> service primitive of the eNB
MAC entity</p></li>
</ul>
</div></blockquote>
<p>Afterwards, when the MAC scheduler decides that some data can be sent
by the logical channel to which the TM RLC entity belongs, the MAC
entity notifies it to the TM RLC entity by calling the
<code class="docutils literal notranslate"><span class="pre">Notify_Tx_Opportunity</span></code> service primitive. Upon reception of this
primitive, the TM RLC entity does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>if the TX opportunity has a size that is greater than or equal to
the size of the head-of-line SDU in the Transmission Buffer</p>
<ul>
<li><p>dequeue the head-of-line SDU from the Transmission Buffer</p></li>
<li><p>create one RLC PDU that contains entirely that SDU, without any
RLC header</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">Transmit_PDU</span></code> primitive in order to send the RLC
PDU to the MAC entity.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</section>
<section id="id87">
<h6><span class="section-number">20.1.8.5.2. </span>Transmit operations in uplink<a class="headerlink" href="#id87" title="Link to this heading">¶</a></h6>
<p>The transmit operations in the uplink are similar to those of the
downlink, with the main difference that a transmission opportunity can
also arise from the assignment of the UL GRANT as part of the Random
Access procedure, without an explicit Buffer Status Report issued by
the TM RLC entity.</p>
</section>
<section id="id88">
<h6><span class="section-number">20.1.8.5.3. </span>Calculation of the buffer size<a class="headerlink" href="#id88" title="Link to this heading">¶</a></h6>
<p>As per the specifications <a class="reference internal" href="index.html#ts36322" id="id89"><span>[TS36322]</span></a>, the TM RLC does not add any RLC
header to the PDUs being transmitted. Because of this, the buffer size
reported to the MAC layer is calculated simply by summing the size of
all packets in the transmission buffer, thus notifying to the MAC the
exact buffer size.</p>
</section>
</section>
<section id="sm-rlc">
<span id="sec-sm-rlc"></span><h5><span class="section-number">20.1.8.6. </span>SM RLC<a class="headerlink" href="#sm-rlc" title="Link to this heading">¶</a></h5>
<p>In addition to the AM, UM and TM implementations that are modeled
after the 3GPP specifications, a simplified RLC model is provided,
which is called Saturation Mode (SM) RLC. This RLC model does not accept
PDUs from any above layer (such as PDCP); rather, the SM RLC takes care of the
generation of RLC PDUs in response to
the notification of transmission opportunities notified by the MAC.
In other words, the SM RLC simulates saturation conditions, i.e., it
assumes that the RLC buffer is always full and can generate a new PDU
whenever notified by the scheduler.</p>
<p>The SM RLC is used for simplified simulation scenarios in which only the
LTE Radio model is used, without the EPC and hence without any IP
networking support. We note that, although the SM RLC is an
unrealistic traffic model, it still allows for the correct simulation
of scenarios with multiple flows belonging to different (non real-time)
QoS classes, in order to test the QoS performance obtained by different
schedulers. This can be
done since it is the task of the Scheduler to assign transmission
resources based on the characteristics (e.g., Guaranteed Bit Rate) of
each Radio Bearer, which are specified upon the definition of each
Bearer within the simulation program.</p>
<p>As for schedulers designed to work with real-time QoS
traffic that has delay constraints, the SM RLC is probably not an appropriate choice.
This is because the absence of actual RLC SDUs (replaced by the artificial
generation of Buffer Status Reports) makes it not possible to provide
the Scheduler with meaningful head-of-line-delay information, which is
often the metric of choice for the implementation of scheduling
policies for real-time traffic flows. For the simulation and testing
of such schedulers, it is advisable to use either the UM or the AM RLC
models instead.</p>
</section>
</section>
<section id="pdcp">
<h4><span class="section-number">20.1.9. </span>PDCP<a class="headerlink" href="#pdcp" title="Link to this heading">¶</a></h4>
<section id="pdcp-model-overview">
<h5><span class="section-number">20.1.9.1. </span>PDCP Model Overview<a class="headerlink" href="#pdcp-model-overview" title="Link to this heading">¶</a></h5>
<p>The reference document for the specification of the PDCP entity is
<a class="reference internal" href="index.html#ts36323" id="id90"><span>[TS36323]</span></a>. With respect to this specification, the PDCP model
implemented in the simulator supports only the following features:</p>
<blockquote>
<div><ul class="simple">
<li><p>transfer of data (user plane or control plane);</p></li>
<li><p>maintenance of PDCP SNs;</p></li>
<li><p>transfer of SN status (for use upon handover);</p></li>
</ul>
</div></blockquote>
<p>The following features are currently not supported:</p>
<blockquote>
<div><ul class="simple">
<li><p>header compression and decompression of IP data flows using the ROHC protocol;</p></li>
<li><p>in-sequence delivery of upper layer PDUs at re-establishment of lower layers;</p></li>
<li><p>duplicate elimination of lower layer SDUs at re-establishment of lower layers for radio bearers mapped on RLC AM;</p></li>
<li><p>ciphering and deciphering of user plane data and control plane data;</p></li>
<li><p>integrity protection and integrity verification of control plane data;</p></li>
<li><p>timer based discard;</p></li>
<li><p>duplicate discarding.</p></li>
</ul>
</div></blockquote>
</section>
<section id="pdcp-service-interface">
<h5><span class="section-number">20.1.9.2. </span>PDCP Service Interface<a class="headerlink" href="#pdcp-service-interface" title="Link to this heading">¶</a></h5>
<p>The PDCP service interface is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">PdcpSapProvider</span></code> part is provided by the PDCP layer and used by the upper layer and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">PdcpSapUser</span></code> part is provided by the upper layer and used by the PDCP layer.</p></li>
</ul>
</div></blockquote>
<section id="pdcp-service-primitives">
<h6><span class="section-number">20.1.9.2.1. </span>PDCP Service Primitives<a class="headerlink" href="#pdcp-service-primitives" title="Link to this heading">¶</a></h6>
<p>The following list specifies which service primitives are provided by the PDCP service interfaces:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">PdcpSapProvider::TransmitPdcpSdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The RRC entity uses this primitive to send an RRC PDU to the lower PDCP entity
in the transmitter peer</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PdcpSapUser::ReceivePdcpSdu</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>The PDCP entity uses this primitive to send an RRC PDU to the upper RRC entity
in the receiver peer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
</section>
</section>
<section id="rrc">
<h4><span class="section-number">20.1.10. </span>RRC<a class="headerlink" href="#rrc" title="Link to this heading">¶</a></h4>
<section id="features">
<h5><span class="section-number">20.1.10.1. </span>Features<a class="headerlink" href="#features" title="Link to this heading">¶</a></h5>
<p>The RRC model implemented in the simulator provides the following functionality:</p>
<blockquote>
<div><ul class="simple">
<li><p>generation (at the eNB) and interpretation (at the UE) of System
Information (in particular the Master Information Block and, at the
time of this writing, only System Information Block Type 1 and 2)</p></li>
<li><p>initial cell selection</p></li>
<li><p>RRC connection establishment procedure</p></li>
<li><p>RRC reconfiguration procedure, supporting the following use cases:
+ reconfiguration of the SRS configuration index
+ reconfiguration of the PHY TX mode (MIMO)
+ reconfiguration of UE measurements
+ data radio bearer setup
+ handover</p></li>
<li><p>RRC connection re-establishment, supporting the following use
cases:
+ handover</p></li>
</ul>
</div></blockquote>
</section>
<section id="id91">
<h5><span class="section-number">20.1.10.2. </span>Architecture<a class="headerlink" href="#id91" title="Link to this heading">¶</a></h5>
<p>The RRC model is divided into the following components:</p>
<blockquote>
<div><ul class="simple">
<li><p>the RRC entities <cite>LteUeRrc</cite> and <cite>LteEnbRrc</cite>, which implement the state
machines of the RRC entities respectively at the UE and the eNB;</p></li>
<li><p>the RRC SAPs <cite>LteUeRrcSapProvider</cite>, <cite>LteUeRrcSapUser</cite>,
<cite>LteEnbRrcSapProvider</cite>, <cite>LteEnbRrcSapUser</cite>, which allow the RRC
entities to send and receive RRC messages and information
elmenents;</p></li>
<li><p>the RRC protocol classes <cite>LteUeRrcProtocolIdeal</cite>,
<cite>LteEnbRrcProtocolIdeal</cite>, <cite>LteUeRrcProtocolReal</cite>,
<cite>LteEnbRrcProtocolReal</cite>, which implement two different models for
the transmission of RRC messages.</p></li>
</ul>
</div></blockquote>
<p>Additionally, the RRC components use various other SAPs in order to
interact with the rest of the protocol stack. A representation of all
the SAPs that are used is provided in the figures <a class="reference internal" href="#fig-lte-arch-ue-data"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the data plane</span></a>,
<a class="reference internal" href="#fig-lte-arch-ue-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the UE on the control plane</span></a>, <a class="reference internal" href="#fig-lte-arch-enb-data"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the data plane</span></a> and
<a class="reference internal" href="#fig-lte-arch-enb-ctrl"><span class="std std-ref">LTE radio protocol stack architecture for the eNB on the control plane</span></a>.</p>
</section>
<section id="ue-rrc-state-machine">
<h5><span class="section-number">20.1.10.3. </span>UE RRC State Machine<a class="headerlink" href="#ue-rrc-state-machine" title="Link to this heading">¶</a></h5>
<p>In Figure <a class="reference internal" href="#fig-lte-ue-rrc-states"><span class="std std-ref">UE RRC State Machine</span></a> we represent the state machine
as implemented in the RRC UE entity.</p>
<figure class="align-center" id="id172">
<span id="fig-lte-ue-rrc-states"></span><a class="reference internal image-reference" href="_images/lte-ue-rrc-states.png"><img alt="_images/lte-ue-rrc-states.png" src="_images/lte-ue-rrc-states.png" style="width: 538.1999999999999px; height: 769.8px;" /></a>
<figcaption>
<p><span class="caption-text">UE RRC State Machine</span><a class="headerlink" href="#id172" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>All the states are transient, however, the UE in “CONNECTED_NORMALLY” state will
only switch to the IDLE state if the downlink SINR is below a defined threshold,
which would lead to radio link failure <a class="reference internal" href="#sec-radio-link-failure"><span class="std std-ref">Radio Link Failure</span></a>.
One the other hand, the UE would not be able switch to IDLE mode due to a handover
failure, as mentioned in <a class="reference internal" href="#sec-x2"><span class="std std-ref">X2</span></a>.</p>
</section>
<section id="enb-rrc-state-machine">
<h5><span class="section-number">20.1.10.4. </span>ENB RRC State Machine<a class="headerlink" href="#enb-rrc-state-machine" title="Link to this heading">¶</a></h5>
<p>The eNB RRC maintains the state for each UE that is attached to the
cell. From an implementation point of view, the state of each UE is
contained in an instance of the UeManager class. The state machine is
represented in Figure <a class="reference internal" href="#fig-lte-enb-rrc-states"><span class="std std-ref">ENB RRC State Machine for each UE</span></a>.</p>
<figure class="align-center" id="id173">
<span id="fig-lte-enb-rrc-states"></span><a class="reference internal image-reference" href="_images/lte-enb-rrc-states.png"><img alt="_images/lte-enb-rrc-states.png" src="_images/lte-enb-rrc-states.png" style="width: 744.8px; height: 683.1999999999999px;" /></a>
<figcaption>
<p><span class="caption-text">ENB RRC State Machine for each UE</span><a class="headerlink" href="#id173" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="initial-cell-selection">
<span id="sec-initial-cell-selection"></span><h5><span class="section-number">20.1.10.5. </span>Initial Cell Selection<a class="headerlink" href="#initial-cell-selection" title="Link to this heading">¶</a></h5>
<p>Initial cell selection is an IDLE mode procedure, performed by UE when it has
not yet camped or attached to an eNodeB. The objective of the procedure is to
find a suitable cell and attach to it to gain access to the cellular network.</p>
<p>It is typically done at the beginning of simulation, as depicted in Figure
<a class="reference internal" href="#fig-lte-cell-selection-timeline"><span class="std std-ref">Sample runs of initial cell selection in UE and timing of related events</span></a> below. The time diagram on the left side
is illustrating the case where initial cell selection succeed on first try,
while the diagram on the right side is for the case where it fails on the first
try and succeed on the second try. The timing assumes the use of real RRC
protocol model (see <a class="reference internal" href="#sec-rrc-protocol-models"><span class="std std-ref">RRC protocol models</span></a>) and no transmission error.</p>
<figure class="align-center" id="id174">
<span id="fig-lte-cell-selection-timeline"></span><a class="reference internal image-reference" href="_images/lte-cell-selection-timeline.png"><img alt="_images/lte-cell-selection-timeline.png" src="_images/lte-cell-selection-timeline.png" style="width: 624.0px; height: 643.2px;" /></a>
<figcaption>
<p><span class="caption-text">Sample runs of initial cell selection in UE and timing of related events</span><a class="headerlink" href="#id174" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The functionality is based on 3GPP IDLE mode specifications, such as in
<a class="reference internal" href="index.html#ts36300" id="id92"><span>[TS36300]</span></a>, <a class="reference internal" href="index.html#ts36304" id="id93"><span>[TS36304]</span></a>, and <a class="reference internal" href="index.html#ts36331" id="id94"><span>[TS36331]</span></a>. However, a proper implementation of IDLE
mode is still missing in the simulator, so we reserve several simplifying
assumptions:</p>
<blockquote>
<div><ul class="simple">
<li><p>multiple carrier frequency is not supported;</p></li>
<li><p>multiple Public Land Mobile Network (PLMN) identities (i.e. multiple network
operators) is not supported;</p></li>
<li><p>RSRQ measurements are not utilized;</p></li>
<li><p>stored information cell selection is not supported;</p></li>
<li><p>“Any Cell Selection” state and camping to an acceptable cell is not
supported;</p></li>
<li><p>marking a cell as barred or reserved is not supported;</p></li>
<li><p>Idle cell reselection is not supported, hence it is not possible for UE to camp to
a different cell after the initial camp has been placed; and</p></li>
<li><p>UE’s Closed Subscriber Group (CSG) white list contains only one CSG identity.</p></li>
</ul>
</div></blockquote>
<p>Also note that initial cell selection is only available for EPC-enabled
simulations. LTE-only simulations must use the manual attachment method. See
section <a class="reference internal" href="index.html#sec-network-attachment"><span class="std std-ref">Network Attachment</span></a> of the User Documentation for more
information on their differences in usage.</p>
<p>The next subsections cover different parts of initial cell selection, namely
<em>cell search</em>, <em>broadcast of system information</em>, and <em>cell selection evaluation</em>.</p>
<section id="cell-search">
<span id="sec-cell-search"></span><h6><span class="section-number">20.1.10.5.1. </span>Cell Search<a class="headerlink" href="#cell-search" title="Link to this heading">¶</a></h6>
<p>Cell search aims to detect surrounding cells and measure the strength of
received signal from each of these cells. One of these cells will become the
UE’s entry point to join the cellular network.</p>
<p>The measurements are based on the RSRP of the received PSS, averaged by Layer 1
filtering, and performed by the PHY layer, as previously described in more
detail in section <a class="reference internal" href="#sec-phy-ue-measurements"><span class="std std-ref">UE PHY Measurements Model</span></a>. PSS is transmitted by eNodeB
over the central 72 sub-carriers of the DL channel (Section 5.1.7.3 <a class="reference internal" href="index.html#ts36300" id="id95"><span>[TS36300]</span></a>),
hence we model cell search to operate using a DL bandwidth of 6 RBs. Note that
measurements of RSRQ are not available at this point of time in simulation. As
a consequence, the <code class="docutils literal notranslate"><span class="pre">LteUePhy::RsrqUeMeasThreshold</span></code> attribute does not apply
during cell search.</p>
<p>By using the measured RSRP, the PHY entity is able to generate a list of
detected cells, each with its corresponding cell ID and averaged RSRP. This list
is periodically pushed via CPHY SAP to the RRC entity as a measurement report.</p>
<p>The RRC entity inspects the report and simply choose the cell with the strongest
RSRP, as also indicated in Section 5.2.3.1 of <a class="reference internal" href="index.html#ts36304" id="id96"><span>[TS36304]</span></a>. Then it instructs back
the PHY entity to synchronize to this particular cell. The actual operating
bandwidth of the cell is still unknown at this time, so the PHY entity listens
only to the minimum bandwidth of 6 RBs. Nevertheless, the PHY entity will be
able to receive system broadcast message from this particular eNodeB, which is
the topic of the next subsection.</p>
</section>
<section id="broadcast-of-system-information">
<h6><span class="section-number">20.1.10.5.2. </span>Broadcast of System Information<a class="headerlink" href="#broadcast-of-system-information" title="Link to this heading">¶</a></h6>
<p>System information blocks are broadcasted by eNodeB to UEs at predefined time
intervals, adapted from Section 5.2.1.2 of <a class="reference internal" href="index.html#ts36331" id="id97"><span>[TS36331]</span></a>. The supported system
information blocks are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Master Information Block (MIB)</dt><dd><p>Contains parameters related to the PHY layer, generated during cell
configuration and broadcasted every 10 ms at the beginning of radio frame
as a control message.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>System Information Block Type 1 (SIB1)</dt><dd><p>Contains information regarding network access, broadcasted every 20 ms at
the middle of radio frame as a control message. Not used in manual
attachment method. UE must have decoded MIB before it can receive SIB1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>System Information Block Type 2 (SIB2)</dt><dd><p>Contains UL- and RACH-related settings, scheduled to transmit via RRC
protocol at 16 ms after cell configuration, and then repeats every 80 ms
(configurable through <cite>LteEnbRrc::SystemInformationPeriodicity</cite> attribute.
UE must be camped to a cell in order to be able to receive its SIB2.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Reception of system information is fundamental for UE to advance in its
lifecycle. MIB enables the UE to increase the initial DL bandwidth of 6 RBs to
the actual operating bandwidth of the network. SIB1 provides information
necessary for cell selection evaluation (explained in the next section). And
finally SIB2 is required before the UE is allowed to switch to CONNECTED state.</p>
</section>
<section id="cell-selection-evaluation">
<span id="sec-cell-selection-evaluation"></span><h6><span class="section-number">20.1.10.5.3. </span>Cell Selection Evaluation<a class="headerlink" href="#cell-selection-evaluation" title="Link to this heading">¶</a></h6>
<p>UE RRC reviews the measurement report produced in <a class="reference internal" href="#sec-cell-search"><span class="std std-ref">Cell Search</span></a> and the
cell access information provided by SIB1. Once both information is available for
a specific cell, the UE triggers the evaluation process. The purpose of this
process is to determine whether the cell is a suitable cell to camp to.</p>
<p>The evaluation process is a slightly simplified version of Section 5.2.3.2 of
<a class="reference internal" href="index.html#ts36304" id="id98"><span>[TS36304]</span></a>. It consists of the following criteria:</p>
<blockquote>
<div><ul class="simple">
<li><p>Rx level criterion; and</p></li>
<li><p>closed subscriber group (CSG) criterion.</p></li>
</ul>
</div></blockquote>
<p>The first criterion, Rx level, is based on the cell’s measured RSRP
<img class="math" src="_images/math/c3ea4d8593d3cb6fe33d1a0ca5def5ef94ae5164.png" alt="Q_{rxlevmeas}"/>, which has to be higher than a required minimum
<img class="math" src="_images/math/31fe99de5833e46d070576e6df3ea7df3e435030.png" alt="Q_{rxlevmin}"/> in order to pass the criterion:</p>
<div class="math">
<p><img src="_images/math/2bdca35105cbeb8515fffaa58cc35c1492bde075.png" alt="Q_{rxlevmeas} - Q_{rxlevmin} &gt; 0"/></p>
</div><p>where <img class="math" src="_images/math/31fe99de5833e46d070576e6df3ea7df3e435030.png" alt="Q_{rxlevmin}"/> is determined by each eNodeB and is obtainable by UE
from SIB1.</p>
<p>The last criterion, CSG, is a combination of a true-or-false parameter called
<em>CSG indication</em> and a simple number <em>CSG identity</em>. The basic rule is that UE
shall not camp to eNodeB with a different CSG identity. But this rule is only
enforced when CSG indication is valued as true. More details are provided in
Section <a class="reference internal" href="index.html#sec-network-attachment"><span class="std std-ref">Network Attachment</span></a> of the User Documentation.</p>
<p>When the cell passes all the above criteria, the cell is deemed as <em>suitable</em>.
Then UE camps to it (<cite>IDLE_CAMPED_NORMALLY</cite> state).</p>
<p>After this, upper layer may request UE to enter CONNECTED mode. Please refer to
section <a class="reference internal" href="#sec-rrc-connection-establishment"><span class="std std-ref">RRC connection establishment</span></a> for details on this.</p>
<p>On the other hand, when the cell does not pass the CSG criterion, then the cell
is labeled as <em>acceptable</em> (Section 10.1.1.1 <a class="reference internal" href="index.html#ts36300" id="id99"><span>[TS36300]</span></a>). In this case, the RRC
entity will tell the PHY entity to synchronize to the second strongest cell and
repeat the initial cell selection procedure using that cell. As long as no
suitable cell is found, the UE will repeat these steps while avoiding cells that
have been identified as acceptable.</p>
</section>
</section>
<section id="radio-admission-control">
<h5><span class="section-number">20.1.10.6. </span>Radio Admission Control<a class="headerlink" href="#radio-admission-control" title="Link to this heading">¶</a></h5>
<p>Radio Admission Control is supported by having the eNB RRC
reply to an RRC CONNECTION REQUEST message sent by the UE with either
an RRC CONNECTION SETUP message or an RRC CONNECTION REJECT message,
depending on whether the new UE is to be admitted or not. In the
current implementation, the behavior is determined by the boolean attribute
<code class="docutils literal notranslate"><span class="pre">ns3::LteEnbRrc::AdmitRrcConnectionRequest</span></code>. There is currently no Radio Admission
Control algorithm that dynamically decides whether a new connection
shall be admitted or not.</p>
</section>
<section id="radio-bearer-configuration">
<h5><span class="section-number">20.1.10.7. </span>Radio Bearer Configuration<a class="headerlink" href="#radio-bearer-configuration" title="Link to this heading">¶</a></h5>
<p>Some implementation choices have been made in the RRC regarding the setup of radio bearers:</p>
<blockquote>
<div><ul class="simple">
<li><p>three Logical Channel Groups (out of four available) are configured
for uplink buffer status report purposes, according to the following policy:</p>
<ul>
<li><p>LCG 0 is for signaling radio bearers</p></li>
<li><p>LCG 1 is for GBR data radio bearers</p></li>
<li><p>LCG 2 is for Non-GBR data radio bearers</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</section>
<section id="radio-link-failure">
<span id="sec-radio-link-failure"></span><h5><span class="section-number">20.1.10.8. </span>Radio Link Failure<a class="headerlink" href="#radio-link-failure" title="Link to this heading">¶</a></h5>
<p>In real LTE networks, Radio link failure (RLF) can happen due to several reasons.
It can be triggered if a UE is unable to decode PDCCH due to poor signal quality,
upon maximum RLC retransmissions, RACH problems and other reasons. 3GPP only
specifies guidelines to detect RLF at the UE side, in <a class="reference internal" href="index.html#ts36331" id="id100"><span>[TS36331]</span></a> and <a class="reference internal" href="index.html#ts36133" id="id101"><span>[TS36133]</span></a>.
On the other hand, the eNB implementation is expected to be vendor specific.
To implement the RLF functionality in ns-3, we have assumed the following
simplifications:</p>
<blockquote>
<div><ul class="simple">
<li><p>The RLF detection procedure at eNodeB is not implemented. <strong>Instead, a direct
function call by using the SAP between UE and eNB RRC (for both ideal and real
RRC) is used to notify the eNB about the RLF</strong>.</p></li>
<li><p>No RRC connection re-establishment procedure is implemented, thus, the UE
directly goes to the IDLE state upon RLF. This is in fact as per the standard
<a class="reference internal" href="index.html#ts36331" id="id102"><span>[TS36331]</span></a> sec 5.3.11.3, since, at this stage the LTE module does not support
the Access Stratum (AS) security.</p></li>
</ul>
</div></blockquote>
<p>The above mentioned RLF specifications can be divided into the following two
categories:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>RLF detection</p></li>
<li><p>Actions upon RLF detection</p></li>
</ol>
</div></blockquote>
<p>In the following, we will explain the RLF implementation in context of these
two categories.</p>
<section id="rlf-detection-implementation">
<h6><span class="section-number">20.1.10.8.1. </span>RLF detection implementation<a class="headerlink" href="#rlf-detection-implementation" title="Link to this heading">¶</a></h6>
<p>The RLF detection at the UE is implemented as per <a class="reference internal" href="index.html#ts36133" id="id103"><span>[TS36133]</span></a>, i.e., by monitoring
the radio link quality based on the reference signals (which in the simulation
is equivalent to the PDCCH) in the downlink. Thus, it is independent of the method
used for the downlink CQI computation, i.e., <em>Ctrl</em> method and <em>Mixed method</em>.
Moreover, when using FFR, especially for hard-FFR, and CQIs based on <em>Mixed method</em>,
UEs might experience relatively good performance and RLF simultaneously. This is
due to the fact that the interference in PDSCH is affected by the actual data
transmissions on the specific RBs and the power control. Therefore, UEs might
experience good SINR in PDSCH, while bad SINR in PDCCH channel. For more details
about these methods please refer to <a class="reference internal" href="#sec-cqi-feedback"><span class="std std-ref">CQI feedback</span></a>. Also, it does not
matter if the DL control error model is disabled, a UE can still detect the RLF
since the SINR based on the control channel is reported to the LteUePhy class,
using a callback hooked in LteHelper while installing a UE device.</p>
<p>The RLF detection starts once the RRC connection is established between UE and
eNodeB, i.e., UE is in “CONNECTED_NORMALLY” state; upon which the RLF parameters
are configured (see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoConfigureRadioLinkFailureDetection</span></code>). In real
networks, these parameters are transmitted by the eNB using IE UE-TimersAndConstants or
RLF-TimersAndConstants. However, for the sake of simplification, in the simulator
they are presented as the attributes of the LteUePhy and LteUeRrc classes.
Moreover, what concerns the carrier aggregation, i.e., when a UE is configured
with multiple component carriers, the RLF detection is only performed by the
primary component carrier, i.e. component carrier id 0
(see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoNotifyConnectionSuccessful</span></code>). In LteUePhy class, CQI
calculation is triggered for every downlink subframe received,
and the average SINR value is measured across all resource blocks. For the RLF
detection, these SINR values are averaged over a downlink frame and if the result
is less than a defined threshold Qout (default: -5dB), the frame cannot be decoded
(see``LteUePhy::RadioLinkFailureDetection``). The Qout threshold corresponds to 10%
block error rate (BLER) of a hypothetical PDCCH transmission taking into account
the PCFICH errors <a class="reference internal" href="index.html#r4-081920" id="id104"><span>[R4-081920]</span></a> (also refer to
<a class="reference internal" href="#sec-control-channels-phy-error-model"><span class="std std-ref">Control Channels PHY Error Model</span></a>). Once, the UE is unable to decode
20 consecutive frames, i.e., the Qout evaluation period (200ms) is reached, an
out-of-sync indication is sent to the UE RRC layer (see <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoNotifyOutOfSync</span></code>).
Else, the counter for the unsuccessfuly decoded frames is reset to zero. At the
LteUeRrc, when the number of consecutive out-of-sync indications matches with the
value of N310 parameter, the T310 timer is started and LteUePhy is notified to start
measuring for in-sync indications (see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoStartInSyncDetection</span></code>). We note
that, the UE RRC state is not changed till the expiration of T310 timer. If the
resultant SINR values averaged over a downlink frame is greater than a defined
threshold Qin (default: -3.8dB), the frame is considered to be successfully
decoded. Qin corresponds to 2% BLER <a class="reference internal" href="index.html#r4-081920" id="id105"><span>[R4-081920]</span></a> of a hypothetical PDCCH transmission
taking into account the PCFICH errors. Once the UE is able to decode 10
consecutive frames, an in-sync indication is sent to the UE RRC layer
(see <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoNotifyInSync</span></code>). Else, the counter for the successfully decoded
frames is reset to zero. If prior to the T310 timer expiry, the number of
consecutive in-sync indications matches with N311 parameter of LteUeRRC, the UE
is considered back in-sync. At this stage, the related parameters are reset to
initiate the radio link failure detection from the beginning
(see <code class="docutils literal notranslate"><span class="pre">LteUePhy::DoConfigureRadioLinkFailureDetection</span></code>). On the other hand, If the
T310 timer expires, the UE considers that a RLF has occurred
(see <code class="docutils literal notranslate"><span class="pre">LteUeRrc::RadioLinkFailureDetected</span></code>).</p>
</section>
<section id="actions-upon-rlf">
<h6><span class="section-number">20.1.10.8.2. </span>Actions upon RLF<a class="headerlink" href="#actions-upon-rlf" title="Link to this heading">¶</a></h6>
<p>Once the T310 timer is expired, a UE is considered to be in RLF; upon which the
UE RRC:</p>
<blockquote>
<div><ul class="simple">
<li><p>Sends a request to the eNB RRC to remove the UE context</p></li>
<li><p>Moves to “CONNECTED_PHY_PROBLEM” state</p></li>
<li><p>Notifies the UE NAS layer about the release of RRC connection.</p></li>
</ul>
</div></blockquote>
<p>Then, after getting the notification from the UE RRC the NAS does the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>Delete all the TFTs</p></li>
<li><p>Reset the bearer counter</p></li>
<li><p>Restore the bearer list, which is used to activate the bearers for the next
RRC connection. This restoration of the bearers is achieved by maintaining an
additional list, i.e., m_bearersToBeActivatedListForReconnection in EpcUeNas
class</p></li>
<li><p>Switch the NAS state to OFF by calling EpcUeNas::Disconnect</p></li>
<li><p>Tells the UE RRC to disconnect</p></li>
</ul>
</div></blockquote>
<p>The UE RRC, upon receiving the call to disconnect from the EpcUeNas class,
performs the action as specified by <a class="reference internal" href="index.html#ts36331" id="id106"><span>[TS36331]</span></a> 5.3.11.3, and finally leaves the
connected state, i.e., its RRC state is changed from “CONNECTED_PHY_PROBLEM” to
“IDLE_START” to perform cell selection as shown in figures <a class="reference internal" href="#fig-lte-ue-rrc-states"><span class="std std-ref">UE RRC State Machine</span></a>
and <a class="reference internal" href="#fig-lte-ue-procedures-after-rlf"><span class="std std-ref">UE procedures after radio link failure</span></a>.</p>
<p>At this stage, the LTE module does not support the paging functionality, therefore,
to allow a UE to read SIB2 message after camping on a suitable cell after RLF, a
work around is used in <code class="docutils literal notranslate"><span class="pre">LteUeRrc::EvaluateCellForSelection</span></code> method. As per this
workaround, the UE RRC invokes the call to <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoConnect</span></code> method, which
enables the UE to switch its state from “IDLE_CAMPED_NORMALLY” to “IDLE_WAIT_SIB2”,
thus, allowing it to perform the random access.</p>
<figure class="align-center" id="id175">
<span id="fig-lte-ue-procedures-after-rlf"></span><a class="reference internal image-reference" href="_images/lte-ue-procedures-after-rlf.png"><img alt="_images/lte-ue-procedures-after-rlf.png" src="_images/lte-ue-procedures-after-rlf.png" style="width: 1155.2px; height: 1625.4499999999998px;" /></a>
<figcaption>
<p><span class="caption-text">UE procedures after radio link failure</span><a class="headerlink" href="#id175" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The eNB RRC, after receiving the notification from the UE RRC starts the procedure
of UE context deletion, which also involves the deletion of the UE context removal
from the EPC <a class="reference internal" href="#fig-lte-ue-context-removal-from-epc"><span class="std std-ref">UE context removal from EPC</span></a> and the eNB stack
<a class="reference internal" href="#fig-lte-ue-context-removal-from-enb-stack"><span class="std std-ref">UE context removal from eNB stack</span></a>. We note that, the UE context
at the MME is not removed since, bearers are only added at the start of a
simulation in MME, and cannot be added again unless scheduled for addition
during a simulation.</p>
<figure class="align-center" id="id176">
<span id="fig-lte-ue-context-removal-from-epc"></span><a class="reference internal image-reference" href="_images/lte-ue-context-removal-from-epc.png"><img alt="_images/lte-ue-context-removal-from-epc.png" src="_images/lte-ue-context-removal-from-epc.png" style="width: 1126.4px; height: 680.0px;" /></a>
<figcaption>
<p><span class="caption-text">UE context removal from EPC</span><a class="headerlink" href="#id176" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id177">
<span id="fig-lte-ue-context-removal-from-enb-stack"></span><a class="reference internal image-reference" href="_images/lte-ue-context-removal-from-enb-stack.png"><img alt="_images/lte-ue-context-removal-from-enb-stack.png" src="_images/lte-ue-context-removal-from-enb-stack.png" style="width: 1433.6000000000001px; height: 548.8000000000001px;" /></a>
<figcaption>
<p><span class="caption-text">UE context removal from eNB stack</span><a class="headerlink" href="#id177" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="ue-rrc-measurements-model">
<span id="sec-ue-measurements"></span><h5><span class="section-number">20.1.10.9. </span>UE RRC Measurements Model<a class="headerlink" href="#ue-rrc-measurements-model" title="Link to this heading">¶</a></h5>
<section id="ue-rrc-measurements-support">
<h6><span class="section-number">20.1.10.9.1. </span>UE RRC measurements support<a class="headerlink" href="#ue-rrc-measurements-support" title="Link to this heading">¶</a></h6>
<p>The UE RRC entity provides support for UE measurements; in particular, it
implements the procedures described in Section 5.5 of <a class="reference internal" href="index.html#ts36331" id="id107"><span>[TS36331]</span></a>, with the
following simplifying assumptions:</p>
<blockquote>
<div><ul class="simple">
<li><p>only E-UTRA intra-frequency measurements are supported, which implies:</p>
<ul>
<li><p>only one measurement object is used during the simulation;</p></li>
<li><p>measurement gaps are not needed to perform the measurements;</p></li>
<li><p>Event B1 and B2 are not implemented;</p></li>
</ul>
</li>
<li><p>only <cite>reportStrongestCells</cite> purpose is supported, while <cite>reportCGI</cite> and
<cite>reportStrongestCellsForSON</cite> purposes are not supported;</p></li>
<li><p><cite>s-Measure</cite> is not supported;</p></li>
<li><p>carrier aggregation is now supported in the LTE module
- Event A6 is not implemented;</p></li>
<li><p>speed dependent scaling of time-to-trigger (Section 5.5.6.2 of <a class="reference internal" href="index.html#ts36331" id="id108"><span>[TS36331]</span></a>) is
not supported.</p></li>
</ul>
</div></blockquote>
</section>
<section id="overall-design">
<h6><span class="section-number">20.1.10.9.2. </span>Overall design<a class="headerlink" href="#overall-design" title="Link to this heading">¶</a></h6>
<p>The model is based on the concept of <em>UE measurements consumer</em>, which is an
entity that may request an eNodeB RRC entity to provide UE measurement reports.
Consumers are, for example, <a class="reference internal" href="#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a>, which compute
handover decision based on UE measurement reports. Test cases and user’s
programs may also become consumers. Figure <a class="reference internal" href="#fig-ue-meas-consumer"><span class="std std-ref">Relationship between UE measurements and its consumers</span></a> depicts
the relationship between these entities.</p>
<figure class="align-center" id="id178">
<span id="fig-ue-meas-consumer"></span><a class="reference internal image-reference" href="_images/ue-meas-consumer.png"><img alt="_images/ue-meas-consumer.png" src="_images/ue-meas-consumer.png" style="width: 513.6px; height: 500.8px;" /></a>
<figcaption>
<p><span class="caption-text">Relationship between UE measurements and its consumers</span><a class="headerlink" href="#id178" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The whole UE measurements function at the RRC level is divided into 4 major
parts:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Measurement configuration (handled by <code class="docutils literal notranslate"><span class="pre">LteUeRrc::ApplyMeasConfig</span></code>)</p></li>
<li><p>Performing measurements (handled by <code class="docutils literal notranslate"><span class="pre">LteUeRrc::DoReportUeMeasurements</span></code>)</p></li>
<li><p>Measurement report triggering (handled by
<code class="docutils literal notranslate"><span class="pre">LteUeRrc::MeasurementReportTriggering</span></code>)</p></li>
<li><p>Measurement reporting (handled by <code class="docutils literal notranslate"><span class="pre">LteUeRrc::SendMeasurementReport</span></code>)</p></li>
</ol>
</div></blockquote>
<p>The following sections will describe each of the parts above.</p>
</section>
<section id="measurement-configuration">
<h6><span class="section-number">20.1.10.9.3. </span>Measurement configuration<a class="headerlink" href="#measurement-configuration" title="Link to this heading">¶</a></h6>
<p>An eNodeB RRC entity configures UE measurements by sending the configuration
parameters to the UE RRC entity. This set of parameters are defined within the
<code class="docutils literal notranslate"><span class="pre">MeasConfig</span></code> Information Element (IE) of the RRC Connection Reconfiguration
message (<a class="reference internal" href="#sec-rrc-connection-reconfiguration"><span class="std std-ref">RRC connection reconfiguration</span></a>).</p>
<p>The eNodeB RRC entity implements the configuration parameters and procedures
described in Section 5.5.2 of <a class="reference internal" href="index.html#ts36331" id="id109"><span>[TS36331]</span></a>, with the following simplifying
assumption:</p>
<blockquote>
<div><ul class="simple">
<li><p>configuration (i.e. addition, modification, and removal) can only be done
before the simulation begins;</p></li>
<li><p>all UEs attached to the eNodeB will be configured the same way, i.e. there is
no support for configuring specific measurement for specific UE; and</p></li>
<li><p>it is assumed that there is a one-to-one mapping between the PCI and the
E-UTRAN Global Cell Identifier (EGCI). This is consistent with the PCI
modeling assumptions described in <a class="reference internal" href="#sec-phy-ue-measurements"><span class="std std-ref">UE PHY Measurements Model</span></a>.</p></li>
</ul>
</div></blockquote>
<p>The eNodeB RRC instance here acts as an intermediary between the consumers and
the attached UEs. At the beginning of simulation, each consumer provides the
eNodeB RRC instance with the UE measurements configuration that it requires.
After that, the eNodeB RRC distributes the configuration to attached UEs.</p>
<p>Users may customize the measurement configuration using several methods. Please
refer to Section <a class="reference internal" href="index.html#sec-configure-ue-measurements"><span class="std std-ref">Configure UE measurements</span></a> of the User Documentation
for the description of these methods.</p>
</section>
<section id="performing-measurements">
<span id="sec-performing-measurements"></span><h6><span class="section-number">20.1.10.9.4. </span>Performing measurements<a class="headerlink" href="#performing-measurements" title="Link to this heading">¶</a></h6>
<p>UE RRC receives both RSRP and RSRQ measurements on periodical basis from UE PHY,
as described in <a class="reference internal" href="#sec-phy-ue-measurements"><span class="std std-ref">UE PHY Measurements Model</span></a>. <em>Layer 3 filtering</em> will be
applied to these received measurements. The implementation of the filtering
follows Section 5.5.3.2 of <a class="reference internal" href="index.html#ts36331" id="id110"><span>[TS36331]</span></a>:</p>
<div class="math">
<p><img src="_images/math/29c7857de953ba4fff359693c5f260c5af58a10d.png" alt="F_n = (1 - a) \times F_{n-1} + a \times M_n"/></p>
</div><p>where:</p>
<blockquote>
<div><ul class="simple">
<li><p><img class="math" src="_images/math/395593ebf06d44ee27b8d1fcf4974e7a387ee3bb.png" alt="M_n"/> is the latest received measurement result from the physical
layer;</p></li>
<li><p><img class="math" src="_images/math/7e5062a83a78f9dbf5931d241fe87ac860b6c506.png" alt="F_n"/> is the updated filtered measurement result;</p></li>
<li><p><img class="math" src="_images/math/dea2d90efaa338db9395aae41c80c6b618fca892.png" alt="F_{n-1}"/> is the old filtered measurement result, where
<img class="math" src="_images/math/b4a384ad79cbf7a46d3a613880c6946d82aac705.png" alt="F_0 = M_1"/> (i.e. the first measurement is not filtered); and</p></li>
<li><p><img class="math" src="_images/math/c71220e849a8cd1afd8c6338c7afaaf56ac6da14.png" alt="a = (\frac{1}{2})^{\frac{k}{4}}"/>, where <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is the configurable
<cite>filterCoefficient</cite> provided by the <code class="docutils literal notranslate"><span class="pre">QuantityConfig</span></code>;</p></li>
</ul>
</div></blockquote>
<p><img class="math" src="_images/math/c897d6ff926999a7065a946e221c87cc1690cf6c.png" alt="k = 4"/> is the default value, but can be configured by setting the
<cite>RsrpFilterCoefficient</cite> and <cite>RsrqFilterCoefficient</cite> attributes in
<code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code>.</p>
<p>Therefore <img class="math" src="_images/math/8b667b0c1fb52d7f5bfb2974ed74774496b5d97e.png" alt="k = 0"/> will disable Layer 3 filtering. On the other hand, past
measurements can be granted more influence on the filtering results by using
larger value of <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>.</p>
</section>
<section id="measurement-reporting-triggering">
<h6><span class="section-number">20.1.10.9.5. </span>Measurement reporting triggering<a class="headerlink" href="#measurement-reporting-triggering" title="Link to this heading">¶</a></h6>
<p>In this part, UE RRC will go through the list of active measurement
configuration and check whether the triggering condition is fulfilled in
accordance with Section 5.5.4 of <a class="reference internal" href="index.html#ts36331" id="id111"><span>[TS36331]</span></a>. When at least one triggering
condition from all the active measurement configuration is fulfilled, the
measurement reporting procedure (described in the next subsection) will be
initiated.</p>
<p>3GPP defines two kinds of <cite>triggerType</cite>: <em>periodical</em> and <em>event-based</em>. At the
moment, only event-based criterion is supported. There are various events that
can be selected, which are briefly described in the table below:</p>
<table class="docutils align-default" id="id179">
<caption><span class="caption-text">List of supported event-based triggering criteria</span><a class="headerlink" href="#id179" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Event A1</p></td>
<td><p>Serving cell becomes better than <cite>threshold</cite></p></td>
</tr>
<tr class="row-odd"><td><p>Event A2</p></td>
<td><p>Serving cell becomes worse than <cite>threshold</cite></p></td>
</tr>
<tr class="row-even"><td><p>Event A3</p></td>
<td><p>Neighbour becomes <cite>offset</cite> dB better than serving cell</p></td>
</tr>
<tr class="row-odd"><td><p>Event A4</p></td>
<td><p>Neighbour becomes better than <cite>threshold</cite></p></td>
</tr>
<tr class="row-even"><td><p>Event A5</p></td>
<td><p>Serving becomes worse than <cite>threshold1</cite>
<em>AND</em> neighbour becomes better than <cite>threshold2</cite></p></td>
</tr>
</tbody>
</table>
<p>Two main conditions to be checked in an event-based trigger are the <em>entering
condition</em> and the <em>leaving condition</em>. More details on these two can be found
in Section 5.5.4 of <a class="reference internal" href="index.html#ts36331" id="id112"><span>[TS36331]</span></a>.</p>
<p>An event-based trigger can be further configured by introducing hysteresis and
time-to-trigger. <em>Hysteresis</em> (<img class="math" src="_images/math/ebdf68e125df3458bab1f50f27f37bff5d30b47d.png" alt="Hys"/>) defines the distance between the
entering and leaving conditions in dB. Similarly, <em>time-to-trigger</em> introduces
delay to both entering and leaving conditions, but as a unit of time.</p>
<p>The <em>periodical</em> type of reporting trigger is not supported, but its behavior
can be easily obtained by using an event-based trigger. This can be done by
configuring the measurement in such a way that the entering condition is always
fulfilled, for example, by setting the threshold of Event A1 to zero (the
minimum level). As a result, the measurement reports will always be triggered
at every certain interval, as determined by the <cite>reportInterval</cite> field within
<code class="docutils literal notranslate"><span class="pre">LteRrcSap::ReportConfigEutra</span></code>, therefore producing the same behaviour as
periodical reporting.</p>
<p>As a limitation with respect to 3GPP specifications, the current model does not
support any cell-specific configuration. These configuration parameters are
defined in measurement object. As a consequence, incorporating a list of black
cells into the triggering process is not supported. Moreover, cell-specific
offset (i.e., <img class="math" src="_images/math/8a0700d16533af8a00972b62b90c339a1903cc30.png" alt="O_{cn}"/> and <img class="math" src="_images/math/f0ecb6d98e862c561316e94841668e6b80181806.png" alt="O_{cp}"/> in Event A3, A4, and A5) are not
supported as well. The value equal to zero is always assumed in place of them.</p>
</section>
<section id="measurement-reporting">
<h6><span class="section-number">20.1.10.9.6. </span>Measurement reporting<a class="headerlink" href="#measurement-reporting" title="Link to this heading">¶</a></h6>
<p>This part handles the submission of measurement report from the UE RRC entity
to the serving eNodeB entity via RRC protocol. Several simplifying assumptions
have been adopted:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>reportAmount</cite> is <em>not</em> applicable (i.e. always assumed to be infinite);</p></li>
<li><p>in measurement reports, the <cite>reportQuantity</cite> is always assumed to be <cite>BOTH</cite>,
i.e., both RSRP and RSRQ are always reported, regardless of the
<cite>triggerQuantity</cite>.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="handover">
<span id="sec-handover"></span><h5><span class="section-number">20.1.10.10. </span>Handover<a class="headerlink" href="#handover" title="Link to this heading">¶</a></h5>
<p>The RRC model supports UE mobility in CONNECTED mode by invoking the X2-based
handover procedure. The model is intra-EUTRAN and intra-frequency, as based on
Section 10.1.2.1 of <a class="reference internal" href="index.html#ts36300" id="id113"><span>[TS36300]</span></a>.</p>
<p>This section focuses on the process of triggering a handover. The handover
execution procedure itself is covered in Section <a class="reference internal" href="#sec-x2"><span class="std std-ref">X2</span></a>.</p>
<p>There are two ways to trigger the handover procedure:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>explicitly</em> (or manually) triggered by the simulation program by scheduling
an execution of the method <code class="docutils literal notranslate"><span class="pre">LteEnbRrc::SendHandoverRequest</span></code>; or</p></li>
<li><p><em>automatically</em> triggered by the eNodeB RRC entity based on UE measurements
and according to the selected handover algorithm.</p></li>
</ul>
</div></blockquote>
<p>Section <a class="reference internal" href="index.html#sec-x2-based-handover"><span class="std std-ref">X2-based handover</span></a> of the User Documentation provides some
examples on using both explicit and automatic handover triggers in simulation.
The next subsection will take a closer look on the automatic method, by
describing the design aspects of the handover algorithm interface and the
available handover algorithms.</p>
<section id="handover-algorithm">
<span id="sec-handover-algorithm"></span><h6><span class="section-number">20.1.10.10.1. </span>Handover algorithm<a class="headerlink" href="#handover-algorithm" title="Link to this heading">¶</a></h6>
<p>Handover in 3GPP LTE has the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>UE-assisted</dt><dd><p>The UE provides input to the network in the form of measurement reports.
This is handled by the <a class="reference internal" href="#sec-ue-measurements"><span class="std std-ref">UE RRC Measurements Model</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Network-controlled</dt><dd><p>The network (i.e. the source eNodeB and the target eNodeB) decides when to
trigger the handover and oversees its execution.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The <em>handover algorithm</em> operates at the source eNodeB and is responsible in
making handover decisions in an “automatic” manner. It interacts with an eNodeB
RRC instance via the <em>Handover Management SAP</em> interface. These relationships
are illustrated in Figure <a class="reference internal" href="#fig-ue-meas-consumer"><span class="std std-ref">Relationship between UE measurements and its consumers</span></a> from the previous section.</p>
<p>The handover algorithm interface consists of the following methods:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForHandover</span></code></dt><dd><p>(Handover Algorithm -&gt; eNodeB RRC) Used by the handover algorithm to
request measurement reports from the eNodeB RRC entity, by passing the
desired reporting configuration. The configuration will be applied to
all future attached UEs.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code></dt><dd><p>(eNodeB RRC -&gt; Handover Algorithm) Based on the UE measurements configured
earlier in <code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForHandover</span></code>, UE may submit measurement
reports to the eNodeB. The eNodeB RRC entity uses the <code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code>
interface to forward these measurement reports to the handover algorithm.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">TriggerHandover</span></code></dt><dd><p>(Handover Algorithm -&gt; eNodeB RRC) After examining the measurement reports
(but not necessarily), the handover algorithm may declare a handover. This
method is used to notify the eNodeB RRC entity about this decision, which
will then proceed to commence the handover procedure.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>One note for the <code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForHandover</span></code>. The method will return
the <code class="docutils literal notranslate"><span class="pre">measId</span></code> (measurement identity) of the newly created measurement
configuration. Typically a handover algorithm would store this unique number. It
may be useful in the <code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code> method, for example when more than one
configuration has been requested and the handover algorithm needs to
differentiate incoming reports based on the configuration that triggered them.</p>
<p>A handover algorithm is implemented by writing a subclass of the
<code class="docutils literal notranslate"><span class="pre">LteHandoverAlgorithm</span></code> abstract superclass and implementing each of the above
mentioned SAP interface methods. Users may develop their own handover algorithm
this way, and then use it in any simulation by following the steps outlined in
Section <a class="reference internal" href="index.html#sec-x2-based-handover"><span class="std std-ref">X2-based handover</span></a> of the User Documentation.</p>
<p>Alternatively, users may choose to use one of the 3 built-in handover algorithms
provided by the LTE module: no-op, A2-A4-RSRQ, and strongest cell handover
algorithm. They are ready to be used in simulations or can be taken as an
example of implementing a handover algorithm. Each of these built-in algorithms
is covered in each of the following subsections.</p>
</section>
<section id="no-op-handover-algorithm">
<h6><span class="section-number">20.1.10.10.2. </span>No-op handover algorithm<a class="headerlink" href="#no-op-handover-algorithm" title="Link to this heading">¶</a></h6>
<p>The <em>no-op handover algorithm</em> (<code class="docutils literal notranslate"><span class="pre">NoOpHandoverAlgorithm</span></code> class) is the simplest
possible implementation of handover algorithm. It basically does nothing, i.e.,
does not call any of the Handover Management SAP interface methods. Users may
choose this handover algorithm if they wish to disable automatic handover
trigger in their simulation.</p>
</section>
<section id="a2-a4-rsrq-handover-algorithm">
<h6><span class="section-number">20.1.10.10.3. </span>A2-A4-RSRQ handover algorithm<a class="headerlink" href="#a2-a4-rsrq-handover-algorithm" title="Link to this heading">¶</a></h6>
<p>The <em>A2-A4-RSRQ handover algorithm</em> provides the functionality of the default
handover algorithm originally included in LENA M6 (ns-3.18), ported to the
Handover Management SAP interface as the <code class="docutils literal notranslate"><span class="pre">A2A4RsrqHandoverAlgorithm</span></code> class.</p>
<p>As the name implies, the algorithm utilizes the Reference Signal Received
Quality (RSRQ) measurements acquired from Event A2 and Event A4. Thus, the
algorithm will add 2 measurement configuration to the corresponding eNodeB RRC
instance. Their intended use are described as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>Event A2</em> (serving cell’s RSRQ becomes worse than <cite>threshold</cite>) is leveraged
to indicate that the UE is experiencing poor signal quality and may benefit
from a handover.</p></li>
<li><p><em>Event A4</em> (neighbour cell’s RSRQ becomes better than <cite>threshold</cite>) is used
to detect neighbouring cells and acquire their corresponding RSRQ from every
attached UE, which are then stored internally by the algorithm. By default,
the algorithm configures Event A4 with a very low threshold, so that the
trigger criteria are always true.</p></li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-lte-legacy-handover-algorithm"><span class="std std-ref">A2-A4-RSRQ handover algorithm</span></a> below summarizes this procedure.</p>
<figure class="align-center" id="id180">
<span id="fig-lte-legacy-handover-algorithm"></span><a class="reference internal image-reference" href="_images/lte-legacy-handover-algorithm.png"><img alt="_images/lte-legacy-handover-algorithm.png" src="_images/lte-legacy-handover-algorithm.png" style="width: 655.1999999999999px; height: 574.6999999999999px;" /></a>
<figcaption>
<p><span class="caption-text">A2-A4-RSRQ handover algorithm</span><a class="headerlink" href="#id180" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Two attributes can be set to tune the algorithm behaviour:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ServingCellThreshold</span></code></dt><dd><p>The <cite>threshold</cite> for Event A2, i.e. a UE must have an RSRQ lower than this
threshold to be considered for a handover.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NeighbourCellOffset</span></code></dt><dd><p>The <cite>offset</cite> that aims to ensure that the UE would receive better signal
quality after the handover. A neighbouring cell is considered as a target
cell for the handover only if its RSRQ is higher than the serving cell’s
RSRQ by the amount of this <cite>offset</cite>.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The value of both attributes are expressed as RSRQ range (Section 9.1.7 of
<a class="reference internal" href="index.html#ts36133" id="id114"><span>[TS36133]</span></a>), which is an integer between 0 and 34, with 0 as the lowest RSRQ.</p>
</section>
<section id="strongest-cell-handover-algorithm">
<h6><span class="section-number">20.1.10.10.4. </span>Strongest cell handover algorithm<a class="headerlink" href="#strongest-cell-handover-algorithm" title="Link to this heading">¶</a></h6>
<p>The <em>strongest cell handover algorithm</em>, or also sometimes known as the
<em>traditional power budget (PBGT) algorithm</em>, is developed using <a class="reference internal" href="index.html#dimou2009" id="id115"><span>[Dimou2009]</span></a> as
reference. The idea is to provide each UE with the best possible Reference
Signal Received Power (RSRP). This is done by performing a handover as soon as
a better cell (i.e. with stronger RSRP) is detected.</p>
<p><em>Event A3</em> (neighbour cell’s RSRP becomes better than serving cell’s RSRP) is
chosen to realize this concept. The <code class="docutils literal notranslate"><span class="pre">A3RsrpHandoverAlgorithm</span></code> class is the
result of the implementation. Handover is triggered for the UE to the best cell
in the measurement report.</p>
<p>A simulation which uses this algorithm is usually more vulnerable to ping-pong
handover (consecutive handover to the previous source eNodeB within short period
of time), especially when the <a class="reference internal" href="#sec-fading-model"><span class="std std-ref">Fading Model</span></a> is enabled. This problem
is typically tackled by introducing a certain delay to the handover. The
algorithm does this by including hysteresis and time-to-trigger parameters
(Section 6.3.5 of <a class="reference internal" href="index.html#ts36331" id="id116"><span>[TS36331]</span></a>) to the UE measurements configuration.</p>
<p><em>Hysteresis</em> (a.k.a. handover margin) delays the handover in regard of RSRP. The
value is expressed in dB, ranges between 0 to 15 dB, and have a 0.5 dB accuracy,
e.g., an input value of 2.7 dB is rounded to 2.5 dB.</p>
<p>On the other hand, <em>time-to-trigger</em> delays the handover in regard of time. 3GPP
defines 16 valid values for time-to-trigger (all in milliseconds): 0, 40, 64,
80, 100, 128, 160, 256, 320, 480, 512, 640, 1024, 1280, 2560, and 5120.</p>
<p>The difference between hysteresis and time-to-trigger is illustrated in Figure
<a class="reference internal" href="#fig-lte-strongest-cell-handover-algorithm"><span class="std std-ref">Effect of hysteresis and time-to-trigger in strongest cell handover algorithm</span></a> below, which is taken from the
<cite>lena-x2-handover-measures</cite> example. It depicts the perceived RSRP of serving
cell and a neighbouring cell by a UE which moves pass the border of the cells.</p>
<figure class="align-center" id="id181">
<span id="fig-lte-strongest-cell-handover-algorithm"></span><img alt="_images/lte-strongest-cell-handover-algorithm.png" src="_images/lte-strongest-cell-handover-algorithm.png" />
<figcaption>
<p><span class="caption-text">Effect of hysteresis and time-to-trigger in strongest cell handover algorithm</span><a class="headerlink" href="#id181" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>By default, the algorithm uses a hysteresis of 3.0 dB and time-to-trigger of
256 ms. These values can be tuned through the <code class="docutils literal notranslate"><span class="pre">Hysteresis</span></code> and
<code class="docutils literal notranslate"><span class="pre">TimeToTrigger</span></code> attributes of the <code class="docutils literal notranslate"><span class="pre">A3RsrpHandoverAlgorithm</span></code> class.</p>
</section>
</section>
<section id="neighbour-relation">
<h5><span class="section-number">20.1.10.11. </span>Neighbour Relation<a class="headerlink" href="#neighbour-relation" title="Link to this heading">¶</a></h5>
<p>LTE module supports a simplified <em>Automatic Neighbour Relation</em> (ANR) function.
This is handled by the <code class="docutils literal notranslate"><span class="pre">LteAnr</span></code> class, which interacts with an eNodeB RRC
instance through the ANR SAP interface.</p>
<section id="neighbour-relation-table">
<h6><span class="section-number">20.1.10.11.1. </span>Neighbour Relation Table<a class="headerlink" href="#neighbour-relation-table" title="Link to this heading">¶</a></h6>
<p>The ANR holds a <em>Neighbour Relation Table</em> (NRT), similar to the description in
Section 22.3.2a of <a class="reference internal" href="index.html#ts36300" id="id117"><span>[TS36300]</span></a>. Each entry in the table is called a <em>Neighbour
Relation</em> (NR) and represents a detected neighbouring cell, which contains the
following boolean fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><cite>No Remove</cite></dt><dd><p>Indicates that the NR shall <em>not</em> be removed from the NRT. This is <cite>true</cite>
by default for user-provided NR and <cite>false</cite> otherwise.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>No X2</cite></dt><dd><p>Indicates that the NR shall <em>not</em> use an X2 interface in order to initiate
procedures towards the eNodeB parenting the target cell. This is <cite>false</cite> by
default for user-provided NR, and <cite>true</cite> otherwise.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>No HO</cite></dt><dd><p>Indicates that the NR shall <em>not</em> be used by the eNodeB for handover
reasons. This is <cite>true</cite> in most cases, except when the NR is both
user-provided and network-detected.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Each NR entry may have at least one of the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>User-provided</dt><dd><p>This type of NR is created as instructed by the simulation user. For
example, a NR is created automatically upon a user-initiated establishment
of X2 connection between 2 eNodeBs, e.g. as described in Section
<a class="reference internal" href="index.html#sec-x2-based-handover"><span class="std std-ref">X2-based handover</span></a>. Another way to create a user-provided NR is
to call the <code class="docutils literal notranslate"><span class="pre">AddNeighbourRelation</span></code> function explicitly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Network-detected</dt><dd><p>This type of NR is automatically created during the simulation as a result
of the discovery of a nearby cell.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>In order to automatically create network-detected NR, ANR utilizes UE
measurements. In other words, ANR is a consumer of UE measurements, as depicted
in Figure <a class="reference internal" href="#fig-ue-meas-consumer"><span class="std std-ref">Relationship between UE measurements and its consumers</span></a>. RSRQ and Event A4 (neighbour becomes
better than <cite>threshold</cite>) are used for the reporting configuration. The default
Event A4 <cite>threshold</cite> is set to the lowest possible, i.e., maximum detection
capability, but can be changed by setting the <code class="docutils literal notranslate"><span class="pre">Threshold</span></code> attribute of
<code class="docutils literal notranslate"><span class="pre">LteAnr</span></code> class. Note that the A2-A4-RSRQ handover algorithm also utilizes a
similar reporting configuration. Despite the similarity, when both ANR and this
handover algorithm are active in the eNodeB, they use separate reporting
configuration.</p>
<p>Also note that automatic setup of X2 interface is not supported. This is the
reason why the <cite>No X2</cite> and <cite>No HO</cite> fields are true in a network-detected but not
user-detected NR.</p>
</section>
<section id="role-of-anr-in-simulation">
<h6><span class="section-number">20.1.10.11.2. </span>Role of ANR in Simulation<a class="headerlink" href="#role-of-anr-in-simulation" title="Link to this heading">¶</a></h6>
<p>The ANR SAP interface provides the means of communication between ANR and eNodeB
RRC. Some interface functions are used by eNodeB RRC to interact with the NRT,
as shown below:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddNeighbourRelation</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Add a new user-provided NR entry into the NRT.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetNoRemove</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Get the value of <cite>No Remove</cite> field of an NR entry of
the given cell ID.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetNoHo</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Get the value of <cite>No HO</cite> field of an NR entry of
the given cell ID.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GetNoX2</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Get the value of <cite>No X2</cite> field of an NR entry of
the given cell ID.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Other interface functions exist to support the role of ANR as a UE measurements
consumer, as listed below:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForAnr</span></code></dt><dd><p>(ANR -&gt; eNodeB RRC) Used by the ANR to request measurement reports from the
eNodeB RRC entity, by passing the desired reporting configuration. The
configuration will be applied to all future attached UEs.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code></dt><dd><p>(eNodeB RRC -&gt; ANR) Based on the UE measurements configured earlier in
<code class="docutils literal notranslate"><span class="pre">AddUeMeasReportConfigForAnr</span></code>, UE may submit measurement reports to the
eNodeB. The eNodeB RRC entity uses the <code class="docutils literal notranslate"><span class="pre">ReportUeMeas</span></code> interface to
forward these measurement reports to the ANR.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Please refer to the corresponding API documentation for <code class="docutils literal notranslate"><span class="pre">LteAnrSap</span></code> class for
more details on the usage and the required parameters.</p>
<p>The ANR is utilized by the eNodeB RRC instance as a data structure to keep track
of the situation of nearby neighbouring cells. The ANR also helps the eNodeB RRC
instance to determine whether it is possible to execute a handover procedure to
a neighbouring cell. This is realized by the fact that eNodeB RRC will only
allow a handover procedure to happen if the NR entry of the target cell has both
<cite>No HO</cite> and <cite>No X2</cite> fields set to <cite>false</cite>.</p>
<p>ANR is enabled by default in every eNodeB instance in the simulation. It can be
disabled by setting the <code class="docutils literal notranslate"><span class="pre">AnrEnabled</span></code> attribute in <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> class to
<cite>false</cite>.</p>
</section>
</section>
<section id="rrc-sequence-diagrams">
<h5><span class="section-number">20.1.10.12. </span>RRC sequence diagrams<a class="headerlink" href="#rrc-sequence-diagrams" title="Link to this heading">¶</a></h5>
<p>In this section we provide some sequence diagrams that explain the
most important RRC procedures being modeled.</p>
<section id="rrc-connection-establishment">
<span id="sec-rrc-connection-establishment"></span><h6><span class="section-number">20.1.10.12.1. </span>RRC connection establishment<a class="headerlink" href="#rrc-connection-establishment" title="Link to this heading">¶</a></h6>
<p>Figure <a class="reference internal" href="#fig-rrc-connection-establishment"><span class="std std-ref">Sequence diagram of the RRC Connection Establishment procedure</span></a> shows how the RRC
Connection Establishment procedure is modeled, highlighting the role
of the RRC layer at both the UE and the eNB, as well as the
interaction with the other layers.</p>
<figure class="align-center" id="id182">
<span id="fig-rrc-connection-establishment"></span><img alt="_images/rrc-connection-establishment.png" src="_images/rrc-connection-establishment.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the RRC Connection Establishment procedure</span><a class="headerlink" href="#id182" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>There are several timeouts related to this procedure, which are listed in the
following Table <a class="reference internal" href="#tab-rrc-connection-establishment-timer"><span class="std std-ref">Timers in RRC connection establishment procedure</span></a>. If any of these
timers expired, the RRC connection establishment procedure is terminated in
failure. At the UE side, if T300 timer has expired a consecutive
<em>connEstFailCount</em> times on the same cell it performs the cell selection again
<a class="reference internal" href="index.html#ts36331" id="id118"><span>[TS36331]</span></a>. Else, the upper layer (UE NAS) will immediately attempt to retry
the procedure.</p>
<span id="tab-rrc-connection-establishment-timer"></span><table class="docutils align-default" id="id183">
<caption><span class="caption-text">Timers in RRC connection establishment procedure</span><a class="headerlink" href="#id183" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>Timer
starts</p></th>
<th class="head"><p>Timer
stops</p></th>
<th class="head"><p>Default
duration</p></th>
<th class="head"><p>When timer
expired</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Connection
request
timeout</p></td>
<td><p>eNodeB
RRC</p></td>
<td><p>New UE
context
added</p></td>
<td><p>Receive RRC
CONNECTION
REQUEST</p></td>
<td><p>15 ms
(Max)</p></td>
<td><p>Remove UE
context</p></td>
</tr>
<tr class="row-odd"><td><p>Connection
timeout
(T300
timer)</p></td>
<td><p>UE RRC</p></td>
<td><p>Send RRC
CONNECTION
REQUEST</p></td>
<td><p>Receive RRC
CONNECTION
SETUP or
REJECT</p></td>
<td><p>100 ms</p></td>
<td><p>Reset UE
MAC</p></td>
</tr>
<tr class="row-even"><td><p>Connection
setup
timeout</p></td>
<td><p>eNodeB
RRC</p></td>
<td><p>Send RRC
CONNECTION
SETUP</p></td>
<td><p>Receive RRC
CONNECTION
SETUP
COMPLETE</p></td>
<td><p>100 ms</p></td>
<td><p>Remove UE
context</p></td>
</tr>
<tr class="row-odd"><td><p>Connection
rejected
timeout</p></td>
<td><p>eNodeB
RRC</p></td>
<td><p>Send RRC
CONNECTION
REJECT</p></td>
<td><p>Never</p></td>
<td><p>30 ms</p></td>
<td><p>Remove UE
context</p></td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> The value of connection request timeout timer at the eNB RRC should
not be higher than the T300 timer at UE RRC. It is to make sure that the UE
context is already removed at the eNB, once the UE will perform cell selection
upon reaching the <em>connEstFailCount</em> count. Moreover, at the time of writing
this document the <a class="reference internal" href="#sec-cell-selection-evaluation"><span class="std std-ref">Cell Selection Evaluation</span></a> does not include
the <img class="math" src="_images/math/2913a255eab003c033596cd80ae2eba017abdb1c.png" alt="Qoffset_{temp}"/> parameter, thus, it is not applied while selecting
the same cell again.</p>
<span id="tab-rrc-connection-establishment-counter"></span><table class="docutils align-default" id="id184">
<caption><span class="caption-text">Counters in RRC connection establishment procedure</span><a class="headerlink" href="#id184" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Location</p></th>
<th class="head"><p>Msg</p></th>
<th class="head"><p>Monitored
by</p></th>
<th class="head"><p>Default
value</p></th>
<th class="head"><p>Limit not reached</p></th>
<th class="head"><p>Limit reached</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ConnEstFailCount</p></td>
<td><p>eNB MAC</p></td>
<td><p>RachConfigCommon
in SIB2, HO REQ
and HO Ack</p></td>
<td><p>UE RRC</p></td>
<td><p>1</p></td>
<td><p>Increment the local counter.
Invalided the prev SIB2 msg,
and try random access
with the same cell.</p></td>
<td><p>Reset the local
counter and perform
cell selection.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="rrc-connection-reconfiguration">
<span id="sec-rrc-connection-reconfiguration"></span><h6><span class="section-number">20.1.10.12.2. </span>RRC connection reconfiguration<a class="headerlink" href="#rrc-connection-reconfiguration" title="Link to this heading">¶</a></h6>
<p>Figure <a class="reference internal" href="#fig-rrc-connection-reconfiguration"><span class="std std-ref">Sequence diagram of the RRC Connection Reconfiguration procedure</span></a> shows how the RRC
Connection Reconfiguration procedure is modeled for the case where
MobilityControlInfo is not provided, i.e., handover is not
performed.</p>
<figure class="align-center" id="id185">
<span id="fig-rrc-connection-reconfiguration"></span><img alt="_images/rrc-connection-reconfiguration.png" src="_images/rrc-connection-reconfiguration.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the RRC Connection Reconfiguration procedure</span><a class="headerlink" href="#id185" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#fig-rrc-connection-reconf-handover"><span class="std std-ref">Sequence diagram of the RRC Connection Reconfiguration procedure
for the handover case</span></a> shows how the RRC
Connection Reconfiguration procedure is modeled for the case where
MobilityControlInfo is provided, i.e., handover is to be performed.
As specified in <a class="reference internal" href="index.html#ts36331" id="id119"><span>[TS36331]</span></a>, <em>After receiving the handover message,
the UE attempts to access the target cell at the first available RACH
occasion according to Random Access resource selection defined in [TS36321]_,
i.e. the handover is asynchronous. Consequently, when
allocating a dedicated preamble for the random access in the target
cell, E-UTRA shall ensure it is available from the first RACH occasion
the UE may use. Upon successful completion of the handover, the UE
sends a message used to confirm the handover.</em> Note that the random
access procedure in this case is non-contention based, hence in a real
LTE system it differs slightly from the one used in RRC connection
established. Also note that the RA Preamble ID is signaled via the
Handover Command included in the X2 Handover Request ACK message sent
from the target eNB to the source eNB; in particular, the preamble is
included in the RACH-ConfigDedicated IE which is part of
MobilityControlInfo.</p>
<figure class="align-center" id="id186">
<span id="fig-rrc-connection-reconf-handover"></span><img alt="_images/rrc-connection-reconfiguration-handover.png" src="_images/rrc-connection-reconfiguration-handover.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the RRC Connection Reconfiguration procedure
for the handover case</span><a class="headerlink" href="#id186" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="rrc-protocol-models">
<span id="sec-rrc-protocol-models"></span><h5><span class="section-number">20.1.10.13. </span>RRC protocol models<a class="headerlink" href="#rrc-protocol-models" title="Link to this heading">¶</a></h5>
<p>As previously anticipated, we provide two different models  for the
transmission and reception of RRC messages: <em>Ideal</em>
and <em>Real</em>. Each of them is described in one of the following
subsections.</p>
<section id="ideal-rrc-protocol-model">
<h6><span class="section-number">20.1.10.13.1. </span>Ideal RRC protocol model<a class="headerlink" href="#ideal-rrc-protocol-model" title="Link to this heading">¶</a></h6>
<p>According to this model, implemented in the classes and <cite>LteUeRrcProtocolIdeal</cite> and
<cite>LteEnbRrcProtocolIdeal</cite>, all RRC messages and information elements
are transmitted between the eNB and the UE in an ideal fashion,
without consuming radio resources and without errors. From an
implementation point of view, this is achieved by passing the RRC data
structure directly between the UE and eNB RRC entities, without
involving the lower layers (PDCP, RLC, MAC, scheduler).</p>
</section>
<section id="real-rrc-protocol-model">
<h6><span class="section-number">20.1.10.13.2. </span>Real RRC protocol model<a class="headerlink" href="#real-rrc-protocol-model" title="Link to this heading">¶</a></h6>
<p>This model is implemented in the classes <cite>LteUeRrcProtocolReal</cite> and
<cite>LteEnbRrcProtocolReal</cite> and aims at modeling the transmission of RRC
PDUs as commonly performed in real LTE systems. In particular:</p>
<blockquote>
<div><ul class="simple">
<li><p>for every RRC message being sent, a real RRC PDUs is created
following the ASN.1 encoding of RRC PDUs and information elements (IEs)
specified in <a class="reference internal" href="index.html#ts36331" id="id120"><span>[TS36331]</span></a>. Some simplification are made with respect
to the IEs included in the PDU, i.e., only those IEs that are
useful for simulation purposes are included. For a detailed list,
please see the IEs defined in <cite>lte-rrc-sap.h</cite> and compare with
<a class="reference internal" href="index.html#ts36331" id="id121"><span>[TS36331]</span></a>.</p></li>
<li><p>the encoded RRC PDUs are sent on Signaling Radio Bearers and are
subject to the same transmission modeling used for data
communications, thus including scheduling, radio resource
consumption, channel errors, delays, retransmissions, etc.</p></li>
</ul>
</div></blockquote>
<section id="signaling-radio-bearer-model">
<h6 aria-level="7"><span class="section-number">20.1.10.13.2.1. </span>Signaling Radio Bearer model<a class="headerlink" href="#signaling-radio-bearer-model" title="Link to this heading">¶</a></h6>
<p>We now describe the Signaling Radio Bearer model that is used for the
<em>Real</em> RRC protocol model.</p>
<blockquote>
<div><ul>
<li><p><strong>SRB0</strong> messages (over CCCH):</p>
<ul class="simple">
<li><p><strong>RrcConnectionRequest</strong>: in real LTE systems, this is an RLC TM
SDU sent over resources specified in the UL Grant in the RAR (not
in UL DCIs); the reason is that C-RNTI is not known yet at this
stage. In the simulator, this is modeled as a real RLC TM RLC PDU
whose UL resources are allocated by the scheduler upon call to
SCHED_DL_RACH_INFO_REQ.</p></li>
<li><p><strong>RrcConnectionSetup</strong>: in the simulator this is implemented as in
real LTE systems, i.e., with an RLC TM SDU sent over resources
indicated by a regular UL DCI, allocated with
SCHED_DL_RLC_BUFFER_REQ triggered by the RLC TM instance that is
mapped to LCID 0 (the CCCH).</p></li>
</ul>
</li>
<li><p><strong>SRB1</strong> messages (over DCCH):</p>
<ul class="simple">
<li><p>All the SRB1 messages modeled in the simulator (e.g.,
<strong>RrcConnectionCompleted</strong>) are implemented as in real LTE systems,
i.e., with a real RLC SDU sent over RLC AM using DL resources
allocated via Buffer Status Reports. See the RLC model
documentation for details.</p></li>
</ul>
</li>
<li><p><strong>SRB2</strong> messages (over DCCH):</p>
<blockquote>
<div><ul class="simple">
<li><p>According to <a class="reference internal" href="index.html#ts36331" id="id122"><span>[TS36331]</span></a>, “<em>SRB1 is for RRC messages (which may
include a piggybacked NAS message) as well as for NAS messages
prior to the establishment of SRB2, all using DCCH logical
channel</em>”, whereas “<em>SRB2 is for NAS messages, using DCCH
logical channel</em>” and “<em>SRB2 has a lower-priority than SRB1 and is
always configured by E-UTRAN after security
activation</em>”. Modeling security-related aspects is not a
requirement of the LTE simulation model, hence we always use
SRB1 and never activate SRB2.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="asn-1-encoding-of-rrc-ie-s">
<h6 aria-level="7"><span class="section-number">20.1.10.13.2.2. </span>ASN.1 encoding of RRC IE’s<a class="headerlink" href="#asn-1-encoding-of-rrc-ie-s" title="Link to this heading">¶</a></h6>
<p>The messages defined in RRC SAP, common to all Ue/Enb SAP Users/Providers, are transported in a transparent container to/from a Ue/Enb. The encoding format for the different Information Elements are specified in <a class="reference internal" href="index.html#ts36331" id="id123"><span>[TS36331]</span></a>, using ASN.1 rules in the unaligned variant. The implementation in Ns3/Lte has been divided in the following classes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Asn1Header : Contains the encoding / decoding of basic ASN types</p></li>
<li><p>RrcAsn1Header : Inherits Asn1Header and contains the encoding / decoding of common IE’s defined in <a class="reference internal" href="index.html#ts36331" id="id124"><span>[TS36331]</span></a></p></li>
<li><p>Rrc specific messages/IEs classes : A class for each of the messages defined in RRC SAP header</p></li>
</ul>
</div></blockquote>
</section>
<section id="asn1header-class-implementation-of-base-asn-1-types">
<h6 aria-level="7"><span class="section-number">20.1.10.13.2.3. </span>Asn1Header class - Implementation of base ASN.1 types<a class="headerlink" href="#asn1header-class-implementation-of-base-asn-1-types" title="Link to this heading">¶</a></h6>
<p>This class implements the methods to Serialize / Deserialize the ASN.1 types being used in <a class="reference internal" href="index.html#ts36331" id="id125"><span>[TS36331]</span></a>, according to the packed encoding rules in ITU-T X.691. The types considered are:</p>
<blockquote>
<div><ul class="simple">
<li><p>Boolean : a boolean value uses a single bit (1=true, 0=false).</p></li>
<li><p>Integer : a constrained integer (with min and max values defined) uses the minimum amount of bits to encode its range (max-min+1).</p></li>
<li><p>Bitstring : a bistring will be copied bit by bit to the serialization buffer.</p></li>
<li><p>Octetstring : not being currently used.</p></li>
<li><p>Sequence : the sequence generates a preamble indicating the presence of optional and default fields. It also adds a bit indicating the presence of extension marker.</p></li>
<li><p>Sequence…Of : the sequence…of type encodes the number of elements of the sequence as an integer (the subsequent elements will need to be encoded afterwards).</p></li>
<li><p>Choice : indicates which element among the ones in the choice set is being encoded.</p></li>
<li><p>Enumeration : is serialized as an integer indicating which value is used, among the ones in the enumeration, with the number of elements in the enumeration as upper bound.</p></li>
<li><p>Null : the null value is not encoded, although its serialization function is defined to provide a clearer map between specification and implementation.</p></li>
</ul>
</div></blockquote>
<p>The class inherits from ns-3 Header, but Deserialize() function is declared pure virtual, thus inherited classes having to implement it. The reason is that deserialization will retrieve the elements in RRC messages, each of them containing different information elements.</p>
<p>Additionally, it has to be noted that the resulting byte length of a specific type/message can vary, according to the presence of optional fields, and due to the optimized encoding. Hence, the serialized bits will be processed using PreSerialize() function, saving the result in m_serializationResult Buffer. As the methods to read/write in a ns3 buffer are defined in a byte basis, the serialization bits are stored into m_serializationPendingBits attribute, until the 8 bits are set and can be written to buffer iterator. Finally, when invoking Serialize(), the contents of the m_serializationResult attribute will be copied to Buffer::Iterator parameter</p>
</section>
<section id="rrcasn1header-common-ies">
<h6 aria-level="7"><span class="section-number">20.1.10.13.2.4. </span>RrcAsn1Header : Common IEs<a class="headerlink" href="#rrcasn1header-common-ies" title="Link to this heading">¶</a></h6>
<p>As some Information Elements are being used for several RRC messages, this class implements the following common IE’s:</p>
<blockquote>
<div><ul class="simple">
<li><p>SrbToAddModList</p></li>
<li><p>DrbToAddModList</p></li>
<li><p>LogicalChannelConfig</p></li>
<li><p>RadioResourceConfigDedicated</p></li>
<li><p>PhysicalConfigDedicated</p></li>
<li><p>SystemInformationBlockType1</p></li>
<li><p>SystemInformationBlockType2</p></li>
<li><p>RadioResourceConfigCommonSIB</p></li>
</ul>
</div></blockquote>
</section>
<section id="rrc-specific-messages-ies-classes">
<h6 aria-level="7"><span class="section-number">20.1.10.13.2.5. </span>Rrc specific messages/IEs classes<a class="headerlink" href="#rrc-specific-messages-ies-classes" title="Link to this heading">¶</a></h6>
<p>The following RRC SAP have been implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p>RrcConnectionRequest</p></li>
<li><p>RrcConnectionSetup</p></li>
<li><p>RrcConnectionSetupCompleted</p></li>
<li><p>RrcConnectionReconfiguration</p></li>
<li><p>RrcConnectionReconfigurationCompleted</p></li>
<li><p>HandoverPreparationInfo</p></li>
<li><p>RrcConnectionReestablishmentRequest</p></li>
<li><p>RrcConnectionReestablishment</p></li>
<li><p>RrcConnectionReestablishmentComplete</p></li>
<li><p>RrcConnectionReestablishmentReject</p></li>
<li><p>RrcConnectionRelease</p></li>
</ul>
</div></blockquote>
</section>
</section>
</section>
</section>
<section id="nas">
<span id="sec-nas"></span><h4><span class="section-number">20.1.11. </span>NAS<a class="headerlink" href="#nas" title="Link to this heading">¶</a></h4>
<p>The focus of the LTE-EPC model is on the NAS Active state, which corresponds to EMM Registered, ECM connected, and RRC connected. Because of this, the following simplifications are made:</p>
<ul class="simple">
<li><p>EMM and ECM are not modeled explicitly; instead, the NAS entity at the UE will interact directly with the MME to perform actions that are equivalent (with gross simplifications) to taking the UE to the states EMM Connected and ECM Connected;</p></li>
<li><p>the NAS also takes care of multiplexing uplink data packets coming from the upper layers into the appropriate EPS bearer by using the Traffic Flow Template classifier (TftClassifier).</p></li>
<li><p>the NAS does not support PLMN and CSG selection</p></li>
<li><p>the NAS does not support any location update/paging procedure in idle mode</p></li>
</ul>
<p>Figure <a class="reference internal" href="#fig-nas-attach"><span class="std std-ref">Sequence diagram of the attach procedure</span></a> shows how the simplified NAS model
implements the attach procedure. Note that both the default and
eventual dedicated EPS bearers are activated as part of this
procedure.</p>
<figure class="align-center" id="id187">
<span id="fig-nas-attach"></span><img alt="_images/nas-attach.png" src="_images/nas-attach.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the attach procedure</span><a class="headerlink" href="#id187" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="s1-s5-and-s11">
<h4><span class="section-number">20.1.12. </span>S1, S5 and S11<a class="headerlink" href="#s1-s5-and-s11" title="Link to this heading">¶</a></h4>
<section id="s1-u-and-s5-user-plane">
<h5><span class="section-number">20.1.12.1. </span>S1-U and S5 (user plane)<a class="headerlink" href="#s1-u-and-s5-user-plane" title="Link to this heading">¶</a></h5>
<p>The S1-U and S5 interfaces are modeled in a realistic way by encapsulating
data packets over GTP/UDP/IP, as done in real LTE-EPC systems. The
corresponding protocol stack is shown in Figure
<a class="reference internal" href="#fig-lte-epc-e2e-data-protocol-stack-with-split"><span class="std std-ref">LTE-EPC data plane protocol stack</span></a>. As shown in the figure,
there are two different layers of
IP networking. The first one is the end-to-end layer, which provides end-to-end
connectivity to the users; this layer involves the UEs, the PGW and
the remote host (including eventual internet routers and hosts in
between), but does not involve the eNB and the SGW. In this version of LTE, the EPC
supports both IPv4 and IPv6 type users. The 3GPP unique 64 bit IPv6 prefix
allocation process for each UE and PGW is followed here. Each EPC is assigned
a unique 16 bit IPv4 and a 48 bit IPv6 network address from the pool of
7.0.0.0/8 and 7777:f00d::/32 respectively. In the end-to-end IP connection
between UE and PGW, all addresses are configured using these prefixes.
The PGW’s address is used by all UEs as the gateway to reach the internet.</p>
<p>The second layer of IP networking is the EPC local area network. This
involves all eNB nodes, SGW nodes and PGW nodes. This network is
implemented as a set of point-to-point links which connect each eNB
with its corresponding SGW node and a point-to-point link which connect
each SGW node with its corresponding PGW node;
thus, each SGW has a set of point-to-point devices, each providing
connectivity to a different eNB. By default, a 10.x.y.z/30 subnet
is assigned to each point-to-point link (a /30 subnet is the smallest
subnet that allows for two distinct host addresses).</p>
<p>As specified by 3GPP, the end-to-end IP
communications is tunneled over the local EPC IP network using
GTP/UDP/IP. In the following, we explain how this tunneling is
implemented in the EPC model. The explanation is done by discussing the
end-to-end flow of data packets.</p>
<figure class="align-center" id="id188">
<span id="fig-epc-data-flow-dl-with-split"></span><img alt="_images/epc-data-flow-dl-with-split.png" src="_images/epc-data-flow-dl-with-split.png" />
<figcaption>
<p><span class="caption-text">Data flow in the downlink between the internet and the UE</span><a class="headerlink" href="#id188" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>To begin with, we consider the case of the downlink, which is depicted
in Figure <a class="reference internal" href="#fig-epc-data-flow-dl-with-split"><span class="std std-ref">Data flow in the downlink between the internet and the UE</span></a>.
Downlink IPv4/IPv6 packets are generated from a generic remote host, and
addressed to one of the UE device. Internet routing will take care of
forwarding the packet to the generic NetDevice of the PGW node
which is connected to the internet (this is the Gi interface according
to 3GPP terminology). The PGW has a VirtualNetDevice which is
assigned the base IPv4 address of the EPC network; hence, static
routing rules will cause the incoming packet from the internet to be
routed through this VirtualNetDevice. In case of IPv6 address as destination,
a manual route towards the VirtualNetDevice is inserted in the routing table,
containing the 48 bit IPv6 prefix from which all the IPv6 addresses of the UEs
and PGW are configured. Such device starts the GTP/UDP/IP tunneling procedure,
by forwarding the packet to a dedicated application in the PGW node which
is called EpcPgwApplication. This application does the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it determines the SGW node to which it must route the traffic
for this UE, by looking at the IP destination address
(which is the address of the UE);</p></li>
<li><p>it classifies the packet using Traffic Flow Templates (TFTs) to
identify to which EPS Bearer it belongs. EPS bearers have a
one-to-one mapping to S5 Bearers, so this operation returns the
GTP-U Tunnel Endpoint Identifier  (TEID) to which the packet
belongs;</p></li>
<li><p>it adds the corresponding GTP-U protocol header to the packet;</p></li>
<li><p>finally, it sends the packet over a UDP socket to the S5
point-to-point NetDevice, addressed to the appropriate SGW.</p></li>
</ol>
</div></blockquote>
<p>As a consequence, the end-to-end IP packet with newly added IP, UDP
and GTP headers is sent through one of the S5 links to the SGW, where
it is received and delivered locally (as the destination address of
the outermost IP header matches the SGW IP address). The local delivery
process will forward the packet, via an UDP socket, to a dedicated
application called EpcSgwApplication. This application then performs
the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it determines the eNB node to which the UE is attached, by looking
at the S5 TEID;</p></li>
<li><p>it maps the S5 TEID to get the S1 TEID. EPS bearers have a
one-to-one mapping to S1-U Bearers, so this operation returns the
S1 GTP-U Tunnel Endpoint Identifier (TEID) to which the packet
belongs;</p></li>
<li><p>it adds a new GTP-U protocol header to the packet;</p></li>
<li><p>finally, it sends the packet over a UDP socket to the S1-U
point-to-point NetDevice, addressed to the eNB to which the UE is
attached.</p></li>
</ol>
</div></blockquote>
<p>Finally, the end-to-end IP packet with newly added IP, UDP
and GTP headers is sent through one of the S1 links to the eNB, where
it is received and delivered locally (as the destination address of
the outermost IP header matches the eNB IP address). The local delivery
process will forward the packet, via an UDP socket, to a dedicated
application called EpcEnbApplication. This application then performs
the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it removes the GTP header and retrieves the S1 TEID which is
contained in it;</p></li>
<li><p>leveraging on the one-to-one mapping between S1-U bearers and
Radio Bearers (which is a 3GPP requirement), it determines the
Bearer ID (BID) to which the packet belongs;</p></li>
<li><p>it records the BID in a dedicated tag called EpsBearerTag,
which is added to the packet;</p></li>
<li><p>it forwards the packet to the LteEnbNetDevice of the eNB node via
a raw packet socket</p></li>
</ol>
</div></blockquote>
<p>Note that, at this point, the outmost header of the packet is the
end-to-end IP header, since the IP/UDP/GTP headers of the S1 protocol
stack have already been stripped. Upon reception of
the packet from the EpcEnbApplication, the LteEnbNetDevice will
retrieve the BID from the EpsBearerTag, and based on the BID
will determine the Radio Bearer instance (and the corresponding PDCP
and RLC protocol instances) which are then used to forward the packet
to the UE over the LTE radio interface. Finally, the LteUeNetDevice of
the UE will receive the packet, and delivery it locally to the IP
protocol stack, which will in turn delivery it to the application of
the UE, which is the end point of the downlink communication.</p>
<figure class="align-center" id="id189">
<span id="fig-epc-data-flow-ul-with-split"></span><img alt="_images/epc-data-flow-ul-with-split.png" src="_images/epc-data-flow-ul-with-split.png" />
<figcaption>
<p><span class="caption-text">Data flow in the uplink between the UE and the internet</span><a class="headerlink" href="#id189" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The case of the uplink is depicted in Figure <a class="reference internal" href="#fig-epc-data-flow-ul-with-split"><span class="std std-ref">Data flow in the uplink between the UE and the internet</span></a>.
Uplink IP packets are generated by a generic application inside the UE,
and forwarded by the local TCP/IP stack to the LteUeNetDevice of the
UE. The LteUeNetDevice then performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it classifies the packet using TFTs and determines the
Radio Bearer to which the packet belongs (and the corresponding
RBID);</p></li>
<li><p>it identifies the corresponding PDCP protocol instance, which is
the entry point of the LTE Radio Protocol stack for this packet;</p></li>
<li><p>it sends the packet to the eNB over the LTE Radio Protocol stack.</p></li>
</ol>
</div></blockquote>
<p>The eNB receives the packet via its LteEnbNetDevice. Since there is a
single PDCP and RLC protocol instance for each Radio Bearer, the
LteEnbNetDevice is able to determine the BID of the packet. This BID
is then recorded onto an EpsBearerTag, which is added to the
packet. The LteEnbNetDevice then forwards the packet to the
EpcEnbApplication via a raw packet socket.</p>
<p>Upon receiving the packet, the EpcEnbApplication performs the
following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it retrieves the BID from the EpsBearerTag in the packet;</p></li>
<li><p>it determines the corresponding EPS Bearer instance and GTP-U TEID by
leveraging on the one-to-one mapping between S1-U bearers and Radio
Bearers;</p></li>
<li><p>it adds a GTP-U header on the packet, including the TEID
determined previously;</p></li>
<li><p>it sends the packet to the SGW node via the UDP socket
connected to the S1-U point-to-point net device.</p></li>
</ol>
</div></blockquote>
<p>At this point, the packet contains the S1-U IP, UDP and GTP headers in
addition to the original end-to-end IP header. When the packet is
received by the corresponding S1-U point-to-point NetDevice of the
SGW node, it is delivered locally (as the destination address of
the outmost IP header matches the address of the point-to-point net
device). The local delivery process will forward the packet to the
EpcSgwApplication via the corresponding UDP socket. The
EpcSgwApplication then performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>it removes the GTP header and retrieves the S1-U TEID;</p></li>
<li><p>it maps the S1-U TEID to get the S5 TEID to which the packet
belongs;</p></li>
<li><p>it determines the PGW to which it must send the packet from
the TEID mapping;</p></li>
<li><p>it add a new GTP-U protocol header to the packet;</p></li>
<li><p>finally, it sends the packet over a UDP socket to the S5
point-to-point NetDevice, addressed to the corresponding PGW.</p></li>
</ol>
</div></blockquote>
<p>At this point, the packet contains the S5 IP, UDP and GTP headers in
addition to the original end-to-end IP header. When the packet is
received by the corresponding S5 point-to-point NetDevice of the
PGW node, it is delivered locally (as the destination address of
the outmost IP header matches the address of the point-to-point net
device). The local delivery process will forward the packet to the
EpcPgwApplication via the corresponding UDP socket. The
EpcPgwApplication then removes the GTP header and forwards the
packet to the VirtualNetDevice. At this point, the outmost header
of the packet is the end-to-end IP header. Hence, if the destination
address within this header is a remote host on the internet, the
packet is sent to the internet via the corresponding NetDevice of the
PGW. In the event that the packet is addressed to another UE, the
IP stack of the PGW will redirect the packet again to the
VirtualNetDevice, and the packet will go through the downlink delivery
process in order to reach its destination UE.</p>
<p>Note that the EPS Bearer QoS is not enforced on the S1-U and S5
links, it is assumed that the overprovisioning of the link bandwidth
is sufficient to meet the QoS requirements of all bearers.</p>
</section>
<section id="s1ap">
<h5><span class="section-number">20.1.12.2. </span>S1AP<a class="headerlink" href="#s1ap" title="Link to this heading">¶</a></h5>
<p>The S1-AP interface provides control plane interaction between the eNB
and the MME. In the simulator, this interface is modeled in a realistic
fashion transmitting the encoded S1AP messages and information elements
specified in <a class="reference internal" href="index.html#ts36413" id="id126"><span>[TS36413]</span></a> on the S1-MME link.</p>
<p>The S1-AP primitives that are modeled are:</p>
<blockquote>
<div><ul class="simple">
<li><p>INITIAL UE MESSAGE</p></li>
<li><p>INITIAL CONTEXT SETUP REQUEST</p></li>
<li><p>INITIAL CONTEXT SETUP RESPONSE</p></li>
<li><p>PATH SWITCH REQUEST</p></li>
<li><p>PATH SWITCH REQUEST ACKNOWLEDGE</p></li>
</ul>
</div></blockquote>
</section>
<section id="s5-and-s11">
<h5><span class="section-number">20.1.12.3. </span>S5 and S11<a class="headerlink" href="#s5-and-s11" title="Link to this heading">¶</a></h5>
<p>The S5 interface provides control plane interaction between the SGW
and the PGW. The S11 interface provides control plane interaction between
the SGw and the MME. Both interfaces use the GPRS Tunneling Protocol (GTPv2-C)
to tunnel signalling messages <a class="reference internal" href="index.html#ts29274" id="id127"><span>[TS29274]</span></a> and use UDP as transport protocol.
In the simulator, these interfaces and protocol are modeled in a realistic
fashion transmitting the encoded GTP-C messages.</p>
<p>The GTPv2-C primitives that are modeled are:</p>
<blockquote>
<div><ul class="simple">
<li><p>CREATE SESSION REQUEST</p></li>
<li><p>CREATE SESSION RESPONSE</p></li>
<li><p>MODIFY BEARER REQUEST</p></li>
<li><p>MODIFY BEARER RESPONSE</p></li>
<li><p>DELETE SESSION REQUEST</p></li>
<li><p>DELETE SESSION RESPONSE</p></li>
<li><p>DELETE BEARER COMMAND</p></li>
<li><p>DELETE BEARER REQUEST</p></li>
<li><p>DELETE BEARER RESPONSE</p></li>
</ul>
</div></blockquote>
<p>Of these primitives, the first two are used upon initial UE attachment for the establishment
of the S1-U and S5 bearers. Section <a class="reference internal" href="#sec-nas"><span class="std std-ref">NAS</span></a> shows the implementation of the attach
procedure. The other primitives are used during the handover to switch the S1-U bearers from
the source eNB to the target eNB as a consequence of the reception by the MME of a
PATH SWITCH REQUEST S1-AP message.</p>
</section>
</section>
<section id="x2">
<span id="sec-x2"></span><h4><span class="section-number">20.1.13. </span>X2<a class="headerlink" href="#x2" title="Link to this heading">¶</a></h4>
<p>The X2 interface interconnects two eNBs <a class="reference internal" href="index.html#ts36420" id="id128"><span>[TS36420]</span></a>. From a logical
point of view, the X2 interface is a point-to-point interface between
the two eNBs. In a real E-UTRAN, the logical point-to-point interface
should be feasible even in the absence of a physical direct connection
between the two eNBs. In the X2 model implemented in the simulator,
the X2 interface is a point-to-point link between the two eNBs. A
point-to-point device is created in both eNBs and the two
point-to-point devices are attached to the point-to-point link.</p>
<p>For a representation of how the X2 interface fits in the overall
architecture of the LENA simulation model, the reader is referred to
the figure <a class="reference internal" href="#fig-epc-topology"><span class="std std-ref">Overview of the LTE-EPC simulation model</span></a>.</p>
<p>The X2 interface implemented in the simulator provides detailed implementation of the following elementary procedures of the Mobility Management functionality <a class="reference internal" href="index.html#ts36423" id="id129"><span>[TS36423]</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Handover Request procedure</p></li>
<li><p>Handover Request Acknowledgement procedure</p></li>
<li><p>SN Status Transfer procedure</p></li>
<li><p>UE Context Release procedure</p></li>
</ul>
</div></blockquote>
<p>These procedures are involved in the X2-based handover. You can find
the detailed description of the handover in section 10.1.2.1 of
<a class="reference internal" href="index.html#ts36300" id="id130"><span>[TS36300]</span></a>. We note that the simulator model currently supports only
the <em>seamless handover</em> as defined in Section 2.6.3.1 of <a class="reference internal" href="index.html#sesia2009" id="id131"><span>[Sesia2009]</span></a>;
in particular, <em>lossless handover</em> as described in Section 2.6.3.2 of
<a class="reference internal" href="index.html#sesia2009" id="id132"><span>[Sesia2009]</span></a> is not supported at the time of this writing.</p>
<p>Figure <a class="reference internal" href="#fig-x2-based-handover-seq-diagram"><span class="std std-ref">Sequence diagram of the X2-based handover</span></a> below shows the interaction of
the entities of the X2 model in the simulator. The shaded labels indicate the
moments when the UE or eNodeB transition to another RRC state.</p>
<figure class="align-center" id="id190">
<span id="fig-x2-based-handover-seq-diagram"></span><a class="reference internal image-reference" href="_images/lte-epc-x2-handover-seq-diagram.png"><img alt="_images/lte-epc-x2-handover-seq-diagram.png" src="_images/lte-epc-x2-handover-seq-diagram.png" style="width: 672.8000000000001px; height: 753.6px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence diagram of the X2-based handover</span><a class="headerlink" href="#id190" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The figure also shows two timers within the handover procedure: the <em>handover
leaving timer</em> is maintained by the source eNodeB, while the <em>handover joining
timer</em> by the target eNodeB. The duration of the timers can be configured in
the <code class="docutils literal notranslate"><span class="pre">HandoverLeavingTimeoutDuration</span></code> and <code class="docutils literal notranslate"><span class="pre">HandoverJoiningTimeoutDuration</span></code>
attributes of the respective <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> instances. When one of these timers
expire, the handover procedure is considered as failed.</p>
<p>However, there is no proper handling of handover failure in the current version
of LTE module. Users should tune the simulation properly in order to avoid
handover failure, otherwise unexpected behaviour may occur. Please refer to
Section <a class="reference internal" href="index.html#sec-tuning-handover-simulation"><span class="std std-ref">Tuning simulation with handover</span></a> of the User Documentation for some
tips regarding this matter.</p>
<p>The X2 model is an entity that uses services from:</p>
<blockquote>
<div><ul class="simple">
<li><p>the X2 interfaces,</p>
<ul>
<li><p>They are implemented as Sockets on top of the point-to-point devices.</p></li>
<li><p>They are used to send/receive X2 messages through the X2-C and X2-U interfaces (i.e. the point-to-point device attached to the point-to-point link) towards the peer eNB.</p></li>
</ul>
</li>
<li><p>the S1 application.</p>
<ul>
<li><p>Currently, it is the EpcEnbApplication.</p></li>
<li><p>It is used to get some information needed for the Elementary Procedures of the X2 messages.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>and it provides services to:</p>
<blockquote>
<div><ul class="simple">
<li><p>the RRC entity (X2 SAP)</p>
<ul>
<li><p>to send/receive RRC messages. The X2 entity sends the RRC message as a transparent container in the X2 message. This RRC message is sent to the UE.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-x2-entity-saps"><span class="std std-ref">Implementation Model of X2 entity and SAPs</span></a> shows the implementation model of the X2 entity and its relationship with all the other entities and services in the protocol stack.</p>
<figure class="align-center" id="id191">
<span id="fig-x2-entity-saps"></span><a class="reference internal image-reference" href="_images/lte-epc-x2-entity-saps.png"><img alt="_images/lte-epc-x2-entity-saps.png" src="_images/lte-epc-x2-entity-saps.png" style="width: 550px;" /></a>
<figcaption>
<p><span class="caption-text">Implementation Model of X2 entity and SAPs</span><a class="headerlink" href="#id191" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The RRC entity manages the initiation of the handover procedure. This is done in the Handover Management submodule of the eNB RRC entity. The target eNB may perform some Admission Control procedures. This is done in the Admission Control submodule. Initially, this submodule will accept any handover request.</p>
<section id="x2-interfaces">
<h5><span class="section-number">20.1.13.1. </span>X2 interfaces<a class="headerlink" href="#x2-interfaces" title="Link to this heading">¶</a></h5>
<p>The X2 model contains two interfaces:</p>
<blockquote>
<div><ul class="simple">
<li><p>the X2-C interface. It is the control interface and it is used to send the X2-AP PDUs
(i.e. the elementary procedures).</p></li>
<li><p>the X2-U interface. It is used to send the bearer data when there is <cite>DL forwarding</cite>.</p></li>
</ul>
</div></blockquote>
<p>Figure <a class="reference internal" href="#fig-lte-epc-x2-interface"><span class="std std-ref">X2 interface protocol stacks</span></a> shows the protocol stacks of the X2-U interface and X2-C interface modeled in the simulator.</p>
<figure class="align-center" id="id192">
<span id="fig-lte-epc-x2-interface"></span><img alt="_images/lte-epc-x2-interface.png" src="_images/lte-epc-x2-interface.png" />
<figcaption>
<p><span class="caption-text">X2 interface protocol stacks</span><a class="headerlink" href="#id192" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="x2-c">
<h6><span class="section-number">20.1.13.1.1. </span>X2-C<a class="headerlink" href="#x2-c" title="Link to this heading">¶</a></h6>
<p>The X2-C interface is the control part of the X2 interface and it is
used to send the X2-AP PDUs (i.e. the elementary procedures).</p>
<p>In the original X2 interface control plane protocol stack, SCTP is
used as the transport protocol but currently, the SCTP protocol is not
modeled in the ns-3 simulator and its implementation is out-of-scope
of the project. The UDP protocol is used as the datagram oriented
protocol instead of the SCTP protocol.</p>
</section>
<section id="x2-u">
<h6><span class="section-number">20.1.13.1.2. </span>X2-U<a class="headerlink" href="#x2-u" title="Link to this heading">¶</a></h6>
<p>The X2-U interface is used to send the bearer data when there is <cite>DL
forwarding</cite> during the execution of the X2-based handover
procedure. Similarly to what done for the S1-U interface, data packets
are encapsulated over GTP/UDP/IP when being sent over this
interface. Note that the EPS Bearer QoS is not enforced on the X2-U
links, it is assumed that the overprovisioning of the link bandwidth
is sufficient to meet the QoS requirements of all bearers.</p>
</section>
</section>
<section id="x2-service-interface">
<h5><span class="section-number">20.1.13.2. </span>X2 Service Interface<a class="headerlink" href="#x2-service-interface" title="Link to this heading">¶</a></h5>
<p>The X2 service interface is used by the RRC entity to send and receive messages of the X2 procedures. It is divided into two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">EpcX2SapProvider</span></code> part is provided by the X2 entity and used by the RRC entity and</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">EpcX2SapUser</span></code> part is provided by the RRC entity and used by the RRC entity.</p></li>
</ul>
</div></blockquote>
<p>The primitives that are supported in our X2-C model are described in the following subsections.</p>
<section id="x2-c-primitives-for-handover-execution">
<h6><span class="section-number">20.1.13.2.1. </span>X2-C primitives for handover execution<a class="headerlink" href="#x2-c-primitives-for-handover-execution" title="Link to this heading">¶</a></h6>
<p>The following primitives are used for the X2-based
handover:</p>
<blockquote>
<div><ul class="simple">
<li><p>HANDOVER REQUEST</p></li>
<li><p>HANDOVER REQUEST ACK</p></li>
<li><p>HANDOVER PREPARATION FAILURE</p></li>
<li><p>SN STATUS STRANSFER</p></li>
<li><p>UE CONTEXT RELEASE</p></li>
</ul>
</div></blockquote>
<p>all the above primitives are used by the currently implemented RRC
model during the preparation and execution of the handover
procedure. Their usage interacts with the RRC state machine;
therefore, they are not meant to be used for code customization, at
least unless it is desired to modify the RRC state machine.</p>
</section>
<section id="x2-c-son-primitives">
<h6><span class="section-number">20.1.13.2.2. </span>X2-C SON primitives<a class="headerlink" href="#x2-c-son-primitives" title="Link to this heading">¶</a></h6>
<p>The following primitives can be used  to implement Self-Organized Network (SON) functionalities:</p>
<blockquote>
<div><ul class="simple">
<li><p>LOAD INFORMATION</p></li>
<li><p>RESOURCE STATUS UPDATE</p></li>
</ul>
</div></blockquote>
<p>note that the current RRC model does not actually use these
primitives, they are included in the model just to make it possible to
develop SON algorithms included in the RRC logic that make use of
them.</p>
<p>As a first example, we show here how the load information primitive
can be used. We assume that the LteEnbRrc has been modified to include
the following new member variables:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">UlInterferenceOverloadIndicationItem</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">m_currentUlInterferenceOverloadIndicationList</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">UlHighInterferenceInformationItem</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">m_currentUlHighInterferenceInformationList</span><span class="p">;</span>
<span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">RelativeNarrowbandTxBand</span><span class="w"> </span><span class="n">m_currentRelativeNarrowbandTxBand</span><span class="p">;</span>
</pre></div>
</div>
<p>for a detailed description of the type of these variables, we suggest
to consult the file <code class="docutils literal notranslate"><span class="pre">epc-x2-sap.h</span></code>, the corresponding doxygen
documentation, and the references therein to the relevant sections of
3GPP TS 36.423. Now, assume that at run time these variables have been
set to meaningful values following the specifications just
mentioned. Then, you can add the following code in the LteEnbRrc class
implementation in order to send a load information primitive:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">CellInformationItem</span><span class="w"> </span><span class="n">cii</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">sourceCellId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_cellId</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">ulInterferenceOverloadIndicationList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_currentUlInterferenceOverloadIndicationList</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">ulHighInterferenceInformationList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_currentUlHighInterferenceInformationList</span><span class="p">;</span>
<span class="n">cii</span><span class="p">.</span><span class="n">relativeNarrowbandTxBand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_currentRelativeNarrowbandTxBand</span><span class="p">;</span>

<span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">LoadInformationParams</span><span class="w"> </span><span class="n">params</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">targetCellId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cellId</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">cellInformationList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cii</span><span class="p">);</span>
<span class="n">m_x2SapProvider</span><span class="o">-&gt;</span><span class="n">SendLoadInformation</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code allows the source eNB to send the message. The method
<code class="docutils literal notranslate"><span class="pre">LteEnbRrc::DoRecvLoadInformation</span></code> will be called when the target
eNB receives the message. The desired processing of the load
information should therefore be implemented within that method.</p>
<p>In the following second example we show how the resource
status update primitive is used. We assume that the LteEnbRrc has been
modified to include the following new member variable:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">CellMeasurementResultItem</span><span class="w"> </span><span class="n">m_cmri</span><span class="p">;</span>
</pre></div>
</div>
<p>similarly to before, we refer to <code class="docutils literal notranslate"><span class="pre">epc-x2-sap.h</span></code> and the references
therein for detailed information about this variable type.
Again, we assume that the variable has been already set to a
meaningful value. Then, you can add the following code in order to
send a resource status update:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EpcX2Sap</span><span class="o">::</span><span class="n">ResourceStatusUpdateParams</span><span class="w"> </span><span class="n">params</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">targetCellId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cellId</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">cellMeasurementResultList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_cmri</span><span class="p">);</span>
<span class="n">m_x2SapProvider</span><span class="o">-&gt;</span><span class="n">SendResourceStatusUpdate</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">eEnbRrc::DoRecvResourceStatusUpdate</span></code> will be called when
the target eNB receives the resource status update message. The
desired processing of this message should therefore be implemented
within that method.</p>
<p>Finally, we note that the setting and processing of the appropriate
values for the variable passed to the above described primitives is
deemed to be specific of the SON algorithm being implemented, and
hence is not covered by this documentation.</p>
</section>
<section id="unsupported-primitives">
<h6><span class="section-number">20.1.13.2.3. </span>Unsupported primitives<a class="headerlink" href="#unsupported-primitives" title="Link to this heading">¶</a></h6>
<p>Mobility Robustness Optimization primitives such as Radio Link Failure
indication and Handover Report are not supported at this stage.</p>
</section>
</section>
</section>
<section id="s11">
<h4><span class="section-number">20.1.14. </span>S11<a class="headerlink" href="#s11" title="Link to this heading">¶</a></h4>
<p>The S11 interface provides control plane interaction between the SGW
and the MME using the GTPv2-C protocol specified in <a class="reference internal" href="index.html#ts29274" id="id133"><span>[TS29274]</span></a>. In the
simulator, this interface is modeled in an ideal
fashion, with direct interaction between the SGW and the MME objects,
without actually implementing the encoding of the messages and without actually
transmitting any PDU on any link.</p>
<p>The S11 primitives that are modeled are:</p>
<blockquote>
<div><ul class="simple">
<li><p>CREATE SESSION REQUEST</p></li>
<li><p>CREATE SESSION RESPONSE</p></li>
<li><p>MODIFY BEARER REQUEST</p></li>
<li><p>MODIFY BEARER RESPONSE</p></li>
</ul>
</div></blockquote>
<p>Of these primitives, the first two are used upon initial UE attachment
for the establishment of the S1-U bearers; the other two are used
during handover to switch the S1-U bearers from the source eNB to the
target eNB as a consequence of the reception by the MME of a PATH
SWITCH REQUEST S1-AP message.</p>
</section>
<section id="power-control">
<h4><span class="section-number">20.1.15. </span>Power Control<a class="headerlink" href="#power-control" title="Link to this heading">¶</a></h4>
<p>This section describes the ns-3 implementation of Downlink and Uplink Power Control.</p>
<section id="downlink-power-control">
<h5><span class="section-number">20.1.15.1. </span>Downlink Power Control<a class="headerlink" href="#downlink-power-control" title="Link to this heading">¶</a></h5>
<p>Since some of Frequency Reuse Algorithms require Downlink Power Control,
this feature was also implemented in ns-3.</p>
<figure class="align-center" id="id193">
<span id="fig-lte-downlik-power-control"></span><img alt="_images/lte-dl-power-control.png" src="_images/lte-dl-power-control.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of Downlink Power Control</span><a class="headerlink" href="#id193" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#fig-lte-downlik-power-control"><span class="std std-ref">Sequence diagram of Downlink Power Control</span></a> shows the sequence diagram of
setting downlink P_A value for UE, highlighting the interactions between
the RRC and the other entities. FR algorithm triggers RRC to change P_A values
for UE. Then RRC starts RrcConnectionReconfiguration function to inform UE
about new configuration. After successful RrcConnectionReconfiguration, RRC
can set P_A value for UE by calling function SetPa from CphySap, value is
saved in new map m_paMap which contain P_A values for each UE served by eNb.</p>
<p>When LteEnbPhy starts new subframe, DCI control messages are processed to get
vector of used RBs. Now also GeneratePowerAllocationMap(uint16_t rnti, int rbId)
function is also called. This function check P_A value for UE, generate power
for each RB and store it in m_dlPowerAllocationMap. Then this map is used by
CreateTxPowerSpectralDensityWithPowerAllocation function to create
Ptr&lt;SpectrumValue&gt; txPsd.</p>
<p>PdschConfigDedicated (TS 36.331, 6.3.2 PDSCH-Config) was added in
LteRrcSap::PhysicalConfigDedicated struct, which is used in
RrcConnectionReconfiguration process.</p>
</section>
<section id="uplink-power-control">
<h5><span class="section-number">20.1.15.2. </span>Uplink Power Control<a class="headerlink" href="#uplink-power-control" title="Link to this heading">¶</a></h5>
<p>Uplink power control controls the transmit power of the different uplink physical
channels. This functionality is described in 3GPP TS 36.213 section 5.</p>
<p>Uplink Power Control is enabled by default, and can be disabled by attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePhy::EnableUplinkPowerControl&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>Two Uplink Power Control mechanisms are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p>Open Loop Uplink Power Control: the UE transmission power depends on estimation of
the downlink path-loss and channel configuration</p></li>
<li><p>Closed Loop Uplink Power Control: as in Open Loop, in addition eNB can control the UE
transmission power by means of explicit Transmit Power Control TPC commands transmitted
in the downlink.</p></li>
</ul>
</div></blockquote>
<p>To switch between these two mechanism types, one should change parameter:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::ClosedLoop&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>By default, Closed Loop Power Control is enabled.</p>
<dl class="simple">
<dt>Two modes of Closed Loop Uplink Power Control are available:</dt><dd><ul class="simple">
<li><p>Absolute mode: TxPower is computed with absolute TPC values</p></li>
<li><p>Accumulative mode: TxPower is computed with accumulated TPC values</p></li>
</ul>
</dd>
</dl>
<p>To switch between these two modes, one should change parameter:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::AccumulationEnabled&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>By default, Accumulation Mode is enabled and TPC commands in DL-DCI are set by all schedulers to 1,
what is mapped to value of 0 in Accumulation Mode.</p>
<section id="uplink-power-control-for-pusch">
<span id="sec-uplink-power-control-pusch"></span><h6><span class="section-number">20.1.15.2.1. </span>Uplink Power Control for PUSCH<a class="headerlink" href="#uplink-power-control-for-pusch" title="Link to this heading">¶</a></h6>
<p>The setting of the UE Transmit power for a Physical Uplink Shared Channel (PUSCH) transmission
is defined as follows:</p>
<blockquote>
<div><ul>
<li><p>If the UE transmits PUSCH without a simultaneous PUCCH for the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, then the
UE transmit power <img class="math" src="_images/math/3d4e0601ab98953c5bd38157a12699834f55aad0.png" alt="P_{PUSCH,c}(i)"/> for PUSCH transmission in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for the
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is given by:</p>
<div class="math">
<p><img src="_images/math/14a3ce5a8521ace1e07c9030b2ad4b4f37bf6312.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               P_{CMAX,c}(i)\\
               10\log_{10}(M_{PUSCH,c}(i))+ P_{O\_PUSCH,c}(j)
               + \alpha_{c} (j) * PL_{c} + \Delta_{TF,c}(i) + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div></li>
<li><p>If the UE transmits PUSCH simultaneous with PUCCH for the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, then the UE
transmit power <img class="math" src="_images/math/3d4e0601ab98953c5bd38157a12699834f55aad0.png" alt="P_{PUSCH,c}(i)"/> for the PUSCH transmission in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for
the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is given by:</p>
<div class="math">
<p><img src="_images/math/96d61b5f5f0645ef73023f3a40fe9d6e16274a85.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               10\log_{10}(\hat{P}_{CMAX,c}(i) - \hat{P}_{PUCCH}(i))\\
               10\log_{10}(M_{PUSCH,c}(i))+ P_{O\_PUSCH,c}(j)
               + \alpha_{c} (j) * PL_{c} + \Delta_{TF,c}(i) + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div><p>Since Uplink Power Control for PUCCH is not implemented, this case is not implemented as well.</p>
</li>
<li><p>If the UE is not transmitting PUSCH for the serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, for the accumulation of
TPC command received with DCI format 3/3A for PUSCH, the UE shall assume that the UE transmit
power <img class="math" src="_images/math/3d4e0601ab98953c5bd38157a12699834f55aad0.png" alt="P_{PUSCH,c}(i)"/> for the PUSCH transmission in    subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for the serving
cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is computed by</p>
<div class="math">
<p><img src="_images/math/813b0ed2ddaead0fba1bb14c1e08d7487ddeb147.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               {P}_{CMAX,c}(i)\\
               P_{O\_PUSCH,c}(1) + \alpha_{c} (1) * PL_{c} + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div></li>
</ul>
</div></blockquote>
<dl>
<dt>where:</dt><dd><ul>
<li><p><img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is the configured UE transmit power defined in 3GPP 36.101. Table 6.2.2-1
in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> and <img class="math" src="_images/math/2d9d562ae50e1e1cf6ad9ec553fa9e5cf9eb4332.png" alt="\hat{P}_{CMAX,c}(i)"/> is the linear
value of <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/>. Default value for <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is 23 dBm</p></li>
<li><p><img class="math" src="_images/math/57f5e05b541685ec156ba34f111255e11762f3e1.png" alt="M_{PUSCH,c}(i)"/> is the bandwidth of the PUSCH resource assignment expressed in number
of resource blocks valid for subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> and serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> .</p></li>
<li><p><img class="math" src="_images/math/9917641057b7ada394237bfd961000139a0d3dc2.png" alt="P_{O\_PUSCH,c}(j)"/> is a parameter composed of the sum of a component <img class="math" src="_images/math/392a794730f67b064bd47e5eea02a8e9d409b0b0.png" alt="P_{O\_NOMINAL\_PUSCH,c}(j)"/>
provided from higher layers for <img class="math" src="_images/math/3d2393215c8673f00280a58962bfb2268b804d41.png" alt="j={0,1}"/> and a component <img class="math" src="_images/math/4c4b38b275d16833b07526da845bcf7d583764f7.png" alt="P_{O\_UE\_PUSCH,c}(j)"/> provided by higher
layers for <img class="math" src="_images/math/3d2393215c8673f00280a58962bfb2268b804d41.png" alt="j={0,1}"/> for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>. SIB2 message needs to be extended to carry these two
components, but currently they can be set via attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::PoNominalPusch&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">IntegerValue</span><span class="p">(</span><span class="mi">-90</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::PoUePusch&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">IntegerValue</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p><img class="math" src="_images/math/6792c6513b51a54b77f54569c5174ff7757b59bf.png" alt="\alpha_{c} (j)"/> is a 3-bit parameter provided by higher layers for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>.
For <img class="math" src="_images/math/995460da8d4ed81292e6d694401f1f5e8b02e9fd.png" alt="j=0,1"/>,   <img class="math" src="_images/math/c5f0ec3bc05b87b5e1a78d4139c55c757e6b0ff0.png" alt="\alpha_c \in \left \{ 0, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1 \right \}"/>
For <img class="math" src="_images/math/d7412635262724ee2e5af7b01635a007c707a461.png" alt="j=2"/>,   <img class="math" src="_images/math/991a028630e9e2bfcd8047ddee88271198b03698.png" alt="\alpha_{c} (j) = 1"/>.
This parameter is configurable by attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::Alpha&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.8</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p><img class="math" src="_images/math/ce695e88739f5e6d1091722cdda6815a41435cda.png" alt="PL_{c}"/> is the downlink pathloss estimate calculated in the UE for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> in dB
and <img class="math" src="_images/math/c945dc552a51dc771b990a8890c24d026dd632e5.png" alt="PL_{c} = referenceSignalPower – higher layer filtered RSRP"/>, where <img class="math" src="_images/math/def53cc8b1453e42ed48e149dbe515d6b4edf7a2.png" alt="referenceSignalPower"/>
is provided by higher layers and RSRP. <img class="math" src="_images/math/def53cc8b1453e42ed48e149dbe515d6b4edf7a2.png" alt="referenceSignalPower"/> is provided in SIB2 message</p></li>
<li><p><img class="math" src="_images/math/ed03ffc1cc73e2da54b060cd9af68778a2d2f57c.png" alt="\Delta_{TF,c}(i) = 10\log_{10}((2^{BPRE\cdot K_s}-1)\cdot\beta_{offset}^{PUSCH} )"/> for <img class="math" src="_images/math/0d62e598dc8588e49abdb5a59a13f5af1a7aad5c.png" alt="K_{s} = 1.25"/>
and <img class="math" src="_images/math/4624a6e2cf0024d742a2e2451af5d0327c85313e.png" alt="\Delta_{TF,c}(i) = 0"/> for <img class="math" src="_images/math/84fd6b40fc0fc1aed6f5d0b456c81157d477439e.png" alt="K_{s} = 0"/>. Only second case is implemented.</p></li>
<li><p><img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is component of Closed Loop Power Control. It is the current PUSCH power control
adjustment state for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>.</p>
<p>If Accumulation Mode is enabled <img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is given by:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/c670de479da7636d7a044cad093f74566bcbc418.png" alt="f_{c}(i) = f_{c}(i-1) + \delta_{PUSCH,c}(i - K_{PUSCH})"/></p>
</div></div></blockquote>
<p>where: <img class="math" src="_images/math/6db51ac2339938d8692759bdadbf5412bdb20e63.png" alt="\delta_{PUSCH,c}"/> is a correction value, also referred to as a TPC command and is included
in PDCCH with DCI; <img class="math" src="_images/math/bebbca1273e36aa6c21fd211edb852d2489870f6.png" alt="\delta_{PUSCH,c}(i - K_{PUSCH})"/> was signalled on PDCCH/EPDCCH with DCI for
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> on subframe <img class="math" src="_images/math/a7494a518d151be25f144fa33cb0e2912e8c0997.png" alt="(i - K_{PUSCH})"/>; <img class="math" src="_images/math/bc1461dd38cda1059bdb24f112bf28fd42f36584.png" alt="K_{PUSCH} = 4"/> for FDD.</p>
<p>If UE has reached <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>, positive TPC commands for serving cell
<img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> are not be accumulated. If UE has reached minimum power, negative TPC commands are not be accumulated.
Minimum UE power is defined in TS36.101 section 6.2.3.  Default value is -40 dBm.</p>
<p>If Accumulation Mode is not enabled <img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is given by:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/53bdd7e0269f9983789b6edcb6670d834b8a4d46.png" alt="f_{c}(i) = \delta_{PUSCH,c}(i - K_{PUSCH})"/></p>
</div></div></blockquote>
<p>where: <img class="math" src="_images/math/6db51ac2339938d8692759bdadbf5412bdb20e63.png" alt="\delta_{PUSCH,c}"/> is a correction value, also referred to as a TPC command and is included
in PDCCH with DCI; <img class="math" src="_images/math/bebbca1273e36aa6c21fd211edb852d2489870f6.png" alt="\delta_{PUSCH,c}(i - K_{PUSCH})"/> was signalled on PDCCH/EPDCCH with DCI for
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> on subframe <img class="math" src="_images/math/a7494a518d151be25f144fa33cb0e2912e8c0997.png" alt="(i - K_{PUSCH})"/>; <img class="math" src="_images/math/bc1461dd38cda1059bdb24f112bf28fd42f36584.png" alt="K_{PUSCH} = 4"/> for FDD.</p>
<p>Mapping of TPC Command Field in DCI format 0/3/4 to absolute and accumulated <img class="math" src="_images/math/6db51ac2339938d8692759bdadbf5412bdb20e63.png" alt="\delta_{PUSCH,c}"/>
values is defined in TS36.231 section 5.1.1.1 Table 5.1.1.1-2</p>
</li>
</ul>
</dd>
</dl>
</section>
<section id="uplink-power-control-for-pucch">
<h6><span class="section-number">20.1.15.2.2. </span>Uplink Power Control for PUCCH<a class="headerlink" href="#uplink-power-control-for-pucch" title="Link to this heading">¶</a></h6>
<p>Since all uplink control messages are an ideal messages and do not consume any radio resources,
Uplink Power Control for PUCCH is not needed and it is not implemented.</p>
</section>
<section id="uplink-power-control-for-srs">
<h6><span class="section-number">20.1.15.2.3. </span>Uplink Power Control for SRS<a class="headerlink" href="#uplink-power-control-for-srs" title="Link to this heading">¶</a></h6>
<p>The setting of the UE Transmit power <img class="math" src="_images/math/fd4f34d013414ca5575ca562a68ddd691469c8f3.png" alt="P_{SRS}"/> for the SRS transmitted on subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>
for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is defined by</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/fa2f9d41bb69b090f6be826348ecad4f2c39ccad.png" alt="P_{PUSCH,c}(i)=\min\begin{Bmatrix}
               {P}_{CMAX,c}(i)\\
               P_{SRS\_OFFSET,c}(m) + 10\log_{10}(M_{SRS,c})+
               P_{O\_PUSCH,c}(j) + \alpha_{c}(j) * PL_{c} + f_{c}(i)
               \end{Bmatrix} [dBm]"/></p>
</div></div></blockquote>
<dl>
<dt>where:</dt><dd><ul>
<li><p><img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is the configured UE transmit power defined in 3GPP 36.101. Table 6.2.2-1.
Default value for <img class="math" src="_images/math/1913b1d7b7ff500a14e08c82d971fb962ad97aa5.png" alt="P_{CMAX,c}(i)"/> is 23 dBm</p></li>
<li><p><img class="math" src="_images/math/bd0dd68f06efe9f08d62b748d2b4cfc4e31914a9.png" alt="P_{SRS\_OFFSET,c}(m)"/> is semi-statically configured by higher layers for <img class="math" src="_images/math/db9078364746510069ca573244ca3af68829f920.png" alt="m=0,1"/> for
serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> . For SRS transmission given trigger type 0 then <img class="math" src="_images/math/db9078364746510069ca573244ca3af68829f920.png" alt="m=0,1"/> and for SRS
transmission given trigger type 1 then <img class="math" src="_images/math/b8e21c1654af1be4509ddba1bdba20de45e397c0.png" alt="m=1"/>.
For <img class="math" src="_images/math/84fd6b40fc0fc1aed6f5d0b456c81157d477439e.png" alt="K_{s} = 0"/> P_Srs_Offset_Value is computed with equation:</p>
<div class="math">
<p><img src="_images/math/b631cb2b417b55aecb9aca353391a41145ab69ca.png" alt="P_{SRS\_OFFSET,c}(m)value = -10.5 + P_{SRS\_OFFSET,c}(m) * 1.5 [dBm]"/></p>
</div><p>This parameter is configurable by attribute system:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::LteUePowerControl::PsrsOffset&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">IntegerValue</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p><img class="math" src="_images/math/b67ab1022e68b744c7123f2152b09c6f1e61b464.png" alt="M_{SRS,c}"/> is the bandwidth of the SRS transmission in subframe <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> for serving
cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> expressed in number of resource blocks. In current implementation SRS is sent
over entire UL bandwidth.</p></li>
<li><p><img class="math" src="_images/math/f32fdde637162a4db132be3c8ec4471b19139efd.png" alt="f_{c}(i)"/> is the current PUSCH power control adjustment state for serving cell <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/>,
as defined in    <a class="reference internal" href="#sec-uplink-power-control-pusch"><span class="std std-ref">Uplink Power Control for PUSCH</span></a></p></li>
<li><p><img class="math" src="_images/math/9917641057b7ada394237bfd961000139a0d3dc2.png" alt="P_{O\_PUSCH,c}(j)"/> and <img class="math" src="_images/math/e779569e20e9f40b7d9044f11f3f15f32d423f04.png" alt="\alpha_{c}(j)"/> are parameters as defined in
<a class="reference internal" href="#sec-uplink-power-control-pusch"><span class="std std-ref">Uplink Power Control for PUSCH</span></a>, where <img class="math" src="_images/math/e11665feca4a260df50360e8263134c58b35b653.png" alt="j = 1"/> .</p></li>
</ul>
</dd>
</dl>
</section>
</section>
</section>
<section id="fractional-frequency-reuse">
<h4><span class="section-number">20.1.16. </span>Fractional Frequency Reuse<a class="headerlink" href="#fractional-frequency-reuse" title="Link to this heading">¶</a></h4>
<section id="id134">
<h5><span class="section-number">20.1.16.1. </span>Overview<a class="headerlink" href="#id134" title="Link to this heading">¶</a></h5>
<p>This section describes the ns-3 support for Fractional Frequency Reuse
algorithms. All implemented algorithms are described in <a class="reference internal" href="index.html#ashamza2013" id="id135"><span>[ASHamza2013]</span></a>.
Currently 7 FR algorithms are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrNoOpAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrHardAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrStrictAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrEnhancedAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrDistributedAlgorithm</span></code></p></li>
</ul>
</div></blockquote>
<p>New LteFfrAlgorithm class was created and it is a abstract class for
Frequency Reuse algorithms implementation. Also, two new SAPs between
FR-Scheduler and FR-RRC were added.</p>
<figure class="align-center" id="id194">
<span id="fig-lte-ffr-scheduling"></span><img alt="_images/lte-ffr-scheduling.png" src="_images/lte-ffr-scheduling.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of Scheduling with FR algorithm</span><a class="headerlink" href="#id194" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#fig-lte-ffr-scheduling"><span class="std std-ref">Sequence diagram of Scheduling with FR algorithm</span></a> shows the sequence diagram of
scheduling process with FR algorithm. In the beginning of scheduling
process, scheduler asks FR entity for available RBGs. According to
implementation FR returns all RBGs available in cell or filter them based
on its policy. Then when trying to assign some RBG to UE, scheduler asks FR
entity if this RBG is allowed for this UE. When FR returns true, scheduler
can assign this RBG to this UE, if not scheduler is checking another RBG
for this UE. Again, FR response depends on implementation and policy applied
to UE.</p>
</section>
<section id="supported-fr-algorithms">
<h5><span class="section-number">20.1.16.2. </span>Supported FR algorithms<a class="headerlink" href="#supported-fr-algorithms" title="Link to this heading">¶</a></h5>
<section id="no-frequency-reuse">
<h6><span class="section-number">20.1.16.2.1. </span>No Frequency Reuse<a class="headerlink" href="#no-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>The NoOp FR algorithm (LteFrNoOpAlgorithm class) is implementation of
Full Frequency Reuse scheme, that means no frequency partitioning is performed
between eNBs of the same network (frequency reuse factor, FRF equals 1). eNBs
uses entire system bandwidth and transmit with uniform power over all RBGs. It
is the simplest scheme and is the basic way of operating an LTE network. This
scheme allows for achieving the high peak data rate. But from the other hand,
due to heavy interference levels from neighbouring cells, cell-edge users
performance is greatly limited.</p>
<p>Figure <a class="reference internal" href="#fig-lte-full-frequency-reuse-scheme"><span class="std std-ref">Full Frequency Reuse scheme</span></a> below presents frequency and
power plan for Full Frequency Reuse scheme.</p>
<figure class="align-center" id="id195">
<span id="fig-lte-full-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-full-frequency-reuse-scheme.png"><img alt="_images/fr-full-frequency-reuse-scheme.png" src="_images/fr-full-frequency-reuse-scheme.png" style="width: 550.1999999999999px; height: 289.8px;" /></a>
<figcaption>
<p><span class="caption-text">Full Frequency Reuse scheme</span><a class="headerlink" href="#id195" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In ns-3, the NoOp FR algorithm always allows scheduler to use full bandwidth
and allows all UEs to use any RBG. It simply does nothing new (i.e. it does not
limit eNB bandwidth, FR algorithm is disabled), it is the simplest implementation
of FrAlgorithm class and is installed in eNb by default.</p>
</section>
<section id="hard-frequency-reuse">
<span id="sec-fr-hard-algorithm"></span><h6><span class="section-number">20.1.16.2.2. </span>Hard Frequency Reuse<a class="headerlink" href="#hard-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>The Hard Frequency Reuse algorithm provides the simplest scheme which allows to
reduce inter-cell interference level. In this scheme whole frequency bandwidth is
divided into few (typically 3, 4, or 7) disjoint sub-bands. Adjacent eNBs are
allocated with different sub-band. Frequency reuse factor equals the number
of sub-bands. This scheme allows to significantly reduce ICI at the cell edge,
so the performance of cell-users is improved. But due to the fact, that each
eNB uses only one part of whole bandwidth, peak data rate level is also reduced
by the factor equal to the reuse factor.</p>
<p>Figure <a class="reference internal" href="#fig-lte-hard-frequency-reuse-scheme"><span class="std std-ref">Hard Frequency Reuse scheme</span></a> below presents frequency and
power plan for Hard Frequency Reuse scheme.</p>
<figure class="align-center" id="id196">
<span id="fig-lte-hard-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-hard-frequency-reuse-scheme.png"><img alt="_images/fr-hard-frequency-reuse-scheme.png" src="_images/fr-hard-frequency-reuse-scheme.png" style="width: 550.1999999999999px; height: 289.8px;" /></a>
<figcaption>
<p><span class="caption-text">Hard Frequency Reuse scheme</span><a class="headerlink" href="#id196" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In our implementation, the Hard FR algorithm has only vector of RBGs available
for eNB and pass it to MAC Scheduler during scheduling functions. When scheduler
ask, if RBG is allowed for specific UE it always return true.</p>
</section>
<section id="strict-frequency-reuse">
<h6><span class="section-number">20.1.16.2.3. </span>Strict Frequency Reuse<a class="headerlink" href="#strict-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>Strict Frequency Reuse scheme is combination of Full and Hard Frequency Reuse
schemes. It consists of dividing the system bandwidth into two parts which will
have different frequency reuse. One common sub-band of the system bandwidth is
used in each cell interior (frequency reuse-1), while the other part of the
bandwidth is divided among the neighboring eNBs as in hard frequency reuse
(frequency reuse-N, N&gt;1), in order to create one sub-band with a low inter-cell
interference level in each sector. Center UEs will be granted with the fully-reused
frequency chunks, while cell-edge UEs with orthogonal chunks. It means that interior
UEs from one cell do not share any spectrum with edge UEs from second cell, which
reduces interference for both. As can be noticed, Strict FR requires a total of
N + 1 sub-bands, and allows to achieve RFR in the middle between 1 and 3.</p>
<p>Figure <a class="reference internal" href="#fig-lte-strict-frequency-reuse-scheme"><span class="std std-ref">Strict Frequency Reuse scheme</span></a> below presents frequency and
power plan for Strict Frequency Reuse scheme with a cell-edge reuse factor of N = 3.</p>
<figure class="align-center" id="id197">
<span id="fig-lte-strict-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-strict-frequency-reuse-scheme.png"><img alt="_images/fr-strict-frequency-reuse-scheme.png" src="_images/fr-strict-frequency-reuse-scheme.png" style="width: 549.6px; height: 284.4px;" /></a>
<figcaption>
<p><span class="caption-text">Strict Frequency Reuse scheme</span><a class="headerlink" href="#id197" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In our implementation, Strict FR algorithm has two maps, one for each sub-band.
If UE can be served within private sub-band, its RNTI is added to m_privateSubBandUe
map. If UE can be served within common sub-band, its RNTI is added to
m_commonSubBandUe map. Strict FR algorithm needs to decide within which sub-band
UE should be served. It uses UE measurements provided by RRB and compare them
with signal quality threshold (this parameter can be easily tuned by attribute
mechanism). Threshold has influence on interior to cell radius ratio.</p>
</section>
<section id="soft-frequency-reuse">
<h6><span class="section-number">20.1.16.2.4. </span>Soft Frequency Reuse<a class="headerlink" href="#soft-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>In Soft Frequency Reuse (SFR) scheme each eNb transmits over the entire system
bandwidth, but there are two sub-bands, within UEs are served with different power
level. Since cell-center UEs share the bandwidth with neighboring cells, they
usually transmit at lower power level than the cell-edge UEs. SFR is more bandwidth
efficient than Strict FR, because it uses entire system bandwidth, but it also
results in more interference to both cell interior and edge users.</p>
<p>There are two possible versions of SFR scheme:</p>
<blockquote>
<div><ul>
<li><p>In first version, the sub-band dedicated for the cell-edge UEs may also be used
by the cell-center UEs but with reduced power level and only if it is not occupied
by the cell-edge UEs. Cell-center sub-band is available to the centre UEs only.
Figure <a class="reference internal" href="#fig-lte-soft-frequency-reuse-scheme-v1"><span class="std std-ref">Soft Frequency Reuse scheme version 1</span></a> below presents frequency and
power plan for this version of Soft Frequency Reuse scheme.</p>
<figure class="align-center" id="id198">
<span id="fig-lte-soft-frequency-reuse-scheme-v1"></span><a class="reference internal image-reference" href="_images/fr-soft-frequency-reuse-scheme-v1.png"><img alt="_images/fr-soft-frequency-reuse-scheme-v1.png" src="_images/fr-soft-frequency-reuse-scheme-v1.png" style="width: 549.6px; height: 284.4px;" /></a>
<figcaption>
<p><span class="caption-text">Soft Frequency Reuse scheme version 1</span><a class="headerlink" href="#id198" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</li>
<li><p>In second version, cell-center UEs do not have access to cell-edge sub-band.
In this way, each cell can use the whole system bandwidth while reducing the
interference to the neighbors cells. From the other hand, lower ICI level at
the cell-edge is achieved at the expense of lower spectrum utilization.
Figure <a class="reference internal" href="#fig-lte-soft-frequency-reuse-scheme-v2"><span class="std std-ref">Soft Frequency Reuse scheme version 2</span></a> below presents frequency
and power plan for this version of Soft Frequency Reuse scheme.</p>
<figure class="align-center" id="id199">
<span id="fig-lte-soft-frequency-reuse-scheme-v2"></span><a class="reference internal image-reference" href="_images/fr-soft-frequency-reuse-scheme-v2.png"><img alt="_images/fr-soft-frequency-reuse-scheme-v2.png" src="_images/fr-soft-frequency-reuse-scheme-v2.png" style="width: 549.6px; height: 284.4px;" /></a>
<figcaption>
<p><span class="caption-text">Soft Frequency Reuse scheme version 2</span><a class="headerlink" href="#id199" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</li>
</ul>
</div></blockquote>
<p>SFR algorithm maintain two maps. If UE should be served with lower power level,
its RNTI is added to m_lowPowerSubBandUe map. If UE should be served with higher
power level, its RNTI is added to m_highPowerSubBandUe map. To decide with which
power level UE should be served SFR algorithm utilize UE measurements, and
compares them to threshold. Signal quality threshold and PdschConfigDedicated
(i.e. P_A value) for inner and outer area can be configured by attributes system.
SFR utilizes Downlink Power Control described here.</p>
</section>
<section id="soft-fractional-frequency-reuse">
<h6><span class="section-number">20.1.16.2.5. </span>Soft Fractional Frequency Reuse<a class="headerlink" href="#soft-fractional-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>Soft Fractional Frequency Reuse (SFFR) is an combination of Strict and Soft
Frequency Reuse schemes. While Strict FR do not use the subbands allocated
for outer region in the adjacent cells, soft FFR uses these subbands for the
inner UEs with low transmit power. As a result, the SFFR, like SFR, use the
subband with high transmit power level and with low transmit power level.
Unlike the Soft FR and like Strict FR, the Soft FFR uses the common sub-band
which can enhance the throughput of the inner users.</p>
<p>Figure <a class="reference internal" href="#fig-lte-soft-fractional-frequency-reuse-scheme"><span class="std std-ref">Soft Fractional Fractional Frequency Reuse scheme</span></a> below presents
frequency and power plan for Soft Fractional Frequency Reuse.</p>
<figure class="align-center" id="id200">
<span id="fig-lte-soft-fractional-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-soft-fractional-frequency-reuse-scheme.png"><img alt="_images/fr-soft-fractional-frequency-reuse-scheme.png" src="_images/fr-soft-fractional-frequency-reuse-scheme.png" style="width: 549.6px; height: 284.4px;" /></a>
<figcaption>
<p><span class="caption-text">Soft Fractional Fractional Frequency Reuse scheme</span><a class="headerlink" href="#id200" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="enhanced-fractional-frequency-reuse">
<h6><span class="section-number">20.1.16.2.6. </span>Enhanced Fractional Frequency Reuse<a class="headerlink" href="#enhanced-fractional-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>Enhanced Fractional Frequency Reuse (EFFR) described in <a class="reference internal" href="index.html#zxie2009" id="id136"><span>[ZXie2009]</span></a> defines 3
cell-types for directly neighboring cells in a cellular system, and reserves
for each cell-type a part of the whole frequency band named <cite>Primary Segment</cite>,
which among different type cells should be orthogonal. The remaining subchannels
constitute the <cite>Secondary Segment</cite>. The <cite>Primary Segment</cite> of a cell-type is
at the same time a part of the <cite>Secondary Segments</cite> belonging to the other two
cell-types. Each cell can occupy all subchannels of its <cite>Primary Segment</cite> at
will, whereas only a part of subchannels in the <cite>Secondary Segment</cite> can be used
by this cell in an interference-aware manner.The <cite>Primary Segment</cite> of each cell
is divided into a reuse-3 part and reuse-1 part. The reuse-1 part can be reused
by all types of cells in the system, whereas reuse-3 part can only be exclusively
reused by other same type cells( i.e. the reuse-3 subchannels cannot be reused
by directly neighboring cells). On the <cite>Secondary Segment</cite> cell acts as a guest,
and occupying secondary subchannels is actually reuse the primary subchannels
belonging to the directly neighboring cells, thus reuse on the <cite>Secondary Segment</cite>
by each cell should conform to two rules:</p>
<blockquote>
<div><ul class="simple">
<li><p>monitor before use</p></li>
<li><p>resource reuse based on SINR estimation</p></li>
</ul>
</div></blockquote>
<p>Each cell listens on every secondary subchannel all the time. And before occupation,
it makes SINR evaluation according to the gathered channel quality information (CQI)
and chooses resources with best estimation values for reuse. If CQI value for RBG is
above configured threshold for some user, transmission for this user can be performed
using this RBG.</p>
<p>In <a class="reference internal" href="index.html#zxie2009" id="id137"><span>[ZXie2009]</span></a> scheduling process is described, it consist of three steps and two
scheduling polices. Since none of currently implemented schedulers allow for
this behaviour, some simplification were applied. In our implementation reuse-1
subchannels can be used only by cell center users. Reuse-3 subchannels can be used by
edge users, and only if there is no edge user, transmission for cell center users can
be served in reuse-3 subchannels.</p>
<p>Figure <a class="reference internal" href="#fig-lte-enhanced-fractional-frequency-reuse-scheme"><span class="std std-ref">Enhanced Fractional Fractional Frequency Reuse scheme</span></a> below presents
frequency and power plan for Enhanced Fractional Frequency Reuse.</p>
<figure class="align-center" id="id201">
<span id="fig-lte-enhanced-fractional-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/fr-enhanced-fractional-frequency-reuse-scheme.png"><img alt="_images/fr-enhanced-fractional-frequency-reuse-scheme.png" src="_images/fr-enhanced-fractional-frequency-reuse-scheme.png" style="width: 549.6px; height: 284.4px;" /></a>
<figcaption>
<p><span class="caption-text">Enhanced Fractional Fractional Frequency Reuse scheme</span><a class="headerlink" href="#id201" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="distributed-fractional-frequency-reuse">
<h6><span class="section-number">20.1.16.2.7. </span>Distributed Fractional Frequency Reuse<a class="headerlink" href="#distributed-fractional-frequency-reuse" title="Link to this heading">¶</a></h6>
<p>This Distributed Fractional Frequency Reuse Algorithm was presented in <a class="reference internal" href="index.html#dkimura2012" id="id138"><span>[DKimura2012]</span></a>. It
automatically optimizes cell-edge sub-bands by focusing on user distribution (in particular,
receive-power distribution). This algorithm adaptively selects RBs for cell-edge sub-band on
basis of coordination information from adjacent cells and notifies the base stations of the
adjacent cells, which RBs it selected to use in edge sub-band. The base station of each cell
uses the received information and the following equation to compute cell-edge-band metric
<img class="math" src="_images/math/ec1a9f4c7cad7557d240f475cdb90cfcc7257ef6.png" alt="A_{k}"/> for each RB.</p>
<div class="math">
<p><img src="_images/math/fa64c1de97c2a781c925d68e9b7d642cc5589ef6.png" alt="A_{k} = \sum_{j\in J}w_{j}X_{j,k}"/></p>
</div><p>where <img class="math" src="_images/math/32c06f8c59d4bd3d13eedea7765a8a74a11f2383.png" alt="J"/> is a set of neighbor cells, <img class="math" src="_images/math/ef2e800870b7cf1e347e083a13a2489d40956934.png" alt="X_{j,k}=\{0,1\}"/> is the RNTP from the <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>-th
neighbor cell. It takes a value of 1 when the <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>-th RB in the <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>-th neighbor cell is used
as a cell-edge sub-band and 0 otherwise. The symbol <img class="math" src="_images/math/d37fde55cb34e8cc3c01da0df07c8409de8bcd9b.png" alt="w_{j}"/> denotes weight with respect to adjacent
cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>, that is, the number of users for which the difference between the power of the signal
received from the serving cell <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> and the power of the signal received from the adjacent cell <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>
is less than a threshold value (i.e., the number of users near the cell edge in the service cell). A large
received power difference means that cell-edge users in the <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>-th cell suffer strong interference
from the <img class="math" src="_images/math/e3fc28292267f066fee7718c64f4bbfece521f24.png" alt="j"/>-th cell.</p>
<p>The RB for which metric <img class="math" src="_images/math/ec1a9f4c7cad7557d240f475cdb90cfcc7257ef6.png" alt="A_{k}"/> is smallest is considered to be least affected by interference from
another cell. Serving cell selects a configured number of RBs as cell-edge sub-band in ascending order
of <img class="math" src="_images/math/ec1a9f4c7cad7557d240f475cdb90cfcc7257ef6.png" alt="A_{k}"/>. As a result, the RBs in which a small number of cell-edge users receive high
interference from adjacent base stations are selected.</p>
<p>The updated RNTP is then sent to all the neighbor cells. In order to avoid the meaningless oscillation
of cell-edge-band selection, a base station ignores an RNTP from another base station that has larger
cell ID than the base station.</p>
<p>Repeating this process across all cells enables the allocation of RBs to cell-edge areas to be optimized
over the system and to be adjusted with changes in user distribution.</p>
<p>Figure <a class="reference internal" href="#fig-lte-distributed-fractional-frequency-reuse-scheme"><span class="std std-ref">Sequence diagram of Distributed Frequency Reuse Scheme</span></a> below presents
sequence diagram of Distributed Fractional Frequency Reuse Scheme.</p>
<figure class="align-center" id="id202">
<span id="fig-lte-distributed-fractional-frequency-reuse-scheme"></span><a class="reference internal image-reference" href="_images/ffr-distributed-scheme.png"><img alt="_images/ffr-distributed-scheme.png" src="_images/ffr-distributed-scheme.png" style="width: 470.40000000000003px; height: 525.6px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence diagram of Distributed Frequency Reuse Scheme</span><a class="headerlink" href="#id202" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="carrier-aggregation">
<span id="sec-carrier-aggregation"></span><h4><span class="section-number">20.1.17. </span>Carrier Aggregation<a class="headerlink" href="#carrier-aggregation" title="Link to this heading">¶</a></h4>
<section id="id139">
<h5><span class="section-number">20.1.17.1. </span>Overview<a class="headerlink" href="#id139" title="Link to this heading">¶</a></h5>
<p>This section describes the ns-3 support for Carrier Aggregation.
The references in the standard are <a class="reference internal" href="index.html#ts36211" id="id140"><span>[TS36211]</span></a>, <a class="reference internal" href="index.html#ts36213" id="id141"><span>[TS36213]</span></a> and <a class="reference internal" href="index.html#ts36331" id="id142"><span>[TS36331]</span></a>.</p>
<p><strong>Note:</strong> Carrier Aggregation was introduced in release 3.27 and currently, only works in downlink.</p>
<p>3GPP standardizes, in release R10, the Carrier Aggregation (CA) technology.</p>
<p>This technology consists of the possibility, to aggregate radio resources belonging to
different carriers, in order to have more bandwidth available, and to achieve a higher
throughput. Carrier Aggregation as defined by 3GPP can be used with both TDD and FDD.
Since ns-3 only supports FDD LTE implementation, we will consider only this case in
this section. Each aggregated carrier is referred to as a component carrier, CC.
The component carrier can have a bandwidth of 1.4, 3, 5, 10, 15 or 20 MHz and a maximum
of five component carriers can be aggregated, hence the maximum aggregated bandwidth is
100 MHz. In FDD the number of aggregated carriers can be different in DL and UL. However,
the number of UL component carriers is always equal to or lower than the number of DL
component carriers. The individual component carriers can also be of different bandwidths.
When carrier aggregation is used there are a number of serving cells, one for each
component carrier. The coverage of the serving cells may differ, for example due to
that CCs on different frequency bands will experience different pathloss. The RRC
connection is only handled by one cell, the Primary serving cell, served by the
Primary component carrier (DL and UL PCC). It is also on the DL PCC that the UE
receives NAS information, such as security parameters.</p>
<p>3GPP defines three different CA bandwidth classes in releases 10 and 11 (where ATBC
is Aggregated Transmission Bandwidth Configuration):</p>
<p>Class A: ATBC <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> 100, maximum number of CC = 1</p>
<p>Class B: ATBC <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> 100, maximum number of CC = 2</p>
<p>Class C: 100 <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> ATBC <img class="math" src="_images/math/8a062baade83eb0aaa8c5b00f6fce6124847bd68.png" alt="\leq"/> 200, maximum number of CC = 2</p>
<p>Figure <a class="reference internal" href="#fig-lte-carrier-aggregation-impact"><span class="std std-ref">CA impact on different layers of LTE protocol stack (from 3gpp.org)</span></a> (from 3gpp.org) shows the main
impact of CA technology on the different layers of the LTE protocol stack.
Introduction of carrier aggregation influences mainly the MAC and new RRC messages
are introduced. In order to keep R8/R9 compatibility the protocol changes will be kept
to a minimum. Basically each component carrier is treated as an R8 carrier. However some
changes are required, such as new RRC messages in order to handle the secondary component
carrier (SCC), and MAC must be able to handle scheduling on a number of CCs. In the
following we describe the impact of the carrier aggregation implementation on the different
layers of the LTE protocol stack in ns-3.</p>
<figure class="align-center" id="id203">
<span id="fig-lte-carrier-aggregation-impact"></span><a class="reference internal image-reference" href="_images/carrier-aggregation-impact.png"><img alt="_images/carrier-aggregation-impact.png" src="_images/carrier-aggregation-impact.png" style="width: 453.6px; height: 345.6px;" /></a>
<figcaption>
<p><span class="caption-text">CA impact on different layers of LTE protocol stack (from 3gpp.org)</span><a class="headerlink" href="#id203" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="impact-on-rrc-layer">
<h6><span class="section-number">20.1.17.1.1. </span>Impact on RRC layer<a class="headerlink" href="#impact-on-rrc-layer" title="Link to this heading">¶</a></h6>
<p>The main impacts on the RRC layer are related to secondary carrier configuration and
measurements reporting. To enable these features we have enhanced the already existing
procedures for the RRC Connection Reconfiguration and UE RRC Measurements Model.</p>
<p>The carrier aggregation enabling procedure is shown in figure <a class="reference internal" href="#fig-ca-rrc-reconf"><span class="std std-ref">A schematic overview of the secondary carrier enabling procedure</span></a>.
As per 3GPP definition, the secondary cell is a cell, operating on a secondary frequency,
which may be configured once an RRC connection is established and which may be used to
provide additional radio resources. Hence, the procedure starts when the UE is in the
CONNECTED_NORMALLY state (see the RRC state machine description). This part of the procedure
is the same as in the previous architecture. In order to simplify the implementation,
the <cite>UE Capability Inquiry</cite> and <cite>UE Capability Information</cite> are not implemented. This
implies to assume that each UE can support the carrier aggregation, and any specific
configuration provided by the eNB to which is attached. The eNB RRC sends to the UE the
secondary carrier configuration parameters through the RRC Connection Reconfiguration
procedure. This procedure may be used for various purposes related to modifications of
the RRC connection, e.g. to establish, modify or release RBs, to perform handover, to
setup, modify or release measurements, to add, modify and release secondary cells (SCells).
At UE side, the RRC is extended to configure the lower layers, in such a way that the
SCell(s) are considered. Once the carriers are configured, the <cite>Reconfiguration Completed</cite>
message is sent back to the eNB RRC, informing the eNB RRC and CCM that the secondary
carriers have been properly configured. The RRC layer at both the UE and the eNB sides
is extended to allow measurement reporting for the secondary carriers. Finally, in order
to allow the procedures for configuration and measurement reporting, the RRC is enhanced
to support serialization and deserialization of RRC message structures that carry information
related to the secondary carriers, e.g., if the <code class="docutils literal notranslate"><span class="pre">RRCConnectionReconfiguration</span></code> message
includes <code class="docutils literal notranslate"><span class="pre">sCellToAddModList</span></code> structure, SCell addition or modification will be performed,
or, if it contains <code class="docutils literal notranslate"><span class="pre">measConfig</span></code> the measurement reporting will be configured. To allow
transmission of this information the following structures are implemented for the sCell:
<code class="docutils literal notranslate"><span class="pre">RadioResourceConfigCommonSCell</span></code>, <code class="docutils literal notranslate"><span class="pre">RadioResourceConfigDedicatedSCell</span></code> and
<code class="docutils literal notranslate"><span class="pre">PhysicalConfigDedicatedSCell</span></code> and <code class="docutils literal notranslate"><span class="pre">NonCriticalExtensionConfiguration</span></code>.
<code class="docutils literal notranslate"><span class="pre">RadioResourceConfigCommonSCell</span></code> and <code class="docutils literal notranslate"><span class="pre">RadioResourceConfigDedicatedSCell</span></code> are
used for SCell addition and modification (see TS 36.331, 5.3.10.3b).
<code class="docutils literal notranslate"><span class="pre">PhysicalConfigDedicatedSCell</span></code> is used for physical channel reconfiguration
(see TS 36.331, 5.3.10.6). Finally, <code class="docutils literal notranslate"><span class="pre">NonCriticalExtensionConfiguration</span></code> is used to
carry information of <code class="docutils literal notranslate"><span class="pre">sCellToAddModeList</span></code> and <code class="docutils literal notranslate"><span class="pre">sCellToReleaseList</span></code>,
which is a modified structure comparing to TS 36.331, 6.6.2, according to which these
are directly in the root of RRCConnectionReconfiguration message. Measurement
reporting is extended with <code class="docutils literal notranslate"><span class="pre">measResultSCell</span></code> structure to include RSRP and RSRQ
measurements for each configured SCell. However, the measurement report triggering
event A6 (neighbour becomes offset better than SCell) is not implemented yet.</p>
<figure class="align-center" id="id204">
<span id="fig-ca-rrc-reconf"></span><a class="reference internal image-reference" href="_images/ca-rrc-reconf.png"><img alt="_images/ca-rrc-reconf.png" src="_images/ca-rrc-reconf.png" style="width: 184.0px; height: 166.0px;" /></a>
<figcaption>
<p><span class="caption-text">A schematic overview of the secondary carrier enabling procedure</span><a class="headerlink" href="#id204" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Handover is possible between different component carriers on the same
eNB (i.e., intra-eNB handover from one frequency to another) and between
carriers on different eNB (i.e., inter-eNB).  One constraint for inter-eNB
handovers is that both eNB must have the same number of component carriers.</p>
</section>
<section id="impact-on-pdcp-layer">
<h6><span class="section-number">20.1.17.1.2. </span>Impact on PDCP layer<a class="headerlink" href="#impact-on-pdcp-layer" title="Link to this heading">¶</a></h6>
<p>There is no impact on PDCP layer.</p>
</section>
<section id="impact-on-rlc-layer">
<h6><span class="section-number">20.1.17.1.3. </span>Impact on RLC layer<a class="headerlink" href="#impact-on-rlc-layer" title="Link to this heading">¶</a></h6>
<p>The impact on the RLC layer is relatively small. There is some impact on configuration of
the buffer and the usage of SAP interfaces between RLC and MAC. Since the capacity of the
lower layers increases with the carrier aggregation it is necessary to accordingly adjust
the size of the RLC buffer. The impact on the implementation of the RLC layer is very small
thanks to the design choice that allows the CCM manager to serve the different RLC instances
through the <code class="docutils literal notranslate"><span class="pre">LteMacSapProvider</span> <span class="pre">interface</span></code>. Thanks to this design choice, the RLC is using
the same interface as in the earlier LTE module architecture, the <code class="docutils literal notranslate"><span class="pre">LteMacSapProvider</span></code>,
but the actual SAP provider in the new architecture is the CCM (some class that inherits
<code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>). The CCM acts as a proxy, it receives function calls
that are meant for the MAC, and forwards them to the MAC of the different component
carriers. Additionally, it uses the information of the UEs and the logical channels for
its own functionalities.</p>
</section>
<section id="impact-on-mac-layer">
<h6><span class="section-number">20.1.17.1.4. </span>Impact on MAC layer<a class="headerlink" href="#impact-on-mac-layer" title="Link to this heading">¶</a></h6>
<p>The impact on the MAC layer depends on the CA scheduling scheme in use. Two different
scheduling schemes are proposed in R10 and are shown in
figure <a class="reference internal" href="#fig-lte-carrier-aggregation-mac-impact"><span class="std std-ref">CA scheduling schemes (from 3gpp.org)</span></a>.</p>
<figure class="align-center" id="id205">
<span id="fig-lte-carrier-aggregation-mac-impact"></span><a class="reference internal image-reference" href="_images/carrier-aggregation-mac-impact.png"><img alt="_images/carrier-aggregation-mac-impact.png" src="_images/carrier-aggregation-mac-impact.png" style="width: 510.3px; height: 374.40000000000003px;" /></a>
<figcaption>
<p><span class="caption-text">CA scheduling schemes (from 3gpp.org)</span><a class="headerlink" href="#id205" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The CIF (Carrier Indicator Field) on PDCCH (represented by the red area) indicates
on which carrier the scheduled resource is located. In the following we describe both
the schemes:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>scheduling grant and resources on the same carrier. One PDCCH is supported per carrier.</p></li>
<li><p>cross-carrier scheduling: it is used to schedule resources on the secondary carrier
without PDCCH.</p></li>
</ol>
</div></blockquote>
<p>Current implementation covers only option 1, so there is no cross-carrier scheduling.
The MAC layer of the eNodeB has suffered minor changes and they are mainly related to
addition of component carrier information in message exchange between layers.</p>
</section>
<section id="impact-on-phy-layer">
<h6><span class="section-number">20.1.17.1.5. </span>Impact on PHY layer<a class="headerlink" href="#impact-on-phy-layer" title="Link to this heading">¶</a></h6>
<p>The impact on PHY layer is minor. There is an instance of PHY layer per each component
carrier and the SAP interface functions remain unchanged. As shown
in <a class="reference internal" href="#fig-lte-carrier-aggregation-mac-impact"><span class="std std-ref">CA scheduling schemes (from 3gpp.org)</span></a> the difference is that since there are
multiple PHY instances, there are also multiple instances of PDCCH, HARQ, ACK/NACK and
CSI per carrier. So, at the eNB PHY, the changes are related to the addition of the
component carrier id information, while at the UE PHY the information of the Component
Carrier is used for some functionalities that depend on the Component Carrier to which
the PHY instance belongs. For example, the UE PHY is extended to allow disabling of
the sounding reference signal (SRS) at the secondary carriers. This is necessary
because there is one UE PHY instance per component carrier, but according
to <a class="reference internal" href="#fig-lte-carrier-aggregation-mac-impact"><span class="std std-ref">CA scheduling schemes (from 3gpp.org)</span></a>, only a single carrier is used
and the uplink traffic is transmitted only over the primary carrier.</p>
</section>
</section>
<section id="code-structure-design">
<h5><span class="section-number">20.1.17.2. </span>Code Structure Design<a class="headerlink" href="#code-structure-design" title="Link to this heading">¶</a></h5>
<p>This section briefly introduces the software design and implementation of the
carrier aggregation functionality.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> are created by the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>
using the method <code class="docutils literal notranslate"><span class="pre">InstallSingleEnbDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">InstallSingleUeDevice</span></code>. These
functions are now extended to allow the carrier aggregation configuration. In the
following we explain the main differences comparing to the previous architecture.</p>
<p>Figure <a class="reference internal" href="#fig-lte-enb-net-device-changes"><span class="std std-ref">Changes in LteEnbNetDevice to support CA</span></a> shows the attributes and associations
of the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> that are affected by the implementation, or are created
in order to support the carrier aggregation functionality. Since <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code>
may have several component carriers, the attributes that were formerly part of
the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> and are carrier specific are migrated to the ComponentCarrier
class, e.g. physical layer configuration parameters. The attributes that are
specific for the eNB component carrier are migrated to <code class="docutils literal notranslate"><span class="pre">ComponentCarrierEnb</span></code>, e.g.
pointers to MAC, PHY, scheduler, fractional frequency reuse instances.
<code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> can contain pointers to several <code class="docutils literal notranslate"><span class="pre">ComponentCarrierEnb</span></code> instances.
This architecture allows that each CC may have its own configuration for PHY, MAC,
scheduling algorithm and franctional frequency reuse algorithm.  These attributes are
currently maintained also in the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> for backward compatibility purpose.
By default the <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> attributes are the same as the
primary carrier attributes.</p>
<figure class="align-center" id="id206">
<span id="fig-lte-enb-net-device-changes"></span><a class="reference internal image-reference" href="_images/ca-lte-enb-net-device-changes.png"><img alt="_images/ca-lte-enb-net-device-changes.png" src="_images/ca-lte-enb-net-device-changes.png" style="width: 1002.6px; height: 608.4px;" /></a>
<figcaption>
<p><span class="caption-text">Changes in <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code> to support CA</span><a class="headerlink" href="#id206" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#fig-lte-ue-net-device-changes"><span class="std std-ref">Changes in LteUeNetDevice to support CA</span></a> shows the attributes and associations
of <code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> that are affected by the carrier aggregation implementation.
Similarly, to the changes in <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code>, pointers that are specific to UE
component carrier are migrated to the <code class="docutils literal notranslate"><span class="pre">ComponentCarrierUe</span></code> class.
<code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> has maintained m_dlEarfcn for initial cell selection purposes.</p>
<figure class="align-center" id="id207">
<span id="fig-lte-ue-net-device-changes"></span><a class="reference internal image-reference" href="_images/ca-lte-ue-net-device-changes.png"><img alt="_images/ca-lte-ue-net-device-changes.png" src="_images/ca-lte-ue-net-device-changes.png" style="width: 809.1px; height: 342.90000000000003px;" /></a>
<figcaption>
<p><span class="caption-text">Changes in <code class="docutils literal notranslate"><span class="pre">LteUeNetDevice</span></code> to support CA</span><a class="headerlink" href="#id207" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="ca-impact-on-data-plane-of-enodeb">
<h6><span class="section-number">20.1.17.2.1. </span>CA impact on data plane of eNodeB<a class="headerlink" href="#ca-impact-on-data-plane-of-enodeb" title="Link to this heading">¶</a></h6>
<p>Figure <a class="reference internal" href="#fig-ca-enb-data-plane"><span class="std std-ref">eNB Data Plane Architecture</span></a> shows the class diagram of the data plane at
the eNB.</p>
<p>The main impact is the insertion of the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> class
in the middle of the LTE protocol stack. During the design phase it was
decided to keep the same SAP interfaces design that existed between MAC and RLC
in order to avoid unnecessary changes in these parts of protocol stack.
To achieve this the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> implements all functions
that were previously exposed by RLC to MAC through <code class="docutils literal notranslate"><span class="pre">LteMacSapUser</span></code> interface.
It also implements functions that were previously exposed by MAC to RLC through
the <code class="docutils literal notranslate"><span class="pre">LteMacSapProvider</span></code> interface. In this way, the carrier aggregation is
transparent to upper and lower layers. The only difference is that the MAC
instance sees now only one <code class="docutils literal notranslate"><span class="pre">LteMacSapUser</span></code>, whereas formerly it was seeing only
one <code class="docutils literal notranslate"><span class="pre">LteMacSapUser</span></code> per RLC instance.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> is responsible for the forwarding messages
in both directions. In the current implementation, a PDCP and a RLC instances are
activated each time a new data radio bearer is configured. The correspondence
between a new  data radio bearer and a RLC instance is one to one. In order to
maintain the same behavior, when a new logical channel is activated, the logical
channel configurations is propagated to each MAC layer object in “as is” fashion.</p>
<figure class="align-center" id="id208">
<span id="fig-ca-enb-data-plane"></span><img alt="_images/ca-enb-data-plane.png" src="_images/ca-enb-data-plane.png" />
<figcaption>
<p><span class="caption-text">eNB Data Plane Architecture</span><a class="headerlink" href="#id208" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#fig-ca-downlink-bsr"><span class="std std-ref">Sequence Diagram of downlink buffer status reporting (BSR) with CA</span></a> shows a sequence diagram of downlink buffer status
reporting with a carrier aggregation implementation of only one secondary carrier.
Each time that an RLC instance sends a buffer status report (BSR), the
<code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> propagates the BSR to the MAC instances.
The <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> may modify a BSR before sending it to the
MAC instances. This modification depends on the traffic split algorithm implemented
in CCM class that inherits <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>.</p>
<figure class="align-center" id="id209">
<span id="fig-ca-downlink-bsr"></span><img alt="_images/ca-downlink-bsr.png" src="_images/ca-downlink-bsr.png" />
<figcaption>
<p><span class="caption-text">Sequence Diagram of downlink buffer status reporting (BSR) with CA</span><a class="headerlink" href="#id209" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="ca-impact-on-control-plane-of-enodeb">
<h6><span class="section-number">20.1.17.2.2. </span>CA impact on control plane of eNodeB<a class="headerlink" href="#ca-impact-on-control-plane-of-enodeb" title="Link to this heading">¶</a></h6>
<p>Figure <a class="reference internal" href="#fig-ca-enb-ctrl-plane"><span class="std std-ref">eNB Control Plane Architecture</span></a> shows the class diagram of the control plane
at the eNB. During the design phase it was decided to maintain the same hooks as in
the former architecture. To do so, at each component carrier the PHY and the MAC are
directly associated to the RRC instance. However, the RRC instance is additionally
connected to the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>, which is responsible for enabling
and disabling the component carriers. When the simulation starts, the number of
component carrier is fixed, but only the primary carrier component is enabled.
Depending on the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> algorithm the other carrier
components could be activated or not.</p>
<figure class="align-center" id="id210">
<span id="fig-ca-enb-ctrl-plane"></span><img alt="_images/ca-enb-ctrl-plane.png" src="_images/ca-enb-ctrl-plane.png" />
<figcaption>
<p><span class="caption-text">eNB Control Plane Architecture</span><a class="headerlink" href="#id210" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#fig-ca-setup-radio-bearer"><span class="std std-ref">Sequence Diagram of Data Radio Bearer Setup</span></a> shows how the Radio Bearer are configured.</p>
<figure class="align-center" id="id211">
<span id="fig-ca-setup-radio-bearer"></span><a class="reference internal image-reference" href="_images/ca-setup-radio-bearer.png"><img alt="_images/ca-setup-radio-bearer.png" src="_images/ca-setup-radio-bearer.png" style="width: 921.6px; height: 844.2px;" /></a>
<figcaption>
<p><span class="caption-text">Sequence Diagram of Data Radio Bearer Setup</span><a class="headerlink" href="#id211" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="ca-impact-on-data-plane-of-ue">
<h6><span class="section-number">20.1.17.2.3. </span>CA impact on data plane of UE<a class="headerlink" href="#ca-impact-on-data-plane-of-ue" title="Link to this heading">¶</a></h6>
<p>Figure <a class="reference internal" href="#fig-ca-ue-data-plane"><span class="std std-ref">UE Data Plane Architecture</span></a> shows the relation between the different classes
related to the UE data plane. The UE data plane architecture is similar to the eNB data
plane implementation. The <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code> is responsible to (re)map
each <code class="docutils literal notranslate"><span class="pre">MacSapUserProvider</span></code> to the corresponding RLC instance or to the proper MAC
instance. The channel remapping depends on algorithm used as <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code>.
A particular case is represented by the UE buffer status report (BSR) to eNB.
Since, i) the standard does not specify how the BSR has to be reported on each component
carrier and ii) it is decided to map one-to-one the logical channel to each MAC layer,
the only way to send BSRs to the eNB is through the primary carrier.
Figure <a class="reference internal" href="#fig-ca-uplink-bsr"><span class="std std-ref">Uplink buffer status reporting with CA</span></a> shows the sequence diagram.
Each time a BSR is generated, the <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code> sends it through
the primary carrier component. When the primary component carrier at the eNB receives
the BSR, it sends it to <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code>. The latter, according to
algorithm dependent policies, forwards a BSR to component carriers. The communication
between the <code class="docutils literal notranslate"><span class="pre">LteEnbMac</span></code> and  the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierManager</span></code> is done through a
specific set of SAP functions which are implemented in the <code class="docutils literal notranslate"><span class="pre">LteUlCcmRrcSapUser</span></code> and
the <code class="docutils literal notranslate"><span class="pre">LteUlCcmRrcSapProvider</span></code>.</p>
<figure class="align-center" id="id212">
<span id="fig-ca-ue-data-plane"></span><a class="reference internal image-reference" href="_images/ca-ue-data-plane.png"><img alt="_images/ca-ue-data-plane.png" src="_images/ca-ue-data-plane.png" style="width: 297.0px; height: 438.59999999999997px;" /></a>
<figcaption>
<p><span class="caption-text">UE Data Plane Architecture</span><a class="headerlink" href="#id212" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id213">
<span id="fig-ca-uplink-bsr"></span><img alt="_images/ca-uplink-bsr.png" src="_images/ca-uplink-bsr.png" />
<figcaption>
<p><span class="caption-text">Uplink buffer status reporting with CA</span><a class="headerlink" href="#id213" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="ca-impact-on-control-plane-of-ue">
<h6><span class="section-number">20.1.17.2.4. </span>CA impact on control plane of UE<a class="headerlink" href="#ca-impact-on-control-plane-of-ue" title="Link to this heading">¶</a></h6>
<p>Figure <a class="reference internal" href="#fig-ca-ue-ctrl-plane"><span class="std std-ref">UE Control Plane Architecture</span></a> shows the relation between the different classes
associated to the UE control plane. The control plane implementation at the UE is basically
the same as the eNB control plane implementation. Each component carrier control SAP
(both for PHY and MAC layer objects) is linked in a one-to-one fashion directly to the RRC
instance. The Ue RRC instance is then connected to the <code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierManager</span></code>
in the same way as in the eNB.</p>
<figure class="align-center" id="id214">
<span id="fig-ca-ue-ctrl-plane"></span><a class="reference internal image-reference" href="_images/ca-ue-ctrl-plane.png"><img alt="_images/ca-ue-ctrl-plane.png" src="_images/ca-ue-ctrl-plane.png" style="width: 870.3000000000001px; height: 416.7px;" /></a>
<figcaption>
<p><span class="caption-text">UE Control Plane Architecture</span><a class="headerlink" href="#id214" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><code class="docutils literal notranslate"><span class="pre">CCHelper</span></code> is the class that is implemented to help the configuration of the physical
layer parameters, such as uplink and downlink,bandwidth and EARFCN of each carrier.</p>
</section>
<section id="ccm-rrc-mac-interfaces">
<h6><span class="section-number">20.1.17.2.5. </span>CCM RRC MAC interfaces<a class="headerlink" href="#ccm-rrc-mac-interfaces" title="Link to this heading">¶</a></h6>
<p>The Component carrier manager (CCM) is also developed by using the SAP interface design.
The following SAP interfaces are implemented for CCM and MAC:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapUser</span></code> part is provided by MAC and is used by the CCM</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapProvider</span></code> part is provided by CCM and is used by the MAC layer</p></li>
</ul>
</div></blockquote>
<p>When the primary component carrier receives an uplink BSR it uses the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapUser</span></code>
to forward it to the CCM, which should decide how to split the traffic corresponding to
this BSR among carriers. Once this decision is made, the CCM uses the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapProvider</span></code>
interface to send back an uplink BSR to some of the MAC instances. Additionally,
the <code class="docutils literal notranslate"><span class="pre">LteCcmMacSapUser</span></code> can be used by the MAC to notify about the PRB occupancy
in the downlink to the CCM. This information may be used by the CCM to decide how
to split the traffic and whether to use the secondary carriers.</p>
</div></blockquote>
</section>
<section id="ccm-rrc-sap-interfaces">
<h6><span class="section-number">20.1.17.2.6. </span>CCM RRC SAP interfaces<a class="headerlink" href="#ccm-rrc-sap-interfaces" title="Link to this heading">¶</a></h6>
<p>The following SAP interfaces are implemented for CCM and RRC:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapProvider</span></code> is provided by the CCM and is used by the RRC layer</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapUser</span></code> is provided by RRC and is used by the CCM</p></li>
</ul>
</div></blockquote>
<p>By using the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapUser</span></code> the CCM may request a specific measurement reporting
configuration to be fulfilled by the UEs attached to the eNB. When a UE measurement
report is received, as a result of this configuration, the eNB RRC entity shall forward
this report to the CCM through the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapProvider::ReportUeMeas</span></code> SAP function.
Additionally, the <code class="docutils literal notranslate"><span class="pre">LteCcmRrcSapProvider</span></code> offers different functions to the RRC that can
be used to add and remove of UEs, setup or release of radio bearer, configuration of the
signalling bearer, etc.</p>
</section>
<section id="component-carrier-managers">
<h6><span class="section-number">20.1.17.2.7. </span>Component carrier managers<a class="headerlink" href="#component-carrier-managers" title="Link to this heading">¶</a></h6>
<p>Currently, there are two component carrier manager implementations available. The first one
is the <code class="docutils literal notranslate"><span class="pre">NoOpComponentCarrierManager</span></code>, which  is the default CCM choice. When this CCM is
used the carrier aggregation feature is disabled. This CCM forwards all traffic, the uplink
and the downlink, over
the primary carrier, and does not use secondary carriers.
Another implementation is the <code class="docutils literal notranslate"><span class="pre">RrComponentCarrierManager</span></code>, which splits the traffic
equally among carriers, by diving the buffer status report among different carriers.
SRB0 and SRB1 flows will be forwarded only over primary carrier.</p>
</section>
</section>
</section>
<section id="helpers">
<h4><span class="section-number">20.1.18. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p>Two helper objects are used to setup simulations and configure the
various components. These objects are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>, which takes care of the configuration of the LTE radio access network,
as well as of coordinating the setup and release of EPS bearers. The <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> class
provides both the API definition and its implementation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code>, which takes care of the configuration of the Evolved Packet Core. The
<code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> class is an abstract base class, which only provides the API definition;
the implementation is delegated to the child classes in order to allow for different
EPC network models.</p></li>
</ul>
</div></blockquote>
<p>A third helper object is used to configure the <a class="reference internal" href="#sec-carrier-aggregation"><span class="std std-ref">Carrier Aggregation</span></a> functionality:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CcHelper</span></code>, which takes care of the configuration of the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierMap</span></code>,
basically, it creates a user specified number of <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrier</span></code>.
<code class="docutils literal notranslate"><span class="pre">LteUeComponentCarrierMap</span></code> is currently created starting from the
<code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierMap</span></code>. <code class="docutils literal notranslate"><span class="pre">LteHelper:InstallSingleUeDevice</span></code>,
in this implementation, is needed to invoke after the <code class="docutils literal notranslate"><span class="pre">LteHelper:InstallSingleEnbDevice</span></code>
to ensure that the <code class="docutils literal notranslate"><span class="pre">LteEnbComponentCarrierMap</span></code> is properly initialized.</p></li>
</ul>
</div></blockquote>
<p>It is possible to create a simple LTE-only simulations by
using the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> alone, or to create complete LTE-EPC simulations by using both
<code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code>. When both helpers are used, they interact in a master-slave
fashion, with the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> being the Master that interacts directly with the user program,
and the <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> working “under the hood” to configure the EPC upon explicit methods
called by the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>. The exact interactions are displayed in the Figure <a class="reference internal" href="#fig-helpers"><span class="std std-ref">Sequence diagram of the interaction between LteHelper and EpcHelper.</span></a>.</p>
<figure class="align-center" id="id215">
<span id="fig-helpers"></span><img alt="_images/helpers.png" src="_images/helpers.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram of the interaction between <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code>.</span><a class="headerlink" href="#id215" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<span id="document-lte-user"></span><section id="user-documentation">
<h3><span class="section-number">20.2. </span>User Documentation<a class="headerlink" href="#user-documentation" title="Link to this heading">¶</a></h3>
<section id="background">
<h4><span class="section-number">20.2.1. </span>Background<a class="headerlink" href="#background" title="Link to this heading">¶</a></h4>
<p>We assume the reader is already familiar with how to use the ns-3
simulator to run generic simulation programs. If this is not the case,
we strongly recommend the reader to consult <a class="reference internal" href="index.html#ns3tutorial" id="id1"><span>[ns3tutorial]</span></a>.</p>
</section>
<section id="usage-overview">
<h4><span class="section-number">20.2.2. </span>Usage Overview<a class="headerlink" href="#usage-overview" title="Link to this heading">¶</a></h4>
<p>The ns-3 LTE model is a software library that allows the simulation of
LTE networks, optionally including the Evolved Packet Core (EPC).  The
process of performing such simulations typically involves the
following steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><em>Define the scenario</em> to be simulated</p></li>
<li><p><em>Write a simulation program</em> that recreates the desired scenario
topology/architecture. This is done accessing the ns-3 LTE model
library using the <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper</span></code> API defined in <code class="docutils literal notranslate"><span class="pre">src/lte/helper/lte-helper.h</span></code>.</p></li>
<li><p><em>Specify configuration parameters</em> of the objects that are being
used for the simulation. This can be done using input files (via the
<code class="docutils literal notranslate"><span class="pre">ns3::ConfigStore</span></code>) or directly within the simulation program.</p></li>
<li><p><em>Configure the desired output</em> to be produced by the simulator</p></li>
<li><p><em>Run</em> the simulation.</p></li>
</ol>
</div></blockquote>
<p>All these aspects will be explained in the following sections by means
of practical examples.</p>
</section>
<section id="basic-simulation-program">
<span id="sec-basic-simulation-program"></span><h4><span class="section-number">20.2.3. </span>Basic simulation program<a class="headerlink" href="#basic-simulation-program" title="Link to this heading">¶</a></h4>
<p>Here is the minimal simulation program that is needed to do an LTE-only simulation (without EPC).</p>
<ol class="arabic">
<li><p>Initial boilerplate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;ns3/core-module.h&gt;
#include &lt;ns3/network-module.h&gt;
#include &lt;ns3/mobility-module.h&gt;
#include &lt;ns3/lte-module.h&gt;

using namespace ns3;

int main(int argc, char *argv[])
{
  // the rest of the simulation program follows
</pre></div>
</div>
</li>
<li><p>Create an <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
</pre></div>
</div>
<p>This will instantiate some common
objects (e.g., the Channel object) and provide the methods to add
eNBs and UEs and configure them.</p>
</li>
<li><p>Create <code class="docutils literal notranslate"><span class="pre">Node</span></code> objects for the eNB(s) and the UEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NodeContainer enbNodes;
enbNodes.Create(1);
NodeContainer ueNodes;
ueNodes.Create(2);
</pre></div>
</div>
<p>Note that the above Node instances at this point still don’t have
an LTE protocol stack installed; they’re just empty nodes.</p>
</li>
<li><p>Configure the Mobility model for all the nodes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MobilityHelper mobility;
mobility.SetMobilityModel(&quot;ns3::ConstantPositionMobilityModel&quot;);
mobility.Install(enbNodes);
mobility.SetMobilityModel(&quot;ns3::ConstantPositionMobilityModel&quot;);
mobility.Install(ueNodes);
</pre></div>
</div>
<p>The above will place all nodes at the coordinates (0,0,0). Please
refer to the documentation of the ns-3 mobility model for how to
set your own position or configure node movement.</p>
</li>
<li><p>Install an LTE protocol stack on the eNB(s):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer enbDevs;
enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes);
</pre></div>
</div>
</li>
<li><p>Install an LTE protocol stack on the UEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer ueDevs;
ueDevs = lteHelper-&gt;InstallUeDevice(ueNodes);
</pre></div>
</div>
</li>
<li><p>Attach the UEs to an eNB. This will configure each UE according to
the eNB configuration, and create an RRC connection between them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(ueDevs, enbDevs.Get(0));
</pre></div>
</div>
</li>
<li><p>Activate a data radio bearer between each UE and the eNB it is attached to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
EpsBearer bearer(q);
lteHelper-&gt;ActivateDataRadioBearer(ueDevs, bearer);
</pre></div>
</div>
<p>this method will also activate two saturation traffic generators for
that bearer, one in uplink and one in downlink.</p>
</li>
<li><p>Set the stop time:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Stop(Seconds(0.005));
</pre></div>
</div>
<p>This is needed otherwise the simulation will last forever, because
(among others) the start-of-subframe event is scheduled repeatedly, and the
ns-3 simulator scheduler will hence never run out of events.</p>
</li>
<li><p>Run the simulation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Run();
</pre></div>
</div>
</li>
<li><p>Cleanup and exit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Destroy();
return 0;
}
</pre></div>
</div>
</li>
</ol>
<p>For how to compile and run simulation programs, please refer to <a class="reference internal" href="index.html#ns3tutorial" id="id2"><span>[ns3tutorial]</span></a>.</p>
</section>
<section id="configuration-of-lte-model-parameters">
<h4><span class="section-number">20.2.4. </span>Configuration of LTE model parameters<a class="headerlink" href="#configuration-of-lte-model-parameters" title="Link to this heading">¶</a></h4>
<p>All the relevant LTE model parameters are managed through the ns-3
attribute system. Please refer to the <a class="reference internal" href="index.html#ns3tutorial" id="id3"><span>[ns3tutorial]</span></a> and <a class="reference internal" href="index.html#ns3manual" id="id4"><span>[ns3manual]</span></a>
for detailed information on all the possible methods to do it
(environmental variables, C++ API, GtkConfigStore…).</p>
<p>In the following, we just briefly summarize
how to do it using input files together with the ns-3 ConfigStore.
First of all, you need to put the following in your simulation
program, right after <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">()</span></code> starts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CommandLine cmd(__FILE__);
cmd.Parse(argc, argv);
ConfigStore inputConfig;
inputConfig.ConfigureDefaults();
// parse again so you can override default values from the command line
cmd.Parse(argc, argv);
</pre></div>
</div>
<p>for the above to work, make sure you also <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;ns3/config-store.h&quot;</span></code>.
Now create a text file named (for example) <code class="docutils literal notranslate"><span class="pre">input-defaults.txt</span></code>
specifying the new default values that you want to use for some attributes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default ns3::LteHelper::Scheduler &quot;ns3::PfFfMacScheduler&quot;
default ns3::LteHelper::PathlossModel &quot;ns3::FriisSpectrumPropagationLossModel&quot;
default ns3::LteEnbNetDevice::UlBandwidth &quot;25&quot;
default ns3::LteEnbNetDevice::DlBandwidth &quot;25&quot;
default ns3::LteEnbNetDevice::DlEarfcn &quot;100&quot;
default ns3::LteEnbNetDevice::UlEarfcn &quot;18100&quot;
default ns3::LteUePhy::TxPower &quot;10&quot;
default ns3::LteUePhy::NoiseFigure &quot;9&quot;
default ns3::LteEnbPhy::TxPower &quot;30&quot;
default ns3::LteEnbPhy::NoiseFigure &quot;5&quot;
</pre></div>
</div>
<p>Supposing your simulation program is called
<code class="docutils literal notranslate"><span class="pre">src/lte/examples/lte-sim-with-input</span></code>, you can now pass these
settings to the simulation program in the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run src/lte/examples/lte-sim-with-input
--command-template=&quot;%s --ns3::ConfigStore::Filename=input-defaults.txt
--ns3::ConfigStore::Mode=Load --ns3::ConfigStore::FileFormat=RawText&quot;
</pre></div>
</div>
<p>Furthermore, you can generate a template input file with the following
command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run src/lte/examples/lte-sim-with-input
--command-template=&quot;%s --ns3::ConfigStore::Filename=input-defaults.txt
--ns3::ConfigStore::Mode=Save --ns3::ConfigStore::FileFormat=RawText&quot;
</pre></div>
</div>
<p>note that the above will put in the file <code class="docutils literal notranslate"><span class="pre">input-defaults.txt</span></code> <em>all</em>
the default values that are registered in your particular build of the
simulator, including lots of non-LTE attributes.</p>
</section>
<section id="configure-lte-mac-scheduler">
<h4><span class="section-number">20.2.5. </span>Configure LTE MAC Scheduler<a class="headerlink" href="#configure-lte-mac-scheduler" title="Link to this heading">¶</a></h4>
<p>There are several types of LTE MAC scheduler user can choose here. User can use following codes to define scheduler type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetSchedulerType(&quot;ns3::FdMtFfMacScheduler&quot;);    // FD-MT scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TdMtFfMacScheduler&quot;);    // TD-MT scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TtaFfMacScheduler&quot;);     // TTA scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::FdBetFfMacScheduler&quot;);   // FD-BET scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TdBetFfMacScheduler&quot;);   // TD-BET scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::FdTbfqFfMacScheduler&quot;);  // FD-TBFQ scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::TdTbfqFfMacScheduler&quot;);  // TD-TBFQ scheduler
lteHelper-&gt;SetSchedulerType(&quot;ns3::PssFfMacScheduler&quot;);     //PSS scheduler
</pre></div>
</div>
<p>TBFQ and PSS have more parameters than other schedulers. Users can define those parameters in following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* TBFQ scheduler::

 Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
 lteHelper-&gt;SetSchedulerAttribute(&quot;DebtLimit&quot;, IntegerValue(yourvalue)); // default value -625000 bytes(-5Mb)
 lteHelper-&gt;SetSchedulerAttribute(&quot;CreditLimit&quot;, UintegerValue(yourvalue)); // default value 625000 bytes(5Mb)
 lteHelper-&gt;SetSchedulerAttribute(&quot;TokenPoolSize&quot;, UintegerValue(yourvalue)); // default value 1 byte
 lteHelper-&gt;SetSchedulerAttribute(&quot;CreditableThreshold&quot;, UintegerValue(yourvalue)); // default value 0

* PSS scheduler::

 Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
 lteHelper-&gt;SetSchedulerAttribute(&quot;nMux&quot;, UIntegerValue(yourvalue)); // the maximum number of UE selected by TD scheduler
 lteHelper-&gt;SetSchedulerAttribute(&quot;PssFdSchedulerType&quot;, StringValue(&quot;CoItA&quot;)); // PF scheduler type in PSS
</pre></div>
</div>
<p>In TBFQ, default values of debt limit and credit limit are set to -5Mb and 5Mb respectively based on paper <a class="reference internal" href="index.html#fabokhari2009" id="id5"><span>[FABokhari2009]</span></a>.
Current implementation does not consider credit threshold (<img class="math" src="_images/math/4db5b6e16e06f929ce3f675c5e535d06ffb02ff7.png" alt="C"/> = 0). In PSS, if user does not define nMux,
PSS will set this value to half of total UE. The default FD scheduler is PFsch.</p>
<p>In addition, token generation rate in TBFQ and target bit rate in PSS need to be configured by Guarantee Bit Rate (GBR) or
Maximum Bit Rate (MBR) in epc bearer QoS parameters. Users can use following codes to define GBR and MBR in both downlink and uplink:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
enum EpsBearer::Qci q = EpsBearer::yourvalue;  // define Qci type
GbrQosInformation qos;
qos.gbrDl = yourvalue; // Downlink GBR
qos.gbrUl = yourvalue; // Uplink GBR
qos.mbrDl = yourvalue; // Downlink MBR
qos.mbrUl = yourvalue; // Uplink MBR
EpsBearer bearer(q, qos);
lteHelper-&gt;ActivateDedicatedEpsBearer(ueDevs, bearer, EpcTft::Default());
</pre></div>
</div>
<p>In PSS, TBR is obtained from GBR in bearer level QoS parameters. In TBFQ, token generation rate is obtained from the MBR
setting in bearer level QoS parameters, which therefore needs to be configured consistently.
For constant bit rate (CBR) traffic, it is suggested to set MBR to GBR. For variance bit rate (VBR) traffic,
it is suggested to set MBR k times larger than GBR in order to cover the peak traffic rate. In current implementation, k is set to
three based on paper <a class="reference internal" href="index.html#fabokhari2009" id="id6"><span>[FABokhari2009]</span></a>. In addition, current version of TBFQ does not consider RLC header and PDCP header length in
MBR and GBR. Another parameter in TBFQ is packet arrival rate. This parameter is calculated within scheduler and equals to the past
average throughput which is used in PF scheduler.</p>
<p>Many useful attributes of the LTE-EPC model will be described in the
following subsections. Still, there are many attributes which are not
explicitly mentioned in the design or user documentation, but which
are clearly documented using the ns-3 attribute system. You can easily
print a list of the attributes of a given object together with their
description and default value passing <code class="docutils literal notranslate"><span class="pre">--PrintAttributes=</span></code> to a simulation
program, like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteHelper&quot;
</pre></div>
</div>
<p>You can try also with other LTE and EPC objects, like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteEnbNetDevice&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteEnbMac&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteEnbPhy&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::LteUePhy&quot;
./ns3 run lena-simple --command-template=&quot;%s --PrintAttributes=ns3::PointToPointEpcHelper&quot;
</pre></div>
</div>
</section>
<section id="simulation-output">
<span id="sec-simulation-output"></span><h4><span class="section-number">20.2.6. </span>Simulation Output<a class="headerlink" href="#simulation-output" title="Link to this heading">¶</a></h4>
<p>The ns-3 LTE model currently supports the output to file of PHY, MAC, RLC
and PDCP level Key Performance Indicators (KPIs). You can enable it in
the following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();

// configure all the simulation scenario here...

lteHelper-&gt;EnablePhyTraces();
lteHelper-&gt;EnableMacTraces();
lteHelper-&gt;EnableRlcTraces();
lteHelper-&gt;EnablePdcpTraces();

Simulator::Run();
</pre></div>
</div>
<p>RLC and PDCP KPIs are calculated over a time interval and stored on ASCII
files, two for RLC KPIs and two for PDCP KPIs, in each case one for
uplink and one for downlink. The time interval duration can be controlled using the attribute
<code class="docutils literal notranslate"><span class="pre">ns3::RadioBearerStatsCalculator::EpochDuration</span></code>.</p>
<p>The columns of the RLC KPI files is the following (the same
for uplink and downlink):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>start time of measurement interval in seconds since the start of simulation</p></li>
<li><p>end time of measurement interval in seconds since the start of simulation</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>Logical Channel ID</p></li>
<li><p>Number of transmitted RLC PDUs</p></li>
<li><p>Total bytes transmitted.</p></li>
<li><p>Number of received RLC PDUs</p></li>
<li><p>Total bytes received</p></li>
<li><p>Average RLC PDU delay in seconds</p></li>
<li><p>Standard deviation of the RLC PDU delay</p></li>
<li><p>Minimum value of the RLC PDU delay</p></li>
<li><p>Maximum value of the RLC PDU delay</p></li>
<li><p>Average RLC PDU size, in bytes</p></li>
<li><p>Standard deviation of the RLC PDU size</p></li>
<li><p>Minimum RLC PDU size</p></li>
<li><p>Maximum RLC PDU size</p></li>
</ol>
</div></blockquote>
<p>Similarly, the columns of the PDCP KPI files is the following (again, the same
for uplink and downlink):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>start time of measurement interval in seconds since the start of simulation</p></li>
<li><p>end time of measurement interval in seconds since the start of simulation</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>Logical Channel ID</p></li>
<li><p>Number of transmitted PDCP PDUs</p></li>
<li><p>Total bytes transmitted.</p></li>
<li><p>Number of received PDCP PDUs</p></li>
<li><p>Total bytes received</p></li>
<li><p>Average PDCP PDU delay in seconds</p></li>
<li><p>Standard deviation of the PDCP PDU delay</p></li>
<li><p>Minimum value of the PDCP PDU delay</p></li>
<li><p>Maximum value of the PDCP PDU delay</p></li>
<li><p>Average PDCP PDU size, in bytes</p></li>
<li><p>Standard deviation of the PDCP PDU size</p></li>
<li><p>Minimum PDCP PDU size</p></li>
<li><p>Maximum PDCP PDU size</p></li>
</ol>
</div></blockquote>
<p><strong>Note:</strong> The PDCP traces for data radio bearers are not generated when
<a class="reference internal" href="index.html#sec-sm-rlc"><span class="std std-ref">SM RLC</span></a> is used.</p>
<p>MAC KPIs are basically a trace of the resource allocation reported by
the scheduler upon the start of every subframe. They are stored in
ASCII files. For downlink MAC KPIs the format is the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>Frame number</p></li>
<li><p>Subframe number</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>MCS of TB 1</p></li>
<li><p>size of TB 1</p></li>
<li><p>MCS of TB 2 (0 if not present)</p></li>
<li><p>size of TB 2 (0 if not present)</p></li>
</ol>
</div></blockquote>
<p>while for uplink MAC KPIs the format is:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>Frame number</p></li>
<li><p>Subframe number</p></li>
<li><p>cell-specific UE ID (RNTI)</p></li>
<li><p>MCS of TB</p></li>
<li><p>size of TB</p></li>
</ol>
</div></blockquote>
<p>The names of the files used for MAC KPI output can be customized via
the ns-3 attributes <code class="docutils literal notranslate"><span class="pre">ns3::MacStatsCalculator::DlOutputFilename</span></code> and
<code class="docutils literal notranslate"><span class="pre">ns3::MacStatsCalculator::UlOutputFilename</span></code>.</p>
<p>PHY KPIs are distributed in seven different files, configurable through the attributes</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::DlRsrpSinrFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::UeSinrFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::InterferenceFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::DlTxOutputFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::UlTxOutputFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::DlRxOutputFilename</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::PhyStatsCalculator::UlRxOutputFilename</span></code></p></li>
</ol>
</div></blockquote>
<p>In the RSRP/SINR file, the following content is available:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>RSRP</p></li>
<li><p>Linear average over all RBs of the downlink SINR in linear units</p></li>
</ol>
</div></blockquote>
<p>The contents in the UE SINR file are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>uplink SINR in linear units for the UE</p></li>
</ol>
</div></blockquote>
<p>In the interference filename the content is:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in seconds at which the allocation is indicated by the scheduler</p></li>
<li><p>Cell ID</p></li>
<li><p>List of interference values per RB</p></li>
</ol>
</div></blockquote>
<p>In UL and DL transmission files the parameters included are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in milliseconds</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>RNTI</p></li>
<li><p>Layer of transmission</p></li>
<li><p>MCS</p></li>
<li><p>size of the TB</p></li>
<li><p>Redundancy version</p></li>
<li><p>New Data Indicator flag</p></li>
</ol>
</div></blockquote>
<p>And finally, in UL and DL reception files the parameters included are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Simulation time in milliseconds</p></li>
<li><p>Cell ID</p></li>
<li><p>unique UE ID (IMSI)</p></li>
<li><p>RNTI</p></li>
<li><p>Transmission Mode</p></li>
<li><p>Layer of transmission</p></li>
<li><p>MCS</p></li>
<li><p>size of the TB</p></li>
<li><p>Redundancy version</p></li>
<li><p>New Data Indicator flag</p></li>
<li><p>Correctness in the reception of the TB</p></li>
</ol>
</div></blockquote>
<p><strong>Note:</strong> The traces generated by simulating the scenarios involving the RLF
will have a discontinuity in time from the moment of the RLF event until the UE
connects again to an eNB.</p>
</section>
<section id="fading-trace-usage">
<h4><span class="section-number">20.2.7. </span>Fading Trace Usage<a class="headerlink" href="#fading-trace-usage" title="Link to this heading">¶</a></h4>
<p>In this section we will describe how to use fading traces within LTE simulations.</p>
<section id="fading-traces-generation">
<h5><span class="section-number">20.2.7.1. </span>Fading Traces Generation<a class="headerlink" href="#fading-traces-generation" title="Link to this heading">¶</a></h5>
<p>It is possible to generate fading traces by using a dedicated matlab script provided with the code (<code class="docutils literal notranslate"><span class="pre">/lte/model/fading-traces/fading-trace-generator.m</span></code>). This script already includes the typical taps configurations for three 3GPP scenarios (i.e., pedestrian, vehicular and urban as defined in Annex B.2 of <a class="reference internal" href="index.html#ts36104" id="id7"><span>[TS36104]</span></a>); however users can also introduce their specific configurations. The list of the configurable parameters is provided in the following:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fc</span></code> : the frequency in use (it affects the computation of the doppler speed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v_km_h</span></code> : the speed of the users</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">traceDuration</span></code> : the duration in seconds of the total length of the trace.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numRBs</span></code> : the number of the resource block to be evaluated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tag</span></code> : the tag to be applied to the file generated.</p></li>
</ul>
</div></blockquote>
<p>The file generated contains ASCII-formatted real values organized in a matrix fashion: every row corresponds to a different RB, and every column correspond to a different temporal fading trace sample.</p>
<p>It has to be noted that the ns-3 LTE module is able to work with any fading trace file that complies with the above described ASCII format. Hence, other external tools can be used to generate custom fading traces, such as for example other simulators or experimental devices.</p>
</section>
<section id="fading-traces-usage">
<h5><span class="section-number">20.2.7.2. </span>Fading Traces Usage<a class="headerlink" href="#fading-traces-usage" title="Link to this heading">¶</a></h5>
<p>When using a fading trace, it is of paramount importance to specify correctly the trace parameters in the simulation, so that the fading model can load and use it correctly.
The parameters to be configured are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TraceFilename</span></code> : the name of the trace to be loaded (absolute path, or relative path w.r.t. the path from where the simulation program is executed);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TraceLength</span></code> : the trace duration in seconds;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SamplesNum</span></code> : the number of samples;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WindowSize</span></code> : the size of the fading sampling window in seconds;</p></li>
</ul>
</div></blockquote>
<p>It is important to highlight that the sampling interval of the fading trace has to be 1 ms or greater, and in the latter case it has to be an integer multiple of 1 ms in order to be correctly processed by the fading module.</p>
<p>The default configuration of the matlab script provides a trace 10 seconds long, made of 10,000 samples (i.e., 1 sample per TTI=1ms) and used with a windows size of 0.5 seconds amplitude. These are also the default values of the parameters above used in the simulator; therefore their settage can be avoided in case the fading trace respects them.</p>
<p>In order to activate the fading module (which is not active by default) the following code should be included in the simulation program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetFadingModel(&quot;ns3::TraceFadingLossModel&quot;);
</pre></div>
</div>
<p>And for setting the parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFadingModelAttribute(&quot;TraceFilename&quot;, StringValue(&quot;src/lte/model/fading-traces/fading_trace_EPA_3kmph.fad&quot;));
lteHelper-&gt;SetFadingModelAttribute(&quot;TraceLength&quot;, TimeValue(Seconds(10.0)));
lteHelper-&gt;SetFadingModelAttribute(&quot;SamplesNum&quot;, UintegerValue(10000));
lteHelper-&gt;SetFadingModelAttribute(&quot;WindowSize&quot;, TimeValue(Seconds(0.5)));
lteHelper-&gt;SetFadingModelAttribute(&quot;RbNum&quot;, UintegerValue(100));
</pre></div>
</div>
<p>It has to be noted that, <code class="docutils literal notranslate"><span class="pre">TraceFilename</span></code> does not have a default value, therefore is has to be always set explicitly.</p>
<p>The simulator provide natively three fading traces generated according to the configurations defined in in Annex B.2 of <a class="reference internal" href="index.html#ts36104" id="id8"><span>[TS36104]</span></a>. These traces are available in the folder <code class="docutils literal notranslate"><span class="pre">src/lte/model/fading-traces/</span></code>). An excerpt from these traces is represented in the following figures.</p>
<figure class="align-center" id="id16">
<span id="fig-fadingpedestriantrace"></span><img alt="Fading trace 3 kmph" src="_images/fading_pedestrian.png" />
<figcaption>
<p><span class="caption-text">Excerpt of the fading trace included in the simulator for a pedestrian scenario (speed of 3 kmph).</span><a class="headerlink" href="#id16" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id17">
<span id="fig-fadingvehiculartrace"></span><img alt="Fading trace 60 kmph" src="_images/fading_vehicular.png" />
<figcaption>
<p><span class="caption-text">Excerpt of the fading trace included in the simulator for a vehicular  scenario (speed of 60 kmph).</span><a class="headerlink" href="#id17" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id18">
<span id="fig-fadingurbantrace"></span><img alt="Fading trace 3 kmph" src="_images/fading_urban_3kmph.png" />
<figcaption>
<p><span class="caption-text">Excerpt of the fading trace included in the simulator for an urban  scenario (speed of 3 kmph).</span><a class="headerlink" href="#id18" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="mobility-model-with-buildings">
<h4><span class="section-number">20.2.8. </span>Mobility Model with Buildings<a class="headerlink" href="#mobility-model-with-buildings" title="Link to this heading">¶</a></h4>
<p>We now explain by examples how to use the buildings model (in particular, the <code class="docutils literal notranslate"><span class="pre">MobilityBuildingInfo</span></code> and the <code class="docutils literal notranslate"><span class="pre">BuildingPropagationModel</span></code> classes) in an ns-3 simulation program to setup an LTE simulation scenario that includes buildings and indoor nodes.</p>
<ol class="arabic">
<li><p>Header files to be included:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;ns3/mobility-building-info.h&gt;
#include &lt;ns3/buildings-propagation-loss-model.h&gt;
#include &lt;ns3/building.h&gt;
</pre></div>
</div>
</li>
<li><p>Pathloss model selection:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();

lteHelper-&gt;SetAttribute(&quot;PathlossModel&quot;, StringValue(&quot;ns3::BuildingsPropagationLossModel&quot;));
</pre></div>
</div>
</li>
<li><p>EUTRA Band Selection</p></li>
</ol>
<p>The selection of the working frequency of the propagation model has to be done with the standard ns-3 attribute system as described in the correspond section (“Configuration of LTE model parameters”) by means of the DlEarfcn and UlEarfcn parameters, for instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEnbDeviceAttribute(&quot;DlEarfcn&quot;, UintegerValue(100));
lteHelper-&gt;SetEnbDeviceAttribute(&quot;UlEarfcn&quot;, UintegerValue(18100));
</pre></div>
</div>
<p>It is to be noted that using other means to configure the frequency used by the propagation model (i.e., configuring the corresponding BuildingsPropagationLossModel attributes directly) might generates conflicts in the frequencies definition in the modules during the simulation, and is therefore not advised.</p>
<ol class="arabic">
<li><p>Mobility model selection:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MobilityHelper mobility;
mobility.SetMobilityModel(&quot;ns3::ConstantPositionMobilityModel&quot;);

It is to be noted that any mobility model can be used.
</pre></div>
</div>
</li>
<li><p>Building creation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double x_min = 0.0;
double x_max = 10.0;
double y_min = 0.0;
double y_max = 20.0;
double z_min = 0.0;
double z_max = 10.0;
Ptr&lt;Building&gt; b = CreateObject&lt;Building&gt;();
b-&gt;SetBoundaries(Box(x_min, x_max, y_min, y_max, z_min, z_max));
b-&gt;SetBuildingType(Building::Residential);
b-&gt;SetExtWallsType(Building::ConcreteWithWindows);
b-&gt;SetNFloors(3);
b-&gt;SetNRoomsX(3);
b-&gt;SetNRoomsY(2);
</pre></div>
</div>
<p>This will instantiate a residential building with base of 10 x 20 meters and height of 10 meters whose external walls are of concrete with windows; the building has three floors and has an internal 3 x 2  grid of rooms of equal size.</p>
</li>
<li><p>Node creation and positioning:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ueNodes.Create(2);
mobility.Install(ueNodes);
BuildingsHelper::Install(ueNodes);
NetDeviceContainer ueDevs;
ueDevs = lteHelper-&gt;InstallUeDevice(ueNodes);
Ptr&lt;ConstantPositionMobilityModel&gt; mm0 = enbNodes.Get(0)-&gt;GetObject&lt;ConstantPositionMobilityModel&gt;();
Ptr&lt;ConstantPositionMobilityModel&gt; mm1 = enbNodes.Get(1)-&gt;GetObject&lt;ConstantPositionMobilityModel&gt;();
mm0-&gt;SetPosition(Vector(5.0, 5.0, 1.5));
mm1-&gt;SetPosition(Vector(30.0, 40.0, 1.5));
</pre></div>
</div>
</li>
<li><p>Finalize the building and mobility model configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BuildingsHelper::MakeMobilityModelConsistent();
</pre></div>
</div>
</li>
</ol>
<p>See the documentation of the <em>buildings</em> module for more detailed information.</p>
</section>
<section id="phy-error-model">
<h4><span class="section-number">20.2.9. </span>PHY Error Model<a class="headerlink" href="#phy-error-model" title="Link to this heading">¶</a></h4>
<p>The Physical error model consists of the data error model and the downlink control error model, both of them active by default. It is possible to deactivate them with the ns3 attribute system, in detail:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteSpectrumPhy::CtrlErrorModelEnabled&quot;, BooleanValue(false));
Config::SetDefault(&quot;ns3::LteSpectrumPhy::DataErrorModelEnabled&quot;, BooleanValue(false));
</pre></div>
</div>
</section>
<section id="mimo-model">
<h4><span class="section-number">20.2.10. </span>MIMO Model<a class="headerlink" href="#mimo-model" title="Link to this heading">¶</a></h4>
<p>Is this subsection we illustrate how to configure the MIMO parameters. LTE defines 7 types of transmission modes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Transmission Mode 1: SISO.</p></li>
<li><p>Transmission Mode 2: MIMO Tx Diversity.</p></li>
<li><p>Transmission Mode 3: MIMO Spatial Multiplexity Open Loop.</p></li>
<li><p>Transmission Mode 4: MIMO Spatial Multiplexity Closed Loop.</p></li>
<li><p>Transmission Mode 5: MIMO Multi-User.</p></li>
<li><p>Transmission Mode 6: Closer loop single layer precoding.</p></li>
<li><p>Transmission Mode 7: Single antenna port 5.</p></li>
</ul>
</div></blockquote>
<p>According to model implemented, the simulator includes the first three transmission modes types. The default one is the Transmission Mode 1 (SISO). In order to change the default Transmission Mode to be used, the attribute <code class="docutils literal notranslate"><span class="pre">DefaultTransmissionMode</span></code> of the <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> can be used, as shown in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteEnbRrc::DefaultTransmissionMode&quot;, UintegerValue(0)); // SISO
Config::SetDefault(&quot;ns3::LteEnbRrc::DefaultTransmissionMode&quot;, UintegerValue(1)); // MIMO Tx diversity(1 layer)
Config::SetDefault(&quot;ns3::LteEnbRrc::DefaultTransmissionMode&quot;, UintegerValue(2)); // MIMO Spatial Multiplexity(2 layers)
</pre></div>
</div>
<p>For changing the transmission mode of a certain user during the simulation a specific interface has been implemented in both standard schedulers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode);
</pre></div>
</div>
<p>This method can be used both for developing transmission mode decision engine (i.e., for optimizing the transmission mode according to channel condition and/or user’s requirements) and for manual switching from simulation script. In the latter case, the switching can be done as shown in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteEnbNetDevice&gt; lteEnbDev = enbDevs.Get(0)-&gt;GetObject&lt;LteEnbNetDevice&gt;();
PointerValue ptrval;
enbNetDev-&gt;GetAttribute(&quot;FfMacScheduler&quot;, ptrval);
Ptr&lt;RrFfMacScheduler&gt; rrsched = ptrval.Get&lt;RrFfMacScheduler&gt;();
Simulator::Schedule(Seconds(0.2), &amp;RrFfMacScheduler::TransmissionModeConfigurationUpdate, rrsched, rnti, 1);
</pre></div>
</div>
<p>Finally, the model implemented can be reconfigured according to different MIMO models by updating the gain values (the only constraints is that the gain has to be constant during simulation run-time and common for the layers). The gain of each Transmission Mode can be changed according to the standard ns3 attribute system, where the attributes are: <code class="docutils literal notranslate"><span class="pre">TxMode1Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode2Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode3Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode4Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode5Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode6Gain</span></code> and <code class="docutils literal notranslate"><span class="pre">TxMode7Gain</span></code>. By default only <code class="docutils literal notranslate"><span class="pre">TxMode1Gain</span></code>, <code class="docutils literal notranslate"><span class="pre">TxMode2Gain</span></code> and <code class="docutils literal notranslate"><span class="pre">TxMode3Gain</span></code> have a meaningful value, that are the ones derived by _[CatreuxMIMO] (i.e., respectively 0.0, 4.2 and -2.8 dB).</p>
</section>
<section id="use-of-antennamodel">
<h4><span class="section-number">20.2.11. </span>Use of AntennaModel<a class="headerlink" href="#use-of-antennamodel" title="Link to this heading">¶</a></h4>
<p>We now show how associate a particular AntennaModel with an eNB device
in order to model a sector of a macro eNB. For this purpose, it is
convenient to use the <code class="docutils literal notranslate"><span class="pre">CosineAntennaModel</span></code> provided by the ns-3
antenna module. The configuration of the eNB is to be done via the
<code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> instance right before the creation of the
<code class="docutils literal notranslate"><span class="pre">EnbNetDevice</span></code>, as shown in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEnbAntennaModelType(&quot;ns3::CosineAntennaModel&quot;);
lteHelper-&gt;SetEnbAntennaModelAttribute(&quot;Orientation&quot;, DoubleValue(0));
lteHelper-&gt;SetEnbAntennaModelAttribute(&quot;Beamwidth&quot;,   DoubleValue(60));
lteHelper-&gt;SetEnbAntennaModelAttribute(&quot;MaxGain&quot;,     DoubleValue(0.0));
</pre></div>
</div>
<p>the above code will generate an antenna model with a 60 degrees
beamwidth pointing along the X axis. The orientation is measured
in degrees from the X axis, e.g., an orientation of 90 would point
along the Y axis, and an orientation of -90 would point in the
negative direction along the Y axis. The beamwidth is the -3 dB
beamwidth, e.g, for a 60 degree beamwidth the antenna gain at an angle
of <img class="math" src="_images/math/ef9b1eccc37b378d3b0cbca837b4f3842f8fe3a7.png" alt="\pm 30"/> degrees from the direction of orientation is -3 dB.</p>
<p>To create a multi-sector site, you need to create different ns-3 nodes
placed at the same position, and to configure separate <code class="docutils literal notranslate"><span class="pre">EnbNetDevice</span></code>
with different antenna orientations to be installed on each node.</p>
</section>
<section id="radio-environment-maps">
<span id="sec-radio-environment-maps"></span><h4><span class="section-number">20.2.12. </span>Radio Environment Maps<a class="headerlink" href="#radio-environment-maps" title="Link to this heading">¶</a></h4>
<p>By using the class <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper</span></code> it is possible to output
to a file a Radio Environment Map (REM), i.e., a uniform 2D grid of values
that represent the Signal-to-noise ratio in the downlink with respect
to the eNB that has the strongest signal at each point. It is possible
to specify if REM should be generated for data or control channel. Also user
can set the RbId, for which REM will be generated. Default RbId is -1, what
means that REM will generated with averaged Signal-to-noise ratio from all RBs.</p>
<p>To do this, you just need to add the following code to your simulation
program towards the end, right before the call to Simulator::Run():</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;RadioEnvironmentMapHelper&gt; remHelper = CreateObject&lt;RadioEnvironmentMapHelper&gt;();
remHelper-&gt;SetAttribute(&quot;Channel&quot;, PointerValue(lteHelper-&gt;GetDownlinkSpectrumChannel()));
remHelper-&gt;SetAttribute(&quot;OutputFile&quot;, StringValue(&quot;rem.out&quot;));
remHelper-&gt;SetAttribute(&quot;XMin&quot;, DoubleValue(-400.0));
remHelper-&gt;SetAttribute(&quot;XMax&quot;, DoubleValue(400.0));
remHelper-&gt;SetAttribute(&quot;XRes&quot;, UintegerValue(100));
remHelper-&gt;SetAttribute(&quot;YMin&quot;, DoubleValue(-300.0));
remHelper-&gt;SetAttribute(&quot;YMax&quot;, DoubleValue(300.0));
remHelper-&gt;SetAttribute(&quot;YRes&quot;, UintegerValue(75));
remHelper-&gt;SetAttribute(&quot;Z&quot;, DoubleValue(0.0));
remHelper-&gt;SetAttribute(&quot;UseDataChannel&quot;, BooleanValue(true));
remHelper-&gt;SetAttribute(&quot;RbId&quot;, IntegerValue(10));
remHelper-&gt;Install();
</pre></div>
</div>
<p>By configuring the attributes of the <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper</span></code> object
as shown above, you can tune the parameters of the REM to be
generated. Note that each <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper</span></code> instance can
generate only one REM; if you want to generate more REMs, you need to
create one separate instance for each REM.</p>
<p>Note that the REM generation is very demanding, in particular:</p>
<blockquote>
<div><ul class="simple">
<li><p>the run-time memory consumption is approximately 5KB per pixel. For example,
a REM with a resolution of 500x500 would need about 1.25 GB of memory, and
a resolution of 1000x1000 would need needs about 5 GB (too much for a
regular PC at the time of this writing). To overcome this issue,
the REM is generated at successive steps, with each step evaluating
at most a number of pixels determined by the value of the
the attribute <code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper::MaxPointsPerIteration</span></code>.</p></li>
<li><p>if you generate a REM at the beginning of a simulation, it will
slow down the execution of the rest of the simulation. If you want
to generate a REM for a program and also use the same program to
get simulation result, it is recommended to add a command-line
switch that allows to either generate the REM or run the complete
simulation. For this purpose, note that there is an attribute
<code class="docutils literal notranslate"><span class="pre">RadioEnvironmentMapHelper::StopWhenDone</span></code> (default: true) that
will force the simulation to stop right after the REM has been generated.</p></li>
</ul>
</div></blockquote>
<p>The REM is stored in an ASCII file in the following format:</p>
<blockquote>
<div><ul class="simple">
<li><p>column 1 is the x coordinate</p></li>
<li><p>column 2 is the y coordinate</p></li>
<li><p>column 3 is the z coordinate</p></li>
<li><p>column 4 is the SINR in linear units</p></li>
</ul>
</div></blockquote>
<p>A minimal gnuplot script that allows you to plot the REM is given
below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set view map;
set xlabel &quot;X&quot;
set ylabel &quot;Y&quot;
set cblabel &quot;SINR (dB)&quot;
unset key
plot &quot;rem.out&quot; using ($1):($2):(10*log10($4)) with image
</pre></div>
</div>
<p>As an example, here is the REM that can be obtained with the example program lena-dual-stripe, which shows a three-sector LTE macrocell in a co-channel deployment with some residential femtocells randomly deployed in two blocks of apartments.</p>
<figure class="align-center" id="id19">
<span id="fig-lena-dual-stripe"></span><img alt="_images/lena-dual-stripe.png" src="_images/lena-dual-stripe.png" />
<figcaption>
<p><span class="caption-text">REM obtained from the lena-dual-stripe example</span><a class="headerlink" href="#id19" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Note that the lena-dual-stripe example program also generate
gnuplot-compatible output files containing information about the
positions of the UE and eNB nodes as well as of the buildings,
respectively in the files <code class="docutils literal notranslate"><span class="pre">ues.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">enbs.txt</span></code> and
<code class="docutils literal notranslate"><span class="pre">buildings.txt</span></code>. These can be easily included when using
gnuplot. For example, assuming that your gnuplot script (e.g., the
minimal gnuplot script described above) is saved in a file named
<code class="docutils literal notranslate"><span class="pre">my_plot_script</span></code>, running the following command would plot the
location of UEs, eNBs and buildings on top of the REM:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gnuplot -p enbs.txt ues.txt buildings.txt my_plot_script
</pre></div>
</div>
</section>
<section id="amc-model-and-cqi-calculation">
<h4><span class="section-number">20.2.13. </span>AMC Model and CQI Calculation<a class="headerlink" href="#amc-model-and-cqi-calculation" title="Link to this heading">¶</a></h4>
<p>The simulator provides two possible schemes for what concerns the selection of the MCSs and
correspondingly the generation of the CQIs. The first one is based on the GSoC module <a class="reference internal" href="index.html#piro2011" id="id9"><span>[Piro2011]</span></a>
and works per RB basis. This model can be activated with the ns3 attribute system, as presented in
the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteAmc::AmcModel&quot;, EnumValue(LteAmc::PiroEW2010));
</pre></div>
</div>
<p>While, the solution based on the physical error model can be controlled with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteAmc::AmcModel&quot;, EnumValue(LteAmc::MiErrorModel));
</pre></div>
</div>
<p>Finally, the required efficiency of the <code class="docutils literal notranslate"><span class="pre">PiroEW2010</span></code> AMC module can be tuned thanks to the <code class="docutils literal notranslate"><span class="pre">Ber</span></code> attribute(), for instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteAmc::Ber&quot;, DoubleValue(0.00005));
</pre></div>
</div>
</section>
<section id="evolved-packet-core-epc">
<span id="sec-evolved-packet-core"></span><h4><span class="section-number">20.2.14. </span>Evolved Packet Core (EPC)<a class="headerlink" href="#evolved-packet-core-epc" title="Link to this heading">¶</a></h4>
<p>We now explain how to write a simulation program that allows to
simulate the EPC in addition to the LTE radio access network. The use
of EPC allows to use IPv4 and IPv6 networking with LTE devices. In other words,
you will be able to use the regular ns-3 applications and sockets over
IPv4 and IPv6 over LTE, and also to connect an LTE network to any other IPv4 and IPv6
network you might have in your simulation.</p>
<p>First of all, in addition to <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> that we already introduced
in <a class="reference internal" href="#sec-basic-simulation-program"><span class="std std-ref">Basic simulation program</span></a>, you need to use an additional
<code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> class, which will take care of creating the EPC entities and
network topology. Note that you can’t use <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> directly, as
it is an abstract base class; instead, you need to use one of its
child classes, which provide different EPC topology implementations. In
this example we will consider <code class="docutils literal notranslate"><span class="pre">PointToPointEpcHelper</span></code>, which
implements an EPC based on point-to-point links. To use it, you need
first to insert this code in your simulation program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
Ptr&lt;PointToPointEpcHelper&gt; epcHelper = CreateObject&lt;PointToPointEpcHelper&gt;();
</pre></div>
</div>
<p>Then, you need to tell the LTE helper that the EPC will be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEpcHelper(epcHelper);
</pre></div>
</div>
<p>the above step is necessary so that the LTE helper will trigger the
appropriate EPC configuration in correspondence with some important
configuration, such as when a new eNB or UE is added to the
simulation, or an EPS bearer is created. The EPC helper will
automatically take care of the necessary setup, such as S1 link
creation and S1 bearer setup. All this will be done without the
intervention of the user.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">lteHelper-&gt;SetEpcHelper(epcHelper)</span></code> enables the use of
EPC, and has the side effect that any new <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> that is
created will have the <code class="docutils literal notranslate"><span class="pre">EpsBearerToRlcMapping</span></code> attribute set to
<code class="docutils literal notranslate"><span class="pre">RLC_UM_ALWAYS</span></code> instead of <code class="docutils literal notranslate"><span class="pre">RLC_SM_ALWAYS</span></code> if the latter was
the default; otherwise, the attribute won’t be changed (e.g., if
you changed the default to <code class="docutils literal notranslate"><span class="pre">RLC_AM_ALWAYS</span></code>, it won’t be touched).</p>
<p>It is to be noted that the <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> will also automatically
create the PGW node and configure it so that it can properly handle
traffic from/to the LTE radio access network.  Still,
you need to add some explicit code to connect the PGW to other
IPv4/IPv6 networks (e.g., the internet, another EPC). Here is a very
simple example about how to connect a single remote host (IPv4 type)
to the PGW via a point-to-point link:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;Node&gt; pgw = epcHelper-&gt;GetPgwNode();

// Create a single RemoteHost
NodeContainer remoteHostContainer;
remoteHostContainer.Create(1);
Ptr&lt;Node&gt; remoteHost = remoteHostContainer.Get(0);
InternetStackHelper internet;
internet.Install(remoteHostContainer);

// Create the internet
PointToPointHelper p2ph;
p2ph.SetDeviceAttribute(&quot;DataRate&quot;, DataRateValue(DataRate(&quot;100Gb/s&quot;)));
p2ph.SetDeviceAttribute(&quot;Mtu&quot;, UintegerValue(1500));
p2ph.SetChannelAttribute(&quot;Delay&quot;, TimeValue(Seconds(0.010)));
NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);
Ipv4AddressHelper ipv4h;
ipv4h.SetBase(&quot;1.0.0.0&quot;, &quot;255.0.0.0&quot;);
Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
// interface 0 is localhost, 1 is the p2p device
Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);


Ipv4StaticRoutingHelper ipv4RoutingHelper;
Ptr&lt;Ipv4StaticRouting&gt; remoteHostStaticRouting;
remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting(remoteHost-&gt;GetObject&lt;Ipv4&gt;());
remoteHostStaticRouting-&gt;AddNetworkRouteTo(epcHelper-&gt;GetEpcIpv4NetworkAddress(),
                                           Ipv4Mask(&quot;255.255.0.0&quot;), 1);
</pre></div>
</div>
<p>Now, you should go on and create LTE eNBs and UEs as explained in the
previous sections. You can of course configure other LTE aspects such
as pathloss and fading models. Right after you created the UEs, you
should also configure them for IP networking. This is done as
follows. We assume you have a container for UE and eNodeB nodes like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NodeContainer ueNodes;
NodeContainer enbNodes;
</pre></div>
</div>
<p>to configure an LTE-only simulation, you would then normally do
something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer ueLteDevs = lteHelper-&gt;InstallUeDevice(ueNodes);
lteHelper-&gt;Attach(ueLteDevs, enbLteDevs.Get(0));
</pre></div>
</div>
<p>in order to configure the UEs for IP networking, you just need to
additionally do like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// we install the IP stack on the UEs
InternetStackHelper internet;
internet.Install(ueNodes);

// assign IP address to UEs
for (uint32_t u = 0; u &lt; ueNodes.GetN(); ++u)
  {
    Ptr&lt;Node&gt; ue = ueNodes.Get(u);
    Ptr&lt;NetDevice&gt; ueLteDevice = ueLteDevs.Get(u);
    Ipv4InterfaceContainer ueIpIface;
    ueIpIface = epcHelper-&gt;AssignUeIpv4Address(NetDeviceContainer(ueLteDevice));
    // set the default gateway for the UE
    Ptr&lt;Ipv4StaticRouting&gt; ueStaticRouting;
    ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(ue-&gt;GetObject&lt;Ipv4&gt;());
    ueStaticRouting-&gt;SetDefaultRoute(epcHelper-&gt;GetUeDefaultGatewayAddress(), 1);
  }
</pre></div>
</div>
<p>The activation of bearers is done in a slightly different way with
respect to what done for an LTE-only simulation. First, the method
ActivateDataRadioBearer is not to be used when the EPC is
used. Second, when EPC is used, the default EPS bearer will be
activated automatically when you call <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach()</span></code>. Third, if
you want to setup dedicated EPS bearer, you can do so using the method
<code class="docutils literal notranslate"><span class="pre">LteHelper::ActivateDedicatedEpsBearer()</span></code>. This method takes as a
parameter the Traffic Flow Template(TFT), which is a struct that
identifies the type of traffic that will be mapped to the dedicated
EPS bearer. Here is an example for how to setup a dedicated bearer
for an application at the UE communicating on port 1234:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;EpcTft&gt; tft = Create&lt;EpcTft&gt;();
EpcTft::PacketFilter pf;
pf.localPortStart = 1234;
pf.localPortEnd = 1234;
tft-&gt;Add(pf);
lteHelper-&gt;ActivateDedicatedEpsBearer(ueLteDevs,
                                      EpsBearer(EpsBearer::NGBR_VIDEO_TCP_DEFAULT),
                                      tft);
</pre></div>
</div>
<p>you can of course use custom EpsBearer and EpcTft configurations,
please refer to the doxygen documentation for how to do it.</p>
<p>Finally, you can install applications on the LTE UE nodes that communicate
with remote applications over the internet. This is done following the
usual ns-3 procedures. Following our simple example with a single
remoteHost, here is how to setup downlink communication, with an
UdpClient application on the remote host, and a PacketSink on the LTE UE
(using the same variable names of the previous code snippets)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>uint16_t dlPort = 1234;
PacketSinkHelper packetSinkHelper(&quot;ns3::UdpSocketFactory&quot;,
                                  InetSocketAddress(Ipv4Address::GetAny(), dlPort));
ApplicationContainer serverApps = packetSinkHelper.Install(ue);
serverApps.Start(Seconds(0.01));
UdpClientHelper client(ueIpIface.GetAddress(0), dlPort);
ApplicationContainer clientApps = client.Install(remoteHost);
clientApps.Start(Seconds(0.01));
</pre></div>
</div>
<p>That’s all! You can now start your simulation as usual:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Simulator::Stop(Seconds(10.0));
Simulator::Run();
</pre></div>
</div>
</section>
<section id="using-the-epc-with-emulation-mode">
<h4><span class="section-number">20.2.15. </span>Using the EPC with emulation mode<a class="headerlink" href="#using-the-epc-with-emulation-mode" title="Link to this heading">¶</a></h4>
<p>In the previous section we used PointToPoint links for the connection between the eNBs and the SGW (S1-U interface) and among eNBs (X2-U and X2-C interfaces). The LTE module supports using emulated links instead of PointToPoint links. This is achieved by just replacing the creation of <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> and <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> with the following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
Ptr&lt;EmuEpcHelper&gt;  epcHelper = CreateObject&lt;EmuEpcHelper&gt;();
lteHelper-&gt;SetEpcHelper(epcHelper);
epcHelper-&gt;Initialize();
</pre></div>
</div>
<p>The attributes <code class="docutils literal notranslate"><span class="pre">ns3::EmuEpcHelper::sgwDeviceName</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::EmuEpcHelper::enbDeviceName</span></code> are used to set the name of the devices used for transporting the S1-U, X2-U and X2-C interfaces at the SGW and eNB, respectively. We will now show how this is done in an example where we execute the example program <code class="docutils literal notranslate"><span class="pre">lena-simple-epc-emu</span></code> using two virtual ethernet interfaces.</p>
<p>First of all we build ns-3 appropriately:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># configure
./ns3 configure --enable-sudo --enable-modules=lte,fd-net-device --enable-examples

# build
./ns3
</pre></div>
</div>
<p>Then we setup two virtual ethernet interfaces, and start wireshark to look at the traffic going through:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># note: you need to be root

# create two paired veth devices
ip link add name veth0 type veth peer name veth1
ip link show

# enable promiscuous mode
ip link set veth0 promisc on
ip link set veth1 promisc on

# bring interfaces up
ip link set veth0 up
ip link set veth1 up

# start wireshark and capture on veth0
wireshark &amp;
</pre></div>
</div>
<p>We can now run the example program with the simulated clock:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --ns3::EmuEpcHelper::sgwDeviceName=veth0
--ns3::EmuEpcHelper::enbDeviceName=veth1&quot;
</pre></div>
</div>
<p>Using wireshark, you should see ARP resolution first, then some GTP
packets exchanged both in uplink and downlink.</p>
<p>The default setting of the example program is 1 eNB and 1UE. You can change this via command line parameters, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --ns3::EmuEpcHelper::sgwDeviceName=veth0
--ns3::EmuEpcHelper::enbDeviceName=veth1 --nEnbs=2 --nUesPerEnb=2&quot;
</pre></div>
</div>
<p>To get a list of the available parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --PrintHelp&quot;
</pre></div>
</div>
<p>To run with the realtime clock: it turns out that the default debug
build is too slow for realtime. Softening the real time constraints
with the BestEffort mode is not a good idea: something can go wrong
(e.g., ARP can fail) and, if so, you won’t get any data packets out.
So you need a decent hardware and the optimized build with statically
linked modules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 configure -d optimized --enable-static --enable-modules=lte --enable-examples
--enable-sudo
</pre></div>
</div>
<p>Then run the example program like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-simple-epc-emu --command=&quot;%s --ns3::EmuEpcHelper::sgwDeviceName=veth0
--ns3::EmuEpcHelper::enbDeviceName=veth1
--SimulatorImplementationType=ns3::RealtimeSimulatorImpl
--ns3::RealtimeSimulatorImpl::SynchronizationMode=HardLimit&quot;
</pre></div>
</div>
<p>note the HardLimit setting, which will cause the program to terminate
if it cannot keep up with real time.</p>
<p>The approach described in this section can be used with any type of
net device. For instance, <a class="reference internal" href="index.html#baldo2014" id="id10"><span>[Baldo2014]</span></a> describes how it was used to
run an emulated LTE-EPC network over a real multi-layer packet-optical
transport network.</p>
</section>
<section id="custom-backhaul">
<span id="sec-custom-backhaul"></span><h4><span class="section-number">20.2.16. </span>Custom Backhaul<a class="headerlink" href="#custom-backhaul" title="Link to this heading">¶</a></h4>
<p>In the previous sections, <a class="reference internal" href="#sec-evolved-packet-core"><span class="std std-ref">Evolved Packet Core (EPC)</span></a>, we explained how to write a simulation
program using EPC with a predefined backhaul network between the RAN and the EPC. We used the
<code class="docutils literal notranslate"><span class="pre">PointToPointEpcHelper</span></code>. This <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> creates point-to-point links between the eNBs and the SGW.</p>
<p>We now explain how to write a simulation program that allows the simulator user to create any kind
of backhaul network in the simulation program.</p>
<p>First of all, in addition to <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code>, you need to use the <code class="docutils literal notranslate"><span class="pre">NoBackhaulEpcHelper</span></code> class, which
implements an EPC but without connecting the eNBs with the core network. It just creates the network
elements of the core network:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
Ptr&lt;NoBackhaulEpcHelper&gt; epcHelper = CreateObject&lt;NoBackhaulEpcHelper&gt;();
</pre></div>
</div>
<p>Then, as usual, you need to tell the LTE helper that the EPC will be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetEpcHelper(epcHelper);
</pre></div>
</div>
<p>Now, you should create the backhaul network. Here we create point-to-point links as it is done
by the <code class="docutils literal notranslate"><span class="pre">PointToPointEpcHelper</span></code>. We assume you have a container for eNB nodes like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NodeContainer enbNodes;
</pre></div>
</div>
<p>We get the SGW node:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;Node&gt; sgw = epcHelper-&gt;GetSgwNode();
</pre></div>
</div>
<p>And we connect every eNB from the container with the SGW with a point-to-point link. We also assign
IPv4 addresses to the interfaces of eNB and SGW with <code class="docutils literal notranslate"><span class="pre">s1uIpv4AddressHelper.Assign(sgwEnbDevices)</span></code>
and finally we tell the EpcHelper that this <code class="docutils literal notranslate"><span class="pre">enb</span></code> has a new S1 interface with
<code class="docutils literal notranslate"><span class="pre">epcHelper-&gt;AddS1Interface(enb,</span> <span class="pre">enbS1uAddress,</span> <span class="pre">sgwS1uAddress)</span></code>, where <code class="docutils literal notranslate"><span class="pre">enbS1uAddress</span></code> and
<code class="docutils literal notranslate"><span class="pre">sgwS1uAddress</span></code> are the IPv4 addresses of the eNB and the SGW, respectively:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ipv4AddressHelper s1uIpv4AddressHelper;

// Create networks of the S1 interfaces
s1uIpv4AddressHelper.SetBase(&quot;10.0.0.0&quot;, &quot;255.255.255.252&quot;);

for (uint16_t i = 0; i &lt; enbNodes.GetN(); ++i)
  {
    Ptr&lt;Node&gt; enb = enbNodes.Get(i);

    // Create a point to point link between the eNB and the SGW with
    // the corresponding new NetDevices on each side
    PointToPointHelper p2ph;
    DataRate s1uLinkDataRate = DataRate(&quot;10Gb/s&quot;);
    uint16_t s1uLinkMtu = 2000;
    Time s1uLinkDelay = Time(0);
    p2ph.SetDeviceAttribute(&quot;DataRate&quot;, DataRateValue(s1uLinkDataRate));
    p2ph.SetDeviceAttribute(&quot;Mtu&quot;, UintegerValue(s1uLinkMtu));
    p2ph.SetChannelAttribute(&quot;Delay&quot;, TimeValue(s1uLinkDelay));
    NetDeviceContainer sgwEnbDevices = p2ph.Install(sgw, enb);

    Ipv4InterfaceContainer sgwEnbIpIfaces = s1uIpv4AddressHelper.Assign(sgwEnbDevices);
    s1uIpv4AddressHelper.NewNetwork();

    Ipv4Address sgwS1uAddress = sgwEnbIpIfaces.GetAddress(0);
    Ipv4Address enbS1uAddress = sgwEnbIpIfaces.GetAddress(1);

    // Create S1 interface between the SGW and the eNB
    epcHelper-&gt;AddS1Interface(enb, enbS1uAddress, sgwS1uAddress);
  }
</pre></div>
</div>
<p>This is just an example how to create a custom backhaul network. In this other example, we connect
all eNBs and the SGW to the same CSMA network:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Create networks of the S1 interfaces
s1uIpv4AddressHelper.SetBase(&quot;10.0.0.0&quot;, &quot;255.255.255.0&quot;);

NodeContainer sgwEnbNodes;
sgwEnbNodes.Add(sgw);
sgwEnbNodes.Add(enbNodes);

CsmaHelper csmah;
NetDeviceContainer sgwEnbDevices = csmah.Install(sgwEnbNodes);
Ptr&lt;NetDevice&gt; sgwDev = sgwEnbDevices.Get(0);

Ipv4InterfaceContainer sgwEnbIpIfaces = s1uIpv4AddressHelper.Assign(sgwEnbDevices);
Ipv4Address sgwS1uAddress = sgwEnbIpIfaces.GetAddress(0);

for (uint16_t i = 0; i &lt; enbNodes.GetN(); ++i)
  {
    Ptr&lt;Node&gt; enb = enbNodes.Get(i);
    Ipv4Address enbS1uAddress = sgwEnbIpIfaces.GetAddress(i + 1);

    // Create S1 interface between the SGW and the eNB
    epcHelper-&gt;AddS1Interface(enb, enbS1uAddress, sgwS1uAddress);
  }
</pre></div>
</div>
<p>As you can see, apart from how you create the backhaul network, i.e. the point-to-point links or
the CSMA network, the important point is to tell the <code class="docutils literal notranslate"><span class="pre">EpcHelper</span></code> that an <code class="docutils literal notranslate"><span class="pre">eNB</span></code> has a new S1 interface.</p>
<p>Now, you should continue configuring your simulation program as it is explained in
<a class="reference internal" href="#sec-evolved-packet-core"><span class="std std-ref">Evolved Packet Core (EPC)</span></a> subsection. This configuration includes: the internet, installing the LTE eNBs
and possibly configuring other LTE aspects, installing the LTE UEs and configuring them as IP nodes,
activation of the dedicated EPS bearers and installing applications on the LTE UEs and on the remote hosts.</p>
</section>
<section id="network-attachment">
<span id="sec-network-attachment"></span><h4><span class="section-number">20.2.17. </span>Network Attachment<a class="headerlink" href="#network-attachment" title="Link to this heading">¶</a></h4>
<p>As shown in the basic example in section <a class="reference internal" href="#sec-basic-simulation-program"><span class="std std-ref">Basic simulation program</span></a>,
attaching a UE to an eNodeB is done by calling <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function.</p>
<p>There are 2 possible ways of network attachment. The first method is the
<em>“manual”</em> one, while the second one has a more <em>“automatic”</em> sense on it. Each
of them will be covered in this section.</p>
<section id="manual-attachment">
<h5><span class="section-number">20.2.17.1. </span>Manual attachment<a class="headerlink" href="#manual-attachment" title="Link to this heading">¶</a></h5>
<p>This method uses the <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function mentioned above. It has been
the only available network attachment method in earlier versions of LTE module.
It is typically invoked before the simulation begins:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(ueDevs, enbDev); // attach one or more UEs to a single eNodeB
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LteHelper::InstallEnbDevice</span></code> and <code class="docutils literal notranslate"><span class="pre">LteHelper::InstallUeDevice</span></code> functions
must have been called before attaching. In an EPC-enabled simulation, it is also
required to have IPv4/IPv6 properly pre-installed in the UE.</p>
<p>This method is very simple, but requires you to know exactly which UE belongs to
to which eNodeB before the simulation begins. This can be difficult when the UE
initial position is randomly determined by the simulation script.</p>
<p>One may choose the distance between the UE and the eNodeB as a criterion for
selecting the appropriate cell. It is quite simple (at least from the
simulator’s point of view) and sometimes practical. But it is important to note
that sometimes distance does not make a single correct criterion. For instance,
the eNodeB antenna directivity should be considered as well. Besides that, one
should also take into account the channel condition, which might be fluctuating
if there is fading or shadowing in effect. In these kind of cases, network
attachment should not be based on distance alone.</p>
<p>In real life, UE will automatically evaluate certain criteria and select the
best cell to attach to, without manual intervention from the user. Obviously
this is not the case in this <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function. The other network
attachment method uses more <em>“automatic”</em> approach to network attachment, as
will be described next.</p>
</section>
<section id="automatic-attachment-using-idle-mode-cell-selection-procedure">
<h5><span class="section-number">20.2.17.2. </span>Automatic attachment using Idle mode cell selection procedure<a class="headerlink" href="#automatic-attachment-using-idle-mode-cell-selection-procedure" title="Link to this heading">¶</a></h5>
<p>The strength of the received signal is the standard criterion used for selecting
the best cell to attach to. The use of this criterion is implemented in the
<cite>initial cell selection</cite> process, which can be invoked by calling another
version of the <code class="docutils literal notranslate"><span class="pre">LteHelper::Attach</span></code> function, as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(ueDevs); // attach one or more UEs to a strongest cell
</pre></div>
</div>
<p>The difference with the manual method is that the destination eNodeB is not
specified. The procedure will find the best cell for the UEs, based on several
criteria, including the strength of the received signal (RSRP).</p>
<p>After the method is called, the UE will spend some time to measure the
neighbouring cells, and then attempt to attach to the best one. More details can
be found in section <a class="reference internal" href="index.html#sec-initial-cell-selection"><span class="std std-ref">Initial Cell Selection</span></a> of the Design
Documentation.</p>
<p>It is important to note that this method only works in EPC-enabled simulations.
LTE-only simulations must resort to manual attachment method.</p>
</section>
<section id="closed-subscriber-group">
<h5><span class="section-number">20.2.17.3. </span>Closed Subscriber Group<a class="headerlink" href="#closed-subscriber-group" title="Link to this heading">¶</a></h5>
<p>An interesting use case of the initial cell selection process is to setup a
simulation environment with Closed Subscriber Group (CSG).</p>
<p>For example, a certain eNodeB, typically a smaller version such as femtocell,
might belong to a private owner (e.g. a household or business), allowing access
only to some UEs which have been previously registered by the owner. The eNodeB
and the registered UEs altogether form a CSG.</p>
<p>The access restriction can be simulated by “labeling” the CSG members with the
same CSG ID. This is done through the attributes in both eNodeB and UE, for
example using the following <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// label the following eNodeBs with CSG identity of 1 and CSG indication enabled
lteHelper-&gt;SetEnbDeviceAttribute(&quot;CsgId&quot;, UintegerValue(1));
lteHelper-&gt;SetEnbDeviceAttribute(&quot;CsgIndication&quot;, BooleanValue(true));

// label one or more UEs with CSG identity of 1
lteHelper-&gt;SetUeDeviceAttribute(&quot;CsgId&quot;, UintegerValue(1));

// install the eNodeBs and UEs
NetDeviceContainer csgEnbDevs = lteHelper-&gt;InstallEnbDevice(csgEnbNodes);
NetDeviceContainer csgUeDevs = lteHelper-&gt;InstallUeDevice(csgUeNodes);
</pre></div>
</div>
<p>Then enable the initial cell selection procedure on the UEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;Attach(csgUeDevs);
</pre></div>
</div>
<p>This is necessary because the CSG restriction only works with automatic method
of network attachment, but not in the manual method.</p>
<p>Note that setting the CSG indication of an eNodeB as false (the default value)
will disable the restriction, i.e., any UEs can connect to this eNodeB.</p>
</section>
</section>
<section id="configure-ue-measurements">
<span id="sec-configure-ue-measurements"></span><h4><span class="section-number">20.2.18. </span>Configure UE measurements<a class="headerlink" href="#configure-ue-measurements" title="Link to this heading">¶</a></h4>
<p>The active UE measurement configuration in a simulation is dictated by the
selected so called “consumers”, such as handover algorithm. Users may add their
own configuration into action, and there are several ways to do so:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>direct configuration in eNodeB RRC entity;</p></li>
<li><p>configuring existing handover algorithm; and</p></li>
<li><p>developing a new handover algorithm.</p></li>
</ol>
</div></blockquote>
<p>This section will cover the first method only. The second method is covered in
<a class="reference internal" href="#sec-automatic-handover"><span class="std std-ref">Automatic handover trigger</span></a>, while the third method is explained in length in
Section <a class="reference internal" href="index.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> of the Design Documentation.</p>
<p>Direct configuration in eNodeB RRC works as follows. User begins by creating a
new <code class="docutils literal notranslate"><span class="pre">LteRrcSap::ReportConfigEutra</span></code> instance and pass it to the
<code class="docutils literal notranslate"><span class="pre">LteEnbRrc::AddUeMeasReportConfig</span></code> function. The function will return the
<code class="docutils literal notranslate"><span class="pre">measId</span></code> (measurement identity) which is a unique reference of the
configuration in the eNodeB instance. This function must be called before the
simulation begins. The measurement configuration will be active in all UEs
attached to the eNodeB throughout the duration of the simulation. During the
simulation, user can capture the measurement reports produced by the UEs by
listening to the existing <code class="docutils literal notranslate"><span class="pre">LteEnbRrc::RecvMeasurementReport</span></code> trace source.</p>
<p>The structure <cite>ReportConfigEutra</cite> is in accord with 3GPP specification.
Definition of the structure and each member field can be found in Section 6.3.5
of <a class="reference internal" href="index.html#ts36331" id="id11"><span>[TS36331]</span></a>.</p>
<p>The code sample below configures Event A1 RSRP measurement to every eNodeB
within the container <code class="docutils literal notranslate"><span class="pre">devs</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LteRrcSap::ReportConfigEutra config;
config.eventId = LteRrcSap::ReportConfigEutra::EVENT_A1;
config.threshold1.choice = LteRrcSap::ThresholdEutra::THRESHOLD_RSRP;
config.threshold1.range = 41;
config.triggerQuantity = LteRrcSap::ReportConfigEutra::RSRP;
config.reportInterval = LteRrcSap::ReportConfigEutra::MS480;

std::vector&lt;uint8_t&gt; measIdList;

NetDeviceContainer::Iterator it;
for (it = devs.Begin(); it != devs.End(); it++)
{
  Ptr&lt;NetDevice&gt; dev = *it;
  Ptr&lt;LteEnbNetDevice&gt; enbDev = dev-&gt;GetObject&lt;LteEnbNetDevice&gt;();
  Ptr&lt;LteEnbRrc&gt; enbRrc = enbDev-&gt;GetRrc();

  uint8_t measId = enbRrc-&gt;AddUeMeasReportConfig(config);
  measIdList.push_back(measId); // remember the measId created

  enbRrc-&gt;TraceConnect(&quot;RecvMeasurementReport&quot;,
                       &quot;context&quot;,
                       MakeCallback(&amp;RecvMeasurementReportCallback));
}
</pre></div>
</div>
<p>Note that thresholds are expressed as range. In the example above, the range 41
for RSRP corresponds to -100 dBm. The conversion from and to the range format is
due to Section 9.1.4 and 9.1.7 of <a class="reference internal" href="index.html#ts36133" id="id12"><span>[TS36133]</span></a>. The <code class="docutils literal notranslate"><span class="pre">EutranMeasurementMapping</span></code>
class has several static functions that can be used for this purpose.</p>
<p>The corresponding callback function would have a definition similar as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
RecvMeasurementReportCallback(std::string context,
                              uint64_t imsi,
                              uint16_t cellId,
                              uint16_t rnti,
                              LteRrcSap::MeasurementReport measReport);
</pre></div>
</div>
<p>This method will register the callback function as a consumer of UE
measurements. In the case where there are more than one consumers in the
simulation (e.g. handover algorithm), the measurements intended for other
consumers will also be captured by this callback function. Users may utilize the
the <code class="docutils literal notranslate"><span class="pre">measId</span></code> field, contained within the <code class="docutils literal notranslate"><span class="pre">LteRrcSap::MeasurementReport</span></code>
argument of the callback function, to tell which measurement configuration has
triggered the report.</p>
<p>In general, this mechanism prevents one consumer to unknowingly intervene with
another consumer’s reporting configuration.</p>
<p>Note that only the reporting configuration part (i.e.
<code class="docutils literal notranslate"><span class="pre">LteRrcSap::ReportConfigEutra</span></code>) of the UE measurements parameter is open for
consumers to configure, while the other parts are kept hidden. The
intra-frequency limitation is the main motivation behind this API implementation
decision:</p>
<blockquote>
<div><ul class="simple">
<li><p>there is only one, unambiguous and definitive <em>measurement object</em>, thus
there is no need to configure it;</p></li>
<li><p><em>measurement identities</em> are kept hidden because of the fact that there is
one-to-one mapping between reporting configuration and measurement identity,
thus a new measurement identity is set up automatically when a new reporting
configuration is created;</p></li>
<li><p><em>quantity configuration</em> is configured elsewhere, see
<a class="reference internal" href="index.html#sec-performing-measurements"><span class="std std-ref">Performing measurements</span></a>; and</p></li>
<li><p><em>measurement gaps</em> are not supported, because it is only applicable for
inter-frequency settings;</p></li>
</ul>
</div></blockquote>
</section>
<section id="x2-based-handover">
<span id="sec-x2-based-handover"></span><h4><span class="section-number">20.2.19. </span>X2-based handover<a class="headerlink" href="#x2-based-handover" title="Link to this heading">¶</a></h4>
<p>As defined by 3GPP, handover is a procedure for changing the serving cell of a
UE in CONNECTED mode. The two eNodeBs involved in the process are typically
called the <em>source eNodeB</em> and the <em>target eNodeB</em>.</p>
<p>In order to enable the execution of X2-based handover in simulation, there are
two requirements that must be met. Firstly, EPC must be enabled in the
simulation (see <a class="reference internal" href="#sec-evolved-packet-core"><span class="std std-ref">Evolved Packet Core (EPC)</span></a>).</p>
<p>Secondly, an X2 interface must be configured between the two eNodeBs, which
needs to be done explicitly within the simulation program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;AddX2Interface(enbNodes);
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">enbNodes</span></code> is a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code> that contains the two eNodeBs between
which the X2 interface is to be configured. If the container has more than two
eNodeBs, the function will create an X2 interface between every pair of eNodeBs
in the container.</p>
<p>Lastly, the target eNodeB must be configured as “open” to X2 HANDOVER REQUEST.
Every eNodeB is open by default, so no extra instruction is needed in most
cases. However, users may set the eNodeB to “closed” by setting the boolean
attribute <code class="docutils literal notranslate"><span class="pre">LteEnbRrc::AdmitHandoverRequest</span></code> to <cite>false</cite>. As an example, you can
run the <code class="docutils literal notranslate"><span class="pre">lena-x2-handover</span></code> program and setting the attribute in this way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NS_LOG=EpcX2:LteEnbRrc ./ns3 run lena-x2-handover --command=&quot;%s --ns3::LteEnbRrc::AdmitHandoverRequest=false&quot;
</pre></div>
</div>
<p>After the above three requirements are fulfilled, the handover procedure can be
triggered manually or automatically. Each will be presented in the following
subsections.</p>
<section id="manual-handover-trigger">
<h5><span class="section-number">20.2.19.1. </span>Manual handover trigger<a class="headerlink" href="#manual-handover-trigger" title="Link to this heading">¶</a></h5>
<p>Handover event can be triggered “manually” within the simulation program by
scheduling an explicit handover event. The <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object provides a
convenient method for the scheduling of a handover event. As an example, let us
assume that <code class="docutils literal notranslate"><span class="pre">ueLteDevs</span></code> is a <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code> that contains the UE that
is to be handed over, and that <code class="docutils literal notranslate"><span class="pre">enbLteDevs</span></code> is another <code class="docutils literal notranslate"><span class="pre">NetDeviceContainer</span></code>
that contains the source and the target eNB. Then, a handover at 0.1s can be
scheduled like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;HandoverRequest(Seconds(0.100),
                           ueLteDevs.Get(0),
                           enbLteDevs.Get(0),
                           enbLteDevs.Get(1));
</pre></div>
</div>
<p>Note that the UE needs to be already connected to the source eNB, otherwise the
simulation will terminate with an error message.</p>
<p>For an example with full source code, please refer to the <code class="docutils literal notranslate"><span class="pre">lena-x2-handover</span></code>
example program.</p>
</section>
<section id="automatic-handover-trigger">
<span id="sec-automatic-handover"></span><h5><span class="section-number">20.2.19.2. </span>Automatic handover trigger<a class="headerlink" href="#automatic-handover-trigger" title="Link to this heading">¶</a></h5>
<p>Handover procedure can also be triggered “automatically” by the serving eNodeB
of the UE. The logic behind the trigger depends on the handover algorithm
currently active in the eNodeB RRC entity. Users may select and configure the
handover algorithm that will be used in the simulation, which will be explained
shortly in this section. Users may also opt to write their own implementation of
handover algorithm, as described in Section <a class="reference internal" href="index.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> of the
Design Documentation.</p>
<p>Selecting a handover algorithm is done via the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object and its
<code class="docutils literal notranslate"><span class="pre">SetHandoverAlgorithmType</span></code> method as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetHandoverAlgorithmType(&quot;ns3::A2A4RsrqHandoverAlgorithm&quot;);
</pre></div>
</div>
<p>The selected handover algorithm may also provide several configurable
attributes, which can be set as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;ServingCellThreshold&quot;,
                                         UintegerValue(30));
lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;NeighbourCellOffset&quot;,
                                         UintegerValue(1));
</pre></div>
</div>
<p>Three options of handover algorithm are included in the LTE module. The
<em>A2-A4-RSRQ</em> handover algorithm (named as <code class="docutils literal notranslate"><span class="pre">ns3::A2A4RsrqHandoverAlgorithm</span></code>) is
the default option, and the usage has already been shown above.</p>
<p>Another option is the <em>strongest cell</em> handover algorithm (named as
<code class="docutils literal notranslate"><span class="pre">ns3::A3RsrpHandoverAlgorithm</span></code>), which can be selected and configured by the
following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetHandoverAlgorithmType(&quot;ns3::A3RsrpHandoverAlgorithm&quot;);
lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;Hysteresis&quot;,
                                         DoubleValue(3.0));
lteHelper-&gt;SetHandoverAlgorithmAttribute(&quot;TimeToTrigger&quot;,
                                         TimeValue(MilliSeconds(256)));
</pre></div>
</div>
<p>The last option is a special one, called the <em>no-op</em> handover algorithm, which
basically disables automatic handover trigger. This is useful for example in
cases where manual handover trigger need an exclusive control of all handover
decision. It does not have any configurable attributes. The usage is as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetHandoverAlgorithmType(&quot;ns3::NoOpHandoverAlgorithm&quot;);
</pre></div>
</div>
<p>For more information on each handover algorithm’s decision policy and their
attributes, please refer to their respective subsections in Section
<a class="reference internal" href="index.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> of the Design Documentation.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">InstallEnbDevice</span></code> function of <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> will instantiate one
instance of the selected handover algorithm for each eNodeB device. In other
words, make sure to select the right handover algorithm before finalizing it in
the following line of code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NetDeviceContainer enbLteDevs = lteHelper-&gt;InstallEnbDevice(enbNodes);
</pre></div>
</div>
<p>Example with full source code of using automatic handover trigger can be found
in the <code class="docutils literal notranslate"><span class="pre">lena-x2-handover-measures</span></code> example program.</p>
</section>
<section id="tuning-simulation-with-handover">
<span id="sec-tuning-handover-simulation"></span><h5><span class="section-number">20.2.19.3. </span>Tuning simulation with handover<a class="headerlink" href="#tuning-simulation-with-handover" title="Link to this heading">¶</a></h5>
<p>As mentioned in the Design Documentation, the current implementation of handover
model may produce unpredicted behaviour when handover failure occurs. This
subsection will focus on the steps that should be taken into account by users
if they plan to use handover in their simulations.</p>
<p>The major cause of handover failure that we will tackle is the error in
transmitting handover-related signaling messages during the execution of a
handover procedure. As apparent from the Figure
<a class="reference internal" href="index.html#fig-x2-based-handover-seq-diagram"><span class="std std-ref">Sequence diagram of the X2-based handover</span></a> from the Design Documentation, there
are many of them and they use different interfaces and protocols. For the sake
of simplicity, we can safely assume that the X2 interface (between the source
eNodeB and the target eNodeB) and the S1 interface (between the target eNodeB
and the SGW/PGW) are quite stable. Therefore we will focus our attention to the
RRC protocol (between the UE and the eNodeBs) and the Random Access procedure,
which are normally transmitted through the air and susceptible to degradation of
channel condition.</p>
<p>A general tips to reduce transmission error is to <em>ensure high enough SINR</em>
level in every UE. This can be done by a proper planning of the network topology
that <em>minimizes network coverage hole</em>. If the topology has a known coverage
hole, then the UE should be configured not to venture to that area.</p>
<p>Another approach to keep in mind is to <em>avoid too-late handovers</em>. In other
words, handover should happen before the UE’s SINR becomes too low, otherwise
the UE may fail to receive the handover command from the source eNodeB. Handover
algorithms have the means to control how early or late a handover decision is
made. For example, A2-A4-RSRQ handover algorithm can be configured with a higher
threshold to make it decide a handover earlier. Similarly, smaller hysteresis
and/or shorter time-to-trigger in the strongest cell handover algorithm
typically results in earlier handovers. In order to find the right values for
these parameters, one of the factors that should be considered is the UE
movement speed. Generally, a faster moving UE requires the handover to be
executed earlier. Some research work have suggested recommended values, such as
in <a class="reference internal" href="index.html#lee2010" id="id13"><span>[Lee2010]</span></a>.</p>
<p>The above tips should be enough in normal simulation uses, but in the case some
special needs arise then an extreme measure can be taken into consideration.
For instance, users may consider <em>disabling the channel error models</em>. This will
ensure that all handover-related signaling messages will be transmitted
successfully, regardless of distance and channel condition. However, it will
also affect all other data or control packets not related to handover, which may
be an unwanted side effect. Otherwise, it can be done as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteSpectrumPhy::CtrlErrorModelEnabled&quot;, BooleanValue(false));
Config::SetDefault(&quot;ns3::LteSpectrumPhy::DataErrorModelEnabled&quot;, BooleanValue(false));
</pre></div>
</div>
<p>By using the above code, we disable the error model in both control and data
channels and in both directions (downlink and uplink). This is necessary because
handover-related signaling messages are transmitted using these channels. An
exception is when the simulation uses the ideal RRC protocol. In this case, only
the Random Access procedure is left to be considered. The procedure consists of
control messages, therefore we only need to disable the control channel’s error
model.</p>
</section>
<section id="handover-traces">
<span id="sec-handover-traces"></span><h5><span class="section-number">20.2.19.4. </span>Handover traces<a class="headerlink" href="#handover-traces" title="Link to this heading">¶</a></h5>
<p>The RRC model, in particular the <code class="docutils literal notranslate"><span class="pre">LteEnbRrc</span></code> and <code class="docutils literal notranslate"><span class="pre">LteUeRrc</span></code>
objects, provide some useful traces which can be hooked up to some
custom functions so that they are called upon start and end of the
handover execution phase at both the UE and eNB side. As an example,
in your simulation program you can declare the following methods:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
NotifyHandoverStartUe(std::string context,
                      uint64_t imsi,
                      uint16_t cellId,
                      uint16_t rnti,
                      uint16_t targetCellId)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; UE IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot;: previously connected to CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot; with RNTI &quot; &lt;&lt; rnti
            &lt;&lt; &quot;, doing handover to CellId &quot; &lt;&lt; targetCellId
            &lt;&lt; std::endl;
}

void
NotifyHandoverEndOkUe(std::string context,
                      uint64_t imsi,
                      uint16_t cellId,
                      uint16_t rnti)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; UE IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot;: successful handover to CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot; with RNTI &quot; &lt;&lt; rnti
            &lt;&lt; std::endl;
}

void
NotifyHandoverStartEnb(std::string context,
                       uint64_t imsi,
                       uint16_t cellId,
                       uint16_t rnti,
                       uint16_t targetCellId)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; eNB CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot;: start handover of UE with IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot; RNTI &quot; &lt;&lt; rnti
            &lt;&lt; &quot; to CellId &quot; &lt;&lt; targetCellId
            &lt;&lt; std::endl;
}

void
NotifyHandoverEndOkEnb(std::string context,
                       uint64_t imsi,
                       uint16_t cellId,
                       uint16_t rnti)
{
  std::cout &lt;&lt; Simulator::Now().GetSeconds() &lt;&lt; &quot; &quot; &lt;&lt; context
            &lt;&lt; &quot; eNB CellId &quot; &lt;&lt; cellId
            &lt;&lt; &quot;: completed handover of UE with IMSI &quot; &lt;&lt; imsi
            &lt;&lt; &quot; RNTI &quot; &lt;&lt; rnti
            &lt;&lt; std::endl;
}
</pre></div>
</div>
<p>Then, you can hook up these methods to the corresponding trace sources
like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverStart&quot;,
                MakeCallback(&amp;NotifyHandoverStartEnb));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteUeRrc/HandoverStart&quot;,
                MakeCallback(&amp;NotifyHandoverStartUe));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk&quot;,
                MakeCallback(&amp;NotifyHandoverEndOkEnb));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk&quot;,
                MakeCallback(&amp;NotifyHandoverEndOkUe));
</pre></div>
</div>
<p>Handover failure events can also be traced by trace sink functions with
a similar signature as above(including IMSI, cell ID, and RNTI). Four
different failure events are traced:</p>
<ol class="arabic simple">
<li><p>HandoverFailureNoPreamble: Handover failure due to non allocation of
non-contention-based preamble at eNB</p></li>
<li><p>HandoverFailureMaxRach: Handover failure due to maximum RACH attempts</p></li>
<li><p>HandoverFailureLeaving: Handover leaving timeout at source eNB</p></li>
<li><p>HandoverFailureJoining: Handover joining timeout at target eNB</p></li>
</ol>
<p>Similarly, one can hook up methods to the corresponding trace sources
like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureNoPreamble&quot;,
                MakeCallback(&amp;NotifyHandoverFailureNoPreamble));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureMaxRach&quot;,
                MakeCallback(&amp;NotifyHandoverFailureMaxRach));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureLeaving&quot;,
                MakeCallback(&amp;NotifyHandoverFailureLeaving));
Config::Connect(&quot;/NodeList/*/DeviceList/*/LteEnbRrc/HandoverFailureJoining&quot;,
                MakeCallback(&amp;NotifyHandoverFailureJoining));
</pre></div>
</div>
<p>The example program <code class="docutils literal notranslate"><span class="pre">src/lte/examples/lena-x2-handover.cc</span></code>
illustrates how the above instructions can be integrated in a
simulation program. You can run the program like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-x2-handover
</pre></div>
</div>
<p>and it will output the messages printed by the custom handover trace
hooks. In order to additionally print out some meaningful logging
information, you can run the program like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NS_LOG=LteEnbRrc:LteUeRrc:EpcX2 ./ns3 run lena-x2-handover
</pre></div>
</div>
</section>
</section>
<section id="frequency-reuse-algorithms">
<h4><span class="section-number">20.2.20. </span>Frequency Reuse Algorithms<a class="headerlink" href="#frequency-reuse-algorithms" title="Link to this heading">¶</a></h4>
<p>In this section we will describe how to use Frequency Reuse Algorithms
in eNb within LTE simulations.
There are two possible ways of configuration. The first approach is the
“manual” one, it requires more parameters to be configured, but allow user
to configure FR algorithm as he/she needs. The second approach is more
“automatic”. It is very convenient, because is the same for each FR algorithm,
so user can switch FR algorithm very quickly by changing only type of FR
algorithm. One drawback is that “automatic” approach uses only limited set
of configurations for each algorithm, what make it less flexible, but is
sufficient for most of cases.</p>
<p>These two approaches will be described more in following sub-section.</p>
<p>If user do not configure Frequency Reuse algorithm, default one
(i.e. LteFrNoOpAlgorithm) is installed in eNb. It acts as if FR
algorithm was disabled.</p>
<p>One thing that should be mentioned is that most of implemented FR algorithms work with
cell bandwidth greater or equal than 15 RBs. This limitation is caused by requirement
that at least three continuous RBs have to be assigned to UE for transmission.</p>
<section id="manual-configuration">
<h5><span class="section-number">20.2.20.1. </span>Manual configuration<a class="headerlink" href="#manual-configuration" title="Link to this heading">¶</a></h5>
<p>Frequency reuse algorithm can be configured “manually” within the simulation
program by setting type of FR algorithm and all its attributes. Currently,
seven FR algorithms are implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrNoOpAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrHardAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrStrictAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrSoftAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrEnhancedAlgorithm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::LteFfrDistributedAlgorithm</span></code></p></li>
</ul>
</div></blockquote>
<p>Selecting a FR algorithm is done via the <code class="docutils literal notranslate"><span class="pre">LteHelper</span></code> object and
its <code class="docutils literal notranslate"><span class="pre">SetFfrAlgorithmType</span></code> method as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ptr&lt;LteHelper&gt; lteHelper = CreateObject&lt;LteHelper&gt;();
lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrHardAlgorithm&quot;);
</pre></div>
</div>
<p>Each implemented FR algorithm provide several configurable attributes. Users do
not have to care about UL and DL bandwidth configuration, because it is done
automatically during cell configuration. To change bandwidth for FR algorithm,
configure required values for <code class="docutils literal notranslate"><span class="pre">LteEnbNetDevice</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>uint8_t bandwidth = 100;
lteHelper-&gt;SetEnbDeviceAttribute(&quot;DlBandwidth&quot;, UintegerValue(bandwidth));
lteHelper-&gt;SetEnbDeviceAttribute(&quot;UlBandwidth&quot;, UintegerValue(bandwidth));
</pre></div>
</div>
<p>Now, each FR algorithms configuration will be described.</p>
<section id="hard-frequency-reuse-algorithm">
<h6><span class="section-number">20.2.20.1.1. </span>Hard Frequency Reuse Algorithm<a class="headerlink" href="#hard-frequency-reuse-algorithm" title="Link to this heading">¶</a></h6>
<p>As described in Section <a class="reference internal" href="index.html#sec-fr-hard-algorithm"><span class="std std-ref">Hard Frequency Reuse</span></a> of the Design Documentation
<code class="docutils literal notranslate"><span class="pre">ns3::LteFrHardAlgorithm</span></code> uses one sub-band. To configure this sub-band user need
to specify offset and bandwidth for DL and UL in number of RBs.</p>
<p>Hard Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DlSubBandOffset</span></code>: Downlink Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlSubBandwidth</span></code>: Downlink Transmission SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlSubBandOffset</span></code>: Uplink Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlSubBandwidth</span></code>: Uplink Transmission SubBandwidth Configuration in number of Resource Block Groups</p></li>
</ul>
</div></blockquote>
<p>Example configuration of LteFrHardAlgorithm can be done in following way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrHardAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlSubBandwidth&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlSubBandwidth&quot;, UintegerValue(8));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
<p>Above example allow eNB to use only RBs from 8 to 16 in DL and UL, while entire cell
bandwidth is 25.</p>
</section>
<section id="strict-frequency-reuse-algorithm">
<h6><span class="section-number">20.2.20.1.2. </span>Strict Frequency Reuse Algorithm<a class="headerlink" href="#strict-frequency-reuse-algorithm" title="Link to this heading">¶</a></h6>
<p>Strict Frequency Reuse Algorithm uses two sub-bands: one common for each cell and one
private. There is also RSRQ threshold, which is needed to decide within which sub-band
UE should be served. Moreover the power transmission in these sub-bands can be different.</p>
<p>Strict Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlCommonSubBandwidth</span></code>: Uplink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandOffset</span></code>: Uplink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandwidth</span></code>: Uplink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlCommonSubBandwidth</span></code>: Downlink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandOffset</span></code>: Downlink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandwidth</span></code>: Downlink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgePowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>Example below allow eNB to use RBs from 0 to 6 as common sub-band and from 12 to 18 as
private sub-band in DL and UL, RSRQ threshold is 20 dB, power in center area equals
<code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">3dB</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrStrictAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandOffset&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandOffset&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(20));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB_3));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgePowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterAreaTpc&quot;, UintegerValue(1));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeAreaTpc&quot;, UintegerValue(2));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
<section id="soft-frequency-reuse-algorithm">
<h6><span class="section-number">20.2.20.1.3. </span>Soft Frequency Reuse Algorithm<a class="headerlink" href="#soft-frequency-reuse-algorithm" title="Link to this heading">¶</a></h6>
<p>With Soft Frequency Reuse Algorithm, eNb uses entire cell bandwidth, but there are two
sub-bands, within UEs are served with different power level.</p>
<p>Soft Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandOffset</span></code>: Uplink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandwidth</span></code>: Uplink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandOffset</span></code>: Downlink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandwidth</span></code>: Downlink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AllowCenterUeUseEdgeSubBand</span></code>: If true center UEs can receive on edge sub-band RBGs, otherwise
edge sub-band is allowed only for edge UEs, default value is true</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgePowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>Example below configures RBs from 8 to 16 to be used by cell edge UEs and this sub-band
is not available for cell center users. RSRQ threshold is 20 dB, power in center area
equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFrSoftAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandwidth&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandOffset&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandwidth&quot;, UintegerValue(8));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;AllowCenterUeUseEdgeSubBand&quot;, BooleanValue(false));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(20));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgePowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
<section id="soft-fractional-frequency-reuse-algorithm">
<h6><span class="section-number">20.2.20.1.4. </span>Soft Fractional Frequency Reuse Algorithm<a class="headerlink" href="#soft-fractional-frequency-reuse-algorithm" title="Link to this heading">¶</a></h6>
<p>Soft Fractional Frequency Reuse (SFFR) uses three sub-bands: center, medium (common)
and edge. User have to configure only two of them: common and edge. Center sub-band
will be composed from the remaining bandwidth. Each sub-band can be served with
different transmission power. Since there are three sub-bands, two RSRQ thresholds needs to
be configured.</p>
<p>Soft Fractional Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlCommonSubBandwidth</span></code>: Uplink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandOffset</span></code>: Uplink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlEdgeSubBandwidth</span></code>: Uplink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlCommonSubBandwidth</span></code>: Downlink Common SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandOffset</span></code>: Downlink Edge SubBand Offset in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlEdgeSubBandwidth</span></code>: Downlink Edge SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterRsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in medium sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeRsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MediumAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for medium sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MediumAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in medium area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>In example below RBs from 0 to 6 will be used as common (medium) sub-band,
RBs from 6 to 12 will be used as edge sub-band and RBs from 12 to 24 will be used as
center sub-band (it is composed with remaining RBs). RSRQ threshold between center
and medium area is 28 dB, RSRQ threshold between medium and edge area is 18 dB.
Power in center area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">3dB</span></code>, power in medium area equals
<code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrSoftAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlCommonSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlEdgeSubBandwidth&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterRsrqThreshold&quot;, UintegerValue(28));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeRsrqThreshold&quot;, UintegerValue(18));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB_3));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;MediumAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
<section id="enhanced-fractional-frequency-reuse-algorithm">
<h6><span class="section-number">20.2.20.1.5. </span>Enhanced Fractional Frequency Reuse Algorithm<a class="headerlink" href="#enhanced-fractional-frequency-reuse-algorithm" title="Link to this heading">¶</a></h6>
<p>Enhanced Fractional Frequency Reuse (EFFR) reserve part of system bandwidth for each cell
(typically there are 3 cell types and each one gets 1/3 of system bandwidth). Then part of
this subbandwidth it used as <cite>Primary Segment</cite> with reuse factor 3 and as <cite>Secondary Segment</cite>
with reuse factor 1. User has to configure (for DL and UL) offset of the cell subbandwidth
in number of RB, number of RB which will be used as <cite>Primary Segment</cite> and number of RB which
will be used as <cite>Secondary Segment</cite>. <cite>Primary Segment</cite> is used by cell at will, but RBs from
<cite>Secondary Segment</cite> can be assigned to UE only is CQI feedback from this UE have higher value
than configured CQI threshold. UE is considered as edge UE when its RSRQ is lower than <code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>.</p>
<p>Since each eNb needs to know where are Primary and Secondary of other cell types,
it will calculate them assuming configuration is the same for each cell and only subbandwidth offsets
are different. So it is important to divide available system bandwidth equally to each cell and apply
the same configuration of Primary and Secondary Segments to them.</p>
<p>Enhanced Fractional Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UlSubBandOffset</span></code>: Uplink SubBand Offset for this cell in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlReuse3SubBandwidth</span></code>: Uplink Reuse 3 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlReuse1SubBandwidth</span></code>: Uplink Reuse 1 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlSubBandOffset</span></code>: Downlink SubBand Offset for this cell in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlReuse3SubBandwidth</span></code>: Downlink Reuse 3 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlReuse1SubBandwidth</span></code>: Downlink Reuse 1 SubBandwidth Configuration in number of Resource Block Groups</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for center sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaPowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlCqiThreshold</span></code>: If the DL-CQI for RBG of is higher than this threshold, transmission on RBG is possible</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UlCqiThreshold</span></code>: If the UL-CQI for RBG of is higher than this threshold, transmission on RBG is possible</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>In example below offset in DL and UL is 0 RB, 4 RB will be used in <cite>Primary Segment</cite> and
<cite>Secondary Segment</cite>. RSRQ threshold between center and edge area is 25 dB. DL and UL CQI
thresholds are set to value of 10. Power in center area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">6dB</span></code>,
power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">0dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrEnhancedAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(25));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlCqiThreshold&quot;, UintegerValue(10));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlCqiThreshold&quot;, UintegerValue(10));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB_6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeAreaPowerOffset&quot;,
                                    UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlReuse3SubBandwidth&quot;, UintegerValue(4));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;UlReuse1SubBandwidth&quot;, UintegerValue(4));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlSubBandOffset&quot;, UintegerValue(0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlReuse3SubBandwidth&quot;, UintegerValue(4));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;DlReuse1SubBandwidth&quot;, UintegerValue(4));
</pre></div>
</div>
</section>
<section id="distributed-fractional-frequency-reuse-algorithm">
<h6><span class="section-number">20.2.20.1.6. </span>Distributed Fractional Frequency Reuse Algorithm<a class="headerlink" href="#distributed-fractional-frequency-reuse-algorithm" title="Link to this heading">¶</a></h6>
<p>Distributed Fractional Frequency Reuse requires X2 interface between all eNB to be installed.
X2 interfaces can be installed only when EPC is configured, so this FFR scheme can be used only with
EPC scenarios.</p>
<p>With Distributed Fractional Frequency Reuse  Algorithm, eNb uses entire cell bandwidth and there can
be two sub-bands: center sub-band and edge sub-band . Within these sub-bands UEs can be served with
different power level. Algorithm adaptively selects RBs for cell-edge sub-band on basis of
coordination information (i.e. RNTP) from adjacent cells and notifies the base stations of the adjacent cells,
which RBs it selected to use in edge sub-band. If there are no UE classified as edge UE in cell,
eNB will not use any RBs as edge sub-band.</p>
<p>Distributed Fractional Frequency Reuse Algorithm provides following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CalculationInterval</span></code>: Time interval between calculation of Edge sub-band, Default value 1 second</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrqThreshold</span></code>: If the RSRQ of is worse than this threshold, UE should be served in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RsrpDifferenceThreshold</span></code>: If the difference between the power of the signal received by UE from
the serving cell and the power of the signal received from the adjacent cell is less than a
RsrpDifferenceThreshold value, the cell weight is incremented</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterPowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgePowerOffset</span></code>: PdschConfigDedicated::Pa value for edge sub-band, default value dB0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeRbNum</span></code>: Number of RB that can be used in edge sub-band</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CenterAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in center area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EdgeAreaTpc</span></code>: TPC value which will be set in DL-DCI for UEs in edge area,
Absolute mode is used, default value 1 is mapped to -1 according to TS36.213 Table 5.1.1.1-2</p></li>
</ul>
</div></blockquote>
<p>In example below calculation interval is 500 ms. RSRQ threshold between center and edge area is 25.
RSRP Difference Threshold is set to be 5. In DL and UL 6 RB will be used by each cell in edge sub-band.
Power in center area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">-</span> <span class="pre">0dB</span></code>, power in edge area equals <code class="docutils literal notranslate"><span class="pre">LteEnbPhy::TxPower</span> <span class="pre">+</span> <span class="pre">3dB</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrDistributedAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CalculationInterval&quot;, TimeValue(MilliSeconds(500)));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrqThreshold&quot;, UintegerValue(25));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;RsrpDifferenceThreshold&quot;, UintegerValue(5));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgeRbNum&quot;, UintegerValue(6));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;CenterPowerOffset&quot;,
                                     UintegerValue(LteRrcSap::PdschConfigDedicated::dB0));
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;EdgePowerOffset&quot;,
                                     UintegerValue(LteRrcSap::PdschConfigDedicated::dB3));
</pre></div>
</div>
</section>
</section>
<section id="automatic-configuration">
<h5><span class="section-number">20.2.20.2. </span>Automatic configuration<a class="headerlink" href="#automatic-configuration" title="Link to this heading">¶</a></h5>
<p>Frequency Reuse algorithms can also be configured in more “automatic” way by setting
only the bandwidth and FrCellTypeId. During initialization of FR instance, configuration
for set bandwidth and FrCellTypeId will be taken from configuration table. It is important
that only sub-bands will be configured, thresholds and transmission power will be set
to default values. If one wants, he/she can change thresholds and transmission power
as show in previous sub-section.</p>
<p>There are three FrCellTypeId : <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3</span></code>, which correspond to three different
configurations for each bandwidth. Three configurations allow to have different
configurations in neighbouring cells in hexagonal eNB layout. If user needs to have
more different configuration for neighbouring cells, he/she need to use manual
configuration.</p>
<p>Example below show automatic FR algorithm configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lteHelper-&gt;SetFfrAlgorithmType(&quot;ns3::LteFfrSoftAlgorithm&quot;);
lteHelper-&gt;SetFfrAlgorithmAttribute(&quot;FrCellTypeId&quot;, UintegerValue(1));
NetDeviceContainer enbDevs = lteHelper-&gt;InstallEnbDevice(enbNodes.Get(0));
</pre></div>
</div>
</section>
</section>
<section id="uplink-power-control">
<h4><span class="section-number">20.2.21. </span>Uplink Power Control<a class="headerlink" href="#uplink-power-control" title="Link to this heading">¶</a></h4>
<p>Uplink Power Control functionality is enabled by default. User can disable it by setting
the boolean attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteUePhy::EnableUplinkPowerControl</span></code> to true.</p>
<p>User can switch between Open Loop Power Control and Closed Loop Power Control mechanisms
by setting the boolean attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteUePowerControl::ClosedLoop</span></code>.
By default Closed Loop Power Control with Accumulation Mode is enabled.</p>
<p>Path-loss is key component of Uplink Power Control. It is computed as difference between
filtered RSRP and ReferenceSignalPower parameter. ReferenceSignalPower is
sent with SIB2.</p>
<p>Attributes available in Uplink Power Control:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ClosedLoop</span></code>: if true Closed Loop Uplink Power Control mode is enabled and Open Loop
Power Control otherwise, default value is false</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AccumulationEnabled</span></code>: if true Accumulation Mode is enabled and Absolute mode otherwise,
default value is false</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Alpha</span></code>: the path loss compensation factor, default value is 1.0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pcmin</span></code>: minimal UE TxPower, default value is -40 dBm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pcmax</span></code>: maximal UE TxPower, default value is 23 dBm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PoNominalPusch</span></code>: this parameter should be set by higher layers, but currently
it needs to be configured by attribute system, possible values are
integers in range (-126 … 24), Default value is -80</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PoUePusch</span></code>: this parameter should be set by higher layers, but currently
it needs to be configured by attribute system, possible values are
integers in range (-8 … 7), Default value is 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PsrsOffset</span></code>: this parameter should be set by higher layers, but currently
it needs to be configured by attribute system, possible values are
integers in range (0 … 15), Default value is 7, what gives P_Srs_Offset_Value = 0</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Traced values in Uplink Power Control:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ReportPuschTxPower</span></code>: Current UE TxPower for PUSCH</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReportPucchTxPower</span></code>: Current UE TxPower for PUCCH</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReportSrsTxPower</span></code>: Current UE TxPower for SRS</p></li>
</ul>
</dd>
</dl>
<p>Example configuration is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteUePhy::EnableUplinkPowerControl&quot;, BooleanValue(true));
Config::SetDefault(&quot;ns3::LteEnbPhy::TxPower&quot;, DoubleValue(30));
Config::SetDefault(&quot;ns3::LteUePowerControl::ClosedLoop&quot;, BooleanValue(true));
Config::SetDefault(&quot;ns3::LteUePowerControl::AccumulationEnabled&quot;, BooleanValue(true));
</pre></div>
</div>
<p>As an example, user can take a look and run the lena-uplink-power-control program.</p>
</section>
<section id="examples-programs">
<h4><span class="section-number">20.2.22. </span>Examples Programs<a class="headerlink" href="#examples-programs" title="Link to this heading">¶</a></h4>
<p>The directory <code class="docutils literal notranslate"><span class="pre">src/lte/examples/</span></code> contains some example simulation programs that
show how to simulate different LTE scenarios.</p>
</section>
<section id="reference-scenarios">
<h4><span class="section-number">20.2.23. </span>Reference scenarios<a class="headerlink" href="#reference-scenarios" title="Link to this heading">¶</a></h4>
<p>There is a vast amount of reference LTE simulation scenarios which can
be found in the literature. Here we list some of them:</p>
<blockquote>
<div><ul>
<li><p>The system simulation scenarios mentioned in section A.2 of <a class="reference internal" href="index.html#tr36814" id="id14"><span>[TR36814]</span></a>.</p></li>
<li><p>The dual stripe model <a class="reference internal" href="index.html#r4-092042" id="id15"><span>[R4-092042]</span></a>, which is partially implemented in the
example program <code class="docutils literal notranslate"><span class="pre">src/lte/examples/lena-dual-stripe.cc</span></code>. This example
program features a lot of configurable parameters which can be customized by
changing the corresponding global variables. To get a list of all these
global variables, you can run this command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./ns3 run lena-dual-stripe --command-template=&quot;%s --PrintGlobals&quot;
</pre></div>
</div>
<p>The following subsection presents an example of running a simulation
campaign using this example program.</p>
</li>
</ul>
</div></blockquote>
<section id="handover-simulation-campaign">
<h5><span class="section-number">20.2.23.1. </span>Handover simulation campaign<a class="headerlink" href="#handover-simulation-campaign" title="Link to this heading">¶</a></h5>
<p>In this subsection, we will demonstrate an example of running a simulation
campaign using the LTE module of <em>ns-3</em>. The objective of the campaign is to
compare the effect of each built-in handover algorithm of the LTE module.</p>
<p>The campaign will use the <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> example program. First, we have
to modify the example program to produce the output that we need. In this
occasion, we want to produce the number of handovers, user average throughput,
and average SINR.</p>
<p>The number of handovers can be obtained by counting the number of times the
<cite>HandoverEndOk</cite> <a class="reference internal" href="#sec-handover-traces"><span class="std std-ref">Handover traces</span></a> is fired. Then the user average
throughput can be obtained by enabling the RLC <a class="reference internal" href="#sec-simulation-output"><span class="std std-ref">Simulation Output</span></a>.
Finally, SINR can be obtained by enabling the PHY simulation output. The
following sample code snippet shows one possible way to obtain the above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void
NotifyHandoverEndOkUe(std::string context, uint64_t imsi,
                      uint16_t cellId, uint16_t rnti)
{
  std::cout &lt;&lt; &quot;Handover IMSI &quot; &lt;&lt; imsi &lt;&lt; std::endl;
}

int
main(int argc, char *argv[])
{
  /*** SNIP ***/

  Config::Connect(&quot;/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk&quot;,
                  MakeCallback(&amp;NotifyHandoverEndOkUe));

  lteHelper-&gt;EnablePhyTraces();
  lteHelper-&gt;EnableRlcTraces();
  Ptr&lt;RadioBearerStatsCalculator&gt; rlcStats = lteHelper-&gt;GetRlcStats();
  rlcStats-&gt;SetAttribute(&quot;StartTime&quot;, TimeValue(Seconds(0)));
  rlcStats-&gt;SetAttribute(&quot;EpochDuration&quot;, TimeValue(Seconds(simTime)));

  Simulator::Run();
  Simulator::Destroy();
  return 0;
}
</pre></div>
</div>
<p>Then we have to configure the parameters of the program to suit our simulation
needs. We are looking for the following assumptions in our simulation:</p>
<blockquote>
<div><ul class="simple">
<li><p>7 sites of tri-sectored macro eNodeBs (i.e. 21 macrocells) deployed in
hexagonal layout with 500 m inter-site distance.</p></li>
<li><p>Although <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> is originally intended for a two-tier
(macrocell and femtocell) simulation, we will simplify our simulation to
one-tier (macrocell) simulation only.</p></li>
<li><p>UEs are randomly distributed around the sites and attach to the network
automatically using Idle mode cell selection. After that, UE will roam the
simulation environment with 60 kmph movement speed.</p></li>
<li><p>50 seconds simulation duration, so UEs would have traveled far enough to
trigger some handovers.</p></li>
<li><p>46 dBm macrocell Tx power and 10 dBm UE Tx power.</p></li>
<li><p>EPC mode will be used because the X2 handover procedure requires it to be
enabled.</p></li>
<li><p>Full-buffer downlink and uplink traffic, both in 5 MHz bandwidth, using TCP
protocol and Proportional Fair scheduler.</p></li>
<li><p>Ideal RRC protocol.</p></li>
</ul>
</div></blockquote>
<p>Table <a class="reference internal" href="#tab-handover-campaign-program-parameter"><span class="std std-ref">lena-dual-stripe parameter configuration for handover campaign</span></a> below shows how we
configure the parameters of <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> to achieve the above
assumptions.</p>
<span id="tab-handover-campaign-program-parameter"></span><table class="docutils align-default" id="id20">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> parameter configuration for handover campaign</span><a class="headerlink" href="#id20" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>simTime</p></td>
<td><p>50</p></td>
<td><p>50 seconds simulation duration</p></td>
</tr>
<tr class="row-odd"><td><p>nBlocks</p></td>
<td><p>0</p></td>
<td><p>Disabling apartment buildings and femtocells</p></td>
</tr>
<tr class="row-even"><td><p>nMacroEnbSites</p></td>
<td><p>7</p></td>
<td><p>Number of macrocell sites (each site has 3
cells)</p></td>
</tr>
<tr class="row-odd"><td><p>nMacroEnbSitesX</p></td>
<td><p>2</p></td>
<td><p>The macrocell sites will be positioned in a
2-3-2 formation</p></td>
</tr>
<tr class="row-even"><td><p>interSiteDistance</p></td>
<td><p>500</p></td>
<td><p>500 m distance between adjacent macrocell sites</p></td>
</tr>
<tr class="row-odd"><td><p>macroEnbTxPowerDbm</p></td>
<td><p>46</p></td>
<td><p>46 dBm Tx power for each macrocell</p></td>
</tr>
<tr class="row-even"><td><p>epc</p></td>
<td><p>1</p></td>
<td><p>Enable EPC mode</p></td>
</tr>
<tr class="row-odd"><td><p>epcDl</p></td>
<td><p>1</p></td>
<td><p>Enable full-buffer DL traffic</p></td>
</tr>
<tr class="row-even"><td><p>epcUl</p></td>
<td><p>1</p></td>
<td><p>Enable full-buffer UL traffic</p></td>
</tr>
<tr class="row-odd"><td><p>useUdp</p></td>
<td><p>0</p></td>
<td><p>Disable UDP traffic and enable TCP instead</p></td>
</tr>
<tr class="row-even"><td><p>macroUeDensity</p></td>
<td><p>0.00002</p></td>
<td><p>Determines number of UEs (translates to 48 UEs
in our simulation)</p></td>
</tr>
<tr class="row-odd"><td><p>outdoorUeMinSpeed</p></td>
<td><p>16.6667</p></td>
<td><p>Minimum UE movement speed in m/s (60 kmph)</p></td>
</tr>
<tr class="row-even"><td><p>outdoorUeMaxSpeed</p></td>
<td><p>16.6667</p></td>
<td><p>Maximum UE movement speed in m/s (60 kmph)</p></td>
</tr>
<tr class="row-odd"><td><p>macroEnbBandwidth</p></td>
<td><p>25</p></td>
<td><p>5 MHz DL and UL bandwidth</p></td>
</tr>
<tr class="row-even"><td><p>generateRem</p></td>
<td><p>1</p></td>
<td><p>(Optional) For plotting the Radio Environment
Map</p></td>
</tr>
</tbody>
</table>
<p>Some of the required assumptions are not available as parameters of
<code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code>. In this case, we override the default attributes, as
shown in Table <a class="reference internal" href="#tab-handover-campaign-default-values"><span class="std std-ref">Overriding default attributes for handover campaign</span></a> below.</p>
<span id="tab-handover-campaign-default-values"></span><table class="docutils align-default" id="id21">
<caption><span class="caption-text">Overriding default attributes for handover campaign</span><a class="headerlink" href="#id21" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Default value name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ns3::LteHelper::HandoverAlgorithm</p></td>
<td><p><cite>ns3::NoOpHandoverAlgorithm</cite>,
<cite>ns3::A3RsrpHandoverAlgorithm</cite>, or
<cite>ns3::A2A4RsrqHandoverAlgorithm</cite></p></td>
<td><p>Choice of handover algorithm</p></td>
</tr>
<tr class="row-odd"><td><p>ns3::LteHelper::Scheduler</p></td>
<td><p><cite>ns3::PfFfMacScheduler</cite></p></td>
<td><p>Proportional Fair scheduler</p></td>
</tr>
<tr class="row-even"><td><p>ns3::LteHelper::UseIdealRrc</p></td>
<td><p>1</p></td>
<td><p>Ideal RRC protocol</p></td>
</tr>
<tr class="row-odd"><td><p>ns3::RadioBearerStatsCalculator::DlRlcOutputFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-DlRlcStats.txt</p></td>
<td><p>File name for DL RLC trace output</p></td>
</tr>
<tr class="row-even"><td><p>ns3::RadioBearerStatsCalculator::UlRlcOutputFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-UlRlcStats.txt</p></td>
<td><p>File name for UL RLC trace output</p></td>
</tr>
<tr class="row-odd"><td><p>ns3::PhyStatsCalculator::DlRsrpSinrFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-DlRsrpSinrStats.txt</p></td>
<td><p>File name for DL PHY RSRP/SINR trace output</p></td>
</tr>
<tr class="row-even"><td><p>ns3::PhyStatsCalculator::UlSinrFilename</p></td>
<td><p><cite>&lt;run&gt;</cite>-UlSinrStats.txt</p></td>
<td><p>File name for UL PHY SINR trace output</p></td>
</tr>
</tbody>
</table>
<p><em>ns-3</em> provides many ways for passing configuration values into a simulation. In
this example, we will use the command line arguments. It is basically done by
appending the parameters and their values to the <code class="docutils literal notranslate"><span class="pre">ns3</span></code> call when starting each
individual simulation. So the <code class="docutils literal notranslate"><span class="pre">ns3</span></code> calls for invoking our 3 simulations would
look as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::NoOpHandoverAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=no-op-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=no-op-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=no-op-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=no-op-UlSinrStats.txt
  --RngRun=1&quot; &gt; no-op.txt

$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::A3RsrpHandoverAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=a3-rsrp-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=a3-rsrp-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=a3-rsrp-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=a3-rsrp-UlSinrStats.txt
  --RngRun=1&quot; &gt; a3-rsrp.txt

$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::A2A4RsrqHandoverAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=a2-a4-rsrq-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=a2-a4-rsrq-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=a2-a4-rsrq-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=a2-a4-rsrq-UlSinrStats.txt
  --RngRun=1&quot; &gt; a2-a4-rsrq.txt
</pre></div>
</div>
<p>Some notes on the execution:</p>
<blockquote>
<div><ul class="simple">
<li><p>Notice that some arguments are not specified because they are already the
same as the default values. We also keep the handover algorithms on each own
default settings.</p></li>
<li><p>Note the file names of simulation output, e.g. RLC traces and PHY traces,
because we have to make sure that they are not overwritten by the next
simulation run. In this example, we specify the names one by one using the
command line arguments.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">--RngRun=1</span></code> argument at the end is used for setting the run number
used by the random number generator used in the simulation. We re-run the
same simulations with different <cite>RngRun</cite> values, hence creating several
independent replications of the same simulations. Then we average the
results obtained from these replications to achieve some statistical
confidence.</p></li>
<li><p>We can add a <code class="docutils literal notranslate"><span class="pre">--generateRem=1</span></code> argument to generate the files necessary for
generating the Radio Environment Map (REM) of the simulation. The result is
Figure <a class="reference internal" href="#fig-lte-handover-campaign-rem"><span class="std std-ref">REM obtained from a simulation in handover campaign</span></a> below, which can be produced by
following the steps described in Section <a class="reference internal" href="#sec-radio-environment-maps"><span class="std std-ref">Radio Environment Maps</span></a>.
This figure also shows the position of eNodeBs and UEs at the beginning of a
simulation using <code class="docutils literal notranslate"><span class="pre">RngRun</span> <span class="pre">=</span> <span class="pre">1</span></code>. Other values of <cite>RngRun</cite> may produce
different UE position.</p></li>
</ul>
</div></blockquote>
<figure class="align-center" id="id22">
<span id="fig-lte-handover-campaign-rem"></span><img alt="_images/lte-handover-campaign-rem.png" src="_images/lte-handover-campaign-rem.png" />
<figcaption>
<p><span class="caption-text">REM obtained from a simulation in handover campaign</span><a class="headerlink" href="#id22" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>After hours of running, the simulation campaign will eventually end. Next we
will perform some post-processing on the produced simulation output to obtain
meaningful information out of it.</p>
<p>In this example, we use GNU Octave to assist the processing of throughput and
SINR data, as demonstrated in a sample GNU Octave script below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% RxBytes is the 10th column
DlRxBytes = load (&quot;no-op-DlRlcStats.txt&quot;) (:,10);
DlAverageThroughputKbps = sum (DlRxBytes) * 8 / 1000 / 50

% RxBytes is the 10th column
UlRxBytes = load (&quot;no-op-UlRlcStats.txt&quot;) (:,10);
UlAverageThroughputKbps = sum (UlRxBytes) * 8 / 1000 / 50

% Sinr is the 6th column
DlSinr = load (&quot;no-op-DlRsrpSinrStats.txt&quot;) (:,6);
% eliminate NaN values
idx = isnan (DlSinr);
DlSinr (idx) = 0;
DlAverageSinrDb = 10 * log10 (mean (DlSinr)) % convert to dB

% Sinr is the 5th column
UlSinr = load (&quot;no-op-UlSinrStats.txt&quot;) (:,5);
% eliminate NaN values
idx = isnan (UlSinr);
UlSinr (idx) = 0;
UlAverageSinrDb = 10 * log10 (mean (UlSinr)) % convert to dB
</pre></div>
</div>
<p>As for the number of handovers, we can use simple shell scripting to count the
number of occurrences of string “Handover” in the log file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ grep &quot;Handover&quot; no-op.txt | wc -l
</pre></div>
</div>
<p>Table <a class="reference internal" href="#tab-handover-campaign-results"><span class="std std-ref">Results of handover campaign</span></a> below shows the complete statistics
after we are done with post-processing on every individual simulation run. The
values shown are the average of the results obtained from <code class="docutils literal notranslate"><span class="pre">RngRun</span></code> of 1, 2, 3,
and 4.</p>
<span id="tab-handover-campaign-results"></span><table class="docutils align-default" id="id23">
<caption><span class="caption-text">Results of handover campaign</span><a class="headerlink" href="#id23" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Statistics</p></th>
<th class="head"><p>No-op</p></th>
<th class="head"><p>A2-A4-RSRQ</p></th>
<th class="head"><p>Strongest cell</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Average DL system throughput</p></td>
<td><p>6 615 kbps</p></td>
<td><p>20 509 kbps</p></td>
<td><p>19 709 kbps</p></td>
</tr>
<tr class="row-odd"><td><p>Average UL system throughput</p></td>
<td><p>4 095 kbps</p></td>
<td><p>5 705 kbps</p></td>
<td><p>6 627 kbps</p></td>
</tr>
<tr class="row-even"><td><p>Average DL SINR</p></td>
<td><p>-0.10 dB</p></td>
<td><p>5.19 dB</p></td>
<td><p>5.24 dB</p></td>
</tr>
<tr class="row-odd"><td><p>Average UL SINR</p></td>
<td><p>9.54 dB</p></td>
<td><p>81.57 dB</p></td>
<td><p>79.65 dB</p></td>
</tr>
<tr class="row-even"><td><p>Number of handovers per UE per second</p></td>
<td><p>0</p></td>
<td><p>0.05694</p></td>
<td><p>0.04771</p></td>
</tr>
</tbody>
</table>
<p>The results show that having a handover algorithm in a mobility simulation
improves both user throughput and SINR significantly. There is little difference
between the two handover algorithms in this campaign scenario. It would be
interesting to see their performance in different scenarios, such as scenarios
with home eNodeBs deployment.</p>
</section>
<section id="frequency-reuse-examples">
<h5><span class="section-number">20.2.23.2. </span>Frequency Reuse examples<a class="headerlink" href="#frequency-reuse-examples" title="Link to this heading">¶</a></h5>
<p>There are two examples showing Frequency Reuse Algorithms functionality.</p>
<p><code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> is simple example with 3 eNBs in triangle layout.
There are 3 cell edge UEs, which are located in the center of this triangle and
3 cell center UEs (one near each eNB). User can also specify the number of randomly
located UEs. FR algorithm is installed in eNBs and each eNB has different FrCellTypeId,
what means each eNB uses different FR configuration. User can run <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code>
with 6 different FR algorithms: NoOp, Hard FR, Strict FR, Soft FR, Soft FFR and Enhanced FFR.
To run scenario with Distributed FFR algorithm, user should use <code class="docutils literal notranslate"><span class="pre">lena-distributed-ffr</span></code>.
These two examples are very similar, but they were split because Distributed FFR requires
EPC to be used, and other algorithms do not.</p>
<p>To run <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> with different Frequency Reuse algorithms, user needs to specify
FR algorithm by overriding the default attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::FfrAlgorithm</span></code>.
Example command to run <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> with Soft FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-frequency-reuse --ns3::LteHelper::FfrAlgorithm=ns3::LteFrSoftAlgorithm&quot;
</pre></div>
</div>
<p>In these examples functionality to generate REM and spectrum analyzer trace was added.
User can enable generation of it by setting <code class="docutils literal notranslate"><span class="pre">generateRem</span></code> and <code class="docutils literal notranslate"><span class="pre">generateSpectrumTrace</span></code>
attributes.</p>
<p>Command to generate REM for RB 1 in data channel from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> scenario
with Soft FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-frequency-reuse --ns3::LteHelper::FfrAlgorithm=ns3::LteFrSoftAlgorithm
  --generateRem=true --remRbId=1&quot;
</pre></div>
</div>
<p>Radio Environment Map for Soft FR is presented in Figure <a class="reference internal" href="#fig-lte-soft-fr-1-rem"><span class="std std-ref">REM for RB 1 obtained from lena-frequency-reuse example with Soft FR
algorithm enabled</span></a>.</p>
<figure class="align-center" id="id24">
<span id="fig-lte-soft-fr-1-rem"></span><img alt="_images/lte-fr-soft-1-rem.png" src="_images/lte-fr-soft-1-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 1 obtained from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> example with Soft FR
algorithm enabled</span><a class="headerlink" href="#id24" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Command to generate spectrum trace from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> scenario
with Soft FFR algorithm is presented below (Spectrum Analyzer position needs to be configured
inside script):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-frequency-reuse --ns3::LteHelper::FfrAlgorithm=ns3::LteFfrSoftAlgorithm
  --generateSpectrumTrace=true&quot;
</pre></div>
</div>
<p>Example spectrum analyzer trace is presented in figure <a class="reference internal" href="#fig-lte-soft-ffr-2-spectrum-trace"><span class="std std-ref">Spectrum Analyzer trace obtained from lena-frequency-reuse example
with Soft FFR algorithm enabled. Spectrum Analyzer was located need eNB
with FrCellTypeId 2.</span></a>.
As can be seen, different data channel subbands are sent with different power level
(according to configuration), while control channel is transmitted with uniform power
along entire system bandwidth.</p>
<figure class="align-center" id="id25">
<span id="fig-lte-soft-ffr-2-spectrum-trace"></span><img alt="_images/lte-ffr-soft-2-spectrum-trace.png" src="_images/lte-ffr-soft-2-spectrum-trace.png" />
<figcaption>
<p><span class="caption-text">Spectrum Analyzer trace obtained from <code class="docutils literal notranslate"><span class="pre">lena-frequency-reuse</span></code> example
with Soft FFR algorithm enabled. Spectrum Analyzer was located need eNB
with FrCellTypeId 2.</span><a class="headerlink" href="#id25" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> can be also run with Frequency Reuse algorithms installed in all macro eNB.
User needs to specify FR algorithm by overriding the default attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::FfrAlgorithm</span></code>.
Example command to run <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> with Hard FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=1 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::NoOpHandoverAlgorithm
  --ns3::LteHelper::FfrAlgorithm=ns3::LteFrHardAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=no-op-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=no-op-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=no-op-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=no-op-UlSinrStats.txt
  --RngRun=1&quot; &gt; no-op.txt
</pre></div>
</div>
<p>Example command to generate REM for RB 1 in data channel from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> scenario
with Hard FR algorithm is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run &quot;lena-dual-stripe
  --simTime=50 --nBlocks=0 --nMacroEnbSites=7 --nMacroEnbSitesX=2
  --epc=0 --useUdp=0 --outdoorUeMinSpeed=16.6667 --outdoorUeMaxSpeed=16.6667
  --ns3::LteHelper::HandoverAlgorithm=ns3::NoOpHandoverAlgorithm
  --ns3::LteHelper::FfrAlgorithm=ns3::LteFrHardAlgorithm
  --ns3::RadioBearerStatsCalculator::DlRlcOutputFilename=no-op-DlRlcStats.txt
  --ns3::RadioBearerStatsCalculator::UlRlcOutputFilename=no-op-UlRlcStats.txt
  --ns3::PhyStatsCalculator::DlRsrpSinrFilename=no-op-DlRsrpSinrStats.txt
  --ns3::PhyStatsCalculator::UlSinrFilename=no-op-UlSinrStats.txt
  --RngRun=1 --generateRem=true --remRbId=1&quot; &gt; no-op.txt
</pre></div>
</div>
<p>Radio Environment Maps for RB 1, 10 and 20 generated from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code>
scenario with Hard Frequency Reuse algorithm are presented in the figures
below. These RB were selected because each one is used by different FR cell type.</p>
<figure class="align-center" id="id26">
<span id="fig-lte-hard-fr-1-rem"></span><img alt="_images/lte-fr-hard-1-rem.png" src="_images/lte-fr-hard-1-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 1 obtained from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> simulation with Hard FR algorithm enabled</span><a class="headerlink" href="#id26" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id27">
<span id="fig-lte-hard-fr-2-rem"></span><img alt="_images/lte-fr-hard-2-rem.png" src="_images/lte-fr-hard-2-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 10 obtained from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> simulation with Hard FR algorithm enabled</span><a class="headerlink" href="#id27" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id28">
<span id="fig-lte-hard-fr-3-rem"></span><img alt="_images/lte-fr-hard-3-rem.png" src="_images/lte-fr-hard-3-rem.png" />
<figcaption>
<p><span class="caption-text">REM for RB 20 obtained from <code class="docutils literal notranslate"><span class="pre">lena-dual-stripe</span></code> simulation with Hard FR algorithm enabled</span><a class="headerlink" href="#id28" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="carrier-aggregation-examples">
<h4><span class="section-number">20.2.24. </span>Carrier aggregation examples<a class="headerlink" href="#carrier-aggregation-examples" title="Link to this heading">¶</a></h4>
<p>The carrier aggregation feature is not enabled by default. The user can enable it by setting the boolean attribute
<code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::UseCa</span></code> to true. The number of component carriers to be used in carrier aggregation can
be configured by setting the attribute <code class="docutils literal notranslate"><span class="pre">ns3::LteHelper::NumberOfComponentCarriers</span></code>. Currently the
maximum number is 5. Additionally, the component carrier manager needs to be configured. By default
the <code class="docutils literal notranslate"><span class="pre">NoOpComponentCarrierManager</span></code> is selected, which means that only the primary carrier is enabled. The Component
carrier manager (CCM) implementation that uses all the available carriers is <code class="docutils literal notranslate"><span class="pre">RrComponentCarrierManager</span></code>.
The CCM can be configured by using the attribute <code class="docutils literal notranslate"><span class="pre">LteHelper::EnbComponentCarrierManager</span></code>.</p>
<p>An example configuration is presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteHelper::UseCa&quot;, BooleanValue(useCa));
Config::SetDefault(&quot;ns3::LteHelper::NumberOfComponentCarriers&quot;, UintegerValue(2));
Config::SetDefault(&quot;ns3::LteHelper::EnbComponentCarrierManager&quot;, StringValue(&quot;ns3::RrComponentCarrierManager&quot;));
</pre></div>
</div>
<p>As an example, the user can take a look and run the <code class="docutils literal notranslate"><span class="pre">lena-simple</span></code> and <code class="docutils literal notranslate"><span class="pre">lena-simple-epc</span></code> programs and enable LTE traces
to check the performance. A new column is added to PHY and MAC traces to indicate the component carrier.</p>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-carrier-aggregation</span></code> is also a test program that can be used as an example as it can be run in a mode to write results
to output files by setting the <code class="docutils literal notranslate"><span class="pre">s_writeResults</span></code> boolean static variable to true. The test can be run by using a <cite>test-runner</cite>:</p>
<blockquote>
<div><p>./ns3 run ‘test-runner –suite=lte-carrier-aggregation’</p>
</div></blockquote>
<p>To plot the test results, a file has to be created in the root folder of the ns-3 repository, and added to it with the following content :</p>
<blockquote>
<div><p>set terminal png
set xlabel “Number of users”
set ylabel “Throughput per UE [Mbps]”
set key top right</p>
<p>downlink_results=”carrier_aggregation_results_dl.txt”
uplink_results=”carrier_aggregation_results_ul.txt”</p>
<p>set output “ca-test-example-dl.png”
set title “Downlink performance”</p>
<dl class="simple">
<dt>plot downlink_results using 1:($2==1 ? $3/1000000<span class="classifier">1/0) w lp t ‘NO SDL’, </span></dt><dd><p>downlink_results using 1:($2==2 ? $3/1000000 : 1/0) w lp t ‘RR SDL 1’, downlink_results using 1:($2==3 ? $3/1000000 : 1/0) w lp t ‘RR SDL 2’</p>
</dd>
</dl>
<p>set output “ca-test-example-ul.png”
set title “Uplink performance”</p>
<dl class="simple">
<dt>plot uplink_results using 1:($2==1 ? $3/1000000<span class="classifier">1/0) w lp t ‘NO SDL’, </span></dt><dd><p>uplink_results using 1:($2==2 ? $3/1000000 : 1/0) w lp t ‘RR SDL 1’, uplink_results using 1:($2==3 ? $3/1000000 : 1/0) w lp t ‘RR SDL 2’</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">gnuplot</span></code> can be run by providing the file name, so that in the ns-3 root directory
figures are generated. An example to run this test suite is shown in figures:
<cite>fig-ca-test-example-ul</cite> and <cite>fig-ca-test-example-dl</cite>.</p>
<figure class="align-center" id="id29">
<span id="fig-ca-test-example-ul"></span><a class="reference internal image-reference" href="_images/ca-test-example-ul.png"><img alt="_images/ca-test-example-ul.png" src="_images/ca-test-example-ul.png" style="width: 384.0px; height: 288.0px;" /></a>
<figcaption>
<p><span class="caption-text">Example of CA test performance in the uplink</span><a class="headerlink" href="#id29" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id30">
<span id="fig-ca-test-example-dl"></span><a class="reference internal image-reference" href="_images/ca-test-example-dl.png"><img alt="_images/ca-test-example-dl.png" src="_images/ca-test-example-dl.png" style="width: 384.0px; height: 288.0px;" /></a>
<figcaption>
<p><span class="caption-text">Example of CA test performance in the downlink</span><a class="headerlink" href="#id30" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="radio-link-failure-example">
<h4><span class="section-number">20.2.25. </span>Radio link failure example<a class="headerlink" href="#radio-link-failure-example" title="Link to this heading">¶</a></h4>
<p>The example <em>lena-radio-link-failure.cc</em> is an example to simulate the RLF
functionality. In particular, it simulates only one moving UE using <em>Ideal</em> or <em>Real</em>
RRC protocol with EPC performing downlink and uplink communication in two
scenarios shown in <a class="reference internal" href="#lena-radio-link-failure-one-enb"><span class="std std-ref">Scenario A: Radio link failure example with one eNB</span></a> and
<a class="reference internal" href="#lena-radio-link-failure-two-enb"><span class="std std-ref">Scenario B: Radio link failure example with two eNBs</span></a></p>
<figure class="align-center" id="id31">
<span id="lena-radio-link-failure-one-enb"></span><img alt="_images/lena-radio-link-failure-one-enb.png" src="_images/lena-radio-link-failure-one-enb.png" />
<figcaption>
<p><span class="caption-text">Scenario A: Radio link failure example with one eNB</span><a class="headerlink" href="#id31" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We note that, the RLF detection is enabled by default, which can be disabled by
configuring the <code class="docutils literal notranslate"><span class="pre">LteUePhy::EnableRlfDetection</span></code> to false, e.g.,:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Config::SetDefault(&quot;ns3::LteUePhy::EnableRlfDetection&quot;, BooleanValue(false));
</pre></div>
</div>
<p>In this example, to study the impact of a RLF on the user’s quality of experience,
we compute an instantaneous (i.e., every 200 ms) DL throughput of the UE, and
writes it into a file for plotting purposes. For example, to simulate the “Scenario
A” with <em>Ideal</em> and <em>Real</em> RRC protocol a user can use the following commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ideal RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=1 --useIdealRrc=1
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;

Real RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=1 --useIdealRrc=0
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;
</pre></div>
</div>
<p>After running the above two commands, we can use a simple gnuplot script to plot
the throughput as shown in the Figure <a class="reference internal" href="#fig-lena-radio-link-failure-one-enb-thrput"><span class="std std-ref">Downlink instantaneous throughput of UE in scenario A</span></a>
, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set terminal png
set output  &quot;lena-radio-link-failure-one-enb-thrput.png&quot;
set multiplot
set xlabel &quot;Time [s]&quot;
set ylabel &quot;Instantaneous throughput UE [Mbps]&quot;
set grid
set title &quot;LTE RLF example 1 eNB DL instantaneous throughput&quot;
plot &quot;rlf_dl_thrput_1_eNB_ideal_rrc&quot; using ($1):($2) with linespoints
title &#39;Ideal RRC&#39; linestyle 1 lw 2 lc rgb &#39;blue&#39;, &quot;rlf_dl_thrput_1_eNB_real_rrc&quot;
using ($1):($2) with linespoints title &#39;Real RRC&#39; linestyle 2 lw 2 lc rgb &#39;red&#39;

unset multiplot
</pre></div>
</div>
<figure class="align-center" id="id32">
<span id="fig-lena-radio-link-failure-one-enb-thrput"></span><img alt="_images/lena-radio-link-failure-one-enb-thrput.png" src="_images/lena-radio-link-failure-one-enb-thrput.png" />
<figcaption>
<p><span class="caption-text">Downlink instantaneous throughput of UE in scenario A</span><a class="headerlink" href="#id32" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In the simulator, a UE can synchronize (i.e., start reading system information)
with an eNB at a low RSRP level, which defaults to -140 dBm (see QRxLevMin attribute of eNB RRC).
It enables the UE to start the random access procedure with the eNB. In this scenario,
when using the <em>Ideal</em> RRC the UE after the RLF will connect and disconnect from
the eNB several times. This is because in the <em>Ideal</em> RRC mode, once the UE is
able to receive Random Access Response (RAR) from the eNB, it can complete the
RRC connection establishment procedure
(<a class="reference internal" href="index.html#sec-rrc-connection-establishment"><span class="std std-ref">RRC connection establishment</span></a>) without any
errors, since all the RRC messages are exchanged ideally between the eNB and the UE.
However, soon after the connection establishment, it ends up in RLF due to the
poor channel quality. On the other hand, with the <em>Real</em> RRC the UE after the RLF
will not be able to complete the RRC connection establishment procedure due to
the loss of RRC messages. Thus, it will not be able to establish the connection
with the eNB. Therefore, in both the cases the UE throughput drops to zero as shown in the
Figure <a class="reference internal" href="#fig-lena-radio-link-failure-one-enb-thrput"><span class="std std-ref">Downlink instantaneous throughput of UE in scenario A</span></a>. It is also worthwhile
to mention that towards the end of the simulation (using <em>Ideal</em> or <em>Real</em> RRC)
there are occasions where RAR timer at the UE MAC would timeout due to the
increased distance between the eNB and the UE, which causes errors while decoding
this message at the UE (Note: the downlink control error model is enabled by default).</p>
<figure class="align-center" id="id33">
<span id="lena-radio-link-failure-two-enb"></span><img alt="_images/lena-radio-link-failure-two-enb.png" src="_images/lena-radio-link-failure-two-enb.png" />
<figcaption>
<p><span class="caption-text">Scenario B: Radio link failure example with two eNBs</span><a class="headerlink" href="#id33" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Similarly, to simulate the “Scenario B” with <em>Ideal</em> and <em>Real</em> RRC protocol
following commands can be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ideal RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=2 --useIdealRrc=1
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;

Real RRC:
./ns3 run &quot;lena-radio-link-failure
--numberOfEnbs=2 --useIdealRrc=0
--interSiteDistance=1200 --n310=1 --n311=1
--t310=1 --enableCtrlErrorModel=1
--enableDataErrorModel=1 --simTime=25&quot;
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fig-lena-radio-link-failure-two-enb-thrput"><span class="std std-ref">Downlink instantaneous throughput of UE in scenario B</span></a>, shows the throughput
in “Scenario B”. We note that in this scenario the handover algorithm is not used.
As expected, with <em>Ideal</em> RRC protocol the UE after the RLF can complete
the random access procedure with the second eNB. Interestingly, the DL SINR after
the connection establishment is not low enough to trigger the RLF, but it is
low enough to impact the DL control reception for some TBs, which in turn causes
loss of data. It can be observed from the slightly unstable throughput of the UE
after connecting to the second eNB. On the other hand, with <em>Real</em> RRC the UE faces
problems in connection establishment phase due to the loss of RRC messages, in
particular, the RRC connection request from the UE. This is the reason why the
UE throughput after the RLF remains zero for a more extended period as compared
to the <em>ideal</em> RRC protocol.</p>
<figure class="align-center" id="id34">
<span id="fig-lena-radio-link-failure-two-enb-thrput"></span><img alt="_images/lena-radio-link-failure-two-enb-thrput.png" src="_images/lena-radio-link-failure-two-enb-thrput.png" />
<figcaption>
<p><span class="caption-text">Downlink instantaneous throughput of UE in scenario B</span><a class="headerlink" href="#id34" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="troubleshooting-and-debugging-tips">
<h4><span class="section-number">20.2.26. </span>Troubleshooting and debugging tips<a class="headerlink" href="#troubleshooting-and-debugging-tips" title="Link to this heading">¶</a></h4>
<p>Many users post on the ns-3-users mailing list asking, for example,
why they do not get any traffic in their simulation, or maybe only
uplink but no downlink traffic is generated, etc. In most of the cases,
this is a bug in the user simulation program. Here the reader can find some
tips to debug the program and find out the cause of the problem.</p>
<p>The general approach is to selectively and incrementally enable the logging
of relevant LTE module components, verifying upon each activation that the
output is as expected. In detail:</p>
<blockquote>
<div><ul class="simple">
<li><p>first check the control plane, in particular the RRC connection
establishment procedure, by enabling the log components LteUeRrc and LteEnbRrc</p></li>
<li><p>then check packet transmissions on the data plane, starting by
enabling the log components LteUeNetDevice and the
EpcSgwApplication, EpcPgwApplication and EpcEnbApplication, then moving down the
LTE radio stack (PDCP, RLC, MAC, and finally PHY). All this until
you find where packets stop being processed / forwarded.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<span id="document-lte-testing"></span><section id="testing-documentation">
<h3><span class="section-number">20.3. </span>Testing Documentation<a class="headerlink" href="#testing-documentation" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4><span class="section-number">20.3.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>To test and validate the ns-3 LTE module, several test suites are provided which are integrated with the ns-3 test framework.
To run them, you need to have configured the build of the simulator in this way:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-tests<span class="w"> </span>--enable-modules<span class="o">=</span>lte<span class="w"> </span>--enable-examples
$<span class="w"> </span>./test.py
</pre></div>
</div>
<p>The above will run not only the test suites belonging to the LTE module, but also those belonging to all the other ns-3 modules on which the LTE module depends. See the ns-3 manual for generic information on the testing framework.</p>
<p>You can get a more detailed report in HTML format in this way:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./test.py<span class="w"> </span>-w<span class="w"> </span>results.html
</pre></div>
</div>
<p>After the above command has run, you can view the detailed result for each test by opening the file <code class="docutils literal notranslate"><span class="pre">results.html</span></code> with a web browser.</p>
<p>You can run each test suite separately using this command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>test-suite-name
</pre></div>
</div>
<p>For more details about <code class="docutils literal notranslate"><span class="pre">test.py</span></code> and the ns-3 testing framework, please refer to the ns-3 manual.</p>
</section>
<section id="description-of-the-test-suites">
<h4><span class="section-number">20.3.2. </span>Description of the test suites<a class="headerlink" href="#description-of-the-test-suites" title="Link to this heading">¶</a></h4>
<section id="unit-tests">
<h5><span class="section-number">20.3.2.1. </span>Unit Tests<a class="headerlink" href="#unit-tests" title="Link to this heading">¶</a></h5>
<section id="sinr-calculation-in-the-downlink">
<h6><span class="section-number">20.3.2.1.1. </span>SINR calculation in the Downlink<a class="headerlink" href="#sinr-calculation-in-the-downlink" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-downlink-sinr</span></code>
checks that the SINR calculation in
downlink is performed correctly. The SINR in the downlink is calculated for each
RB assigned to data transmissions by dividing the power of the
intended signal from the considered eNB by the sum of the noise power plus all
the transmissions on the same RB coming from other eNBs (the interference
signals):</p>
<div class="math">
<p><img src="_images/math/28484b1073fba52353d75545588781fdb05043f6.png" alt="\gamma = \frac{ P_\mathrm{signal} }{ P_\mathrm{noise} + \sum P_\mathrm{interference} }"/></p>
</div><p>In general, different signals can be active during different periods
of time. We define a <em>chunk</em> as the time interval between any two
events of type either start or end of a waveform. In other words, a
chunk identifies a time interval during which the set of active
waveforms does not change. Let <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> be the generic chunk,
<img class="math" src="_images/math/db063ac3b718da47702b1dbb3c52d3feac13333b.png" alt="T_i"/> its duration and <img class="math" src="_images/math/a977acc9184b6a4e44fd2967a39ad72fe5e977ce.png" alt="\mathrm{SINR_i}"/> its SINR,
calculated with the above equation. The calculation of the average
SINR <img class="math" src="_images/math/798e66d3d5e9ba0f585aa4b233b3b325ca579412.png" alt="\overline{\gamma}"/> to be used for CQI feedback reporting
uses the following formula:</p>
<div class="math">
<p><img src="_images/math/85025a8c28e6c72641bdfd413da392fc26d2601f.png" alt="\overline{\gamma} = \frac{ \sum_i {\gamma}_i  T_i }{ \sum_i T_{i} }"/></p>
</div><p>The test suite checks that the above calculation is performed
correctly in the simulator. The test vectors are obtained offline by
an Octave script that implements the above equation, and that
recreates a number of random transmitted signals and interference
signals that mimic a scenario where an UE is trying to decode a signal
from an eNB while facing interference from other eNBs. The test passes
if the calculated values are equal to the test vector within a
tolerance of <img class="math" src="_images/math/df048aa37b785a8082d34feb1e133dd438e73fa3.png" alt="10^{-7}"/>. The tolerance is meant to account for
the approximation errors typical of floating point arithmetic.</p>
</section>
<section id="sinr-calculation-in-the-uplink">
<h6><span class="section-number">20.3.2.1.2. </span>SINR calculation in the Uplink<a class="headerlink" href="#sinr-calculation-in-the-uplink" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-uplink-sinr</span></code> checks that the SINR calculation in
uplink is performed correctly. This test suite is identical to
<code class="docutils literal notranslate"><span class="pre">lte-downlink-sinr</span></code> described in the previous section, with the
difference than both the signal and the interference now refer to
transmissions by the UEs, and reception is performed by the eNB.
This test suite recreates a number of random transmitted signals and
interference signals to mimic a scenario where an eNB is trying to
decode the signal from several UEs simultaneously (the ones in the
cell of the eNB) while facing interference from other UEs (the ones
belonging to other cells).</p>
<p>The test vectors are obtained by a dedicated Octave script. The test
passes if the calculated values are equal to the test vector within a
tolerance of <img class="math" src="_images/math/df048aa37b785a8082d34feb1e133dd438e73fa3.png" alt="10^{-7}"/> which, as for the downlink SINR test,
deals with floating point arithmetic approximation issues.</p>
</section>
<section id="e-utra-absolute-radio-frequency-channel-number-earfcn">
<h6><span class="section-number">20.3.2.1.3. </span>E-UTRA Absolute Radio Frequency Channel Number (EARFCN)<a class="headerlink" href="#e-utra-absolute-radio-frequency-channel-number-earfcn" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-earfcn</span></code> checks that the carrier frequency used
by the LteSpectrumValueHelper class (which implements the LTE spectrum
model) is done in compliance with <a class="reference internal" href="index.html#ts36101" id="id1"><span>[TS36101]</span></a>, where the E-UTRA
Absolute Radio Frequency Channel Number (EARFCN) is defined. The test
vector for this test suite comprises a set of EARFCN values and the
corresponding carrier frequency calculated by hand following the
specification of <a class="reference internal" href="index.html#ts36101" id="id2"><span>[TS36101]</span></a>. The test passes if the carrier frequency
returned by LteSpectrumValueHelper is the same as the known value for
each element in the test vector.</p>
</section>
</section>
<section id="system-tests">
<h5><span class="section-number">20.3.2.2. </span>System Tests<a class="headerlink" href="#system-tests" title="Link to this heading">¶</a></h5>
<section id="dedicated-bearer-deactivation-tests">
<h6><span class="section-number">20.3.2.2.1. </span>Dedicated Bearer Deactivation Tests<a class="headerlink" href="#dedicated-bearer-deactivation-tests" title="Link to this heading">¶</a></h6>
<p>The test suite ‘lte-test-deactivate-bearer’ creates test case with single EnodeB and Three UE’s.
Each UE consists of one Default and one Dedicated EPS bearer with same bearer specification but with different ARP.
Test Case Flow is as follows:
Attach UE -&gt; Create Default+Dedicated Bearer -&gt; Deactivate one of the Dedicated bearer</p>
<p>Test case further deactivates dedicated bearer having bearer ID 2(LCID=BearerId+2) of First UE (UE_ID=1)
User can schedule bearer deactivation after specific time delay using Simulator::Schedule () method.</p>
<p>Once the test case execution ends it will create <code class="docutils literal notranslate"><span class="pre">DlRlcStats.txt</span></code> and <code class="docutils literal notranslate"><span class="pre">UlRlcStats.txt</span></code>. Key fields that need to be checked in statistics are:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="p">|</span>Start<span class="w"> </span><span class="p">|</span><span class="w"> </span>end<span class="w"> </span><span class="p">|</span><span class="w"> </span>Cell<span class="w"> </span>ID<span class="w"> </span><span class="p">|</span><span class="w"> </span>IMSI<span class="w"> </span><span class="p">|</span><span class="w"> </span>RNTI<span class="w"> </span><span class="p">|</span><span class="w"> </span>LCID<span class="w"> </span><span class="p">|</span><span class="w"> </span>TxBytes<span class="w"> </span><span class="p">|</span><span class="w"> </span>RxBytes<span class="w"> </span><span class="p">|</span>
</pre></div>
</div>
<p>Test case executes in three epochs:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>In first Epoch (0.04s-1.04s) All UE’s and corresponding bearers gets attached and packet flow over the dedicated bearers activated.</p></li>
<li><p>In second Epoch (1.04s-2.04s), bearer deactivation is instantiated, hence User can see relatively less number of TxBytes on UE_ID=1 and LCID=4 as compared to other bearers.</p></li>
<li><p>In third Epoch (2.04s-3.04s) since bearer deactivation of UE_ID=1 and LCID=4 is completed, user will not see any logging related to LCID=4.</p></li>
</ol>
</div></blockquote>
<p>Test case passes if and only if</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>IMSI=1 and LCID=4 completely removed in third epoch</p></li>
<li><p>No packets seen in TxBytes and RxBytes corresponding to IMSI=1 and LCID=4</p></li>
</ol>
</div></blockquote>
<p>If above criteria do not match, the test case is considered to be failed</p>
</section>
<section id="adaptive-modulation-and-coding-tests">
<span id="sec-lte-amc-tests"></span><h6><span class="section-number">20.3.2.2.2. </span>Adaptive Modulation and Coding Tests<a class="headerlink" href="#adaptive-modulation-and-coding-tests" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-link-adaptation</span></code> provides system tests recreating a
scenario with a single eNB and a single UE. Different test cases are created
corresponding to different SNR values perceived by the UE. The aim of the test
is to check that in each test case the chosen MCS corresponds to some known
reference values. These reference values are obtained by
re-implementing in Octave (see <cite>src/lte/test/reference/lte_amc.m</cite>) the
model described in Section <a class="reference internal" href="index.html#sec-lte-amc"><span class="std std-ref">Adaptive Modulation and Coding</span></a> for the calculation of the
spectral efficiency, and determining the corresponding MCS index
by manually looking up the tables in <a class="reference internal" href="index.html#r1-081483" id="id3"><span>[R1-081483]</span></a>. The resulting test vector is
represented in Figure <a class="reference internal" href="#fig-lte-mcs-index"><span class="std std-ref">Test vector for Adaptive Modulation and Coding</span></a>.</p>
<p>The MCS which is used by the simulator is measured by
obtaining the tracing output produced by the scheduler after 4ms (this
is needed to account for the initial delay in CQI reporting). The SINR
which is calculated by the simulator is also obtained using the
<code class="docutils literal notranslate"><span class="pre">LteChunkProcessor</span></code> interface. The test
passes if both the following conditions are satisfied:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the SINR calculated by the simulator correspond to the SNR
of the test vector within an absolute tolerance of <img class="math" src="_images/math/df048aa37b785a8082d34feb1e133dd438e73fa3.png" alt="10^{-7}"/>;</p></li>
<li><p>the MCS index used by the simulator exactly corresponds to
the one in the test vector.</p></li>
</ol>
</div></blockquote>
<figure class="align-center" id="id12">
<span id="fig-lte-mcs-index"></span><img alt="_images/lte-mcs-index.png" src="_images/lte-mcs-index.png" />
<figcaption>
<p><span class="caption-text">Test vector for Adaptive Modulation and Coding</span><a class="headerlink" href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="inter-cell-interference-tests">
<h6><span class="section-number">20.3.2.2.3. </span>Inter-cell Interference Tests<a class="headerlink" href="#inter-cell-interference-tests" title="Link to this heading">¶</a></h6>
<p>The test suite <cite>lte-interference</cite> provides system tests recreating an
inter-cell interference scenario with two eNBs, each having a single
UE attached to it and employing Adaptive Modulation and Coding both in
the downlink and in the uplink. The topology of the scenario
is depicted in Figure <a class="reference internal" href="#fig-lte-interference-test-scenario"><span class="std std-ref">Topology for the inter-cell interference test</span></a>. The
<img class="math" src="_images/math/3ae609da43d4b08e38f5d39c0e6b1334d3c6bbd9.png" alt="d_1"/> parameter represents the distance of each UE to the eNB it
is attached to, whereas the <img class="math" src="_images/math/cc01b82d36d02dbb2f81204ce239408227e1f242.png" alt="d_2"/> parameter represent the
interferer distance. We note that the scenario topology is such that
the interferer distance is the same for uplink and downlink; still,
the actual interference power perceived will be different, because of
the different propagation loss in the uplink and downlink
bands. Different test cases are obtained by varying the <img class="math" src="_images/math/3ae609da43d4b08e38f5d39c0e6b1334d3c6bbd9.png" alt="d_1"/>
and <img class="math" src="_images/math/cc01b82d36d02dbb2f81204ce239408227e1f242.png" alt="d_2"/> parameters.</p>
<figure class="align-center" id="id13">
<span id="fig-lte-interference-test-scenario"></span><img alt="_images/lte-interference-test-scenario.png" src="_images/lte-interference-test-scenario.png" />
<figcaption>
<p><span class="caption-text">Topology for the inter-cell interference test</span><a class="headerlink" href="#id13" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The test vectors are obtained by use of a dedicated octave script
(available in
<cite>src/lte/test/reference/lte_link_budget_interference.m</cite>), which does
the link budget calculations (including interference) corresponding to the topology of each
test case, and outputs the resulting SINR and spectral efficiency. The
latter is then used to determine (using the same procedure adopted for
<a class="reference internal" href="#sec-lte-amc-tests"><span class="std std-ref">Adaptive Modulation and Coding Tests</span></a>. We note that the test vector
contains separate values for uplink and downlink.</p>
</section>
<section id="ue-measurements-tests">
<h6><span class="section-number">20.3.2.2.4. </span>UE Measurements Tests<a class="headerlink" href="#ue-measurements-tests" title="Link to this heading">¶</a></h6>
<p>The test suite <cite>lte-ue-measurements</cite> provides system tests recreating an
inter-cell interference scenario identical of the one defined for
<cite>lte-interference</cite> test-suite. However, in this test the quantities to be
tested are represented by RSRP and RSRQ measurements performed by the UE in two
different points of the stack: the source, which is UE PHY layer, and the
destination, that is the eNB RRC.</p>
<p>The test vectors are obtained by the use of a dedicated octave script (available
in <cite>src/lte/test/reference/lte-ue-measurements.m</cite>), which does the link budget
calculations (including interference) corresponding to the topology of each
test case, and outputs the resulting RSRP and RSRQ. The obtained values are then
used for checking the correctness of the UE Measurements at PHY layer. After
that, they have to be converted according to 3GPP formatting for the purpose of
checking their correctness at eNB RRC level.</p>
</section>
<section id="ue-measurement-configuration-tests">
<h6><span class="section-number">20.3.2.2.5. </span>UE measurement configuration tests<a class="headerlink" href="#ue-measurement-configuration-tests" title="Link to this heading">¶</a></h6>
<p>Besides the previously mentioned test suite, there are 3 other test suites for
testing UE measurements: <cite>lte-ue-measurements-piecewise-1</cite>,
<cite>lte-ue-measurements-piecewise-2</cite>, and <cite>lte-ue-measurements-handover</cite>. These
test suites are more focused on the reporting trigger procedure, i.e. the
correctness of the implementation of the event-based triggering criteria is
verified here.</p>
<p>In more specific, the tests verify the <em>timing</em> and the <em>content</em> of each
measurement reports received by eNodeB. Each test case is an stand-alone LTE
simulation and the test case will pass if measurement report(s) only occurs at
the prescribed time and shows the correct level of RSRP (RSRQ is not verified at
the moment).</p>
<section id="piecewise-configuration">
<h6 aria-level="7"><span class="section-number">20.3.2.2.5.1. </span>Piecewise configuration<a class="headerlink" href="#piecewise-configuration" title="Link to this heading">¶</a></h6>
<p>The piecewise configuration aims to test a particular UE measurements
configuration. The simulation script will setup the corresponding measurements
configuration to the UE, which will be active throughout the simulation.</p>
<p>Since the reference values are precalculated by hands, several assumptions are
made to simplify the simulation. Firstly, the channel is only affected by path
loss model (in this case, Friis model is used). Secondly, the ideal RRC protocol
is used, and layer 3 filtering is disabled. Finally, the UE moves in a
predefined motion pattern between 4 distinct spots, as depicted in Figure
<a class="reference internal" href="#fig-ue-meas-piecewise-motion"><span class="std std-ref">UE movement trace throughout the simulation in piecewise configuration</span></a> below. Therefore the fluctuation of the
measured RSRP can be determined more easily.</p>
<figure class="align-center" id="id14">
<span id="fig-ue-meas-piecewise-motion"></span><a class="reference internal image-reference" href="_images/ue-meas-piecewise-motion.png"><img alt="_images/ue-meas-piecewise-motion.png" src="_images/ue-meas-piecewise-motion.png" style="width: 832.8000000000001px; height: 297.6px;" /></a>
<figcaption>
<p><span class="caption-text">UE movement trace throughout the simulation in piecewise configuration</span><a class="headerlink" href="#id14" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The motivation behind the <em>“teleport”</em> between the predefined spots is to
introduce drastic change of RSRP level, which will guarantee the triggering of
entering or leaving condition of the tested event. By performing drastic
changes, the test can be run within shorter amount of time.</p>
<p>Figure <a class="reference internal" href="#fig-ue-meas-piecewise-a1"><span class="std std-ref">Measured RSRP trace of an example Event A1 test case in piecewise
configuration</span></a> below shows the measured RSRP after
layer 1 filtering by the PHY layer during the simulation with a piecewise
configuration. Because layer 3 filtering is disabled, these are the exact values
used by the UE RRC instance to evaluate reporting trigger procedure. Notice that
the values are refreshed every 200 ms, which is the default filtering period of
PHY layer measurements report. The figure also shows the time when entering and
leaving conditions of an example instance of Event A1 (serving cell becomes
better than threshold) occur during the simulation.</p>
<figure class="align-center" id="id15">
<span id="fig-ue-meas-piecewise-a1"></span><a class="reference internal image-reference" href="_images/ue-meas-piecewise-a1.png"><img alt="_images/ue-meas-piecewise-a1.png" src="_images/ue-meas-piecewise-a1.png" style="width: 823.2px; height: 329.6px;" /></a>
<figcaption>
<p><span class="caption-text">Measured RSRP trace of an example Event A1 test case in piecewise
configuration</span><a class="headerlink" href="#id15" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Each reporting criterion is tested several times with different threshold/offset
parameters. Some test scenarios also take hysteresis and time-to-trigger into
account. Figure <a class="reference internal" href="#fig-ue-meas-piecewise-a1-hys"><span class="std std-ref">Measured RSRP trace of an example Event A1 with hysteresis test case in
piecewise configuration</span></a> depicts the effect of
hysteresis in another example of Event A1 test.</p>
<figure class="align-center" id="id16">
<span id="fig-ue-meas-piecewise-a1-hys"></span><a class="reference internal image-reference" href="_images/ue-meas-piecewise-a1-hys.png"><img alt="_images/ue-meas-piecewise-a1-hys.png" src="_images/ue-meas-piecewise-a1-hys.png" style="width: 855.2px; height: 329.6px;" /></a>
<figcaption>
<p><span class="caption-text">Measured RSRP trace of an example Event A1 with hysteresis test case in
piecewise configuration</span><a class="headerlink" href="#id16" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Piecewise configuration is used in two test suites of UE measurements. The first
one is <cite>lte-ue-measurements-piecewise-1</cite>, henceforth Piecewise test #1, which
simulates 1 UE and 1 eNodeB. The other one is <cite>lte-ue-measurements-piecewise-2</cite>,
which has 1 UE and 2 eNodeBs in the simulation.</p>
<p>Piecewise test #1 is intended to test the event-based criteria which are not
dependent on the existence of a neighboring cell. These criteria include Event
A1 and A2. The other events are also briefly tested to verify that they are
still working correctly (albeit not reporting anything) in the absence of any
neighboring cell. Table <a class="reference internal" href="#tab-ue-meas-piecewise-1"><span class="std std-ref">UE measurements test scenarios using piecewise configuration #1</span></a> below lists the
scenarios tested in piecewise test #1.</p>
<span id="tab-ue-meas-piecewise-1"></span><table class="docutils align-default" id="id17">
<caption><span class="caption-text">UE measurements test scenarios using piecewise configuration #1</span><a class="headerlink" href="#id17" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Test #</p></th>
<th class="head"><p>Reporting Criteria</p></th>
<th class="head"><p>Threshold/Offset</p></th>
<th class="head"><p>Hysteresis</p></th>
<th class="head"><p>Time-to-Trigger</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Event A1</p></td>
<td><p>Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Short</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Long</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Super</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>Event A1</p></td>
<td><p>High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>Event A2</p></td>
<td><p>Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Short</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Long</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Super</p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Event A2</p></td>
<td><p>High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Event A3</p></td>
<td><p>Zero</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Event A4</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
<p>Other events such as Event A3, A4, and A5 depend on measurements of neighbouring
cell, so they are more thoroughly tested in Piecewise test #2. The simulation
places the nodes on a straight line and instruct the UE to <em>“jump”</em> in a similar
manner as in Piecewise test #1. Handover is disabled in the simulation, so the
role of serving and neighbouring cells do not switch during the simulation.
Table <a class="reference internal" href="#tab-ue-meas-piecewise-2"><span class="std std-ref">UE measurements test scenarios using piecewise configuration #2</span></a> below lists the scenarios tested in
Piecewise test #2.</p>
<span id="tab-ue-meas-piecewise-2"></span><table class="docutils align-default" id="id18">
<caption><span class="caption-text">UE measurements test scenarios using piecewise configuration #2</span><a class="headerlink" href="#id18" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Test #</p></th>
<th class="head"><p>Reporting Criteria</p></th>
<th class="head"><p>Threshold/Offset</p></th>
<th class="head"><p>Hysteresis</p></th>
<th class="head"><p>Time-to-Trigger</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Event A1</p></td>
<td><p>Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Event A1</p></td>
<td><p>Normal</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Event A1</p></td>
<td><p>High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Event A2</p></td>
<td><p>Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>Event A2</p></td>
<td><p>Normal</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>Event A2</p></td>
<td><p>High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>Event A3</p></td>
<td><p>Positive</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>Event A3</p></td>
<td><p>Zero</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>Event A3</p></td>
<td><p>Zero</p></td>
<td><p>No</p></td>
<td><p>Short</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Event A3</p></td>
<td><p>Zero</p></td>
<td><p>No</p></td>
<td><p>Super</p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Event A3</p></td>
<td><p>Zero</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Event A3</p></td>
<td><p>Negative</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Event A4</p></td>
<td><p>Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Event A4</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Event A4</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Short</p></td>
</tr>
<tr class="row-odd"><td><p>18</p></td>
<td><p>Event A4</p></td>
<td><p>Normal</p></td>
<td><p>No</p></td>
<td><p>Super</p></td>
</tr>
<tr class="row-even"><td><p>19</p></td>
<td><p>Event A4</p></td>
<td><p>Normal</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>Event A4</p></td>
<td><p>High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>21</p></td>
<td><p>Event A5</p></td>
<td><p>Low-Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>22</p></td>
<td><p>Event A5</p></td>
<td><p>Low-Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>23</p></td>
<td><p>Event A5</p></td>
<td><p>Low-High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>26</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-Normal</p></td>
<td><p>No</p></td>
<td><p>Short</p></td>
</tr>
<tr class="row-even"><td><p>27</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-Normal</p></td>
<td><p>No</p></td>
<td><p>Super</p></td>
</tr>
<tr class="row-odd"><td><p>28</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-Normal</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>29</p></td>
<td><p>Event A5</p></td>
<td><p>Normal-High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>30</p></td>
<td><p>Event A5</p></td>
<td><p>High-Low</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>31</p></td>
<td><p>Event A5</p></td>
<td><p>High-Normal</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td><p>Event A5</p></td>
<td><p>High-High</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
<p>One note about the tests with time-to-trigger, they are tested using 3 different
values of time-to-trigger: <em>short</em> (shorter than report interval), <em>long</em>
(shorter than the filter measurement period of 200 ms), and <em>super</em> (longer than
200 ms). The first two ensure that time-to-trigger evaluation always use the
latest measurement reports received from PHY layer. While the last one is
responsible for verifying time-to-trigger cancellation, for example when a
measurement report from PHY shows that the entering/leaving condition is no
longer true before the first trigger is fired.</p>
</section>
<section id="handover-configuration">
<h6 aria-level="7"><span class="section-number">20.3.2.2.5.2. </span>Handover configuration<a class="headerlink" href="#handover-configuration" title="Link to this heading">¶</a></h6>
<p>The purpose of the handover configuration is to verify whether UE measurement
configuration is updated properly after a successful handover takes place. For
this purpose, the simulation will construct 2 eNodeBs with different UE
measurement configuration, and the UE will perform handover from one cell to
another. The UE will be located on a straight line between the 2 eNodeBs, and
the handover will be invoked manually. The duration of each simulation is
2 seconds (except the last test case) and the handover is triggered exactly at
halfway of simulation.</p>
<p>The <cite>lte-ue-measurements-handover</cite> test suite covers various types of
configuration differences. The first one is the difference in report interval,
e.g. the first eNodeB is configured with 480 ms report interval, while the
second eNodeB is configured with 240 ms report interval. Therefore, when the UE
performed handover to the second cell, the new report interval must take effect.
As in piecewise configuration, the timing and the content of each measurement
report received by the eNodeB will be verified.</p>
<p>Other types of differences covered by the test suite are differences in event
and differences in threshold/offset. Table <a class="reference internal" href="#tab-ue-meas-handover"><span class="std std-ref">UE measurements test scenarios using handover configuration</span></a> below
lists the tested scenarios.</p>
<span id="tab-ue-meas-handover"></span><table class="docutils align-default" id="id19">
<caption><span class="caption-text">UE measurements test scenarios using handover configuration</span><a class="headerlink" href="#id19" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Test #</p></th>
<th class="head"><p>Test Subject</p></th>
<th class="head"><p>Initial Configuration</p></th>
<th class="head"><p>Post-Handover Configuration</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Report interval</p></td>
<td><p>480 ms</p></td>
<td><p>240 ms</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Report interval</p></td>
<td><p>120 ms</p></td>
<td><p>640 ms</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Event</p></td>
<td><p>Event A1</p></td>
<td><p>Event A2</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Event</p></td>
<td><p>Event A2</p></td>
<td><p>Event A1</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Event</p></td>
<td><p>Event A3</p></td>
<td><p>Event A4</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>Event</p></td>
<td><p>Event A4</p></td>
<td><p>Event A3</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>Event</p></td>
<td><p>Event A2</p></td>
<td><p>Event A3</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>Event</p></td>
<td><p>Event A3</p></td>
<td><p>Event A2</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>Event</p></td>
<td><p>Event A4</p></td>
<td><p>Event A5</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>Event</p></td>
<td><p>Event A5</p></td>
<td><p>Event A4</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>Threshold/offset</p></td>
<td><p>RSRP range 52 (Event A1)</p></td>
<td><p>RSRP range 56 (Event A1)</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Threshold/offset</p></td>
<td><p>RSRP range 52 (Event A2)</p></td>
<td><p>RSRP range 56 (Event A2)</p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Threshold/offset</p></td>
<td><p>A3 offset -30 (Event A3)</p></td>
<td><p>A3 offset +30 (Event A3)</p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Threshold/offset</p></td>
<td><p>RSRP range 52 (Event A4)</p></td>
<td><p>RSRP range 56 (Event A4)</p></td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Threshold/offset</p></td>
<td><p>RSRP range 52-52 (Event A5)</p></td>
<td><p>RSRP range 56-56 (Event A5)</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Time-to-trigger</p></td>
<td><p>1024 ms</p></td>
<td><p>100 ms</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Time-to-trigger</p></td>
<td><p>1024 ms</p></td>
<td><p>640 ms</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="round-robin-scheduler-performance">
<h6><span class="section-number">20.3.2.2.6. </span>Round Robin scheduler performance<a class="headerlink" href="#round-robin-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-rr-ff-mac-scheduler</span></code> creates different test cases with
a single eNB and several UEs, all having the same Radio Bearer specification. In
each test case, the UEs see the same SINR from the eNB; different test cases are
implemented by using different distance among UEs and the eNB (i.e., therefore
having different SINR values) and different numbers of UEs. The test consists on
checking that the obtained throughput performance is equal among users and
matches a reference throughput value obtained according to the SINR perceived
within a given tolerance.</p>
<p>The test vector is obtained according to the values of transport block
size reported in table 7.1.7.2.1-1 of <a class="reference internal" href="index.html#ts36213" id="id4"><span>[TS36213]</span></a>, considering an
equal distribution of the physical resource block among the users
using Resource Allocation Type 0 as defined in Section 7.1.6.1 of
<a class="reference internal" href="index.html#ts36213" id="id5"><span>[TS36213]</span></a>.  Let <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> be the TTI duration, <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> be the
number of UEs, <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> the transmission bandwidth configuration in
number of RBs, <img class="math" src="_images/math/89878909dbb648acdc4a44ded1bd982d7bddef5d.png" alt="G"/> the RBG size, <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> the modulation and
coding scheme in use at the given SINR and <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the
transport block size in bits as defined by 3GPP TS 36.213. We first
calculate the number <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> of RBGs allocated to each user as</p>
<div class="math">
<p><img src="_images/math/3a58b382558ef326f3bff10428d167579e1422cc.png" alt="L = \left\lfloor \frac{B}{NG} \right\rfloor"/></p>
</div><p>The reference throughput <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> in bit/s achieved by each UE is then calculated as</p>
<div class="math">
<p><img src="_images/math/9e526169ddafeeef57f4e17ada4bbac5a706cd41.png" alt="T =  \frac{S(M, L G)}{8 \; \tau}"/></p>
</div><p>The test passes if the measured throughput matches with the reference throughput
within a relative tolerance of 0.1. This tolerance is needed to account for the
transient behavior at the beginning of the simulation (e.g., CQI feedback is
only available after a few subframes) as well as for the accuracy of the
estimator of the average throughput performance over the chosen simulation time
(0.4s). This choice of the simulation time is justified by the need to
follow the ns-3 guidelines of keeping the total execution time of the test
suite low, in spite of the high number of test cases. In any case, we note that
a lower value of the tolerance can be used when longer simulations are
run.</p>
<p>In Figure <a class="reference internal" href="#fig-lenathrtestcase1">fig-lenaThrTestCase1</a>, the curves labeled “RR” represent the test values
calculated for the RR scheduler test, as a function of the number of UEs and of
the MCS index being used in each test case.</p>
<figure class="align-center" id="id20">
<span id="fig-lenathrtestcase1"></span><img alt="_images/lenaThrTestCase1.png" src="_images/lenaThrTestCase1.png" />
<figcaption>
<p><span class="caption-text">Test vectors for the RR and PF Scheduler in the downlink in a
scenario where all UEs use the same MCS.</span><a class="headerlink" href="#id20" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="proportional-fair-scheduler-performance">
<h6><span class="section-number">20.3.2.2.7. </span>Proportional Fair scheduler performance<a class="headerlink" href="#proportional-fair-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-pf-ff-mac-scheduler</span></code> creates different test cases with
a single eNB, using the Proportional Fair (PF) scheduler, and several UEs, all
having the same Radio Bearer specification. The test cases are grouped in two
categories in order to evaluate the performance both in terms of the adaptation
to the channel condition and from a fairness perspective.</p>
<p>In the first category of test cases, the UEs are all placed at the
same distance from the eNB, and hence all placed in order to have the
same SINR. Different test cases are implemented by using a different
SINR value and a different number of UEs. The test consists on
checking that the obtained throughput performance matches with the
known reference throughput up to a given tolerance. The expected
behavior of the PF scheduler when all UEs have the same SNR is that
each UE should get an equal fraction of the throughput obtainable by a
single UE when using all the resources. We calculate the reference
throughput value by dividing the throughput achievable by a single UE
at the given SNR by the total number of UEs.
Let <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> be the TTI duration, <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> the transmission
bandwidth configuration in number of RBs, <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> the modulation and
coding scheme in use at the given SINR and <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the
transport block size as defined in <a class="reference internal" href="index.html#ts36213" id="id6"><span>[TS36213]</span></a>. The reference
throughput <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> in bit/s achieved by each UE is calculated as</p>
<div class="math">
<p><img src="_images/math/75bcc9f8bcbbb0674941dfdf20b2b6f6c902776d.png" alt="T = \frac{S(M,B)}{\tau N}"/></p>
</div><p>The curves labeled “PF” in Figure <a class="reference internal" href="#fig-lenathrtestcase1">fig-lenaThrTestCase1</a> represent the test values
calculated for the PF scheduler tests of the first category, that we just described.</p>
<p>The second category of tests aims at verifying the fairness of the PF
scheduler in a more realistic simulation scenario where the UEs have a
different SINR (constant for the whole simulation). In these conditions, the PF
scheduler will give to each user a share of the system bandwidth that is
proportional to the capacity achievable by a single user alone considered its
SINR. In detail, let <img class="math" src="_images/math/86810cecefe160a038ea1bf18596df24b14c6731.png" alt="M_i"/> be the modulation and coding scheme being used by
each UE (which is a deterministic function of the SINR of the UE, and is hence
known in this scenario). Based on the MCS, we determine the achievable
rate <img class="math" src="_images/math/8d47777d070e3b1ae6a9ea0d4918309bc8c942fe.png" alt="R_i"/> for each user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> using the
procedure described in Section~ref{sec:pfs}. We then define the
achievable rate ratio <img class="math" src="_images/math/82c9865186cffc16a000df3163d099e127e79683.png" alt="\rho_{R,i}"/> of each user <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> as</p>
<div class="math">
<p><img src="_images/math/f988ce85051553dc2eb9f8a676fbf3ad72983cee.png" alt="\rho_{R,i} = \frac{R_i}{\sum_{j=1}^N R_j}"/></p>
</div><p>Let now <img class="math" src="_images/math/db063ac3b718da47702b1dbb3c52d3feac13333b.png" alt="T_i"/> be the throughput actually achieved by the UE <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> , which
is obtained as part of the simulation output. We define the obtained throughput
ratio <img class="math" src="_images/math/d50da03a8d8d6abc057b48ff04e947daa9a7b15d.png" alt="\rho_{T,i}"/> of UE <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> as</p>
<div class="math">
<p><img src="_images/math/68b763abec910cc3cdb7ee0310a48f9f0ea99f91.png" alt="\rho_{T,i} = \frac{T_i}{\sum_{j=1}^N T_j}"/></p>
</div><p>The test consists of checking that the following condition is verified:</p>
<div class="math">
<p><img src="_images/math/a37d4759d31070ba4122ff1706823ef7cec784ce.png" alt="\rho_{R,i} = \rho_{T,i}"/></p>
</div><p>if so, it means that the throughput obtained by each UE over the whole
simulation matches with the steady-state throughput expected by the PF scheduler
according to the theory. This test can be derived from <a class="reference internal" href="index.html#holtzman2000" id="id7"><span>[Holtzman2000]</span></a>
as follows. From Section 3 of <a class="reference internal" href="index.html#holtzman2000" id="id8"><span>[Holtzman2000]</span></a>, we know that</p>
<div class="math">
<p><img src="_images/math/492894fb1acb2add183d85af60fee5573c6c8240.png" alt="\frac{T_i}{R_i} = c, \, \forall i"/></p>
</div><p>where <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.png" alt="c"/> is a constant. By substituting the above into the
definition of <img class="math" src="_images/math/d50da03a8d8d6abc057b48ff04e947daa9a7b15d.png" alt="\rho_{T,i}"/> given previously, we get</p>
<div class="math">
<p><img src="_images/math/95ba7aceb61377ab8b3ac330ccfeb7f6d88c8784.png" alt="\frac{T_i}{\sum_{j=1}^N T_j} &amp;=  \frac{c R_i}{\sum_{j=1}^N c R_j} \\
                             &amp;=  \frac{c R_i}{c \sum_{j=1}^N  R_j} \\
                             &amp;=  \frac{R_i}{\sum_{j=1}^N  R_j}"/></p>
</div><p>which is exactly the expression being used in the test.</p>
<p>Figure <a class="reference internal" href="#fig-lenathrtestcase2"><span class="std std-ref">Throughput ratio evaluation for the PF scheduler in a scenario
where the UEs have MCS index 28, 24, 16, 12, 6</span></a> presents the results obtained in a test case with
UEs <img class="math" src="_images/math/47ebeea110970a2f0c0bbfdd735ee20597454368.png" alt="i=1,\dots,5"/> that are located at a distance from the base
station such that they will use respectively the MCS index <img class="math" src="_images/math/cd9b814585c043fa03e467fd4c8b668ed9e12f68.png" alt="28, 24, 16, 12,
6"/>. From the figure, we note that, as expected, the obtained throughput is
proportional to the achievable rate. In other words, the PF scheduler assign
more resources to the users that use a higher MCS index.</p>
<figure class="align-center" id="id21">
<span id="fig-lenathrtestcase2"></span><img alt="_images/lenaThrTestCase2.png" src="_images/lenaThrTestCase2.png" />
<figcaption>
<p><span class="caption-text">Throughput ratio evaluation for the PF scheduler in a scenario
where the UEs have MCS index <img class="math" src="_images/math/84dfd90bb41131bbdbd7500ddcae02261bd5eae1.png" alt="28, 24, 16, 12, 6"/></span><a class="headerlink" href="#id21" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="maximum-throughput-scheduler-performance">
<h6><span class="section-number">20.3.2.2.8. </span>Maximum Throughput scheduler performance<a class="headerlink" href="#maximum-throughput-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>Test suites <code class="docutils literal notranslate"><span class="pre">lte-fdmt-ff-mac-scheduler</span></code> and <code class="docutils literal notranslate"><span class="pre">lte-tdmt-ff-mac-scheduler</span></code>
create different test cases with a single eNB and several UEs, all having the same
Radio Bearer specification, using the Frequency Domain Maximum Throughput (FDMT)
scheduler and Time Domain Maximum Throughput (TDMT) scheduler respectively.
In other words, UEs are all placed at the
same distance from the eNB, and hence all placed in order to have the
same SNR. Different test cases are implemented by using a different
SNR values and a different number of UEs. The test consists on
checking that the obtained throughput performance matches with the
known reference throughput up to a given tolerance.The expected
behavior of both FDMT and TDMT scheduler when all UEs have the same SNR is that
scheduler allocates all RBGs to the first UE defined in script. This is because
the current FDMT and TDMT implementation always select the first UE to serve when there are
multiple UEs having the same SNR value. We calculate the reference
throughput value for first UE by the throughput achievable of a single UE
at the given SNR, while reference throughput value for other UEs by zero.
Let <img class="math" src="_images/math/914b2d4b6659b86d3153d5510839dfb254dfc8a3.png" alt="\tau"/> be the TTI duration, <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> the transmission
bandwidth configuration in number of RBs, <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> the modulation and
coding scheme in use at the given SNR and <img class="math" src="_images/math/d64763a87db595ccd16337f6408e1ee9e978b35a.png" alt="S(M, B)"/> be the
transport block size as defined in <a class="reference internal" href="index.html#ts36213" id="id9"><span>[TS36213]</span></a>. The reference
throughput <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> in bit/s achieved by each UE is calculated as</p>
<div class="math">
<p><img src="_images/math/c65898d0b1958e128c90e2502a0b08c4bb9fb438.png" alt="T = \frac{S(M,B)}{\tau}"/></p>
</div></section>
<section id="throughput-to-average-scheduler-performance">
<h6><span class="section-number">20.3.2.2.9. </span>Throughput to Average scheduler performance<a class="headerlink" href="#throughput-to-average-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>Test suites <code class="docutils literal notranslate"><span class="pre">lte-tta-ff-mac-scheduler</span></code>
create different test cases with a single eNB and several UEs, all having the same
Radio Bearer specification using TTA scheduler. Network topology and configurations in
TTA test case are as the same as the test for MT scheduler. More complex test case needs to be
developed to show the fairness feature of TTA scheduler.</p>
</section>
<section id="blind-average-throughput-scheduler-performance">
<h6><span class="section-number">20.3.2.2.10. </span>Blind Average Throughput scheduler performance<a class="headerlink" href="#blind-average-throughput-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>Test suites <code class="docutils literal notranslate"><span class="pre">lte-tdbet-ff-mac-scheduler</span></code> and <code class="docutils literal notranslate"><span class="pre">lte-fdbet-ff-mac-scheduler</span></code> create different
test cases with a single eNB and several UEs, all having the same Radio Bearer specification.</p>
<p>In the first test case of <code class="docutils literal notranslate"><span class="pre">lte-tdbet-ff-mac-scheduler</span></code> and <code class="docutils literal notranslate"><span class="pre">lte-fdbet-ff-mac-scheduler</span></code>,
the UEs are all placed at the same distance from the eNB, and hence all placed in order to
have the same SNR. Different test cases are implemented by using a different SNR value and
a different number of UEs. The test consists on checking that the obtained throughput performance
matches with the known reference throughput up to a given tolerance. In long term, the expected
behavior of both TD-BET and FD-BET when all UEs have the same SNR is that each UE should get an
equal throughput. However, the exact throughput value of TD-BET and FD-BET in this test case is not
the same.</p>
<p>When all UEs have the same SNR, TD-BET can be seen as a specific case of PF where achievable rate equals
to 1. Therefore, the throughput obtained by TD-BET is equal to that of PF. On the other hand, FD-BET performs
very similar to the round robin (RR) scheduler in case of that all UEs have the same SNR and the number of UE( or RBG)
is an integer multiple of the number of RBG( or UE). In this case, FD-BET always allocate the same number of RBGs
to each UE. For example, if eNB has 12 RBGs and there are 6 UEs, then each UE will get 2 RBGs in each TTI.
Or if eNB has 12 RBGs and there are 24 UEs, then each UE will get 2 RBGs per two TTIs. When the number of
UE (RBG) is not an integer multiple of the number of RBG (UE), FD-BET will not follow the RR behavior because
it will assigned different number of RBGs to some UEs, while the throughput of each UE is still the same.</p>
<p>The second category of tests aims at verifying the fairness of the both TD-BET and FD-BET schedulers in a more realistic
simulation scenario where the UEs have a different SNR (constant for the whole simulation). In this case,
both scheduler should give the same amount of averaged throughput to each user.</p>
<p>Specifically, for TD-BET, let <img class="math" src="_images/math/d907a3c4e1257ec91ba2b8475cc048392650b648.png" alt="F_i"/> be the fraction of time allocated to user i in total simulation time,
<img class="math" src="_images/math/6e52cf2780073e8abb171a8c34b93990892fcf45.png" alt="R^{fb}_i"/> be the full bandwidth achievable rate for user i and <img class="math" src="_images/math/db063ac3b718da47702b1dbb3c52d3feac13333b.png" alt="T_i"/> be the achieved throughput of
user i. Then we have:</p>
<div class="math">
<p><img src="_images/math/c498fe9fafd4361ed531459c696976eaca391594.png" alt="T_i = F_i R^{fb}_i"/></p>
</div><p>In TD-BET, the sum of <img class="math" src="_images/math/d907a3c4e1257ec91ba2b8475cc048392650b648.png" alt="F_i"/> for all user equals one. In long term, all UE has the same <img class="math" src="_images/math/db063ac3b718da47702b1dbb3c52d3feac13333b.png" alt="T_i"/> so that we replace
<img class="math" src="_images/math/db063ac3b718da47702b1dbb3c52d3feac13333b.png" alt="T_i"/> by <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/>.  Then we have:</p>
<div class="math">
<p><img src="_images/math/29e4997814a9d43d0eddaefc5056750ad45d2de7.png" alt="T = \frac{1}{ \sum_{i=1}^{N} \frac{1}{R^{fb}_i} }"/></p>
</div></section>
<section id="token-band-fair-queue-scheduler-performance">
<h6><span class="section-number">20.3.2.2.11. </span>Token Band Fair Queue scheduler performance<a class="headerlink" href="#token-band-fair-queue-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>Test suites <code class="docutils literal notranslate"><span class="pre">lte-fdtbfq-ff-mac-scheduler</span></code> and <code class="docutils literal notranslate"><span class="pre">lte-tdtbfq-ff-mac-scheduler</span></code> create different
test cases for testing three key features of TBFQ scheduler: traffic policing, fairness and traffic
balance. Constant Bit Rate UDP traffic is used in both downlink and uplink in all test cases.
The packet interval is set to 1ms to keep the RLC buffer non-empty. Different traffic rate is
achieved by setting different packet size. Specifically, two classes of flows are created in the
test suites:</p>
<blockquote>
<div><ul class="simple">
<li><p>Homogeneous flow: flows with the same token generation rate and packet arrival rate</p></li>
<li><p>Heterogeneous flow: flows with different packet arrival rate, but with the same token generation rate</p></li>
</ul>
</div></blockquote>
<p>In test case 1 verifies traffic policing and fairness features for the scenario that all UEs are
placed at the same distance from the eNB. In this case, all Ues have the same SNR value. Different
test cases are implemented by using a different SNR value and a different number of UEs. Because each
flow have the same traffic rate and token generation rate, TBFQ scheduler will guarantee the same
throughput among UEs without the constraint of token generation rate. In addition, the exact value
of UE throughput is depended on the total traffic rate:</p>
<blockquote>
<div><ul class="simple">
<li><p>If total traffic rate &lt;= maximum throughput, UE throughput = traffic rate</p></li>
<li><p>If total traffic rate &gt; maximum throughput,  UE throughput = maximum throughput / N</p></li>
</ul>
</div></blockquote>
<p>Here, N is the number of UE connected to eNodeB. The maximum throughput in this case equals to the rate
that all RBGs are assigned to one UE(e.g., when distance equals 0, maximum throughput is 2196000 byte/sec).
When the traffic rate is smaller than max bandwidth, TBFQ can police the traffic by token generation rate
so that the UE throughput equals its actual traffic rate (token generation rate is set to traffic
generation rate); On the other hand, when total traffic rate is bigger than the max throughput, eNodeB
cannot forward all traffic to UEs. Therefore, in each TTI, TBFQ will allocate all RBGs to one UE due to
the large packets buffered in RLC buffer. When  a UE is scheduled in current TTI, its token counter is decreased
so that it will not be scheduled in the next TTI. Because each UE has the same traffic generation rate,
TBFQ will serve each UE in turn and only serve one UE in each TTI (both in TD TBFQ and FD TBFQ).
Therefore, the UE throughput in the second condition equals to the evenly share of maximum throughput.</p>
<p>Test case 2 verifies traffic policing and fairness features for the scenario that each UE is placed at
the different distance from the eNB. In this case, each UE has the different SNR value. Similar to test
case 1, UE throughput in test case 2 is also depended on the total traffic rate but with a different
maximum throughput. Suppose all UEs have a high traffic load. Then the traffic will saturate the RLC buffer
in eNodeB. In each TTI, after selecting one UE with highest metric, TBFQ will allocate all RBGs to this
UE due to the large RLC buffer size. On the other hand, once RLC buffer is saturated, the total throughput
of all UEs cannot increase any more. In addition, as we discussed in test case 1, for homogeneous flows
which have the same t_i and r_i, each UE will achieve the same throughput in long term. Therefore, we
can use the same method in TD BET to calculate the maximum throughput:</p>
<div class="math">
<p><img src="_images/math/d34d5a38c8404e86a786bb537b2b770b276ef0e7.png" alt="T = \frac{N}{ \sum_{i=1}^{N} \frac{1}{R^{fb}_i} }"/></p>
</div><p>Here, <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> is the maximum throughput. <img class="math" src="_images/math/6e52cf2780073e8abb171a8c34b93990892fcf45.png" alt="R^{fb}_i"/> be the full bandwidth achievable rate
for user i. <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> is the number of UE.</p>
<p>When the total traffic rate is bigger than <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/>, the UE throughput equals to <img class="math" src="_images/math/f4f5fee98a65554e83f0b6b6b57bce8c039656a1.png" alt="\frac{T}{N}"/> . Otherwise, UE throughput
equals to its traffic generation rate.</p>
<p>In test case 3, three flows with different traffic rate are created. Token generation rate for each
flow is the same and equals to the average traffic rate of three flows. Because TBFQ use a shared token
bank, tokens contributed by UE with lower traffic load can be utilized by UE with higher traffic load.
In this way, TBFQ can guarantee the traffic rate for each flow. Although we use heterogeneous flow here,
the calculation of maximum throughput is as same as that in test case 2. In calculation max throughput
of test case 2, we assume that all UEs suffer high traffic load so that scheduler always assign all RBGs
to one UE in each TTI. This assumes is also true in heterogeneous flow case. In other words, whether
those flows have the same traffic rate and token generation rate, if their traffic rate is bigger enough,
TBFQ performs as same as it in test case 2. Therefore, the maximum bandwidth in test case 3 is as
same as it in test case 2.</p>
<p>In test case 3, in some flows, token generate rate does not equal to MBR, although all flows are CBR
traffic. This is not accorded with our parameter setting rules. Actually, the traffic balance feature
is used in VBR traffic. Because different UE’s peak rate may occur in different time, TBFQ use shared
token bank to balance the traffic among those VBR traffics. Test case 3 use CBR traffic to verify this
feature. But in the real simulation, it is recommended to set token generation rate to MBR.</p>
</section>
<section id="priority-set-scheduler-performance">
<h6><span class="section-number">20.3.2.2.12. </span>Priority Set scheduler performance<a class="headerlink" href="#priority-set-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>Test suites <code class="docutils literal notranslate"><span class="pre">lte-pss-ff-mac-scheduler</span></code> create different test cases with a single eNB and several UEs.
In all test cases, we select PFsch in FD scheduler. Same testing results can also be obtained by using CoItA
scheduler. In addition, all test cases do not define nMux so that TD scheduler in PSS will always select half
of total UE.</p>
<p>In the first class test case of <code class="docutils literal notranslate"><span class="pre">lte-pss-ff-mac-scheduler</span></code>, the UEs are all placed at the same distance from
the eNB, and hence all placed in order to have the same SNR. Different test cases are implemented
by using a different TBR for each UEs. In each test cases, all UEs have the same
Target Bit Rate configured by GBR in EPS bear setting. The expected behavior of PSS is to guarantee that
each UE’s throughput at least equals its TBR if the total flow rate is blow maximum throughput. Similar
to TBFQ, the maximum throughput in this case equals to the rate that all RBGs are assigned to one UE.
When the traffic rate is smaller than max bandwidth, the UE throughput equals its actual traffic rate;
On the other hand, UE throughput equals to the evenly share of the maximum throughput.</p>
<p>In the first class of test cases, each UE has the same SNR. Therefore, the priority metric in PF scheduler will be
determined by past average throughput <img class="math" src="_images/math/4ecf033f6e91f008221774f2f6279ad6c0c912a7.png" alt="T_{j}(t)"/> because each UE has the same achievable throughput
<img class="math" src="_images/math/a82d1e9b4714a0230016c70f71b944185ae73c4a.png" alt="R_{j}(k,t)"/> in PFsch or same <img class="math" src="_images/math/1e93cbf9c879a53af32e43febd8525c6c3f9867d.png" alt="CoI[k,n]"/> in CoItA. This means that PSS will performs like a
TD-BET which allocates all RBGs to one UE in each TTI. Then the maximum value of UE throughput equals to
the achievable rate that all RBGs are allocated to this UE.</p>
<p>In the second class of test case of <code class="docutils literal notranslate"><span class="pre">lte-pss-ff-mac-scheduler</span></code>, the UEs are all placed at the same distance from
the eNB, and hence all placed in order to have the same SNR. Different TBR values are assigned to each UE.
There also exist an maximum throughput in this case. Once total traffic rate is bigger than this threshold,
there will be some UEs that cannot achieve their TBR. Because there is no fading, subband CQIs for each
RBGs frequency are the same. Therefore, in FD scheduler,in each TTI, priority metrics of UE for all RBGs
are the same. This means that FD scheduler will always allocate all RBGs to one user. Therefore, in the
maximum throughput case, PSS performs like a TD-BET. Then we have:</p>
<div class="math">
<p><img src="_images/math/2a210b2b968096a6e23c9dc4cc5674f38eb383a5.png" alt="T = \frac{N}{ \sum_{i=1}^N \frac{1}{R^{fb}_i} }"/></p>
</div><p>Here, <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> is the maximum throughput. <img class="math" src="_images/math/6e52cf2780073e8abb171a8c34b93990892fcf45.png" alt="R^{fb}_i"/> be the full bandwidth achievable rate
for user i. <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> is the number of UE.</p>
</section>
<section id="channel-and-qos-aware-scheduler-performance">
<h6><span class="section-number">20.3.2.2.13. </span>Channel and QoS aware scheduler performance<a class="headerlink" href="#channel-and-qos-aware-scheduler-performance" title="Link to this heading">¶</a></h6>
<p>The performance of the Channel and QoS aware scheduler can be tested in the similar way to performance of
Priority Set scheduler when GBR flows are not delay sensitive by measuring if the achieved throughput at
RLC layer is close to the TBR. Having this in mind, the performance of the CQA scheduler is tested by using
the same test cases as the <code class="docutils literal notranslate"><span class="pre">lte-pss-ff-mac-scheduler</span></code>. Additionally, in <a class="reference internal" href="index.html#bbojovic2014" id="id10"><span>[Bbojovic2014]</span></a> can be found performance
evaluation of CQA scheduler when the GBR flows are delay sensitive by considering different QoE metrics.</p>
</section>
<section id="building-propagation-loss-model">
<h6><span class="section-number">20.3.2.2.14. </span>Building Propagation Loss Model<a class="headerlink" href="#building-propagation-loss-model" title="Link to this heading">¶</a></h6>
<p>The aim of the system test is to verify the integration of the
BuildingPathlossModel with the lte module. The test exploits a set of
three pre calculated losses for generating the expected SINR at the
receiver counting the transmission and the noise powers. These SINR
values are compared with the results obtained from a LTE
simulation that uses the BuildingPathlossModel. The reference loss values are
calculated off-line with an Octave script
(/test/reference/lte_pathloss.m). Each test case passes if the
reference loss value is equal to the value calculated by the simulator
within a tolerance of <img class="math" src="_images/math/ee3f80b4ad23c990072c3a64d1fd4e264c2b4a10.png" alt="0.001"/> dB, which accounts for numerical
errors in the calculations.</p>
</section>
<section id="physical-error-model">
<h6><span class="section-number">20.3.2.2.15. </span>Physical Error Model<a class="headerlink" href="#physical-error-model" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-phy-error-model</span></code> generates different test cases for
evaluating both data and control error models. For what concern the data, the
test consists of six test cases with single eNB and a various number of UEs,
all having the same Radio Bearer specification. Each test is designed for
evaluating the error rate perceived by a specific TB size in order to verify
that it corresponds to the expected values according to the BLER generated for
CB size analog to the TB size. This means that, for instance, the test will
check that the performance of a TB of <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> bits is analogous to the one of
a CB size of <img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/> bits by collecting the performance of a user which has
been forced the generation of a such TB size according to the distance to eNB.
In order to significantly test the BLER at MAC level, we configured the Adaptive
Modulation and Coding (AMC) module, the <code class="docutils literal notranslate"><span class="pre">LteAmc</span></code> class, for making it less
robust to channel conditions by using the PiroEW2010 AMC model and configuring
it to select the MCS considering a target BER of 0.03 (instead of the default
value of 0.00005). We note that these values do not reflect the actual BER,
since they come from an analytical bound which does not consider all the
transmission chain aspects; therefore the BER and BLER actually experienced at
the reception of a TB is in general different.</p>
<p>The parameters of the six test cases are reported in the following:</p>
<ol class="arabic simple">
<li><p>4 UEs placed 1800 meters far from the eNB, which implies the use of MCS 2
(SINR of -5.51 dB) and a TB of 256 bits, that in turns produce a BLER of 0.33
(see point A in figure <a class="reference internal" href="#fig-mcs-2-test"><span class="std std-ref">BLER for tests 1, 2, 3.</span></a>).</p></li>
<li><p>2 UEs placed 1800 meters far from the eNB, which implies the use of MCS 2
(SINR of -5.51 dB) and a TB of 528 bits, that in turns produce a BLER of 0.11
(see point B in figure <a class="reference internal" href="#fig-mcs-2-test"><span class="std std-ref">BLER for tests 1, 2, 3.</span></a>).</p></li>
<li><p>1 UE placed 1800 meters far from the eNB, which implies the use of MCS 2
(SINR of -5.51 dB) and a TB of 1088 bits, that in turns produce a BLER of
0.02 (see point C in figure <a class="reference internal" href="#fig-mcs-2-test"><span class="std std-ref">BLER for tests 1, 2, 3.</span></a>).</p></li>
<li><p>1 UE placed 600 meters far from the eNB, which implies the use of MCS 12
(SINR of 4.43 dB) and a TB of 4800 bits, that in turns produce a BLER of 0.3
(see point D in figure <a class="reference internal" href="#fig-mcs-12-test"><span class="std std-ref">BLER for tests 4, 5.</span></a>).</p></li>
<li><p>3 UEs placed 600 meters far from the eNB, which implies the use of MCS 12
(SINR of 4.43 dB) and a TB of 1632 bits, that in turns produce a BLER of 0.55
(see point E in figure <a class="reference internal" href="#fig-mcs-12-test"><span class="std std-ref">BLER for tests 4, 5.</span></a>).</p></li>
<li><p>1 UE placed 470 meters far from the eNB, which implies the use of MCS 16
(SINR of 8.48 dB) and a TB of 7272 bits (segmented in 2 CBs of 3648 and 3584
bits), that in turns produce a BLER of 0.14, since each CB has CBLER equal to
0.075 (see point F in figure <a class="reference internal" href="#fig-mcs-14-test"><span class="std std-ref">BLER for test 6.</span></a>).</p></li>
</ol>
<figure class="align-center" id="id22">
<span id="fig-mcs-2-test"></span><img alt="_images/MCS_2_test.png" src="_images/MCS_2_test.png" />
<figcaption>
<p><span class="caption-text">BLER for tests 1, 2, 3.</span><a class="headerlink" href="#id22" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id23">
<span id="fig-mcs-12-test"></span><img alt="_images/MCS_12_test.png" src="_images/MCS_12_test.png" />
<figcaption>
<p><span class="caption-text">BLER for tests 4, 5.</span><a class="headerlink" href="#id23" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id24">
<span id="fig-mcs-14-test"></span><img alt="_images/MCS_16_test.png" src="_images/MCS_16_test.png" />
<figcaption>
<p><span class="caption-text">BLER for test 6.</span><a class="headerlink" href="#id24" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The test condition verifies that in each test case the expected number of
packets received correctly corresponds to a Bernoulli distribution with a
confidence interval of 99%, where the probability of success in each trail is
<img class="math" src="_images/math/d36478bf1526dbe2e253374dcdbd0b8bda2b1f59.png" alt="p=1-BER"/> and <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> is the total number of packets sent.</p>
<p>The error model of PCFICH-PDCCH channels consists of 4 test cases with a single
UE and several eNBs, where the UE is connected to only one eNB in order to have
the remaining acting as interfering ones. The errors on data are disabled in
order to verify only the ones due to erroneous decodification of PCFICH-PDCCH.
As before, the system has been forced on working in a less conservative fashion
in the AMC module for appreciating the results in border situations. The
parameters of the 4 tests cases are reported in the following:</p>
<ol class="arabic simple">
<li><p>2 eNBs placed 1078 meters far from the UE, which implies a SINR of -2.00 dB
and a TB of 217 bits, that in turns produce a BLER of 0.007.</p></li>
<li><p>3 eNBs placed 1040 meters far from the UE, which implies a SINR of -4.00 dB
and a TB of 217 bits, that in turns produce a BLER of 0.045.</p></li>
<li><p>4 eNBs placed 1250 meters far from the UE, which implies a SINR of -6.00 dB
and a TB of 133 bits, that in turns produce a BLER of 0.206.</p></li>
<li><p>5 eNBs placed 1260 meters far from the UE, which implies a SINR of -7.00 dB
and a TB of 81 bits, that in turns produce a BLER of 0.343.</p></li>
</ol>
<p>The test condition verifies that in each test case the expected number
of packets received correct corresponds to a Bernoulli distribution
with a confidence interval of 99.8%, where the probability of success
in each trail is <img class="math" src="_images/math/d36478bf1526dbe2e253374dcdbd0b8bda2b1f59.png" alt="p=1-BER"/> and <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> is the total number of
packet sent. The larger confidence interval is due to the errors that
might be produced in quantizing the MI and the error curve.</p>
</section>
<section id="harq-model">
<h6><span class="section-number">20.3.2.2.16. </span>HARQ Model<a class="headerlink" href="#harq-model" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-harq</span></code> includes two tests for evaluating the HARQ model and the related extension in the error model. The test consists on checking whether the amount of bytes received during the simulation corresponds to the expected ones according to the values of transport block and the HARQ dynamics. In detail, the test checks whether the throughput obtained after one HARQ retransmission is the expected one. For evaluating the expected throughput the expected TB delivering time has been evaluated according to the following formula:</p>
<div class="math">
<p><img src="_images/math/723de0915c5c2f50cd30f32c77b25c20d20c7d40.png" alt="\mathrm{T} = P_s^1 \times 1 + P_s^2 \times 2 + (1-P_s^2) \times 3"/></p>
</div><p>where <img class="math" src="_images/math/c993c310c4a2ba39cfe4524fc7c2db4b2ca951d9.png" alt="P_s^i"/> is the probability of receiving with success the HARQ block at the attempt <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/> (i.e., the RV with 3GPP naming). According to the scenarios, in the test we always have <img class="math" src="_images/math/c2b60b1c27279e3c7af50521c9d10a83e886dd85.png" alt="P_s^1"/> equal to 0.0, while <img class="math" src="_images/math/4d857dbf2b9059e72307c913c79b1ea79b6276b1.png" alt="P_s^2"/> varies in the two tests, in detail:</p>
<div class="math">
<p><img src="_images/math/74bde59a16537c544d41bcb6776a67df68719511.png" alt="\mathrm{T_{test-1}} = 0.0 \times 1 + 0.926 \times 2 + 0.074 \times 3 = 2.074

\mathrm{T_{test-2}} = 0.0 \times 1 + 0.752 \times 2 + 0.248 \times 3 = 2.248"/></p>
</div><p>The expected throughput is calculted by counting the number of transmission slots available during the simulation (e.g., the number of TTIs) and the size of the TB in the simulation, in detail:</p>
<div class="math">
<p><img src="_images/math/11f9e6395cfe5617fdbfc408385dac4c6f708303.png" alt="\mathrm{Thr_{test-i}} = \frac{TTI_{NUM}}{T_{test-i}} TB_{size} = \left\{ \begin{array}{lll} \dfrac{1000}{2.074}66 = 31822\mbox{ bps} &amp; \mbox{ for test-1} \\ &amp; \\ \dfrac{1000}{2.248}472 = 209964\mbox{ bps} &amp; \mbox{ for test-2}\end{array} \right."/></p>
</div><p>where <img class="math" src="_images/math/f07c5faf5141b9ac4231d7169a7a41724a9c17ce.png" alt="TTI_{NUM}"/> is the total number of TTIs in 1 second.
The test is performed both for Round Robin scheduler. The test passes if the measured throughput matches with the reference throughput within a relative tolerance of 0.1. This tolerance is needed to account for the transient behavior at the beginning of the simulation and the on-fly blocks at the end of the simulation.</p>
</section>
<section id="mimo-model">
<h6><span class="section-number">20.3.2.2.17. </span>MIMO Model<a class="headerlink" href="#mimo-model" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-mimo</span></code> aims at verifying both the effect of the gain considered for each Transmission Mode on the system performance and the Transmission Mode switching through the scheduler interface. The test consists on checking whether the amount of bytes received during a certain window of time (0.1 seconds in our case) corresponds to the expected ones according to the values of transport block
size reported in table 7.1.7.2.1-1 of <a class="reference internal" href="index.html#ts36213" id="id11"><span>[TS36213]</span></a>, similarly to what done for the tests of the schedulers.</p>
<p>The test is performed both for Round Robin and Proportional Fair schedulers. The test passes if the measured throughput matches with the reference throughput within a relative tolerance of 0.1. This tolerance is needed to account for the
transient behavior at the beginning of the simulation and the transition phase between the Transmission Modes.</p>
</section>
<section id="antenna-model-integration">
<h6><span class="section-number">20.3.2.2.18. </span>Antenna Model integration<a class="headerlink" href="#antenna-model-integration" title="Link to this heading">¶</a></h6>
<p>The test suite <cite>lte-antenna</cite> checks that the AntennaModel integrated
with the LTE model works correctly. This test suite recreates a
simulation scenario with one eNB node at coordinates (0,0,0) and one
UE node at coordinates (x,y,0). The eNB node is configured with an
CosineAntennaModel having given orientation and beamwidth. The UE
instead uses the default IsotropicAntennaModel. The test
checks that the received power both in uplink and downlink account for
the correct value of the antenna gain, which is determined
offline; this is implemented by comparing the uplink and downlink SINR
and checking that both match with the reference value up to a
tolerance of <img class="math" src="_images/math/7e21945d9e6e712189e545e2144022340947d5fa.png" alt="10^{-6}"/> which accounts for numerical errors.
Different test cases are provided by varying the x and y coordinates
of the UE,  and the beamwidth and the orientation of the antenna of
the eNB.</p>
</section>
<section id="rlc">
<h6><span class="section-number">20.3.2.2.19. </span>RLC<a class="headerlink" href="#rlc" title="Link to this heading">¶</a></h6>
<p>Two test suites <code class="docutils literal notranslate"><span class="pre">lte-rlc-um-transmitter</span></code> and
<code class="docutils literal notranslate"><span class="pre">lte-rlc-am-transmitter</span></code> check that the UM RLC and the AM RLC
implementation work correctly. Both these suites work by testing RLC
instances connected to special test entities that play the role of the
MAC and of the PDCP, implementing respectively the LteMacSapProvider
and LteRlcSapUser interfaces. Different test cases (i.e., input test
vector consisting of series of primitive calls by the MAC and the
PDCP) are provided that check the behavior in the following cases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>one SDU, one PDU: the MAC notifies a TX opportunity causes the creation of a PDU which exactly
contains a whole SDU</p></li>
<li><p>segmentation: the MAC notifies multiple TX opportunities that are smaller than the SDU
size stored in the transmission buffer, which is then to be fragmented and hence
multiple PDUs are generated;</p></li>
<li><p>concatenation: the MAC notifies a TX opportunity that is bigger than the SDU, hence
multiple SDUs are concatenated in the same PDU</p></li>
<li><p>buffer status report: a series of new SDUs notifications by the
PDCP is inteleaved with a series of TX opportunity notification in
order to verify that the buffer status report procedure is
correct.</p></li>
</ol>
</div></blockquote>
<p>In all these cases, an output test vector is determine manually from
knowledge of the input test vector and knowledge of the expected
behavior. These test vector are specialized for UM RLC and
AM RLC due to their different behavior. Each test case passes if the
sequence of primitives triggered by the RLC instance being tested is
exactly equal to the output test vector. In particular, for each PDU
transmitted by the RLC instance, both the size and the content of the
PDU are verified to check for an exact match with the test vector.</p>
<p>The AM RLC implementation features an additional test suite,
<code class="docutils literal notranslate"><span class="pre">lte-rlc-am-e2e</span></code>, which test the correct retransmission of RLC PDUs
in presence of channel losses. The test instantiates an RLC AM
transmitter and a receiver, and interposes a channel that randomly
drops packet according to a fixed loss probability. Different test
cases are instantiated using different <code class="docutils literal notranslate"><span class="pre">RngRun</span></code> values and different
loss probability values. Each test case passes if at the end of the
simulation all SDUs are correctly delivered to the upper layers of the
receiving RLC AM entity.</p>
</section>
<section id="rrc">
<h6><span class="section-number">20.3.2.2.20. </span>RRC<a class="headerlink" href="#rrc" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-rrc</span></code> tests the correct functionality of the following aspects:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>MAC Random Access</p></li>
<li><p>RRC System Information Acquisition</p></li>
<li><p>RRC Connection Establishment</p></li>
<li><p>RRC Reconfiguration</p></li>
</ol>
</div></blockquote>
<p>The test suite considers a type of scenario with four eNBs aligned in a square
layout with 100-meter edges. Multiple UEs are located at a specific spot on the
diagonal of the square and are instructed to connect to the first eNB. Each test
case implements an instance of this scenario with specific values of the
following parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p>number of UEs</p></li>
<li><p>number of Data Radio Bearers to be activated for each UE</p></li>
<li><p>time <img class="math" src="_images/math/511913a5166810e272143aa5a72e55d8a777f5da.png" alt="t^c_0"/> at which the first UE is instructed to start connecting to the eNB</p></li>
<li><p>time interval <img class="math" src="_images/math/753eeeba5df399768e0087372e9611205b6c9c18.png" alt="d^i"/> between the start of connection of UE <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and UE <img class="math" src="_images/math/85f9a5bfa0dccf215f10e2a5005def3cbe2afc0d.png" alt="n+1"/>; the time at which user <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> connects is thus determined as <img class="math" src="_images/math/60750e15a3b5ace16e2b074b3c30658d1a4e2519.png" alt="t^c_n = t^c_0 + n d^i"/> sdf</p></li>
<li><p>the relative position of the UEs on the diagonal of the square, where higher
values indicate larger distance from the serving eNodeB, i.e., higher
interference from the other eNodeBs</p></li>
<li><p>a boolean flag indicating whether the ideal or the real RRC protocol model is used</p></li>
</ul>
</div></blockquote>
<p>Each test cases passes if a number of test conditions are positively evaluated for each UE after a delay <img class="math" src="_images/math/2d351aabbbef8512d94c9258ca8ffbf0020ec335.png" alt="d^e"/> from the time it started connecting to the eNB. The delay <img class="math" src="_images/math/2d351aabbbef8512d94c9258ca8ffbf0020ec335.png" alt="d^e"/> is determined as</p>
<div class="math">
<p><img src="_images/math/bd9a678191c4e31b62f82430a69c9dc2766801c0.png" alt="d^e = d^{si} + d^{ra} + d^{ce} + d^{cr}"/></p>
</div><p>where:</p>
<blockquote>
<div><ul class="simple">
<li><p><img class="math" src="_images/math/5d76a28e8ea44d4f8a3790b762b492c065fa5f84.png" alt="d^{si}"/> is the max delay necessary for the acquisition of System Information. We set it to 90ms accounting for 10ms for the MIB acquisition and 80ms for the subsequent SIB2 acquisition</p></li>
<li><p><img class="math" src="_images/math/3a5bd844f1fcc534188d7b3f6774f8f510cd9014.png" alt="d^{ra}"/> is the delay for the MAC Random Access (RA)
procedure. This depends on preamble collisions as well as on the
availability of resources for the UL grant allocation. The total amount of
necessary RA attempts depends on preamble collisions and failures
to allocate the UL grant because of lack of resources. The number
of collisions depends on the number of UEs that try to access
simultaneously; we estimated that for a <img class="math" src="_images/math/74261a208872c78696fcccf7acb68e0d369ff3c0.png" alt="0.99"/> RA success
probability, 5 attempts are sufficient for up to 20 UEs, and  10 attempts for up
to 50 UEs.
For the UL grant, considered the system bandwidth and the
default MCS used for the UL grant (MCS 0), at most 4 UL grants can
be assigned in a TTI; so for <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> UEs trying to
do RA simultaneously the max number of attempts due to the UL grant
issue is <img class="math" src="_images/math/63cc23020a0d2080bb342b59f5c0ec2fdad056b1.png" alt="\lceil n/4 \rceil"/>. The time for
a RA attempt  is determined by 3ms + the value of
LteEnbMac::RaResponseWindowSize, which defaults to 3ms, plus 1ms
for the scheduling of the new transmission.</p></li>
<li><p><img class="math" src="_images/math/35f9280c7c24e94b4237675033babdec0dc3a5ba.png" alt="d^{ce}"/> is the delay required for the transmission of RRC CONNECTION
SETUP + RRC CONNECTION SETUP COMPLETED. We consider a round trip
delay of 10ms plus <img class="math" src="_images/math/18d4b9aa5e87a37cbeec703da93d17309a0ed4d0.png" alt="\lceil 2n/4 \rceil"/> considering that 2
RRC packets have to be transmitted and that at most 4 such packets
can be transmitted per TTI. In cases where interference is high, we
accommodate one retry attempt by the UE, so we double the <img class="math" src="_images/math/35f9280c7c24e94b4237675033babdec0dc3a5ba.png" alt="d^{ce}"/>
value and then add <img class="math" src="_images/math/5d76a28e8ea44d4f8a3790b762b492c065fa5f84.png" alt="d^{si}"/> on top of it (because the timeout has
reset the previously received SIB2).</p></li>
<li><p><img class="math" src="_images/math/7ebefb6f961db880c32e35741f8f45249ef84823.png" alt="d^{cr}"/> is the delay required for eventually needed RRC
CONNECTION RECONFIGURATION transactions. The number of transactions needed is
1 for each bearer activation. Similarly to what done for
<img class="math" src="_images/math/35f9280c7c24e94b4237675033babdec0dc3a5ba.png" alt="d^{ce}"/>, for each transaction we consider a round trip
delay of 10ms plus <img class="math" src="_images/math/18d4b9aa5e87a37cbeec703da93d17309a0ed4d0.png" alt="\lceil 2n/4 \rceil"/>.
delay of 20ms.</p></li>
</ul>
</div></blockquote>
<p>The base version of the test <code class="docutils literal notranslate"><span class="pre">LteRrcConnectionEstablishmentTestCase</span></code>
tests for correct RRC connection establishment in absence of channel
errors. The conditions that are evaluated for this test case to pass
are, for each UE:</p>
<blockquote>
<div><ul class="simple">
<li><p>the RRC state at the UE is CONNECTED_NORMALLY</p></li>
<li><p>the UE is configured with the CellId, DlBandwidth, UlBandwidth,
DlEarfcn and UlEarfcn of the eNB</p></li>
<li><p>the IMSI of the UE stored at the eNB is correct</p></li>
<li><p>the number of active Data Radio Bearers is the expected one, both
at the eNB and at the UE</p></li>
<li><p>for each Data Radio Bearer, the following identifiers match between
the UE and the eNB: EPS bearer id, DRB id, LCID</p></li>
</ul>
</div></blockquote>
<p>The test variant <code class="docutils literal notranslate"><span class="pre">LteRrcConnectionEstablishmentErrorTestCase</span></code> is
similar except for the presence of errors in the transmission of a
particular RRC message of choice during the first connection
attempt. The error is obtained by temporarily moving the UE to a far
away location; the time of movement has been determined empirically
for each instance of the test case based on the message that it was
desired to be in error. The test case checks that at least one of the following
conditions is false at the time right before the UE is moved back to
the original location:</p>
<blockquote>
<div><ul class="simple">
<li><p>the RRC state at the UE is CONNECTED_NORMALLY</p></li>
<li><p>the UE context at the eNB is present</p></li>
<li><p>the RRC state of the UE Context at the eNB is CONNECTED_NORMALLY</p></li>
</ul>
</div></blockquote>
</section>
<section id="initial-cell-selection">
<h6><span class="section-number">20.3.2.2.21. </span>Initial cell selection<a class="headerlink" href="#initial-cell-selection" title="Link to this heading">¶</a></h6>
<p>The test suite <cite>lte-cell-selection</cite> is responsible for verifying the
<a class="reference internal" href="index.html#sec-initial-cell-selection"><span class="std std-ref">Initial Cell Selection</span></a> procedure. The test is a simulation of a small
network of 2 non-CSG cells and 2 non-CSG cells. Several static UEs are then
placed at predefined locations. The UEs enter the simulation without being
attached to any cell. Initial cell selection is enabled for these UEs, so each
UE will find the best cell and attach to it by themselves.</p>
<p>At predefined check points time during the simulation, the test verifies that
every UE is attached to the right cell. Moreover, the test also ensures that the
UE is properly connected, i.e., its final state is <cite>CONNECTED_NORMALLY</cite>. Figure
<a class="reference internal" href="#fig-lte-cell-selection-scenario"><span class="std std-ref">Sample result of cell selection test</span></a> depicts the network layout and the
expected result. When a UE is depicted as having 2 successful cell selections
(e.g., UE #3 and #4), any of them is accepted by the test case.</p>
<figure class="align-center" id="id25">
<span id="fig-lte-cell-selection-scenario"></span><a class="reference internal image-reference" href="_images/lte-cell-selection-scenario.png"><img alt="_images/lte-cell-selection-scenario.png" src="_images/lte-cell-selection-scenario.png" style="width: 624.0px; height: 345.6px;" /></a>
<figcaption>
<p><span class="caption-text">Sample result of cell selection test</span><a class="headerlink" href="#id25" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The figure shows that CSG members may attach to either CSG or non-CSG cells, and
simply choose the stronger one. On the other hand, non-members can only attach
to non-CSG cells, even when they are actually receiving stronger signal from a
CSG cell.</p>
<p>For reference purpose, Table <a class="reference internal" href="#tab-cell-selection-error-rate"><span class="std std-ref">UE error rate in Initial Cell Selection test</span></a> shows the
error rate of each UE when receiving transmission from the control channel.
Based on this information, the check point time for UE #3 is done at a later
time than the others to compensate for its higher risk of failure.</p>
<span id="tab-cell-selection-error-rate"></span><table class="docutils align-default" id="id26">
<caption><span class="caption-text">UE error rate in Initial Cell Selection test</span><a class="headerlink" href="#id26" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>UE #</p></th>
<th class="head"><p>Error rate</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>0.00%</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>1.44%</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>12.39%</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>0.33%</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>0.00%</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>0.00%</p></td>
</tr>
</tbody>
</table>
<p>The test uses the default Friis path loss model and without any channel fading
model.</p>
</section>
<section id="secondary-cell-selection">
<h6><span class="section-number">20.3.2.2.22. </span>Secondary cell selection<a class="headerlink" href="#secondary-cell-selection" title="Link to this heading">¶</a></h6>
<p>The unit test <code class="docutils literal notranslate"><span class="pre">lte-secondary-cell-selection`</span></code> tests that a UE can attach to
any component carrier (not just the 0-th one) during initial cell selection.</p>
</section>
<section id="handover-with-multiple-component-carriers">
<h6><span class="section-number">20.3.2.2.23. </span>Handover with multiple component carriers<a class="headerlink" href="#handover-with-multiple-component-carriers" title="Link to this heading">¶</a></h6>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">lte-primary-cell-change</span></code> tests a number of handover
cases between different component carriers, for both the Ideal RRC and the
Real RRC.  The following handover cases are tested:</p>
<ul class="simple">
<li><p>(inter-eNB) eNB to eNB with one component carrier</p></li>
<li><p>(inter-eNB) handover between the first carrier of two eNBs</p></li>
<li><p>(inter-eNB) handover between the second carrier of one eNB to the first carrier of another eNB</p></li>
<li><p>(inter-eNB) handover between the second carrier of one eNB to the second carrier of another eNB</p></li>
<li><p>(intra-eNB) three handover cases between component carriers of the same eNB</p></li>
</ul>
</section>
<section id="gtp-u-protocol">
<h6><span class="section-number">20.3.2.2.24. </span>GTP-U protocol<a class="headerlink" href="#gtp-u-protocol" title="Link to this heading">¶</a></h6>
<p>The unit test suite <code class="docutils literal notranslate"><span class="pre">epc-gtpu</span></code> checks that the encoding and decoding of the GTP-U
header is done correctly. The test fills in a header with a set of
known values, adds the header to a packet, and then removes the header
from the packet. The test fails if, upon removing, any of the fields
in the GTP-U header is not decoded correctly. This is detected by
comparing the decoded value from the known value.</p>
</section>
<section id="s1-u-interface">
<h6><span class="section-number">20.3.2.2.25. </span>S1-U interface<a class="headerlink" href="#s1-u-interface" title="Link to this heading">¶</a></h6>
<p>Two test suites (<code class="docutils literal notranslate"><span class="pre">epc-s1u-uplink</span></code> and <code class="docutils literal notranslate"><span class="pre">epc-s1u-downlink</span></code>) make
sure that the S1-U interface implementation works correctly in
isolation. This is achieved by creating a set of simulation scenarios
where the EPC model alone is used, without the LTE model (i.e.,
without the LTE radio protocol stack, which is replaced by simple CSMA
devices). This checks that the
interoperation between multiple EpcEnbApplication instances in
multiple eNBs and the EpcSgwPgwApplication instance in the SGW/PGW
node works correctly in a variety of scenarios, with varying numbers
of end users (nodes with a CSMA device installed), eNBs, and different
traffic patterns (packet sizes and number of total packets).
Each test case works by injecting the chosen traffic pattern in the
network (at the considered UE or at the remote host for in the uplink or the
downlink test suite respectively) and checking that at the receiver
(the remote host or each  considered UE, respectively) that exactly the same
traffic patterns is received. If any mismatch in the transmitted and
received traffic pattern is detected for any UE, the test fails.</p>
</section>
<section id="tft-classifier">
<h6><span class="section-number">20.3.2.2.26. </span>TFT classifier<a class="headerlink" href="#tft-classifier" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">epc-tft-classifier</span></code> checks in isolation that the
behavior of the EpcTftClassifier class is correct. This is performed
by creating different classifier instances where different TFT
instances are activated, and testing for each classifier that an
heterogeneous set of packets (including IP and TCP/UDP headers) is
classified correctly. Several test cases are provided that check the
different matching aspects of a TFT (e.g. local/remote IP address, local/remote port) both for uplink and
downlink traffic.  Each test case corresponds to a specific packet and
a specific classifier instance with a given set of TFTs. The test case
passes if the bearer identifier returned by the classifier exactly
matches with the one that is expected for the considered packet.</p>
</section>
<section id="end-to-end-lte-epc-data-plane-functionality">
<h6><span class="section-number">20.3.2.2.27. </span>End-to-end LTE-EPC data plane functionality<a class="headerlink" href="#end-to-end-lte-epc-data-plane-functionality" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-epc-e2e-data</span></code> ensures the correct end-to-end
functionality of the LTE-EPC data plane. For each test case in this
suite, a complete LTE-EPC simulation
scenario is created with the following characteristics:</p>
<blockquote>
<div><ul class="simple">
<li><p>a given number of eNBs</p></li>
<li><p>for each eNB, a given number of UEs</p></li>
<li><p>for each UE, a given number of active EPS bearers</p></li>
<li><p>for each active EPS bearer, a given traffic pattern (number of UDP
packets to be transmitted and packet size)</p></li>
</ul>
</div></blockquote>
<p>Each test is executed by transmitting the given traffic pattern both
in the uplink and in the downlink, at subsequent time intervals. The
test passes if all the following conditions are satisfied:</p>
<blockquote>
<div><ul class="simple">
<li><p>for each active EPS bearer, the transmitted and received traffic
pattern (respectively  at the UE and the remote host for uplink,
and vice versa for downlink) is exactly the same</p></li>
<li><p>for each active EPS bearer and each direction (uplink or downlink),
exactly the expected number of packet flows over the corresponding
RadioBearer instance</p></li>
</ul>
</div></blockquote>
</section>
<section id="x2-handover">
<h6><span class="section-number">20.3.2.2.28. </span>X2 handover<a class="headerlink" href="#x2-handover" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-x2-handover</span></code> checks the correct functionality of the X2 handover procedure. The scenario being tested is a topology with two eNBs connected by an X2 interface. Each test case is a particular instance of this scenario defined by the following parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p>the number of UEs that are initially attached to the first eNB</p></li>
<li><p>the number of EPS bearers activated for each UE</p></li>
<li><p>a list of handover events to be triggered, where each event is defined by:
+ the start time of the handover trigger
+ the index of the UE doing the handover
+ the index of the source eNB
+ the index of the target eNB</p></li>
<li><p>a boolean flag indicating whether the target eNB admits the handover or not</p></li>
<li><p>a boolean flag indicating whether the ideal RRC protocol is to be used instead of the real RRC protocol</p></li>
<li><p>the type of scheduler to be used (RR or PF)</p></li>
</ul>
</div></blockquote>
<p>Each test case passes if the following conditions are true:</p>
<blockquote>
<div><ul class="simple">
<li><p>at time 0.06s, the test CheckConnected verifies that each UE is connected to the first eNB</p></li>
<li><p>for each event in the handover list:</p>
<ul>
<li><p>at the indicated event start time, the indicated UE is connected to the indicated source eNB</p></li>
<li><p>0.1s after the start time, the indicated UE is connected to the indicated target eNB</p></li>
<li><p>0.6s after the start time, for each active EPS bearer, the uplink and downlink sink applications of the indicated UE have achieved a number of bytes which is at least half the number of bytes transmitted by the corresponding source applications</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>The condition “UE is connected to eNB” is evaluated positively if and only if all the following conditions are met:</p>
<blockquote>
<div><ul class="simple">
<li><p>the eNB has the context of the UE (identified by the RNTI value
retrieved from the UE RRC)</p></li>
<li><p>the RRC state of the UE at the eNB is CONNECTED_NORMALLY</p></li>
<li><p>the RRC state at the UE is CONNECTED_NORMALLY</p></li>
<li><p>the UE is configured with the CellId, DlBandwidth, UlBandwidth,
DlEarfcn and UlEarfcn of the eNB</p></li>
<li><p>the IMSI of the UE stored at the eNB is correct</p></li>
<li><p>the number of active Data Radio Bearers is the expected one, both
at the eNB and at the UE</p></li>
<li><p>for each Data Radio Bearer, the following identifiers match between
the UE and the eNB: EPS bearer id, DRB id, LCID</p></li>
</ul>
</div></blockquote>
</section>
<section id="automatic-x2-handover">
<h6><span class="section-number">20.3.2.2.29. </span>Automatic X2 handover<a class="headerlink" href="#automatic-x2-handover" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-x2-handover-measures</span></code> checks the correct functionality of the handover
algorithm. The scenario being tested is a topology with two, three or four eNBs connected by
an X2 interface. The eNBs are located in a straight line in the X-axes. A UE moves along the
X-axes going from the neighborhood of one eNB to the next eNB. Each test case is a particular
instance of this scenario defined by the following parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p>the number of eNBs in the X-axes</p></li>
<li><p>the number of UEs</p></li>
<li><p>the number of EPS bearers activated for the UE</p></li>
<li><p>a list of check point events to be triggered, where each event is defined by:
+ the time of the first check point event
+ the time of the last check point event
+ interval time between two check point events
+ the index of the UE doing the handover
+ the index of the eNB where the UE must be connected</p></li>
<li><p>a boolean flag indicating whether UDP traffic is to be used instead of TCP traffic</p></li>
<li><p>the type of scheduler to be used</p></li>
<li><p>the type of handover algorithm to be used</p></li>
<li><p>a boolean flag indicating whether handover is admitted by default</p></li>
<li><p>a boolean flag indicating whether the ideal RRC protocol is to be used instead of the
real RRC protocol</p></li>
</ul>
</div></blockquote>
<p>The test suite consists of many test cases. In fact, it has been one of the most
time-consuming test suite in ns-3. The test cases run with <em>some</em> combination of
the following variable parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p>number of eNBs: 2, 3, 4;</p></li>
<li><p>number of EPS bearers: 0, 1, 2;</p></li>
<li><p>RRC: ideal, real (see <a class="reference internal" href="index.html#sec-rrc-protocol-models"><span class="std std-ref">RRC protocol models</span></a>);</p></li>
<li><p>MAC scheduler: round robin, proportional fair (see <a class="reference internal" href="index.html#sec-ff-mac-scheduler"><span class="std std-ref">The FemtoForum MAC Scheduler Interface</span></a>); and</p></li>
<li><p>handover algorithm: A2-A4-RSRQ, strongest cell (see <a class="reference internal" href="index.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a>).</p></li>
</ul>
</div></blockquote>
<p>Each test case passes if the following conditions are true:</p>
<blockquote>
<div><ul class="simple">
<li><p>at time 0.08s, the test CheckConnected verifies that each UE is connected to the first eNB</p></li>
<li><p>for each event in the check point list:</p>
<ul>
<li><p>at the indicated check point time, the indicated UE is connected to the indicated eNB</p></li>
<li><p>0.5s after the check point, for each active EPS bearer, the uplink and downlink sink
applications of the UE have achieved a number of bytes which is at least half the number
of bytes transmitted by the corresponding source applications</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>The condition “UE is connected to eNB” is evaluated positively if and only if all the following conditions are met:</p>
<blockquote>
<div><ul class="simple">
<li><p>the eNB has the context of the UE (identified by the RNTI value
retrieved from the UE RRC)</p></li>
<li><p>the RRC state of the UE at the eNB is CONNECTED_NORMALLY</p></li>
<li><p>the RRC state at the UE is CONNECTED_NORMALLY</p></li>
<li><p>the UE is configured with the CellId, DlBandwidth, UlBandwidth,
DlEarfcn and UlEarfcn of the eNB</p></li>
<li><p>the IMSI of the UE stored at the eNB is correct</p></li>
<li><p>the number of active Data Radio Bearers is the expected one, both
at the eNB and at the UE</p></li>
<li><p>for each Data Radio Bearer, the following identifiers match between
the UE and the eNB: EPS bearer id, DRB id, LCID</p></li>
</ul>
</div></blockquote>
</section>
<section id="handover-delays">
<h6><span class="section-number">20.3.2.2.30. </span>Handover delays<a class="headerlink" href="#handover-delays" title="Link to this heading">¶</a></h6>
<p>Handover procedure consists of several message exchanges between UE, source
eNodeB, and target eNodeB over both RRC protocol and X2 interface. Test suite
<code class="docutils literal notranslate"><span class="pre">lte-handover-delay</span></code> verifies that this procedure consistently spends the
same amount of time.</p>
<p>The test suite will run several handover test cases. Each test case is an
individual simulation featuring a handover at a specified time in simulation.
For example, the handover in the first test case is invoked at time +0.100s,
while in the second test case it is at +0.101s. There are 10 test cases, each
testing a different subframe in LTE. Thus the last test case has the handover
at +0.109s.</p>
<p>The simulation scenario in the test cases is as follow:</p>
<blockquote>
<div><ul class="simple">
<li><p>EPC is enabled</p></li>
<li><p>2 eNodeBs with circular (isotropic) antenna, separated by 1000 meters</p></li>
<li><p>1 static UE positioned exactly in the center between the eNodeBs</p></li>
<li><p>no application installed</p></li>
<li><p>no channel fading</p></li>
<li><p>default path loss model (Friis)</p></li>
<li><p>0.300s simulation duration</p></li>
</ul>
</div></blockquote>
<p>The test case runs as follow. At the beginning of the simulation, the UE is
attached to the first eNodeB. Then at the time specified by the test case input
argument, a handover request will be explicitly issued to the second eNodeB.
The test case will then record the starting time, wait until the handover is
completed, and then record the completion time. If the difference between the
completion time and starting time is less than a predefined threshold, then the
test passes.</p>
<p>A typical handover in the current ns-3 implementation takes 4.2141 ms when using
Ideal RRC protocol model, and 19.9283 ms when using Real RRC protocol model.
Accordingly, the test cases use 5 ms and 20 ms as the maximum threshold values.
The test suite runs 10 test cases with Ideal RRC protocol model and 10 test
cases with Real RRC protocol model. More information regarding these models can
be found in Section <a class="reference internal" href="index.html#sec-rrc-protocol-models"><span class="std std-ref">RRC protocol models</span></a>.</p>
<p>The motivation behind using subframes as the main test parameters is the fact
that subframe index is one of the factors for calculating RA-RNTI, which is used
by Random Access during the handover procedure. The test cases verify this
computation, utilizing the fact that the handover will be delayed when this
computation is broken. In the default simulation configuration, the handover
delay observed because of a broken RA-RNTI computation is typically 6 ms.</p>
</section>
<section id="handover-failure">
<h6><span class="section-number">20.3.2.2.31. </span>Handover failure<a class="headerlink" href="#handover-failure" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-handover-failure</span></code> tests the proper operation of a number
of handover failure cases by inducing the conditions leading to the following
eight failure modes:</p>
<ol class="arabic simple">
<li><p>Maximum number of RACH transmissions exceeded from UE to target eNB</p></li>
<li><p>Non-allocation of non-contention-based preamble at the target eNB, due to the maximum number reached</p></li>
<li><p>HANDOVER JOINING timeout before reception of RRC CONNECTION RECONFIGURATION at source eNB</p></li>
<li><p>HANDOVER JOINING timeout before completion of non-contention RACH process to target eNB</p></li>
<li><p>HANDOVER JOINING timeout before reception of RRC CONNECTION RECONFIGURATION COMPLETE at target eNB</p></li>
<li><p>HANDOVER LEAVING timeout before reception of RRC CONNECTION RECONFIGURATION at source eNB</p></li>
<li><p>HANDOVER LEAVING timeout before completion of non-contention RACH process to target eNB</p></li>
<li><p>HANDOVER LEAVING timeout before reception of RRC CONNECTION RECONFIGURATION COMPLETE attarget eNB</p></li>
</ol>
<p>Both Ideal and Real RRC models are checked by this test suite.</p>
</section>
<section id="selection-of-target-cell-in-handover-algorithm">
<h6><span class="section-number">20.3.2.2.32. </span>Selection of target cell in handover algorithm<a class="headerlink" href="#selection-of-target-cell-in-handover-algorithm" title="Link to this heading">¶</a></h6>
<p>eNodeB may utilize <a class="reference internal" href="index.html#sec-handover-algorithm"><span class="std std-ref">Handover algorithm</span></a> to automatically create
handover decisions during simulation. The decision includes the UE which should
do the handover and the target cell where the UE should perform handover to.</p>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-handover-target</span></code> verifies that the handover algorithm is
making the right decision, in particular, in choosing the right target cell. It
consists of several short test cases for different network topology (2×2 grid
and 3×2 grid) and types of handover algorithm (the A2-A4-RSRQ handover algorithm
and the strongest cell handover algorithm).</p>
<p>Each test case is a simulation of a micro-cell environment with the following
parameter:</p>
<blockquote>
<div><ul class="simple">
<li><p>EPC is enabled</p></li>
<li><p>several circular (isotropic antenna) micro-cell eNodeBs in a rectangular grid
layout, with 130 m distance between each adjacent point</p></li>
<li><p>1 static UE, positioned close to and attached to the source cell</p></li>
<li><p>no control channel error model</p></li>
<li><p>no application installed</p></li>
<li><p>no channel fading</p></li>
<li><p>default path loss model (Friis)</p></li>
<li><p>1s simulation duration</p></li>
</ul>
</div></blockquote>
<p>To trigger a handover, the test case “shutdowns” the source cell at +0.5s
simulation time. Figure <a class="reference internal" href="#fig-lte-handover-target-scenario"><span class="std std-ref">lte-handover-target test scenario in a 2×2 grid</span></a> below
illustrates the process. This is done by setting the source cell’s Tx power to
a very low value. As a result, the handover algorithm notices that the UE
deserves a handover and several neighboring cells become candidates of target
cell at the same time.</p>
<figure class="align-center" id="id27">
<span id="fig-lte-handover-target-scenario"></span><a class="reference internal image-reference" href="_images/lte-handover-target-scenario.png"><img alt="_images/lte-handover-target-scenario.png" src="_images/lte-handover-target-scenario.png" style="width: 871.2px; height: 316.8px;" /></a>
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">lte-handover-target</span></code> test scenario in a 2×2 grid</span><a class="headerlink" href="#id27" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The test case then verifies that the handover algorithm, when faced with more
than one options of target cells, is able to choose the right one.</p>
</section>
<section id="downlink-power-control">
<h6><span class="section-number">20.3.2.2.33. </span>Downlink Power Control<a class="headerlink" href="#downlink-power-control" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-downlink-power-control</span></code> checks correctness of Downlink
Power Control in three different ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>LteDownlinkPowerControlSpectrumValue test case   check if
<code class="docutils literal notranslate"><span class="pre">LteSpectrumValueHelper::CreateTxPowerSpectralDensity</span></code> is creating correct
spectrum value for PSD for downlink transmission. The test vector contain EARFCN,
system bandwidth, TX power, TX power for each RB, active RBs, and expected TxPSD.
The test passes if TxPDS generated by
<code class="docutils literal notranslate"><span class="pre">LteSpectrumValueHelper::CreateTxPowerSpectralDensity</span></code> is equal to expected TxPSD.</p></li>
<li><p>LteDownlinkPowerControlTestCase test case check if TX power difference between
data and control channel is equal to configured PdschConfigDedicated::P_A value.
TX power of control channel is measured by <code class="docutils literal notranslate"><span class="pre">LteTestSinrChunkProcessor</span></code> added
to <code class="docutils literal notranslate"><span class="pre">RsPowerChunkProcessor</span></code> list in UE DownlinkSpectrumPhy. Tx power of data
channel is measured in similar way, but it had to be implemented. Now
<code class="docutils literal notranslate"><span class="pre">LteTestSinrChunkProcessor</span></code> is added to <code class="docutils literal notranslate"><span class="pre">DataPowerChunkProcessor</span></code> list in UE
DownlinkSpectrumPhy. Test vector contain a set of all available P_A values. Test
pass if power difference equals P_A value.</p></li>
<li><p>LteDownlinkPowerControlRrcConnectionReconfiguration test case check if
RrcConnectionReconfiguration is performed correctly. When FR entity gets UE
measurements, it immediately calls function to change P_A value for this UE and also
triggers callback connected with this event. Then, test check if UE gets
RrcConnectionReconfiguration message (it trigger callback). Finally, it checks if eNB
receive RrcConnectionReconfigurationCompleted message, what also trigger callback.
The test passes if all event have occurred. The test is performed two times, with
IdealRrcProtocol and with RealRrcProtocol.</p></li>
</ul>
</div></blockquote>
</section>
<section id="uplink-power-control-tests">
<h6><span class="section-number">20.3.2.2.34. </span>Uplink Power Control Tests<a class="headerlink" href="#uplink-power-control-tests" title="Link to this heading">¶</a></h6>
<p>UE uses Uplink Power Control to automatically change Tx Power level for Uplink
Physical Channels. Tx Power is computed based on path-loss, number of RB used for transmission,
some configurable parameters and TPC command from eNB.</p>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-uplink-power-control</span></code> verifies if Tx Power is computed correctly.
There are three different test cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>LteUplinkOpenLoopPowerControlTestCase test case checks Uplink Power Control functionality
in Open Loop mechanism. UE is attached to eNB and is transmitting data in Downlink and
Uplink. Uplink Power Control with Open Loop mechanism is enabled and UE changes position
each 100 ms. In each position Uplink Power Control entity is calculating new Tx Power level
for all uplink channels. These values are traced and test passes if Uplink Tx Power for
PUSCH, PUCCH and SRS in each UE position are equal to expected values.</p></li>
<li><p>LteUplinkClosedLoopPowerControlAbsoluteModeTestCase test case checks Uplink Power Control
functionality with Closed Loop mechanism and Absolute Mode enabled.
UE is attached to eNB and is transmitting data in Downlink and Uplink. Uplink Power Control
with Closed Loop mechanism and Absolute Mode is enabled. UE is located 100 m from eNB and
is not changing its position. LteFfrSimple algorithm is used on eNB side to set TPC values in
DL-DCI messages. TPC configuration in eNB is changed every 100 ms, so every 100 ms Uplink
Power Control entity in UE should calculate different Tx Power level for all uplink channels.
These values are traced and test passes if Uplink Tx Power for PUSCH, PUCCH and SRS
computed with all TCP values are equal to expected values.</p></li>
<li><p>LteUplinkClosedLoopPowerControlAccumulatedModeTestCase test case checks Closed Loop Uplink
Power Control functionality with Closed Loop mechanism and Accumulative Mode enabled.
UE is attached to eNB and is transmitting data in Downlink and Uplink. Uplink Power Control
with Closed Loop mechanism and Accumulative Mode is enabled. UE is located 100 m from eNB and
is not changing its position. As in above test case, LteFfrSimple algorithm is used on eNB
side to set TPC values in DL-DCI messages, but in this case TPC command are set in DL-DCI
only configured number of times, and after that TPC is set to be 1, what is mapped to value
of 0 in Accumulative Mode (TS36.213 Table 5.1.1.1-2). TPC configuration in eNB is changed
every 100 ms. UE is accumulating these values and calculates Tx Power levels for all uplink
channels based on accumulated value. If computed Tx Power level is lower than minimal
UE Tx Power, UE should transmit with its minimal Tx Power. If computed Tx Power level is
higher than maximal UE Tx Power, UE should transmit with its maximal Tx Power.
Tx Power levels for PUSCH, PUCCH and SRS are traced and test passes if they are equal to
expected values.</p></li>
</ul>
</div></blockquote>
</section>
<section id="frequency-reuse-algorithms">
<h6><span class="section-number">20.3.2.2.35. </span>Frequency Reuse Algorithms<a class="headerlink" href="#frequency-reuse-algorithms" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-frequency-reuse</span></code> contain two types of test cases.</p>
<p>First type of test cases check if RBGs are used correctly according to FR algorithm
policy. We are testing if scheduler use only RBGs allowed by FR configuration. To
check which RBGs are used <code class="docutils literal notranslate"><span class="pre">LteSimpleSpectrumPhy</span></code> is attached to Downlink Channel.
It notifies when data downlink channel transmission has occurred and pass signal
TxPsd spectrum value to check which RBs were used for transmission. The test vector
comprise a set of configuration for Hard and Strict FR algorithms (there is no point
to check other FR algorithms in this way because they use entire cell bandwidth).
Test passes if none of not allowed RBGs are used.</p>
<p>Second type of test cases check if UE is served within proper sub-band and with proper
transmission power. In this test scenario, there are two eNBs.There are also two UEs
and each eNB is serving one.  One uses Frequency Reuse algorithm and second one does not.
Second eNB is responsible for generating interferences in whole system bandwidth.
UE served by first eNB is changing position each few second (rather slow because time is
needed to report new UE Measurements). To check which RBGs are used for this UE
<code class="docutils literal notranslate"><span class="pre">LteSimpleSpectrumPhy</span></code> is attached to Downlink Channel. It notifies when data
downlink channel transmission in cell 1 has occurred and pass signal TxPsd spectrum value
to check which RBs were used for transmission and their power level.
The same approach is applied in Uplink direction and second <code class="docutils literal notranslate"><span class="pre">LteSimpleSpectrumPhy</span></code>
is attached to Uplink Channel. Test passes if UE served by eNB with FR algorithm
is served in DL and UL with expected RBs and with expected power level.
Test vector comprise a configuration for Strict FR, Soft FR, Soft FFR, Enhanced FFR.
Each FR algorithm is tested with all schedulers, which support FR (i.e. PF, PSS, CQA,
TD-TBFQ, FD-TBFQ). (Hard FR do not use UE measurements, so there is no point to perform
this type of test for Hard FR).</p>
<p>Test case for Distributed FFR algorithm is quite similar to above one, but since eNBs need
to exchange some information, scenario with EPC enabled and X2 interfaces is considered.
Moreover, both eNB are using Distributed FFR algorithm. There are 2 UE in first cell,
and 1 in second cell. Position of each UE is changed (rather slow because time is
needed to report new UE Measurements), to obtain different result from calculation in
Distributed FFR algorithm entities. To check which RBGs are used for UE transmission
<code class="docutils literal notranslate"><span class="pre">LteSimpleSpectrumPhy</span></code> is attached to Downlink Channel. It notifies when data
downlink channel transmission has occurred and pass signal TxPsd spectrum value
to check which RBs were used for transmission and their power level.
The same approach is applied in Uplink direction and second <code class="docutils literal notranslate"><span class="pre">LteSimpleSpectrumPhy</span></code>
is attached to Uplink Channel.
Test passes if UE served by eNB in cell 2, is served in DL and UL with expected RBs
and with expected power level. Test vector comprise a configuration for Distributed FFR.
Test is performed with all schedulers, which support FR (i.e. PF, PSS, CQA,
TD-TBFQ, FD-TBFQ).</p>
</section>
<section id="inter-cell-interference-with-fr-algorithms-tests">
<h6><span class="section-number">20.3.2.2.36. </span>Inter-cell Interference with FR algorithms Tests<a class="headerlink" href="#inter-cell-interference-with-fr-algorithms-tests" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-interference-fr</span></code> is very similar to <code class="docutils literal notranslate"><span class="pre">lte-interference</span></code>.
Topology (Figure <a class="reference internal" href="#fig-lte-interference-test-scenario"><span class="std std-ref">Topology for the inter-cell interference test</span></a>) is the same and test checks
interference level. The difference is that, in this test case Frequency Reuse algorithms
are enabled and we are checking interference level on different RBGs (not only on one).
For example, when we install Hard FR algorithm in eNbs, and first half of system bandwidth
is assigned to one eNb, and second half to second eNb, interference level should be much
lower compared to legacy scenario. The test vector comprise a set of configuration for
all available Frequency Reuse Algorithms. Test passes if calculated SINR on specific
RBs is equal to these obtained by Octave script.</p>
</section>
<section id="carrier-aggregation-test">
<h6><span class="section-number">20.3.2.2.37. </span>Carrier aggregation test<a class="headerlink" href="#carrier-aggregation-test" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-carrier-aggregation</span></code> is a system test program that creates different test
cases with a single eNB and several UEs, all having the same radio bearer specification. Different
test cases are implemented by using different SINR values and different numbers of UEs. eNBs and UEs
are configured to use the secondary carrier and the component carrier manager is configured to
split the data uniformly between primary and secondary carrier. The test consists of checking that
the throughput obtained over the different carriers are equal considering a given tolerance. For more
details about this test, see the section Carrier aggregation usage example.</p>
</section>
<section id="carrier-aggregation-test-for-enb-and-ue-configuration">
<h6><span class="section-number">20.3.2.2.38. </span>Carrier aggregation test for eNB and UE configuration<a class="headerlink" href="#carrier-aggregation-test-for-enb-and-ue-configuration" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">carrier-aggregation-config-test</span></code> is a system test program, which verifies the
following two cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>When carrier aggregation is enabled and UE carriers configuration is different than the default
configuration done in LteHelper, we check that the UE(s) is configured properly once it receives
RRC Connection Reconfiguration message from eNB.</p></li>
<li><p>A user can configure 2 or more eNBs and UEs with different configuration parameters, i.e.,
each eNB and UE can have different EARFCN and Bandwidths and a UE connects to an eNB with similar DL EARFCN.
In this test, we check with CA enabled but the end results will be the same if carrier aggregation is not
enabled and we have more than one eNBs and UEs with different configurations.</p></li>
</ul>
</div></blockquote>
<p>Since, we do not need EPC to test the configuration, this test only simulates the LTE radio access with RLC SM.
There are two test cases, Test 1 tests that the UE is configured properly after receiving RRC Connection Reconfiguration
message from the eNB, which will overwrite UE default configuration done in LteHelper for the sake of
creating PHY and MAC instances equal to the number of component carriers. Test 2 tests that every eNB or UE in a
simulation scenario can be configured with different EARFCNs and Bandwidths. For both test cases, it also counts
the number of times the hooked trace source <code class="docutils literal notranslate"><span class="pre">SCarrierConfigured</span></code> get triggered. As, it reflects how many UEs
got attached to their respective eNB. If the count is not equal to the number of UEs in the scenario, the test fails,
which could be the result of improper UE configuration.</p>
</section>
<section id="radio-link-failure-test">
<h6><span class="section-number">20.3.2.2.39. </span>Radio link failure Test<a class="headerlink" href="#radio-link-failure-test" title="Link to this heading">¶</a></h6>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">lte-radio-link-failure</span></code> is a system test, which tests the
radio link failure functionality using Ideal and Real RRC protocols.
In particular, it tests the following to verify the Radio link
Failure (RLF) implementation.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The state and the configuration of the UE while it is connected to the eNB.</p></li>
<li><p>The state of the UE while T310 timer is running at the UE.</p></li>
<li><p>The number of out-of-sync and in-synch indications received.</p></li>
<li><p>The state of the UE before the simulation end.</p></li>
<li><p>The UE context existence at the eNB before the simulation end.</p></li>
</ol>
</div></blockquote>
<p>This test simulates only one static UE with EPC performing downlink and uplink
communication in the following two scenarios:</p>
<section id="one-enb-using-ideal-and-real-rrc">
<h6 aria-level="7"><span class="section-number">20.3.2.2.39.1. </span>One eNB using Ideal and Real RRC<a class="headerlink" href="#one-enb-using-ideal-and-real-rrc" title="Link to this heading">¶</a></h6>
<figure class="align-center" id="id28">
<span id="fig-lte-test-rlf-one-enb"></span><img alt="_images/lte-test-rlf-one-enb.png" src="_images/lte-test-rlf-one-enb.png" />
<figcaption>
<p><span class="caption-text">RLF scenario with one eNB</span><a class="headerlink" href="#id28" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In this scenario, the UE is initially placed near to the eNB, and on the
following instances above conditions are verified against the expected outcome.</p>
<p><strong>At 0.3 sec:</strong>  It verifies that the UE is well connected, i.e., it is in
“CONNECTED_NORMALLY” state, and is attached to the eNB with cell id 1. It also
checks for the match between the configuration of the UE and the UE context at
the eNB, e.g., IMSI, bandwidth, D/UL EARFCN, number of bearers and the bearer IDs.
The miss match would result in the test suite failure.</p>
<p><strong>At 0.4 sec:</strong> The UE jumps far away from the eNB, which causes the DL SINR at
the UE to fall below -5 dB. In result, the UE PHY after monitoring the SINR for
20 consecutive frames will send a notification to the UE RRC. In this test, the
N310 counter is set to 1; thus, the UE RRC will start the T310 (set to 1 sec)
timer upon the first notification from the PHY layer.</p>
<p><strong>At 1 sec:</strong> At this stage, it is expected that the T310 timer is still running,
and the UE is connected to the eNB.</p>
<p><strong>Upon RLF:</strong> It is expected that the UE RRC will start the T310 timer upon reaching
the configured, i.e., N310 = 1 number of notification from the eNB. The RRC will
receive no in-sync indication since the UE stays at far away position.</p>
<p><strong>Before the end of simulation:</strong>  The expected behavior is that the UE state
will be in “IDLE_CELL_SEARCH” since there is no eNB available where it has jumped.
Moreover, the deletion of the UE context from the eNB is also verified.</p>
</section>
<section id="two-enbs-using-ideal-and-real-rrc">
<h6 aria-level="7"><span class="section-number">20.3.2.2.39.2. </span>Two eNBs using Ideal and Real RRC<a class="headerlink" href="#two-enbs-using-ideal-and-real-rrc" title="Link to this heading">¶</a></h6>
<figure class="align-center" id="id29">
<span id="fig-lte-test-rlf-two-enb"></span><img alt="_images/lte-test-rlf-two-enb.png" src="_images/lte-test-rlf-two-enb.png" />
<figcaption>
<p><span class="caption-text">RLF scenario with two eNBs</span><a class="headerlink" href="#id29" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In this scenario, the only difference is the addition of a second eNB near the
position where the UE jumps away. Therefore, except the outcome before the end
of the simulation, all the outcomes are similar to that we expected in the first
scenario.</p>
<p><strong>Before the end of simulation:</strong>  It is expected that the UE after the RLF will
connect to the second eNB, i.e., it will be in “CONNECTED_NORMALLY” state, and
its context exists in the second eNB.</p>
</section>
</section>
</section>
</section>
</section>
<span id="document-lte-profiling"></span><section id="profiling-documentation">
<h3><span class="section-number">20.4. </span>Profiling Documentation<a class="headerlink" href="#profiling-documentation" title="Link to this heading">¶</a></h3>
<section id="overview-and-objectives">
<h4><span class="section-number">20.4.1. </span>Overview and objectives<a class="headerlink" href="#overview-and-objectives" title="Link to this heading">¶</a></h4>
<p>The main objective of the profiling carried out is to assess the simulator performance on a broad set of scenarios. This evaluation provides reference values for simulation running times and memory consumption figures. It also helps to identify potential performance improvements and to check for scalability problems when increasing the number of eNodeB and UEs attached to those.</p>
<p>In the following sections, a detailed description of the general profiling framework employed to perform the study is introduced. It also includes details on the main performed tests and its results evaluation.</p>
</section>
<section id="framework-description">
<h4><span class="section-number">20.4.2. </span>Framework description<a class="headerlink" href="#framework-description" title="Link to this heading">¶</a></h4>
<section id="simulation-scripts">
<h5><span class="section-number">20.4.2.1. </span>Simulation scripts<a class="headerlink" href="#simulation-scripts" title="Link to this heading">¶</a></h5>
<p>The simulation script used for all the E-UTRAN results showed in this documentation is located at <code class="docutils literal notranslate"><span class="pre">src/lte/examples/lena-profiling.cc</span></code>. It uses the complete PHY and MAC UE/eNodeB implementation with a simplified RLC implementation on top. This script generates a squared grid topology, placing a eNodeB at the centre of each square. UEs attached to this node are scattered randomly across the square (using a random uniform distribution along X and Y axis). If <em>BuildingPropagationModel</em> is used, the squares are replaced by rooms. To generate the UL and DL traffic, the RLC implementation always report data to be transferred.</p>
<figure class="align-center" id="id3">
<span id="fig-eutranprofilingscenario"></span><a class="reference internal image-reference" href="_images/eutran-profiling-scenario.png"><img alt="_images/eutran-profiling-scenario.png" src="_images/eutran-profiling-scenario.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">E-UTRAN</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For the EPC results, the script is <code class="docutils literal notranslate"><span class="pre">src/lte/examples/lena-simple-epc.cc</span></code>. It uses a complete E-UTRAN implementation (PHY+MAC+RLC/UM+PDCP) and the most relevant EPC user plane entities the PGW and SGW, including GTP-U tunneling. This script generates a given number of eNodeBs, distributed across a line and attaches a single UE to every eNodeB. It also creates an EPC network and an external host connected to it through the Internet. Each UE sends and receives data to and from the remote host. In addition, each UE is also sending data to the UE camped in the adjacent eNodeB.</p>
<figure class="align-center" id="id4">
<span id="fig-epcprofilingscenario"></span><a class="reference internal image-reference" href="_images/epc-profiling-scenario.png"><img alt="_images/epc-profiling-scenario.png" src="_images/epc-profiling-scenario.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Propagation Model</span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>RLC and MAC traces are enabled for all UEs and all eNodeBs and those traces are written to disk directly. The MAC scheduler used is <em>round robin</em>.</p>
<section id="simulation-input-parameters">
<h6><span class="section-number">20.4.2.1.1. </span>Simulation input parameters<a class="headerlink" href="#simulation-input-parameters" title="Link to this heading">¶</a></h6>
<p>The <em>lena-profiling</em> simulation script accepts the following input parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">simTime</span></code>: time to simulate (in seconds)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nUe</span></code>: number of UEs attached to each eNodeB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nEnb</span></code>: number of eNodeB composing the grid per floor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFloors</span></code>: number of floors, 0 for <em>Friis propagation model</em> (no walls), 1 or greater for <em>Building propagation model</em> generating a nFloors-storey building.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">traceDirectory</span></code>: destination directory where simulation traces will be stored</p></li>
</ul>
</div></blockquote>
<p>The <em>lena-simple-epc</em> script accepts those other parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">simTime</span></code>: time to simulate (in seconds)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numberOfNodes</span></code>: number of eNodeB + UE pairs created</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="time-measurement">
<h5><span class="section-number">20.4.2.2. </span>Time measurement<a class="headerlink" href="#time-measurement" title="Link to this heading">¶</a></h5>
<p>Running time is measured using default Linux shell command <strong>time</strong>. This command counts how much user time the execution of a program takes.</p>
</section>
<section id="perl-script">
<h5><span class="section-number">20.4.2.3. </span>Perl script<a class="headerlink" href="#perl-script" title="Link to this heading">¶</a></h5>
<p>To simplify the process of running the profiling script for a wide range of values and collecting its timing data, a simple Perl script to automate the complete process is provided. It is placed in <code class="docutils literal notranslate"><span class="pre">src/lte/test/lte-test-run-time.pl</span></code> for <em>lena-profiling</em> and in <code class="docutils literal notranslate"><span class="pre">src/lte/epc-test-run-time.pl</span></code> for <em>lena-simple-epc</em>. It simply runs a batch of simulations with a range of parameters and stores the timing results in a CSV file called <em>lteTimes.csv</em> and <em>epcTimes.csv</em> respectively. The range of values each parameter sweeps can be modified editing the corresponding script.</p>
<section id="requirements">
<h6><span class="section-number">20.4.2.3.1. </span>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h6>
<dl class="simple">
<dt>The following Perl modules are required to use the provided script, all of them available from CPAN:</dt><dd><ul class="simple">
<li><p>IO::CaptureOutput</p></li>
<li><p>Statistics::Descriptive</p></li>
</ul>
</dd>
</dl>
<p>For installing the modules, simply use the following command:</p>
<p><code class="docutils literal notranslate"><span class="pre">perl</span> <span class="pre">-MCPAN</span> <span class="pre">-e</span> <span class="pre">'install</span> <span class="pre">moduleName'</span></code></p>
</section>
<section id="plotting-results">
<h6><span class="section-number">20.4.2.3.2. </span>Plotting results<a class="headerlink" href="#plotting-results" title="Link to this heading">¶</a></h6>
<p>To plot the results obtained from running the Perl scripts, two gnuplot scripts are provided, in <code class="docutils literal notranslate"><span class="pre">src/lte/test/lte-test-run-plot</span></code> and <code class="docutils literal notranslate"><span class="pre">src/lte/test/epc-test-run-plot</span></code>. Most of the plots available in this documentation can be reproduced with those, typing the commands <code class="docutils literal notranslate"><span class="pre">gnuplot</span> <span class="pre">&lt;</span> <span class="pre">src/lte/test/lte-test-run-plot</span></code>  and  <code class="docutils literal notranslate"><span class="pre">gnuplot</span> <span class="pre">&lt;</span> <span class="pre">src/lte/test/epc-test-run-plot</span></code>.</p>
</section>
</section>
<section id="reference-software-and-equipment">
<h5><span class="section-number">20.4.2.4. </span>Reference software and equipment<a class="headerlink" href="#reference-software-and-equipment" title="Link to this heading">¶</a></h5>
<p>All timing tests had been run in a Intel Pentium IV 3.00 GHz machine with 512 Mb of RAM memory running Fedora Core 10 with a 2.6.27.41-170.2.117 kernel, storing the traces directly to the hard disk.</p>
<p>Also, as a reference configuration, the build has been configured static and optimized. The exact <code class="docutils literal notranslate"><span class="pre">ns3</span></code> command issued is:</p>
<p><code class="docutils literal notranslate"><span class="pre">CXXFLAGS=&quot;-O3</span> <span class="pre">-w&quot;</span> <span class="pre">./ns3</span> <span class="pre">configure</span> <span class="pre">-d</span> <span class="pre">optimized</span> <span class="pre">--enable-static</span> <span class="pre">--enable-examples</span> <span class="pre">--enable-modules=lte</span></code></p>
</section>
</section>
<section id="results">
<h4><span class="section-number">20.4.3. </span>Results<a class="headerlink" href="#results" title="Link to this heading">¶</a></h4>
<section id="e-utran">
<h5><span class="section-number">20.4.3.1. </span>E-UTRAN<a class="headerlink" href="#e-utran" title="Link to this heading">¶</a></h5>
<p>The following results and figures had been obtained with LENA <strong>changeset 2c5b0d697717</strong>.</p>
<section id="running-time">
<h6><span class="section-number">20.4.3.1.1. </span>Running time<a class="headerlink" href="#running-time" title="Link to this heading">¶</a></h6>
<p>This scenario, evaluates the running time for a fixed simulation time (10s) and Friis propagation mode increasing the number of UEs attached to each eNodeB and the number of planted eNodeBs in the scenario.</p>
<figure class="align-center" id="id5">
<span id="fig-runtime"></span><a class="reference internal image-reference" href="_images/runningTime10s.png"><img alt="_images/runningTime10s.png" src="_images/runningTime10s.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Running time</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The figure shows the expected behaviour, since it increases linearly respect the number of UEs per eNodeB and quadratically respect the total number of eNodeBs.</p>
</section>
<section id="propagation-model">
<h6><span class="section-number">20.4.3.1.2. </span>Propagation model<a class="headerlink" href="#propagation-model" title="Link to this heading">¶</a></h6>
<p>The objective of this scenario is to evaluate the impact of the propagation model complexity in the overall run time figures. Therefore, the same scenario is simulated twice: once using the more simple Friis model, once with the more complex Building model. The rest of the parameters (e.g. number of eNodeB and of UE attached per eNodeB) were maintained. The timing results for both models are compared in the following figure.</p>
<figure class="align-center" id="id6">
<span id="fig-propagationmodel"></span><a class="reference internal image-reference" href="_images/propagationModel.png"><img alt="_images/propagationModel.png" src="_images/propagationModel.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Propagation Model</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In this situation, results are also coherent with what is expected. The more complex the model, the higher the running time. Moreover, as the number of computed path losses increases (i.e. more UEs per eNodeB or more eNodeBs) the extra complexity of the propagation model drives the running time figures further apart.</p>
</section>
<section id="simulation-time">
<h6><span class="section-number">20.4.3.1.3. </span>Simulation time<a class="headerlink" href="#simulation-time" title="Link to this heading">¶</a></h6>
<p>In this scenario, for a fixed set of UEs per eNodeB, different simulation times had been run. As the simulation time increases, running time should also increase linearly, i.e. for a given scenario, simulate four seconds should take twice times what it takes to simulate two seconds. The slope of this line is a function of the complexity of the scenario: the more eNodeB / UEs placed, the higher the slope of the line.</p>
<figure class="align-center" id="id7">
<span id="fig-simulationtime"></span><a class="reference internal image-reference" href="_images/simulationTime.png"><img alt="_images/simulationTime.png" src="_images/simulationTime.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Simulation time</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="memory-usage">
<h6><span class="section-number">20.4.3.1.4. </span>Memory usage<a class="headerlink" href="#memory-usage" title="Link to this heading">¶</a></h6>
<p>Massif tool to profile memory consumption</p>
<figure class="align-center" id="id8">
<span id="fig-profilingmemory"></span><a class="reference internal image-reference" href="_images/profiling-memory.png"><img alt="_images/profiling-memory.png" src="_images/profiling-memory.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Memory profile</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="epc">
<h5><span class="section-number">20.4.3.2. </span>EPC<a class="headerlink" href="#epc" title="Link to this heading">¶</a></h5>
<p>The following results and figures had been obtained with LENA <strong>changeset e8b3ccdf6673</strong>. The rationale behind the two scenarios profiled on this section is the same than for the E-UTRA part.</p>
<section id="id1">
<h6><span class="section-number">20.4.3.2.1. </span>Running time<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h6>
<p>Running time evolution is quadratic since we increase at the same time the number of eNodeB and the number of UEs.</p>
<figure class="align-center" id="id9">
<span id="fig-epcruntime"></span><a class="reference internal image-reference" href="_images/epcRunningTime.png"><img alt="_images/epcRunningTime.png" src="_images/epcRunningTime.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Running time</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>To estimate the additional complexity of the upper LTE Radio Protocol Stack model and the EPC model, we compare two scenarios using the simplified E-UTRAN version (using only PHY, MAC and the simplified RLC/SM, with no EPC and no ns-3 applications) against the complete E-UTRAN + EPC (with UM RLC, PDCP, end-to-end IP networking and regular ns-3 applications). Both configuration have been tested with the same number of UEs per eNodeB, the same number of eNodeBs, and approximately the same volume of transmitted data (an exact match was not possible due to the different ways in which packets are generated in the two configurations).</p>
<figure class="align-center" id="id10">
<span id="fig-epceutranruntime"></span><a class="reference internal image-reference" href="_images/epcEutranRunningTime.png"><img alt="_images/epcEutranRunningTime.png" src="_images/epcEutranRunningTime.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">EPC E-UTRAN running time</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>From the figure, it is evident that the additional complexity of using the upper LTE stack plus the EPC model translates approximately into a doubling of the execution time of the simulations. We believe that, considered all the new features that have been added, this figure is acceptable.</p>
</section>
<section id="id2">
<h6><span class="section-number">20.4.3.2.2. </span>Simulation time<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h6>
<p>Finally, again the linearity of the running time as the simulation time increases gets validated through a set of experiments, as the following figure shows.</p>
<figure class="align-center" id="id11">
<span id="fig-epcsimtime"></span><a class="reference internal image-reference" href="_images/epcSimulationTime.png"><img alt="_images/epcSimulationTime.png" src="_images/epcSimulationTime.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Simulation time</span><a class="headerlink" href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
</section>
</section>
<span id="document-lte-references"></span><section id="references">
<h3><span class="section-number">20.5. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="ts25814" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS25814<span class="fn-bracket">]</span></span>
<p>3GPP TS 25.814 “Physical layer aspect for evolved Universal Terrestrial Radio Access”</p>
</div>
<div class="citation" id="ts29274" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS29274<span class="fn-bracket">]</span></span>
<p>3GPP TS 29.274 “GPRS Tunnelling Protocol for Control plane (GTPv2-C)”</p>
</div>
<div class="citation" id="ts36101" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36101<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.101 “E-UTRA User Equipment (UE) radio transmission and reception”</p>
</div>
<div class="citation" id="ts36104" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36104<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.104 “E-UTRA Base Station (BS) radio transmission and reception”</p>
</div>
<div class="citation" id="ts36133" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36133<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.133 “E-UTRA Requirements for support of radio resource management”</p>
</div>
<div class="citation" id="ts36211" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36211<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.211 “E-UTRA Physical Channels and Modulation”</p>
</div>
<div class="citation" id="ts36212" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36212<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.212 “E-UTRA Multiplexing and channel coding”</p>
</div>
<div class="citation" id="ts36213" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36213<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.213 “E-UTRA Physical layer procedures”</p>
</div>
<div class="citation" id="ts36214" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36214<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.214 “E-UTRA Physical layer – Measurements”</p>
</div>
<div class="citation" id="ts36300" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36300<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.300 “E-UTRA and E-UTRAN; Overall description; Stage 2”</p>
</div>
<div class="citation" id="ts36304" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36304<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.304 “E-UTRA User Equipment (UE) procedures in idle mode”</p>
</div>
<div class="citation" id="ts36321" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36321<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.321 “E-UTRA Medium Access Control (MAC) protocol specification”</p>
</div>
<div class="citation" id="ts36322" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36322<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.322 “E-UTRA Radio Link Control (RLC) protocol specification”</p>
</div>
<div class="citation" id="ts36323" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36323<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.323 “E-UTRA Packet Data Convergence Protocol (PDCP) specification”</p>
</div>
<div class="citation" id="ts36331" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36331<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.331 “E-UTRA Radio Resource Control (RRC) protocol specification”</p>
</div>
<div class="citation" id="ts36413" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36413<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.413 “E-UTRAN S1 application protocol (S1AP)”</p>
</div>
<div class="citation" id="ts36420" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36420<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.420 “E-UTRAN X2 general aspects and principles”</p>
</div>
<div class="citation" id="ts36423" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TS36423<span class="fn-bracket">]</span></span>
<p>3GPP TS 36.423 “E-UTRAN X2 application protocol (X2AP)”</p>
</div>
<div class="citation" id="tr36814" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TR36814<span class="fn-bracket">]</span></span>
<p>3GPP TR 36.814 “E-UTRA Further advancements for E-UTRA physical layer aspects”</p>
</div>
<div class="citation" id="r1-081483" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>R1-081483<span class="fn-bracket">]</span></span>
<p>3GPP R1-081483 <a class="reference external" href="http://www.3gpp.org/ftp/tsg_ran/WG1_RL1/TSGR1_52b/Docs/R1-081483.zip">“Conveying MCS and TB size via PDCCH”</a></p>
</div>
<div class="citation" id="r4-092042" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>R4-092042<span class="fn-bracket">]</span></span>
<p>3GPP R4-092042 <a class="reference external" href="http://www.3gpp.org/ftp/tsg_ran/wg4_radio/TSGR4_51/Documents/R4-092042.zip">“Simulation assumptions and parameters for FDD HeNB RF requirements”</a></p>
</div>
<div class="citation" id="ffapi" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>FFAPI<span class="fn-bracket">]</span></span>
<p>FemtoForum <a class="reference external" href="https://web.archive.org/web/20141209082506/http://www.smallcellforum.org/smallcellforum_resources/pdfsend05.php?file=LTE%20MAC%20Scheduler%20Interface%20Specification.pdf">“LTE MAC Scheduler Interface Specification v1.11”</a></p>
</div>
<div class="citation" id="ns3tutorial" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ns3tutorial<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.nsnam.org/docs/tutorial/singlehtml/index.html">“The ns-3 Tutorial”</a></p>
</div>
<div class="citation" id="ns3manual" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ns3manual<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.nsnam.org/docs/manual/singlehtml/index.html">“The ns-3 Manual”</a></p>
</div>
<div class="citation" id="sesia2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Sesia2009<span class="fn-bracket">]</span></span>
<p>S. Sesia, I. Toufik and M. Baker,
“LTE - The UMTS Long Term Evolution - from theory to practice”,
Wiley, 2009</p>
</div>
<div class="citation" id="baldo2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Baldo2009<span class="fn-bracket">]</span></span>
<p>N. Baldo and M. Miozzo, “Spectrum-aware Channel and PHY layer modeling for ns3”,
Proceedings of ICST NSTools 2009, Pisa, Italy</p>
</div>
<div class="citation" id="piro2010" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Piro2010<span class="fn-bracket">]</span></span>
<p>Giuseppe Piro, Luigi Alfredo Grieco, Gennaro Boggia, and Pietro Camarda,
“A Two-level Scheduling Algorithm for QoS Support in the Downlink of LTE Cellular Networks”,
Proc. of European Wireless, EW2010, Lucca, Italy, Apr., 2010</p>
</div>
<div class="citation" id="holtzman2000" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Holtzman2000<span class="fn-bracket">]</span></span>
<p>J.M. Holtzman, “CDMA forward link waterfilling power control”,
in Proc. of IEEE VTC Spring, 2000.</p>
</div>
<div class="citation" id="piro2011" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Piro2011<span class="fn-bracket">]</span></span>
<p>G. Piro, N. Baldo. M. Miozzo, “An LTE module for the ns-3 network simulator”,
in Proc. of Wns3 2011 (in conjunction with SimuTOOLS 2011), March 2011, Barcelona (Spain)</p>
</div>
<div class="citation" id="seo2004" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Seo2004<span class="fn-bracket">]</span></span>
<p>H. Seo, B. G. Lee. “A proportional-fair power allocation scheme for fair and efficient multiuser OFDM systems”,
in Proc. of IEEE GLOBECOM, December 2004. Dallas (USA)</p>
</div>
<div class="citation" id="ofcom2600mhz" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Ofcom2600MHz<span class="fn-bracket">]</span></span>
<p>Ofcom, “Consultation on assessment of future mobile
competition and proposals for the award of 800 MHz and 2.6 GHz
spectrum and related issues”, March 2011</p>
</div>
<div class="citation" id="realwireless" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>RealWireless<span class="fn-bracket">]</span></span>
<p>RealWireless, “Low-power shared access to spectrum
for mobile broadband”,  Final Report, Ofcom Project MC/073, 18th
March 2011</p>
</div>
<div class="citation" id="paduapem" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>PaduaPEM<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://mailman.isi.edu/pipermail/ns-developers/2011-November/009397.html">“Ns-developers - LTE error model contribution”</a></p>
</div>
<div class="citation" id="viennaltesim" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ViennaLteSim<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.tuwien.at/etit/tc/en/vienna-simulators/vienna-lte-a-simulators/lte-a-downlink-system-level-simulator/">“The Vienna LTE Simulators”</a></p>
</div>
<div class="citation" id="lozanocost" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>LozanoCost<span class="fn-bracket">]</span></span>
<p>Joan Olmos, Silvia Ruiz, Mario García-Lozano and David Martín-Sacristán,
“Link Abstraction Models Based on Mutual Information for LTE Downlink”,
COST 2100 TD(10)11052 Report</p>
</div>
<div class="citation" id="wimaxemd" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>wimaxEmd<span class="fn-bracket">]</span></span>
<p>WiMAX Forum White Paper, “WiMAX System Evaluation Methodology”, July 2008.</p>
</div>
<div class="citation" id="mathworks" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>mathworks<span class="fn-bracket">]</span></span>
<p>Matlab R2011b Documentation Communications System Toolbox,
<a class="reference external" href="http://www.mathworks.es/help/toolbox/comm/ug/a1069449399.html#bq5zk36">“Methodology for Simulating Multipath Fading Channels”</a></p>
</div>
<div class="citation" id="catreuxmimo" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>CatreuxMIMO<span class="fn-bracket">]</span></span>
<p>S. Catreux, L.J. Greenstein, V. Erceg,
“Some results and insights on the performance gains of MIMO systems,”
Selected Areas in Communications, IEEE Journal on , vol.21, no.5, pp. 839- 847, June 2003</p>
</div>
<div class="citation" id="ikuno2010" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Ikuno2010<span class="fn-bracket">]</span></span>
<p>J.C. Ikuno, M. Wrulich, M. Rupp, “System Level Simulation of LTE Networks,”
Vehicular Technology Conference (VTC 2010-Spring), 2010 IEEE 71st , vol., no., pp.1-5, 16-19 May 2010</p>
</div>
<div class="citation" id="milos2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Milos2012<span class="fn-bracket">]</span></span>
<p>J. Milos, “Performance Analysis Of PCFICH LTE Control Channel”,
Proceedings of the 19th Conference STUDENT EEICT 2012, Brno, CZ, 2012.</p>
</div>
<div class="citation" id="fujitsuwhitepaper" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>FujitsuWhitePaper<span class="fn-bracket">]</span></span>
<p>“Enhancing LTE Cell-Edge Performance via PDCCH ICIC”.</p>
</div>
<div class="citation" id="bharucha2011" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Bharucha2011<span class="fn-bracket">]</span></span>
<p>Z. Bharucha, G. Auer, T. Abe, N. Miki,
“Femto-to-Macro Control Channel Interference Mitigation via Cell ID Manipulation in LTE,”
Vehicular Technology Conference (VTC Fall), 2011 IEEE , vol., no., pp.1-6, 5-8 Sept. 2011</p>
</div>
<div class="citation" id="r4-081920" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>R4-081920<span class="fn-bracket">]</span></span>
<p>3GPP R4-081920 <a class="reference external" href="http://www.3gpp.org/ftp/tsg_ran/wg4_radio/TSGR4_48/Documents/R4-081920.zip">“LTE PDCCH/PCFICH Demodulation Performance Results with Implementation Margin”</a></p>
</div>
<div class="citation" id="fcapo2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>FCapo2012<span class="fn-bracket">]</span></span>
<p>F.Capozzi, G.Piro, L.A. Grieco, G.Boggia, P.Camarda,
“Downlink Packet Scheduling in LTE Cellular Networks: Key Design Issues and a Survey”,
IEEE Comm. Surveys and Tutorials, vol.2012, no.99, pp.1-23, Jun. 2012</p>
</div>
<div class="citation" id="fabokhari2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>FABokhari2009<span class="fn-bracket">]</span></span>
<p>F.A. Bokhari, H. Yanikomeroglu, W.K. Wong, M. Rahman,
“Cross-Layer Resource Scheduling for Video Traffic in the Downlink of OFDMA-Based Wireless 4G Networks”,
EURASIP J. Wirel. Commun. Netw., vol.2009, no.3, pp. 1-10, Jan. 2009.</p>
</div>
<div class="citation" id="wkwong2004" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>WKWong2004<span class="fn-bracket">]</span></span>
<p>W.K. Wong, H.Y. Tang, V.C.M, Leung,
“Token bank fair queuing: a new scheduling algorithm for wireless multimedia services”,
Int. J. Commun. Syst., vol.17, no.6, pp.591-614, Aug.2004.</p>
</div>
<div class="citation" id="gmonghal2008" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GMonghal2008<span class="fn-bracket">]</span></span>
<p>G. Mongha, K.I. Pedersen, I.Z. Kovacs, P.E. Mogensen,
“QoS Oriented Time and Frequency Domain Packet Schedulers for The UTRAN Long Term Evolution”,
In Proc. IEEE VTC, 2008.</p>
</div>
<div class="citation" id="dimou2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Dimou2009<span class="fn-bracket">]</span></span>
<p>K. Dimou, M. Wang, Y. Yang, M. Kazmi, A. Larmo, J. Pettersson, W. Muller, Y. Timner,
“Handover within 3GPP LTE: Design Principles and Performance”,
Vehicular Technology Conference Fall (VTC 2009-Fall), 2009 IEEE 70th, pp.1-5, 20-23 Sept. 2009</p>
</div>
<div class="citation" id="lee2010" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Lee2010<span class="fn-bracket">]</span></span>
<p>Y.J. Lee, B.J. Shin, J.C. Lim, D.H. Hong,
“Effects of time-to-trigger parameter on handover performance in SON-based LTE systems”,
Communications (APCC), 2010 16th Asia-Pacific Conference on, pp.492-496, Oct. 31 2010–Nov. 3 2010</p>
</div>
<div class="citation" id="bbojovic2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Bbojovic2014<span class="fn-bracket">]</span></span>
<p>B. Bojovic, N. Baldo, <a class="reference external" href="http://www.cttc.es/publication/a-new-channel-and-qos-aware-scheduler-to-enhance-the-capacity-of-voice-over-lte-systems/">“A new Channel and QoS Aware
Scheduler to enhance the capacity of Voice over LTE systems”</a>,
in Proceedings of 11th International Multi-Conference on Systems,
Signals &amp; Devices (SSD’14), Castelldefels, 11-14 February 2014,
Castelldefels (Spain).</p>
</div>
<div class="citation" id="baldo2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Baldo2014<span class="fn-bracket">]</span></span>
<p>N. Baldo, R. Martínez, P. Dini, R. Vilalta, M. Miozzo,
R. Casellas, R. Muñoz, <a class="reference external" href="http://www.cttc.es/publication/a-testbed-for-fixed-mobile-convergence-experimentation-adrenaline-lena-integration/">“A Testbed for Fixed Mobile Convergence
Experimentation: ADRENALINE-LENA Integration”</a>,
in Proceedings of European Wireless 2014, 14-16 May 2014, Barcelona
(Spain).</p>
</div>
<div class="citation" id="ashamza2013" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ASHamza2013<span class="fn-bracket">]</span></span>
<p>Abdelbaset S. Hamza, Shady S. Khalifa, Haitham S. Hamza, and Khaled Elsayed, “A Survey on Inter-Cell Interference Coordination Techniques in OFDMA-based Cellular Networks”, IEEE Communications Surveys &amp; Tutorials, March 19, 2013</p>
</div>
<div class="citation" id="zxie2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ZXie2009<span class="fn-bracket">]</span></span>
<p>Zheng Xie, Bernhard Walke, “Enhanced Fractional Frequency Reuse to Increase Capacity of OFDMA Systems”, Proceedings of the 3rd international conference on New technologies, mobility and security, NTMS 2009</p>
</div>
<div class="citation" id="dkimura2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>DKimura2012<span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="4">
<li><p>Kimura, H. Seki, “Inter-Cell Interference Coordination (ICIC) Technology”, FUJITSU Sci. Tech. J., Vol. 48, No. 1 (January 2012)</p></li>
</ol>
</div>
</div>
</section>
</div>
</section>
<span id="document-mesh"></span><section id="wi-fi-mesh-module-documentation">
<h2><span class="section-number">21. </span>Wi-Fi Mesh Module Documentation<a class="headerlink" href="#wi-fi-mesh-module-documentation" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-mesh-design"></span><section id="design-documentation">
<h3><span class="section-number">21.1. </span>Design Documentation<a class="headerlink" href="#design-documentation" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4><span class="section-number">21.1.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>The <em>ns-3</em> <cite>mesh</cite> module extends the <em>ns-3</em> <cite>wifi</cite> module to provide mesh
networking capabilities according to the IEEE 802.11s standard <a class="reference internal" href="index.html#ieee80211s" id="id1"><span>[ieee80211s]</span></a>.</p>
<p>The basic purpose of IEEE 802.11s is to define a mode of operation for
Wi-Fi that permits frames to be forwarded over multiple radio hops
transparent to higher layer protocols such as IP.  To accomplish this,
mesh-capable stations form a <cite>Mesh Basic Service Set</cite> (MBSS) by running
a pair-wise peering protocol to establish forwarding associations, and
by running a routing protocol to find paths through the network.  A
special gateway device called a <cite>mesh gate</cite> allows a MBSS to interconnect
with a Distribution System (DS).</p>
<p>The basic enhancements defined by IEEE 802.11s include:</p>
<ul class="simple">
<li><p>discovery services</p></li>
<li><p>peering management</p></li>
<li><p>security</p></li>
<li><p>beaconing and synchronization</p></li>
<li><p>the Mesh Coordination Function (MCF)</p></li>
<li><p>power management</p></li>
<li><p>channel switching</p></li>
<li><p>extended frame formats</p></li>
<li><p>path selection and forwarding</p></li>
<li><p>interworking (proxy mesh gateways)</p></li>
<li><p>intra-mesh congestion control, and</p></li>
<li><p>emergency service support.</p></li>
</ul>
<p>The <em>ns-3</em> models implement only a subset of the above service extensions,
focusing mainly on those items related to peering and routing/forwarding
of data frames through the mesh.</p>
<p>The Mesh NetDevice based on 802.11s D3.0 draft standard
was added in <em>ns-3.6</em> and includes the Mesh Peering Management Protocol and
HWMP (routing) protocol implementations. An overview
presentation by Kirill Andreev was published at the Workshop on ns-3
in 2009 <a class="reference internal" href="index.html#and09" id="id2"><span>[And09]</span></a>.  An overview paper is available at <a class="reference internal" href="index.html#and10" id="id3"><span>[And10]</span></a>.</p>
<p>As of ns-3.23 release, the model has been updated to the 802.11s-2012
standard <a class="reference internal" href="index.html#ieee80211s" id="id4"><span>[ieee80211s]</span></a> with regard to packet formats, based on the
contribution in <a class="reference internal" href="index.html#hep15" id="id5"><span>[Hep15]</span></a>.</p>
<p>These changes include:</p>
<ul class="simple">
<li><p>Category codes and the categories compliant to IEEE-802.11-2012 Table 8-38—Category values.</p></li>
<li><p>Information Elements (An adjustment of the element ID values was needed according to Table 8-54 of IEEE-802.11-2012).</p></li>
<li><p>Mesh Peering Management element format changed according to IEEE-802.11-2012 Figure 8-370.</p></li>
<li><p>Mesh Configuration element format changed according to IEEE-802.11-2012 Figure 8-363.</p></li>
<li><p>PERR element format changed according to IEEE-802.11-2012 Figure 8-394.</p></li>
</ul>
<p>With these changes the messages of the Peering Management Protocol and Hybrid Wireless Mesh Protocol will be transmitted compliant to IEEE802.11-2012 and the resulting pcap trace files can be analyzed by Wireshark.</p>
<p>The multi-interface mesh points are supported as an extension of IEEE draft version 3.0. Note that corresponding <em>ns-3</em> mesh device helper creates a single interface station by default.</p>
<section id="overview-of-ieee-802-11s">
<h5><span class="section-number">21.1.1.1. </span>Overview of IEEE 802.11s<a class="headerlink" href="#overview-of-ieee-802-11s" title="Link to this heading">¶</a></h5>
<p>The implementation of the 802.11s extension consists of two main parts: the Peer Management Protocol (PMP) and Hybrid Wireless Mesh Protocol (HWMP).</p>
<p>The tasks of the peer management protocol are the following:</p>
<ul class="simple">
<li><p>opening links, detecting beacons, and starting peer link finite state machine, and</p></li>
<li><p>closing peer links due to transmission failures or beacon loss.</p></li>
</ul>
<p>If a peer link between the sender and receiver does not exist, a frame will be
dropped. So, the plug-in to the peer management protocol (PMP) is the first
in the list of <code class="docutils literal notranslate"><span class="pre">ns3::MeshWifiInterfaceMacPlugins</span></code> to be used.</p>
<section id="peer-management-protocol">
<h6><span class="section-number">21.1.1.1.1. </span>Peer management protocol<a class="headerlink" href="#peer-management-protocol" title="Link to this heading">¶</a></h6>
<p>The peer management protocol consists of three main parts:</p>
<ul class="simple">
<li><p>the protocol itself, <code class="docutils literal notranslate"><span class="pre">ns3::dot11s::PeerManagementProtocol</span></code>, which keeps all active peer links on interfaces, handles all changes of their states and notifies the routing protocol about link failures.</p></li>
<li><p>the MAC plug-in, <code class="docutils literal notranslate"><span class="pre">ns3::dot11s::PeerManagementProtocolMac</span></code>, which drops frames if there is no peer link, and peeks all needed information from management frames and information elements from beacons.</p></li>
<li><p>the peer link, <code class="docutils literal notranslate"><span class="pre">ns3::dot11s::PeerLink</span></code>, which keeps finite state machine of each peer link, keeps beacon loss counter and counter of successive transmission failures.</p></li>
</ul>
<p>The procedure of closing a peer link is not described in detail in the
standard, so in the model the link may be closed by:</p>
<ul class="simple">
<li><p>beacon loss (see an appropriate attribute of ns3::dot11s::PeerLink class)</p></li>
<li><p>transmission failure – when a predefined number of successive packets have failed to transmit, the link will be closed.</p></li>
</ul>
<p>The peer management protocol is also responsible for beacon collision avoidance, because it keeps beacon timing elements from all neighbours. Note that the PeerManagementProtocol is not attached to the MeshPointDevice as a routing protocol, but the structure is similar: the upper tier of the protocol is
<code class="docutils literal notranslate"><span class="pre">ns3::dot11s::PeerManagementProtocol</span></code> and its plug-in is
<code class="docutils literal notranslate"><span class="pre">ns3::dot11s::PeerManagementProtocolMac</span></code>.</p>
</section>
<section id="hybrid-wireless-mesh-protocol">
<h6><span class="section-number">21.1.1.1.2. </span>Hybrid Wireless Mesh Protocol<a class="headerlink" href="#hybrid-wireless-mesh-protocol" title="Link to this heading">¶</a></h6>
<p>HWMP is implemented in both modes, reactive and proactive, although path maintenance is not implemented (so active routes may time out and need to be rebuilt, causing packet loss). Also the model implements an ability to transmit broadcast data and management frames as unicasts (see appropriate attributes). This feature is disabled at a station when the number of neighbors of the station is more than a threshold value.</p>
</section>
<section id="forwarding-delay">
<h6><span class="section-number">21.1.1.1.3. </span>Forwarding delay<a class="headerlink" href="#forwarding-delay" title="Link to this heading">¶</a></h6>
<p>Previous versions of this model have had issues with collisions due to
the lack of a model for forwarding delay, and lack of clarity about whether
backoff should be invoked when forwarding a broadcast frame.  These issues
become problematic for mesh, because in a topology in which multiple nodes
within radio range of the next hop node decide to forward a received
frame at the same time, they will repeatedly collide (if no backoff is
triggered).  Past contributors have argued for the triggering of backoff
when forwarding a frame (e.g., <a class="reference internal" href="index.html#hep16" id="id6"><span>[Hep16]</span></a>), but current wifi module maintainers
concluded that the standard does not call for backoff in this case.
This was also privately confirmed with a Wi-Fi vendor.
<a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/478">Issue 478</a> in the GitLab.com
tracker has more discussion on this point.</p>
<p>In practice, it is assumed that collisions can be avoided due to the fact
that each mesh node will take slightly different times to process and
forward the frame, and one will go first and trigger a channel busy detection
on the other nodes.  To accomplish this in ns-3, we
must include a model for forwarding delay that includes some randomness.</p>
<p>The class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::MeshPointDevice</span></code> is responsible for forwarding
unicast frames, and the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::dot11s::HwmpProtocol</span></code> is
responsible for forwarding management frames when HWMP is used.
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::MeshPointDevice</span></code> has an attribute
called <cite>ForwardingDelay</cite> that configures a random variable (units of
microseconds) from which a forwarding delay value is drawn for each frame
forwarding event.  The default configuration of this attribute
is a uniform random variable between 300 and 400 microseconds.  The mean
value was chosen based on the measurement results reported in <a class="reference internal" href="index.html#hep16" id="id7"><span>[Hep16]</span></a> which
measured and derived an average 350 microsecond delay in forwarding frames
on real mesh devices.  The range of this variable is somewhat arbitrary and
determined by some simulation testing to provide a generally low
probability of collision; the 100 microsecond range is roughly 11 slot times.
The HWMP protocol can also access this random variable to create forwarding
delay for the forwarding of management frames.
Users may substitute other random variable configurations as desired.</p>
</section>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">21.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<section id="supported-features">
<h5><span class="section-number">21.1.2.1. </span>Supported features<a class="headerlink" href="#supported-features" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Peering Management Protocol (PMP), including link close heuristics and beacon collision avoidance.</p></li>
<li><p>Hybrid Wireless Mesh Protocol (HWMP), including proactive and reactive modes, unicast/broadcast propagation of management traffic, multi-radio extensions.</p></li>
<li><p>802.11e compatible airtime link metric.</p></li>
</ul>
</section>
<section id="verification">
<h5><span class="section-number">21.1.2.2. </span>Verification<a class="headerlink" href="#verification" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Comes with the custom Wireshark dissector.</p></li>
<li><p>Linux kernel mac80211 layer compatible message formats.</p></li>
</ul>
</section>
<section id="unsupported-features">
<h5><span class="section-number">21.1.2.3. </span>Unsupported features<a class="headerlink" href="#unsupported-features" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Mesh Coordinated Channel Access (MCCA).</p></li>
<li><p>Internetworking: mesh access point and mesh portal.</p></li>
<li><p>Security.</p></li>
<li><p>Power save.</p></li>
<li><p>Path maintenance (sending PREQ proactively before a path expires)</p></li>
<li><p>Though multi-radio operation is supported, no channel assignment protocol is proposed for now. (Correct channel switching is not implemented)</p></li>
</ul>
</section>
<section id="models-yet-to-be-created">
<h5><span class="section-number">21.1.2.4. </span>Models yet to be created<a class="headerlink" href="#models-yet-to-be-created" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Mesh access point (QoS + non-QoS?)</p></li>
<li><p>Mesh portal (QoS + non-QoS?)</p></li>
</ul>
</section>
<section id="open-issues">
<h5><span class="section-number">21.1.2.5. </span>Open issues<a class="headerlink" href="#open-issues" title="Link to this heading">¶</a></h5>
<p>Users should be aware that the mesh module has not been actively maintained
for several years and that there may be some performance and
standards-alignment issues with the current code.  Below is a listing of
possible (confirmed and unconfirmed) issues.</p>
<p>A bug was previously reported in the Wi-Fi module that manifests itself as performance
degradation in large mesh networks, due to incorrect duplicate frame
detection for QoS data frames (<a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2326">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2326</a>).</p>
<p>Mesh does not work for 802.11n/ac/ax stations (<a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/176">https://gitlab.com/nsnam/ns-3-dev/-/issues/176</a>).</p>
<p>Mesh PCAP is not decoded properly by Wireshark (<a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2880">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2880</a>).</p>
<p>Energy module can not be used on mesh devices (<a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2265">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2265</a>).</p>
<p>IE11S_MESH_PEERING_PROTOCOL_VERSION should be removed as per standard.
Protocol ID should actually be part of the Mesh Peering Management IE (<a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2600">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2600</a>).</p>
<p>MeshInformationElementVector printing error (<a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2728">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2728</a>).</p>
<p>Mesh is not compatible with IPv6 (<a class="reference external" href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2881">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2881</a>).</p>
<p>Mesh is forwarding multicast frames as unicast rather than as group-addressed frames (<a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/485">https://gitlab.com/nsnam/ns-3-dev/-/issues/485</a>).</p>
<p>Mesh group addresses are not being set correctly for multicast frames (<a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/476">https://gitlab.com/nsnam/ns-3-dev/-/issues/476</a>).</p>
</section>
</section>
</section>
<span id="document-mesh-user"></span><section id="user-documentation">
<h3><span class="section-number">21.2. </span>User Documentation<a class="headerlink" href="#user-documentation" title="Link to this heading">¶</a></h3>
<section id="using-the-meshnetdevice">
<h4><span class="section-number">21.2.1. </span>Using the MeshNetDevice<a class="headerlink" href="#using-the-meshnetdevice" title="Link to this heading">¶</a></h4>
</section>
</section>
<span id="document-mesh-testing"></span><section id="testing-documentation">
<h3><span class="section-number">21.3. </span>Testing Documentation<a class="headerlink" href="#testing-documentation" title="Link to this heading">¶</a></h3>
</section>
<span id="document-mesh-references"></span><section id="references">
<h3><span class="section-number">21.4. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="and09" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>And09<span class="fn-bracket">]</span></span>
<p>K. Andreev, <a class="reference external" href="http://www.nsnam.org/wiki/Wns3-2009">Realization of IEEE802.11s draft standard in NS-3</a>.</p>
</div>
<div class="citation" id="and10" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>And10<span class="fn-bracket">]</span></span>
<p>K. Andreev and P. Boyko, <a class="reference external" href="http://www.nsnam.org/workshops/wns3-2010/dot11s.pdf">IEEE 802.11s Mesh Networking NS-3 Model</a>.</p>
</div>
<div class="citation" id="hep15" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Hep15<span class="fn-bracket">]</span></span>
<p>C. Hepner and A. Witt and R. Muenzner, <a class="reference external" href="https://www.nsnam.org/wp-content/uploads/2015/05/WNS3_2015_submission_33.pdf">Validation of the ns-3 802.11s model and proposed changes compliant to IEEE 802.11-2012</a>, Poster at 2015 Workshop on ns-3, May 2015.</p>
</div>
<div class="citation" id="hep16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Hep16<span class="fn-bracket">]</span></span>
<p>C. Hepner and S. Moll and R. Muenzner, <a class="reference external" href="http://dl.acm.org/citation.cfm?id=3021439">Influence of Processing Delays on the VoIP Performance for IEEE 802.11s Multihop Wireless Mesh Networks:  Comparison of ns-3 Network Simulations with Hardware Measurements</a>, Proceedings of SIMUTOOLS 16, August, 2016.</p>
</div>
<div class="citation" id="ieee80211s" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ieee80211s<span class="fn-bracket">]</span></span>
<p>IEEE Standard for Information Technology, Telecommunications and information exchange between systems, Local and metropolitan area networks, Specific requirements,  Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) specifications, Amendment 10: Mesh Networking, 10 September 2011.</p>
</div>
</div>
</section>
</div>
</section>
<span id="document-distributed"></span><section id="mpi-for-distributed-simulation">
<h2><span class="section-number">22. </span>MPI for Distributed Simulation<a class="headerlink" href="#mpi-for-distributed-simulation" title="Link to this heading">¶</a></h2>
<p>Parallel and distributed discrete event simulation allows the execution of a
single simulation program on multiple processors. By splitting up the simulation
into logical processes, LPs, each LP can be executed by a different processor.
This simulation methodology enables very large-scale simulations by leveraging
increased processing power and memory availability. In order to ensure proper
execution of a distributed simulation, message passing between LPs is required.
To support distributed simulation in <em>ns-3</em>, the standard Message Passing
Interface (MPI) is used, along with a new distributed simulator class.
Currently, dividing a simulation for distributed purposes in <em>ns-3</em> can only occur
across point-to-point links.</p>
<section id="current-implementation-details">
<span id="id1"></span><h3><span class="section-number">22.1. </span>Current Implementation Details<a class="headerlink" href="#current-implementation-details" title="Link to this heading">¶</a></h3>
<p>During the course of a distributed simulation, many packets must cross simulator
boundaries. In other words, a packet that originated on one LP is destined for a
different LP, and in order to make this transition, a message containing the
packet contents must be sent to the remote LP. Upon receiving this message, the
remote LP can rebuild the packet and proceed as normal. The process of sending
an receiving messages between LPs is handled easily by the new MPI interface in
<em>ns-3</em>.</p>
<p>Along with simple message passing between LPs, a distributed simulator is used
on each LP to determine which events to process. It is important to process
events in time-stamped order to ensure proper simulation execution. If a LP
receives a message containing an event from the past, clearly this is an issue,
since this event could change other events which have already been executed. To
address this problem, two conservative synchronization algorithm with lookahead are
used in <em>ns-3</em>. For more information on different synchronization approaches and
parallel and distributed simulation in general, please refer to “Parallel and
Distributed Simulation Systems” by Richard Fujimoto.</p>
<p>The default parallel synchronization strategy implemented in the
DistributedSimulatorImpl class is based on a globally synchronized
algorithm using an MPI collective operation to synchronize simulation
time across all LPs.  A second synchronization strategy based on local
communication and null messages is implemented in the
NullMessageSimulatorImpl class, For the null message strategy the
global all to all gather is not required; LPs only need to
communication with LPs that have shared point-to-point links.  The
algorithm to use is controlled by which the <em>ns-3</em> global value
SimulatorImplementationType.</p>
<p>The best algorithm to use is dependent on the communication and event
scheduling pattern for the application.  In general, null message
synchronization algorithms will scale better due to local
communication scaling better than a global all-to-all gather that is
required by DistributedSimulatorImpl.  There are two known cases where
the global synchronization performs better.  The first is when most
LPs have point-to-point link with most other LPs, in other words the
LPs are nearly fully connected.  In this case the null message
algorithm will generate more message passing traffic than the
all-to-all gather.  A second case where the global all-to-all gather
is more efficient is when there are long periods of simulation time
when no events are occurring.  The all-to-all gather algorithm is able
to quickly determine then next event time globally.  The nearest
neighbor behavior of the null message algorithm will require more
communications to propagate that knowledge; each LP is only aware of
neighbor next event times.</p>
<section id="remote-point-to-point-links">
<h4><span class="section-number">22.1.1. </span>Remote point-to-point links<a class="headerlink" href="#remote-point-to-point-links" title="Link to this heading">¶</a></h4>
<p>As described in the introduction, dividing a simulation for distributed purposes
in <em>ns-3</em> currently can only occur across point-to-point links; therefore, the
idea of remote point-to-point links is very important for distributed simulation
in <em>ns-3</em>. When a point-to-point link is installed, connecting two nodes, the
point-to-point helper checks the system id, or rank, of both nodes. The rank
should be assigned during node creation for distributed simulation and is
intended to signify on which LP a node belongs. If the two nodes are on the same
rank, a regular point-to-point link is created. If, however, the two nodes are
on different ranks, then these nodes are intended for different LPs, and a
remote point-to-point link is used. If a packet is to be sent across a remote
point-to-point link, MPI is used to send the message to the remote LP.</p>
</section>
<section id="distributing-the-topology">
<h4><span class="section-number">22.1.2. </span>Distributing the topology<a class="headerlink" href="#distributing-the-topology" title="Link to this heading">¶</a></h4>
<p>Currently, the full topology is created on each rank, regardless of the
individual node system ids. Only the applications are specific to a rank. For
example, consider node 1 on LP 1 and node 2 on LP 2, with a traffic generator on
node 1. Both node 1 and node 2 will be created on both LP1 and LP2; however, the
traffic generator will only be installed on LP1. While this is not optimal for
memory efficiency, it does simplify routing, since all current routing
implementations in <em>ns-3</em> will work with distributed simulation.</p>
</section>
</section>
<section id="running-distributed-simulations">
<h3><span class="section-number">22.2. </span>Running Distributed Simulations<a class="headerlink" href="#running-distributed-simulations" title="Link to this heading">¶</a></h3>
<section id="prerequisites">
<h4><span class="section-number">22.2.1. </span>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading">¶</a></h4>
<p>Ensure that MPI is installed, as well as mpic++. In Ubuntu repositories,
these are openmpi-bin, openmpi-common, openmpi-doc, libopenmpi-dev. In
Fedora, these are openmpi and openmpi-devel.</p>
<p>Note:</p>
<p>There is a conflict on some Fedora systems between libotf and openmpi. A
possible “quick-fix” is to yum remove libotf before installing openmpi.
This will remove conflict, but it will also remove emacs. Alternatively,
these steps could be followed to resolve the conflict:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Rename the tiny otfdump which emacs says it needs:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mv<span class="w"> </span>/usr/bin/otfdump<span class="w"> </span>/usr/bin/otfdump.emacs-version
</pre></div>
</div>
</li>
<li><p>Manually resolve openmpi dependencies:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>yum<span class="w"> </span>install<span class="w"> </span>libgfortran<span class="w"> </span>libtorque<span class="w"> </span>numactl
</pre></div>
</div>
</li>
<li><p>Download rpm packages:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>openmpi-1.3.1-1.fc11.i586.rpm
openmpi-devel-1.3.1-1.fc11.i586.rpm
openmpi-libs-1.3.1-1.fc11.i586.rpm
openmpi-vt-1.3.1-1.fc11.i586.rpm
</pre></div>
</div>
<p>from <a class="reference external" href="http://mirrors.kernel.org/fedora/releases/11/Everything/i386/os/Packages/">http://mirrors.kernel.org/fedora/releases/11/Everything/i386/os/Packages/</a></p>
</li>
<li><p>Force the packages in:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>rpm<span class="w"> </span>-ivh<span class="w"> </span>--force<span class="w"> </span><span class="se">\</span>
openmpi-1.3.1-1.fc11.i586.rpm<span class="w"> </span><span class="se">\</span>
openmpi-libs-1.3.1-1.fc11.i586.rpm<span class="w"> </span><span class="se">\</span>
openmpi-devel-1.3.1-1.fc11.i586.rpm<span class="w"> </span><span class="se">\</span>
openmpi-vt-1.3.1-1.fc11.i586.rpm
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<p>Also, it may be necessary to add the openmpi bin directory to PATH in order to
execute mpic++ and mpirun from the command line. Alternatively, the full path to
these executables can be used. Finally, if openmpi complains about the inability
to open shared libraries, such as libmpi_cxx.so.0, it may be necessary to add
the openmpi lib directory to LD_LIBRARY_PATH.</p>
<p>Here is an example of setting up PATH and LD_LIBRARY_PATH using a bash shell:</p>
<blockquote>
<div><ul>
<li><p>For a 32-bit Linux distribution:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/lib/openmpi/bin
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:/usr/lib/openmpi/lib
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>For a 64-bit Linux distribution:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/lib64/openmpi/bin
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:/usr/lib64/openmpi/lib
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>These lines can be added into ~/.bash_profile or ~/.bashrc to avoid having to
retype them when a new shell is opened.</p>
<p>Note 2:  There is a separate issue on recent Fedora distributions, which is
that the libraries are built with AVX instructions.  On older machines or
some virtual machines, this results in an illegal instruction
being thrown.  This is not an <em>ns-3</em> issue, a simple MPI test case will also
fail.  The AVX instructions are being called during initialization.</p>
<p>The symptom of this is that attempts to run an ns-3 MPI program will fail
with the error: <cite>terminated with signal SIGILL</cite>.  To check if this is the
problem, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>grep<span class="w"> </span>avx<span class="w"> </span>/proc/cpuinfo
</pre></div>
</div>
<p>and it will not return anything if AVX is not present.</p>
<p>If AVX is not supported, it is recommended to switch to a different MPI
implementation such as MPICH:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>dnf<span class="w"> </span>remove<span class="w"> </span>openmpi<span class="w"> </span>openmpi-devel
$<span class="w"> </span>dnf<span class="w"> </span>install<span class="w"> </span>mpich<span class="w"> </span>mpich-devel<span class="w"> </span>environment-modules
$<span class="w"> </span>module<span class="w"> </span>load<span class="w"> </span>mpi/mpich-x86_64
</pre></div>
</div>
</section>
<section id="building-and-running-examples">
<h4><span class="section-number">22.2.2. </span>Building and Running Examples<a class="headerlink" href="#building-and-running-examples" title="Link to this heading">¶</a></h4>
<p>If you already built <em>ns-3</em> without MPI enabled, you must re-build:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>distclean
</pre></div>
</div>
<p>Configure <em>ns-3</em> with the –enable-mpi option:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>-d<span class="w"> </span>debug<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests<span class="w"> </span>--enable-mpi
</pre></div>
</div>
<p>Ensure that MPI is enabled by checking the optional features shown from the
output of configure.</p>
<p>Next, build <em>ns-3</em>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3
</pre></div>
</div>
<p>After building <em>ns-3</em> with mpi enabled, the example programs are now
ready to run with <cite>mpiexec</cite>.  It is advised to avoid running ns3 directly
with <cite>mpiexec</cite>; two options that should be more robust are to either use
the <cite>–command-template</cite> way of running the mpiexec program, or to use
<cite>./ns3 shell</cite> and run the executables directly on the command line.
Here are a few examples (from the root <em>ns-3</em> directory):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>simple-distributed<span class="w"> </span>--command-template<span class="o">=</span><span class="s2">&quot;mpiexec -np 2 %s&quot;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>nms-p2p-nix-distributed<span class="w"> </span>--command-template<span class="o">=</span><span class="s2">&quot;mpiexec -np 2 -machinefile mpihosts %s --nix=0&quot;</span>
</pre></div>
</div>
<p>An example using the null message synchronization algorithm:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>simple-distributed<span class="w"> </span>--command-template<span class="o">=</span><span class="s2">&quot;mpiexec -np 2 %s --nullmsg&quot;</span>
</pre></div>
</div>
<p>The np switch is the number of logical processors to use. The machinefile switch
is which machines to use. In order to use machinefile, the target file must
exist (in this case mpihosts). This can simply contain something like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>localhost
localhost
localhost
...
</pre></div>
</div>
<p>Or if you have a cluster of machines, you can name them.</p>
<p>The other alternative to <cite>command-template</cite> is to use <cite>./ns3 shell</cite>.  Here
are the equivalent examples to the above (assuming optimized build profile):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>shell
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build/src/mpi/examples
$<span class="w"> </span>mpiexec<span class="w"> </span>-np<span class="w"> </span><span class="m">2</span><span class="w"> </span>ns3-dev-simple-distributed-optimized
$<span class="w"> </span>mpiexec<span class="w"> </span>-np<span class="w"> </span><span class="m">2</span><span class="w"> </span>-machinefile<span class="w"> </span>mpihosts<span class="w"> </span>ns3-dev-nms-p2p-nix-distributed-optimized<span class="w"> </span>--nix<span class="o">=</span><span class="m">0</span>
$<span class="w"> </span>mpiexec<span class="w"> </span>-np<span class="w"> </span><span class="m">2</span><span class="w"> </span>ns3-dev-simple-distributed-optimized<span class="w"> </span>--nullmsg
</pre></div>
</div>
</section>
<section id="setting-synchronization-algorithm-to-use">
<h4><span class="section-number">22.2.3. </span>Setting synchronization algorithm to use<a class="headerlink" href="#setting-synchronization-algorithm-to-use" title="Link to this heading">¶</a></h4>
<p>The global value SimulatorImplementationType is used to set the
synchronization algorithm to use.  This value must be set before the
MpiInterface::Enable method is invoked if the default
DistributedSimulatorImpl is not used.  Here is an example code snippet
showing how to add a command line argument to control the
synchronization algorithm choice::</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmd.AddValue<span class="o">(</span><span class="s2">&quot;nullmsg&quot;</span>,<span class="w"> </span><span class="s2">&quot;Enable the use of null-message synchronization&quot;</span>,<span class="w"> </span>nullmsg<span class="o">)</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="o">(</span>nullmsg<span class="o">)</span>
<span class="w">  </span><span class="o">{</span>
<span class="w">    </span>GlobalValue::Bind<span class="o">(</span><span class="s2">&quot;SimulatorImplementationType&quot;</span>,
<span class="w">                       </span>StringValue<span class="o">(</span><span class="s2">&quot;ns3::NullMessageSimulatorImpl&quot;</span><span class="o">))</span><span class="p">;</span>
<span class="w">  </span><span class="o">}</span>
<span class="k">else</span>
<span class="w">  </span><span class="o">{</span>
<span class="w">    </span>GlobalValue::Bind<span class="o">(</span><span class="s2">&quot;SimulatorImplementationType&quot;</span>,
<span class="w">                       </span>StringValue<span class="o">(</span><span class="s2">&quot;ns3::DistributedSimulatorImpl&quot;</span><span class="o">))</span><span class="p">;</span>
<span class="w">  </span><span class="o">}</span>

//<span class="w"> </span>Enable<span class="w"> </span>parallel<span class="w"> </span>simulator<span class="w"> </span>with<span class="w"> </span>the<span class="w"> </span><span class="nb">command</span><span class="w"> </span>line<span class="w"> </span>arguments
MpiInterface::Enable<span class="o">(</span><span class="p">&amp;</span>argc,<span class="w"> </span><span class="p">&amp;</span>argv<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="creating-custom-topologies">
<h4><span class="section-number">22.2.4. </span>Creating custom topologies<a class="headerlink" href="#creating-custom-topologies" title="Link to this heading">¶</a></h4>
<p>The example programs in src/mpi/examples give a good idea of how to create different
topologies for distributed simulation. The main points are assigning system ids
to individual nodes, creating point-to-point links where the simulation should
be divided, and installing applications only on the LP associated with the
target node.</p>
<p>Assigning system ids to nodes is simple and can be handled two different ways.
First, a NodeContainer can be used to create the nodes and assign system ids:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Creates 5 nodes with system id 1.</span>
</pre></div>
</div>
<p>Alternatively, nodes can be created individually, assigned system ids, and added
to a NodeContainer. This is useful if a NodeContainer holds nodes with different
system ids:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Create node1 with system id 0</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Create node2 with system id 1</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node1</span><span class="p">);</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node2</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, where the simulation is divided is determined by the placement of
point-to-point links. If a point-to-point link is created between two
nodes with different system ids, a remote point-to-point link is created,
as described in <a class="reference internal" href="#current-implementation-details"><span class="std std-ref">Current Implementation Details</span></a>.</p>
<p>Finally, installing applications only on the LP associated with the target node
is very important. For example, if a traffic generator is to be placed on node
0, which is on LP0, only LP0 should install this application.  This is easily
accomplished by first checking the simulator system id, and ensuring that it
matches the system id of the target node before installing the application.</p>
</section>
</section>
<section id="tracing-during-distributed-simulations">
<h3><span class="section-number">22.3. </span>Tracing During Distributed Simulations<a class="headerlink" href="#tracing-during-distributed-simulations" title="Link to this heading">¶</a></h3>
<p>Depending on the system id (rank) of the simulator, the information traced will
be different, since traffic originating on one simulator is not seen by another
simulator until it reaches nodes specific to that simulator. The easiest way to
keep track of different traces is to just name the trace files or pcaps
differently, based on the system id of the simulator. For example, something
like this should work well, assuming all of these local variables were
previously defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MpiInterface</span><span class="o">::</span><span class="n">GetSystemId</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnablePcapAll</span><span class="p">(</span><span class="s">&quot;distributed-rank0&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">phy</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;distributed-rank0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">apDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="n">csma</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;distributed-rank0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">csmaDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MpiInterface</span><span class="o">::</span><span class="n">GetSystemId</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">EnablePcapAll</span><span class="p">(</span><span class="s">&quot;distributed-rank1&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">phy</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;distributed-rank1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">apDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="n">csma</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;distributed-rank1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">csmaDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<span id="document-mobility"></span><section id="mobility">
<span id="id1"></span><h2><span class="section-number">23. </span>Mobility<a class="headerlink" href="#mobility" title="Link to this heading">¶</a></h2>
<p>The mobility support in <em>ns-3</em> includes:</p>
<ul class="simple">
<li><p>a set of mobility models which are used to track and maintain the <em>current</em> cartesian position and speed of an object.</p></li>
<li><p>a “course change notifier” trace source which can be used to register listeners to the course changes of a mobility model</p></li>
<li><p>a number of helper classes which are used to place nodes and setup mobility models (including parsers for some mobility definition formats).</p></li>
</ul>
<section id="model-description">
<h3><span class="section-number">23.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for mobility lives in the directory <code class="docutils literal notranslate"><span class="pre">src/mobility</span></code>.</p>
<section id="design">
<h4><span class="section-number">23.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>The design includes mobility models, position allocators, and helper
functions.</p>
<p>In <em>ns-3</em>, <cite>MobilityModel`</cite> objects track the evolution of position
with respect to a (cartesian) coordinate system.  The mobility model
is typically aggregated to an <code class="docutils literal notranslate"><span class="pre">ns3::Node</span></code> object and queried using
<code class="docutils literal notranslate"><span class="pre">GetObject&lt;MobilityModel&gt;</span> <span class="pre">()</span></code>. The base class <code class="docutils literal notranslate"><span class="pre">ns3::MobilityModel</span></code>
is subclassed for different motion behaviors.</p>
<p>The initial position of objects is typically set with a PositionAllocator.
These types of objects will lay out the position on a notional canvas.
Once the simulation starts, the position allocator may no longer be
used, or it may be used to pick future mobility “waypoints” for such
mobility models.</p>
<p>Most users interact with the mobility system using mobility helper
classes.  The MobilityHelper combines a mobility model and position
allocator, and can be used with a node container to install a similar
mobility capability on a set of nodes.</p>
<p>We first describe the coordinate system and issues
surrounding multiple coordinate systems.</p>
<section id="coordinate-system">
<h5><span class="section-number">23.1.1.1. </span>Coordinate system<a class="headerlink" href="#coordinate-system" title="Link to this heading">¶</a></h5>
<p>There are many possible coordinate systems and possible translations between
them.  <em>ns-3</em> uses the Cartesian coordinate system only, at present.</p>
<p>The question has arisen as to how to use the mobility models (supporting
Cartesian coordinates) with different coordinate systems.  This is possible
if the user performs conversion between the <em>ns-3</em> Cartesian and the
other coordinate system.  One possible library to assist is
the <a class="reference external" href="https://proj.org">proj4</a> library for projections and reverse
projections.</p>
<p>If we support converting between coordinate systems, we must adopt a
reference.  It has been suggested to use the geocentric Cartesian coordinate
system as a reference.  Contributions are welcome in this regard.</p>
<p>The question has arisen about adding a new mobility model whose motion
is natively implemented in a different coordinate system (such as an
orbital mobility model implemented using spherical coordinate system).
We advise to create a subclass with the APIs desired
(such as Get/SetSphericalPosition), and new position allocators, and
implement the motion however desired, but must also support the conversion to
cartesian (by supporting the cartesian Get/SetPosition).</p>
</section>
<section id="coordinates">
<h5><span class="section-number">23.1.1.2. </span>Coordinates<a class="headerlink" href="#coordinates" title="Link to this heading">¶</a></h5>
<p>The base class for a coordinate is called <code class="docutils literal notranslate"><span class="pre">ns3::Vector</span></code>.  While
positions are normally described as coordinates and not vectors in
the literature, it is possible to reuse the same data structure to
represent position (x,y,z) and velocity (magnitude and direction
from the current position).  <em>ns-3</em> uses class Vector for both.</p>
<p>There are also some additional related structures used to support
mobility models.</p>
<ul class="simple">
<li><p>Rectangle</p></li>
<li><p>Box</p></li>
<li><p>Waypoint</p></li>
</ul>
</section>
<section id="mobilitymodel">
<h5><span class="section-number">23.1.1.3. </span>MobilityModel<a class="headerlink" href="#mobilitymodel" title="Link to this heading">¶</a></h5>
<p>Describe base class</p>
<ul class="simple">
<li><p>GetPosition ()</p></li>
<li><p>Position and Velocity attributes</p></li>
<li><p>GetDistanceFrom ()</p></li>
<li><p>CourseChangeNotification</p></li>
</ul>
</section>
<section id="mobilitymodel-subclasses">
<h5><span class="section-number">23.1.1.4. </span>MobilityModel Subclasses<a class="headerlink" href="#mobilitymodel-subclasses" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>ConstantPosition</p></li>
<li><p>ConstantVelocity</p></li>
<li><p>ConstantAcceleration</p></li>
<li><p>GaussMarkov</p></li>
<li><p>Hierarchical</p></li>
<li><p>RandomDirection2D</p></li>
<li><p>RandomWalk2D</p></li>
<li><p>RandomWaypoint</p></li>
<li><p>SteadyStateRandomWaypoint</p></li>
<li><p>Waypoint</p></li>
</ul>
</section>
<section id="positionallocator">
<h5><span class="section-number">23.1.1.5. </span>PositionAllocator<a class="headerlink" href="#positionallocator" title="Link to this heading">¶</a></h5>
<p>Position allocators usually used only at beginning, to lay out the nodes
initial position.  However, some mobility models (e.g. RandomWaypoint) will
use a position allocator to pick new waypoints.</p>
<ul class="simple">
<li><p>ListPositionAllocator</p></li>
<li><p>GridPositionAllocator</p></li>
<li><p>RandomRectanglePositionAllocator</p></li>
<li><p>RandomBoxPositionAllocator</p></li>
<li><p>RandomDiscPositionAllocator</p></li>
<li><p>UniformDiscPositionAllocator</p></li>
</ul>
</section>
<section id="helper">
<h5><span class="section-number">23.1.1.6. </span>Helper<a class="headerlink" href="#helper" title="Link to this heading">¶</a></h5>
<p>A special mobility helper is provided that is mainly aimed at supporting
the installation of mobility to a Node container (when using containers
at the helper API level).  The MobilityHelper class encapsulates
a MobilityModel factory object and a PositionAllocator used for
initial node layout.</p>
<p>Group mobility is also configurable via a GroupMobilityHelper object.
Group mobility reuses the HierarchicalMobilityModel allowing one to
define a reference (parent) mobility model and child (member) mobility
models, with the position being the vector sum of the two mobility
model positions (i.e., the child position is defined as an offset to
the parent position).  In the GroupMobilityHelper, the parent mobility
model is not associated with any node, and is used as the parent mobility
model for all (distinct) child mobility models.  The reference point group
mobility model <a class="reference internal" href="index.html#camp2002" id="id2"><span>[Camp2002]</span></a> is the basis for this <em>ns-3</em> model.</p>
</section>
<section id="ns-2-mobilityhelper">
<h5><span class="section-number">23.1.1.7. </span>ns-2 MobilityHelper<a class="headerlink" href="#ns-2-mobilityhelper" title="Link to this heading">¶</a></h5>
<p>The <em>ns-2</em> mobility format is a widely used mobility trace format.  The
documentation is available at: <a class="reference external" href="http://www.isi.edu/nsnam/ns/doc/node172.html">http://www.isi.edu/nsnam/ns/doc/node172.html</a></p>
<p>Valid trace files use the following <em>ns-2</em> statements:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">$node</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>X_<span class="w"> </span>x1
<span class="nv">$node</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>Y_<span class="w"> </span>y1
<span class="nv">$node</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>Z_<span class="w"> </span>z1
<span class="nv">$ns</span><span class="w"> </span>at<span class="w"> </span><span class="nv">$time</span><span class="w"> </span><span class="nv">$node</span><span class="w"> </span>setdest<span class="w"> </span>x2<span class="w"> </span>y2<span class="w"> </span>speed
<span class="nv">$ns</span><span class="w"> </span>at<span class="w"> </span><span class="nv">$time</span><span class="w"> </span><span class="nv">$node</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>X_<span class="w"> </span>x1
<span class="nv">$ns</span><span class="w"> </span>at<span class="w"> </span><span class="nv">$time</span><span class="w"> </span><span class="nv">$node</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>Y_<span class="w"> </span>Y1
<span class="nv">$ns</span><span class="w"> </span>at<span class="w"> </span><span class="nv">$time</span><span class="w"> </span><span class="nv">$node</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>Z_<span class="w"> </span>Z1
</pre></div>
</div>
<p>In the above, the initial positions are set using the <code class="docutils literal notranslate"><span class="pre">set</span></code> statements.
Also, this <code class="docutils literal notranslate"><span class="pre">set</span></code> can be specified for a future time, such as in the
last three statements above.</p>
<p>The command <code class="docutils literal notranslate"><span class="pre">setdest</span></code> instructs the simulation to start moving the
specified node towards the coordinate (x2, y2) at the specified time.
Note that the node may never get to the destination, but will
proceed towards the destination at the specified speed until it
either reaches the destination (where it will pause), is set to
a new position (via <code class="docutils literal notranslate"><span class="pre">set</span></code>), or sent on another course change
(via <code class="docutils literal notranslate"><span class="pre">setdest</span></code>).</p>
<p>Note that in <em>ns-3</em>, movement along the Z dimension is not supported.</p>
<p>Some examples of external tools that can export in this format include:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://net.cs.uni-bonn.de/wg/cs/applications/bonnmotion/">BonnMotion</a></p>
<ul>
<li><p><a class="reference external" href="https://www.nsnam.org/wiki/HOWTO_use_ns-3_with_BonnMotion_mobility_generator_and_analysis_tool">Installation instructions</a> and</p></li>
<li><p><a class="reference external" href="https://sys.cs.uos.de/bonnmotion/doc/README.pdf">Documentation</a> for using BonnMotion with <em>ns-3</em></p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://sourceforge.net/apps/mediawiki/sumo/index.php?title=Main_Page">SUMO</a></p></li>
<li><p><a class="reference external" href="http://trans.epfl.ch/">TraNS</a></p></li>
<li><p><em>ns-2</em> <a class="reference external" href="http://www.winlab.rutgers.edu/~zhibinwu/html/ns2_wireless_scene.htm">setdest</a> utility</p></li>
</ul>
<p>A special Ns2MobilityHelper object can be used to parse these files
and convert the statements into <em>ns-3</em> mobility events.  The underlying
ConstantVelocityMobilityModel is used to model these movements.</p>
<p>See below for additional usage instructions on this helper.</p>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">23.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>only cartesian coordinates are presently supported</p></li>
</ul>
</section>
<section id="references">
<h4><span class="section-number">23.1.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="camp2002" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Camp2002<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id7">2</a>)</span>
<p>T. Camp, J. Boleng, V. Davies.  “A survey of mobility models for ad hoc network research”,
in Wireless Communications and Mobile Computing, 2002: vol. 2, pp. 2483-2502.</p>
</div>
</div>
</section>
</section>
<section id="usage">
<h3><span class="section-number">23.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>Most <em>ns-3</em> program authors typically interact with the mobility system
only at configuration time.  However, various <em>ns-3</em> objects interact
with mobility objects repeatedly during runtime, such as a propagation
model trying to determine the path loss between two mobile nodes.</p>
<section id="id3">
<h4><span class="section-number">23.2.1. </span>Helper<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<p>A typical usage pattern can be found in the <code class="docutils literal notranslate"><span class="pre">third.cc</span></code> program in the
tutorial.</p>
<p>First, the user instantiates a <code class="docutils literal notranslate"><span class="pre">MobilityHelper</span></code> object and sets some
<code class="docutils literal notranslate"><span class="pre">Attributes</span></code> controlling the “position allocator” functionality.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MobilityHelper</span><span class="w"> </span><span class="n">mobility</span><span class="p">;</span>

<span class="n">mobility</span><span class="p">.</span><span class="n">SetPositionAllocator</span><span class="p">(</span><span class="s">&quot;ns3::GridPositionAllocator&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="s">&quot;MinX&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
<span class="w">  </span><span class="s">&quot;MinY&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
<span class="w">  </span><span class="s">&quot;DeltaX&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span>
<span class="w">  </span><span class="s">&quot;DeltaY&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
<span class="w">  </span><span class="s">&quot;GridWidth&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
<span class="w">  </span><span class="s">&quot;LayoutType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;RowFirst&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This code tells the mobility helper to use a two-dimensional grid to initially
place the nodes.  The first argument is an <em>ns-3</em> TypeId specifying the
type of mobility model; the remaining attribute/value pairs configure
this position allocator.</p>
<p>Next, the user typically sets the MobilityModel subclass; e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">mobility</span><span class="p">.</span><span class="n">SetMobilityModel</span><span class="p">(</span><span class="s">&quot;ns3::RandomWalk2dMobilityModel&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="s">&quot;Bounds&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RectangleValue</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">(</span><span class="mi">-50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">-50</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">)));</span>
</pre></div>
</div>
<p>Once the helper is configured, it is typically passed a container, such as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">mobility</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiStaNodes</span><span class="p">);</span>
</pre></div>
</div>
<p>A MobilityHelper object may be reconfigured and reused for different
NodeContainers during the configuration of an <em>ns-3</em> scenario.</p>
</section>
<section id="ns2mobilityhelper">
<h4><span class="section-number">23.2.2. </span>Ns2MobilityHelper<a class="headerlink" href="#ns2mobilityhelper" title="Link to this heading">¶</a></h4>
<p>Two example programs are provided demonstrating the use of the
<em>ns-2</em> mobility helper:</p>
<ul class="simple">
<li><p>ns2-mobility-trace.cc</p></li>
<li><p>bonnmotion-ns2-example.cc</p></li>
</ul>
<section id="ns2-mobility-trace">
<h5><span class="section-number">23.2.2.1. </span>ns2-mobility-trace<a class="headerlink" href="#ns2-mobility-trace" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">ns2-mobility-trace.cc</span></code> program is an example of loading an
<em>ns-2</em> trace file that specifies the movements of two nodes over 100
seconds of simulation time.  It is paired with the file
<code class="docutils literal notranslate"><span class="pre">default.ns_movements</span></code>.</p>
<p>The program behaves as follows:</p>
<ul class="simple">
<li><p>a Ns2MobilityHelper object is created, with the specified trace file.</p></li>
<li><p>A log file is created, using the log file name argument.</p></li>
<li><p>A node container is created with the number of nodes specified in the command line.  For this particular trace file, specify the value 2 for this argument.</p></li>
<li><p>the Install() method of Ns2MobilityHelper to set mobility to nodes. At this moment, the file is read line by line, and the movement is scheduled in the simulator.</p></li>
<li><p>A callback is configured, so each time a node changes its course a log message is printed.</p></li>
</ul>
<p>The example prints out messages generated by each read line from the ns2 movement trace file.   For each line, it shows if the line is correct, or of it has errors and in this case it will be ignored.</p>
<p>Example usage:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;ns2-mobility-trace \</span>
<span class="s2">--traceFile=src/mobility/examples/default.ns_movements \</span>
<span class="s2">--nodeNum=2 \</span>
<span class="s2">--duration=100.0 \</span>
<span class="s2">--logFile=ns2-mob.log&quot;</span>
</pre></div>
</div>
<p>Sample log file output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+0.0ns POS: x=150, y=93.986, z=0; VEL:0, y=50.4038, z=0
+0.0ns POS: x=195.418, y=150, z=0; VEL:50.1186, y=0, z=0
+104727357.0ns POS: x=200.667, y=150, z=0; VEL:50.1239, y=0, z=0
+204480076.0ns POS: x=205.667, y=150, z=0; VEL:0, y=0, z=0
</pre></div>
</div>
</section>
<section id="bonnmotion-ns2-example">
<h5><span class="section-number">23.2.2.2. </span>bonnmotion-ns2-example<a class="headerlink" href="#bonnmotion-ns2-example" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">bonnmotion-ns2-example.cc</span></code> program, which models the movement of
a single mobile node for 1000 seconds of simulation time, has a few
associated files:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bonnmotion.ns_movements</span></code> is the <em>ns-2</em>-formatted mobility trace</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bonnmotion.params</span></code> is a BonnMotion-generated file with some metadata about the mobility trace</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bonnmotion.ns_params</span></code> is another BonnMotion-generated file with ns-2-related metadata.</p></li>
</ul>
<p>Neither of the latter two files is used by <em>ns-3</em>, although they are generated
as part of the BonnMotion process to output ns-2-compatible traces.</p>
<p>The program <code class="docutils literal notranslate"><span class="pre">bonnmotion-ns2-example.cc</span></code> will output the following to stdout:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>At 0.00 node 0: Position(329.82, 66.06, 0.00);   Speed(0.53, -0.22, 0.00)
At 100.00 node 0: Position(378.38, 45.59, 0.00);   Speed(0.00, 0.00, 0.00)
At 200.00 node 0: Position(304.52, 123.66, 0.00);   Speed(-0.92, 0.97, 0.00)
At 300.00 node 0: Position(274.16, 131.67, 0.00);   Speed(-0.53, -0.46, 0.00)
At 400.00 node 0: Position(202.11, 123.60, 0.00);   Speed(-0.98, 0.35, 0.00)
At 500.00 node 0: Position(104.60, 158.95, 0.00);   Speed(-0.98, 0.35, 0.00)
At 600.00 node 0: Position(31.92, 183.87, 0.00);   Speed(0.76, -0.51, 0.00)
At 700.00 node 0: Position(107.99, 132.43, 0.00);   Speed(0.76, -0.51, 0.00)
At 800.00 node 0: Position(184.06, 80.98, 0.00);   Speed(0.76, -0.51, 0.00)
At 900.00 node 0: Position(250.08, 41.76, 0.00);   Speed(0.60, -0.05, 0.00)
</pre></div>
</div>
<p>The motion of the mobile node is sampled every 100 seconds, and its position
and speed are printed out.  This output may be compared to the output of
a similar <em>ns-2</em> program (found in the <em>ns-2</em> <code class="docutils literal notranslate"><span class="pre">tcl/ex/</span></code> directory of <em>ns-2</em>)
running from the same mobility trace.</p>
<p>The next file is generated from <em>ns-2</em> (users will have to download and
install <em>ns-2</em> and run this Tcl program to see this output).
The output of the <em>ns-2</em> <code class="docutils literal notranslate"><span class="pre">bonnmotion-example.tcl</span></code> program is shown below
for comparison (file <code class="docutils literal notranslate"><span class="pre">bonnmotion-example.tr</span></code>):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>M 0.00000 0 (329.82, 66.06, 0.00), (378.38, 45.59), 0.57
M 100.00000 0 (378.38, 45.59, 0.00), (378.38, 45.59), 0.57
M 119.37150 0 (378.38, 45.59, 0.00), (286.69, 142.52), 1.33
M 200.00000 0 (304.52, 123.66, 0.00), (286.69, 142.52), 1.33
M 276.35353 0 (286.69, 142.52, 0.00), (246.32, 107.57), 0.70
M 300.00000 0 (274.16, 131.67, 0.00), (246.32, 107.57), 0.70
M 354.65589 0 (246.32, 107.57, 0.00), (27.38, 186.94), 1.04
M 400.00000 0 (202.11, 123.60, 0.00), (27.38, 186.94), 1.04
M 500.00000 0 (104.60, 158.95, 0.00), (27.38, 186.94), 1.04
M 594.03719 0 (27.38, 186.94, 0.00), (241.02, 42.45), 0.92
M 600.00000 0 (31.92, 183.87, 0.00), (241.02, 42.45), 0.92
M 700.00000 0 (107.99, 132.43, 0.00), (241.02, 42.45), 0.92
M 800.00000 0 (184.06, 80.98, 0.00), (241.02, 42.45), 0.92
M 884.77399 0 (241.02, 42.45, 0.00), (309.59, 37.22), 0.60
M 900.00000 0 (250.08, 41.76, 0.00), (309.59, 37.22), 0.60
</pre></div>
</div>
<p>The output formatting is slightly different, and the course change
times are additionally plotted, but it can be seen that the position
vectors are the same between the two traces at intervals of 100 seconds.</p>
<p>The mobility computations performed on the <em>ns-2</em> trace file are slightly
different in <em>ns-2</em> and <em>ns-3</em>, and floating-point arithmetic is used,
so there is a chance that the position in <em>ns-2</em> may be slightly
different than the respective position when using the trace file
in <em>ns-3</em>.</p>
</section>
</section>
<section id="use-of-random-variables">
<h4><span class="section-number">23.2.3. </span>Use of Random Variables<a class="headerlink" href="#use-of-random-variables" title="Link to this heading">¶</a></h4>
<p>A typical use case is to evaluate protocols on a mobile topology that
involves some randomness in the motion or initial position allocation.
To obtain random motion and positioning that is not affected by
the configuration of the rest of the scenario, it is recommended to
use the “AssignStreams” facility of the random number system.</p>
<p>Class <code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code> and class <code class="docutils literal notranslate"><span class="pre">PositionAllocator</span></code> both have public
API to assign streams to underlying random variables:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Assign a fixed random variable stream number to the random variables</span>
<span class="cm"> * used by this model. Return the number of streams (possibly zero) that</span>
<span class="cm"> * have been assigned.</span>
<span class="cm"> *</span>
<span class="cm"> * \param stream first stream index to use</span>
<span class="cm"> * \return the number of stream indices assigned by this model</span>
<span class="cm"> */</span>
<span class="kt">int64_t</span><span class="w"> </span><span class="nf">AssignStreams</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">MobilityHelper</span></code> also provides this API.  The typical usage
pattern when using the helper is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span><span class="w"> </span><span class="n">streamIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/*some positive integer */</span>
<span class="n">MobilityHelper</span><span class="w"> </span><span class="n">mobility</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="p">(</span><span class="n">configure</span><span class="w"> </span><span class="n">mobility</span><span class="p">)</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiStaNodes</span><span class="p">);</span>
<span class="kt">int64_t</span><span class="w"> </span><span class="n">streamsUsed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mobility</span><span class="p">.</span><span class="n">AssignStreams</span><span class="p">(</span><span class="n">wifiStaNodes</span><span class="p">,</span><span class="w"> </span><span class="n">streamIndex</span><span class="p">);</span>
</pre></div>
</div>
<p>If AssignStreams is called before Install, it will not have any effect.</p>
</section>
<section id="advanced-usage">
<h4><span class="section-number">23.2.4. </span>Advanced Usage<a class="headerlink" href="#advanced-usage" title="Link to this heading">¶</a></h4>
<p>A number of external tools can be used to generate traces read by
the Ns2MobilityHelper.</p>
<section id="ns-2-scengen">
<h5><span class="section-number">23.2.4.1. </span>ns-2 scengen<a class="headerlink" href="#ns-2-scengen" title="Link to this heading">¶</a></h5>
<p>TBD</p>
</section>
<section id="id4">
<h5><span class="section-number">23.2.4.2. </span>BonnMotion<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h5>
<p><a class="reference external" href="http://net.cs.uni-bonn.de/wg/cs/applications/bonnmotion/">http://net.cs.uni-bonn.de/wg/cs/applications/bonnmotion/</a></p>
</section>
<section id="id5">
<h5><span class="section-number">23.2.4.3. </span>SUMO<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h5>
<p><a class="reference external" href="http://sourceforge.net/apps/mediawiki/sumo/index.php?title=Main_Page">http://sourceforge.net/apps/mediawiki/sumo/index.php?title=Main_Page</a></p>
</section>
<section id="id6">
<h5><span class="section-number">23.2.4.4. </span>TraNS<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h5>
<p><a class="reference external" href="http://trans.epfl.ch/">http://trans.epfl.ch/</a></p>
</section>
</section>
<section id="examples">
<h4><span class="section-number">23.2.5. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>main-random-topology.cc</p></li>
<li><p>main-random-walk.cc</p></li>
<li><p>main-grid-topology.cc</p></li>
<li><p>ns2-mobility-trace.cc</p></li>
<li><p>ns2-bonnmotion.cc</p></li>
</ul>
<section id="reference-point-group-mobility-example-cc">
<h5><span class="section-number">23.2.5.1. </span>reference-point-group-mobility-example.cc<a class="headerlink" href="#reference-point-group-mobility-example-cc" title="Link to this heading">¶</a></h5>
<p>The reference point group mobility model (<a class="reference internal" href="index.html#camp2002" id="id7"><span>[Camp2002]</span></a>) is demonstrated
in the example program <cite>reference-point-group-mobility-example.cc</cite>.
This example runs a short simulation that illustrates a parent
WaypointMobilityModel traversing a rectangular course within a bounding
box, and three member nodes independently execute a two-dimensional
random walk around the parent position, within a small bounding box.
The example illustrates configuration using the GroupMobilityHelper
and manual configuration without a helper; the configuration option
is selectable by command-line argument.</p>
<p>The example outputs two mobility trace files, a course change trace and
a time-series trace of node position.  The latter trace file can be
parsed by a Bash script (<cite>reference-point-group-mobility-animate.sh</cite>)
to create PNG images at one-second intervals, which can then be combined
using an image processing program such as ImageMagick to form a
basic animated gif of the mobility.  The example and animation program
files have further instructions on how to run them.</p>
</section>
</section>
</section>
<section id="validation">
<h3><span class="section-number">23.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>TBD</p>
</section>
</section>
<span id="document-network"></span><section id="network-module">
<h2><span class="section-number">24. </span>Network Module<a class="headerlink" href="#network-module" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-packets"></span><section id="packets">
<h3><span class="section-number">24.1. </span>Packets<a class="headerlink" href="#packets" title="Link to this heading">¶</a></h3>
<p>The design of the Packet framework of <em>ns</em> was heavily guided by a few
important use-cases:</p>
<ul class="simple">
<li><p>avoid changing the core of the simulator to introduce new types of packet
headers or trailers</p></li>
<li><p>maximize the ease of integration with real-world code and systems</p></li>
<li><p>make it easy to support fragmentation, defragmentation, and, concatenation
which are important, especially in wireless systems.</p></li>
<li><p>make memory management of this object efficient</p></li>
<li><p>allow actual application data or dummy application bytes for emulated
applications</p></li>
</ul>
<p>Each network packet contains a byte buffer, a set of byte tags, a set of packet
tags, and metadata.</p>
<p>The byte buffer stores the serialized content of the headers and trailers added
to a packet. The serialized representation of these headers is expected to match
that of real network packets bit for bit (although nothing forces you to do
this) which means that the content of a packet buffer is expected to be that of
a real packet.</p>
<p>Fragmentation and defragmentation are quite natural to implement within this
context: since we have a buffer of real bytes, we can split it in multiple
fragments and re-assemble these fragments. We expect that this choice will make
it really easy to wrap our Packet data structure within Linux-style skb or
BSD-style mbuf to integrate real-world kernel code in the simulator. We also
expect that performing a real-time plug of the simulator to a real-world network
will be easy.</p>
<p>One problem that this design choice raises is that it is difficult to
pretty-print the packet headers without context. The packet metadata describes
the type of the headers and trailers which were serialized in the byte buffer.
The maintenance of metadata is optional and disabled by default. To enable it,
you must call Packet::EnablePrinting() and this will allow you to get non-empty
output from Packet::Print and Packet::Print.</p>
<p>Also, developers often want to store data in packet objects that is not found
in the real packets (such as timestamps or flow-ids). The Packet class
deals with this requirement by storing a set of tags (class Tag).
We have found two classes of use cases for these tags, which leads to
two different types of tags. So-called ‘byte’ tags are used to tag a subset of
the bytes in the packet byte buffer while ‘packet’ tags are used to tag the
packet itself. The main difference between these two kinds of tags is what
happens when packets are copied, fragmented, and reassembled: ‘byte’ tags follow
bytes while ‘packet’ tags follow packets. Another important difference between
these two kinds of tags is that byte tags cannot be removed and are expected to
be written once, and read many times, while packet tags are expected to be
written once, read many times, and removed exactly once. An example of a ‘byte’
tag is a FlowIdTag which contains a flow id and is set by the application
generating traffic. An example of a ‘packet’ tag is a cross-layer QoS class id
set by an application and processed by a lower-level MAC layer.</p>
<p>Memory management of Packet objects is entirely automatic and extremely
efficient: memory for the application-level payload can be modeled by a virtual
buffer of zero-filled bytes for which memory is never allocated unless
explicitly requested by the user or unless the packet is fragmented or
serialized out to a real network device. Furthermore, copying, adding, and,
removing headers or trailers to a packet has been optimized to be virtually free
through a technique known as Copy On Write.</p>
<p>Packets (messages) are fundamental objects in the simulator and
their design is important from a performance and resource management
perspective. There are various ways to design the simulation packet, and
tradeoffs among the different approaches. In particular, there is a tension
between ease-of-use, performance, and safe interface design.</p>
<section id="packet-design-overview">
<h4><span class="section-number">24.1.1. </span>Packet design overview<a class="headerlink" href="#packet-design-overview" title="Link to this heading">¶</a></h4>
<p>Unlike <em>ns-2</em>, in which Packet objects contain a buffer of C++
structures corresponding to protocol headers, each network packet in
<em>ns-3</em> contains a byte Buffer, a list of byte Tags, a list of
packet Tags, and a PacketMetadata object:</p>
<ul class="simple">
<li><p>The byte buffer stores the serialized content of the chunks added to a packet.
The serialized representation of these chunks is expected to match that of
real network packets bit for bit (although nothing forces you to do this)
which means that the content of a packet buffer is expected to be that of a
real packet.  Packets can also be created with an arbitrary zero-filled
payload for which no real memory is allocated.</p></li>
<li><p>Each list of tags stores an arbitrarily large set of arbitrary user-provided
data structures in the packet.  Each Tag is uniquely identified by its type;
only one instance of each type of data structure is allowed in a list of tags.
These tags typically contain per-packet cross-layer information or flow
identifiers (i.e., things that you wouldn’t find in the bits on the wire).</p></li>
</ul>
<figure class="align-default" id="id2">
<span id="id1"></span><img alt="_images/packet.png" src="_images/packet.png" />
<figcaption>
<p><span class="caption-text">Implementation overview of Packet class.</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure <a class="reference internal" href="#id1"><span class="std std-ref">Implementation overview of Packet class.</span></a> is a high-level overview of the Packet implementation;
more detail on the byte Buffer implementation is provided later in Figure
<a class="reference internal" href="#buffer"><span class="std std-ref">Implementation overview of a packet’s byte Buffer.</span></a>. In <em>ns-3</em>, the Packet byte buffer is analogous to a Linux skbuff
or BSD mbuf; it is a serialized representation of the actual data in the packet.
The tag lists are containers for extra items useful for simulation convenience;
if a Packet is converted to an emulated packet and put over an actual network,
the tags are stripped off and the byte buffer is copied directly into a real
packet.</p>
<p>Packets are reference counted objects. They are handled with smart pointer (Ptr)
objects like many of the objects in the <em>ns-3</em> system.  One small difference you
will see is that class Packet does not inherit from class Object or class
RefCountBase, and implements the Ref() and Unref() methods directly. This was
designed to avoid the overhead of a vtable in class Packet.</p>
<p>The Packet class is designed to be copied cheaply; the overall design
is based on Copy on Write (COW).  When there are multiple references
to a packet object, and there is an operation on one of them, only
so-called “dirty” operations will trigger a deep copy of the packet:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Packet::AddHeader()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Packet::AddTrailer()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">both</span> <span class="pre">versions</span> <span class="pre">of</span> <span class="pre">ns3::Packet::AddAtEnd()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Packet::RemovePacketTag()</span></code></p></li>
</ul>
<p>The fundamental classes for adding to and removing from the byte buffer are
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Header</span></code> and <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Trailer</span></code>. Headers are more common but the below
discussion also largely applies to protocols using trailers. Every protocol
header that needs to be inserted and removed from a Packet instance should
derive from the abstract Header base class and implement the private pure
virtual methods listed below:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::SerializeTo()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::DeserializeFrom()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::GetSerializedSize()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Header::PrintTo()</span></code></p></li>
</ul>
<p>Basically, the first three functions are used to serialize and deserialize
protocol control information to/from a Buffer. For example, one may define
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">TCPHeader</span> <span class="pre">:</span> <span class="pre">public</span> <span class="pre">Header</span></code>. The TCPHeader object will typically
consist of some private data (like a sequence number) and public interface
access functions (such as checking the bounds of an input). But the underlying
representation of the TCPHeader in a Packet Buffer is 20 serialized bytes (plus
TCP options). The TCPHeader::SerializeTo() function would therefore be designed
to write these 20 bytes properly into the packet, in network byte order. The
last function is used to define how the Header object prints itself onto an
output stream.</p>
<p>Similarly, user-defined Tags can be appended to the packet. Unlike Headers,
Tags are not serialized into a contiguous buffer but are stored in lists. Tags
can be flexibly defined to be any type, but there can only be one instance of
any particular object type in the Tags buffer at any time.</p>
</section>
<section id="using-the-packet-interface">
<h4><span class="section-number">24.1.2. </span>Using the packet interface<a class="headerlink" href="#using-the-packet-interface" title="Link to this heading">¶</a></h4>
<p>This section describes how to create and use the <code class="docutils literal notranslate"><span class="pre">ns3::Packet</span></code> object.</p>
<section id="creating-a-new-packet">
<h5><span class="section-number">24.1.2.1. </span>Creating a new packet<a class="headerlink" href="#creating-a-new-packet" title="Link to this heading">¶</a></h5>
<p>The following command will create a new packet with a new unique Id.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pkt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>What is the Uid (unique Id)?  It is an internal id that the system uses to
identify packets.  It can be fetched via the following method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">uid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">GetUid</span><span class="p">();</span>
</pre></div>
</div>
<p>But please note the following. This uid is an internal uid and cannot be counted
on to provide an accurate counter of how many “simulated packets” of a
particular protocol are in the system. It is not trivial to make this uid into
such a counter, because of questions such as what should the uid be when the
packet is sent over broadcast media, or when fragmentation occurs. If a user
wants to trace actual packet counts, he or she should look at e.g. the IP ID
field or transport sequence numbers, or other packet or frame counters at other
protocol layers.</p>
<p>We mentioned above that it is possible to create packets with zero-filled
payloads that do not actually require a memory allocation (i.e., the packet may
behave, when delays such as serialization or transmission delays are computed,
to have a certain number of payload bytes, but the bytes will only be allocated
on-demand when needed).  The command to do this is, when the packet is
created:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pkt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
<p>where N is a positive integer.</p>
<p>The packet now has a size of N bytes, which can be verified by the GetSize()
method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \returns the size in bytes of the packet (including the zero-filled</span>
<span class="cm"> *          initial payload)</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">GetSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>You can also initialize a packet with a character buffer. The input
data is copied and the input buffer is untouched. The constructor
applied is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Packet</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>Here is an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pkt1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>Packets are freed when there are no more references to them, as with all <em>ns-3</em>
objects referenced by the Ptr class.</p>
</section>
<section id="adding-and-removing-buffer-data">
<h5><span class="section-number">24.1.2.2. </span>Adding and removing Buffer data<a class="headerlink" href="#adding-and-removing-buffer-data" title="Link to this heading">¶</a></h5>
<p>After the initial packet creation (which may possibly create some fake initial
bytes of payload), all subsequent buffer data is added by adding objects of
class Header or class Trailer. Note that, even if you are in the application
layer, handling packets, and want to write application data, you write it as an
ns3::Header or ns3::Trailer. If you add a Header, it is prepended to the
packet, and if you add a Trailer, it is added to the end of the packet. If you
have no data in the packet, then it makes no difference whether you add a Header
or Trailer. Since the APIs and classes for header and trailer are pretty much
identical, we’ll just look at class Header here.</p>
<p>The first step is to create a new header class. All new Header classes
must inherit from class Header, and implement the following methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Serialize</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Deserialize</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetSerializedSize</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">()</span></code></p></li>
</ul>
<p>To see a simple example of how these are done, look at the UdpHeader class
headers src/internet/model/udp-header.cc. There are many other examples within
the source code.</p>
<p>Once you have a header (or you have a preexisting header), the following
Packet API can be used to add or remove such headers.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Add header to this packet. This method invokes the</span>
<span class="cm"> * Header::GetSerializedSize and Header::Serialize</span>
<span class="cm"> * methods to reserve space in the buffer and request the</span>
<span class="cm"> * header to serialize itself in the packet buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to add to this packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">AddHeader</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Header</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">header</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * Deserialize and remove the header from the internal buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This method invokes Header::Deserialize(begin) and should be used for</span>
<span class="cm"> * fixed-length headers.</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to remove from the internal buffer.</span>
<span class="cm"> * \returns the number of bytes removed from the packet.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">RemoveHeader</span><span class="p">(</span><span class="n">Header</span><span class="w"> </span><span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * Deserialize but does _not_ remove the header from the internal buffer.</span>
<span class="cm"> * This method invokes Header::Deserialize.</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to read from the internal buffer.</span>
<span class="cm"> * \returns the number of bytes read from the packet.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">PeekHeader</span><span class="p">(</span><span class="n">Header</span><span class="w"> </span><span class="o">&amp;</span><span class="n">header</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance, here are the typical operations to add and remove a UDP header.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// add header</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">UdpHeader</span><span class="w"> </span><span class="n">udpHeader</span><span class="p">;</span>
<span class="c1">// Fill out udpHeader fields appropriately</span>
<span class="n">packet</span><span class="o">-&gt;</span><span class="n">AddHeader</span><span class="p">(</span><span class="n">udpHeader</span><span class="p">);</span>
<span class="p">...</span>
<span class="c1">// remove header</span>
<span class="n">UdpHeader</span><span class="w"> </span><span class="n">udpHeader</span><span class="p">;</span>
<span class="n">packet</span><span class="o">-&gt;</span><span class="n">RemoveHeader</span><span class="p">(</span><span class="n">udpHeader</span><span class="p">);</span>
<span class="c1">// Read udpHeader fields as needed</span>
</pre></div>
</div>
<p>If the header is variable-length, then another variant of RemoveHeader() is
needed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \brief Deserialize and remove the header from the internal buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This method invokes Header::Deserialize(begin, end) and should be</span>
<span class="cm"> * used for variable-length headers (where the size is determined somehow</span>
<span class="cm"> * by the caller).</span>
<span class="cm"> *</span>
<span class="cm"> * \param header a reference to the header to remove from the internal buffer.</span>
<span class="cm"> * \param size number of bytes to deserialize</span>
<span class="cm"> * \returns the number of bytes removed from the packet.</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">RemoveHeader</span><span class="p">(</span><span class="n">Header</span><span class="w"> </span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the caller must figure out and provide the right ‘size’ as
an argument (the Deserialization routine may not know when to stop).  An
example of this type of header would be a series of Type-Length-Value (TLV)
information elements, where the ending point of the series of TLVs can
be deduced from the packet length.</p>
</section>
<section id="adding-and-removing-tags">
<h5><span class="section-number">24.1.2.3. </span>Adding and removing Tags<a class="headerlink" href="#adding-and-removing-tags" title="Link to this heading">¶</a></h5>
<p>There is a single base class of Tag that all packet tags must derive from. They
are used in two different tag lists in the packet; the lists have different
semantics and different expected use cases.</p>
<p>As the names imply, ByteTags follow bytes and PacketTags follow packets. What
this means is that when operations are done on packets, such as fragmentation,
concatenation, and appending or removing headers, the byte tags keep track of
which packet bytes they cover. For instance, if a user creates a TCP segment,
and applies a ByteTag to the segment, each byte of the TCP segment will be
tagged. However, if the next layer down inserts an IPv4 header, this ByteTag
will not cover those bytes.  The converse is true for the PacketTag; it covers a
packet despite the operations on it.</p>
<p>Each tag type must subclass <code class="docutils literal notranslate"><span class="pre">ns3::Tag</span></code>, and only one instance of
each Tag type may be in each tag list. Here are a few differences in the
behavior of packet tags and byte tags.</p>
<ul class="simple">
<li><p><strong>Fragmentation:</strong>  As mentioned above, when a packet is fragmented, each
packet fragment (which is a new packet) will get a copy of all packet tags,
and byte tags will follow the new packet boundaries (i.e. if the fragmented
packets fragment across a buffer region covered by the byte tag, both packet
fragments will still have the appropriate buffer regions byte tagged).</p></li>
<li><p><strong>Concatenation:</strong> When packets are combined, two different buffer regions
will become one. For byte tags, the byte tags simply follow the respective
buffer regions. For packet tags, only the tags on the first packet survive
the merge.</p></li>
<li><p><strong>Finding and Printing:</strong> Both classes allow you to iterate over all of the
tags and print them.</p></li>
<li><p><strong>Removal:</strong> Users can add and remove the same packet tag multiple times on a
single packet (AddPacketTag() and RemovePacketTag()). The packet However,
once a byte tag is added, it can only be removed by stripping all byte tags
from the packet. Removing one of possibly multiple byte tags is not supported
by the current API.</p></li>
</ul>
<p>If a user wants to take an existing packet object and reuse it as a new packet,
he or she should remove all byte tags and packet tags before doing so. An
example is the UdpEchoServer class, which takes the received packet and “turns
it around” to send back to the echo client.</p>
<p>The Packet API for byte tags is given below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \param tag the new tag to add to this packet</span>
<span class="cm"> *</span>
<span class="cm"> * Tag each byte included in this packet with the</span>
<span class="cm"> * new tag.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that adding a tag is a const operation which is pretty</span>
<span class="cm"> * un-intuitive. The rationale is that the content and behavior of</span>
<span class="cm"> * a packet is _not_ changed when a tag is added to a packet: any</span>
<span class="cm"> * code which was not aware of the new tag is going to work just</span>
<span class="cm"> * the same if the new tag is added. The real reason why adding a</span>
<span class="cm"> * tag was made a const operation is to allow a trace sink which gets</span>
<span class="cm"> * a packet to tag the packet, even if the packet is const (and most</span>
<span class="cm"> * trace sources should use const packets because it would be</span>
<span class="cm"> * totally evil to allow a trace sink to modify the content of a</span>
<span class="cm"> * packet).</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">AddByteTag</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Tag</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * \returns an iterator over the set of byte tags included in this packet.</span>
<span class="cm"> */</span>
<span class="n">ByteTagIterator</span><span class="w"> </span><span class="nf">GetByteTagIterator</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * \param tag the tag to search in this packet</span>
<span class="cm"> * \returns true if the requested tag type was found, false otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * If the requested tag type is found, it is copied in the user&#39;s</span>
<span class="cm"> * provided tag instance.</span>
<span class="cm"> */</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">FindFirstMatchingByteTag</span><span class="p">(</span><span class="n">Tag</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Remove all the tags stored in this packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">RemoveAllByteTags</span><span class="p">();</span>

<span class="cm">/**</span>
<span class="cm"> * \param os output stream in which the data should be printed.</span>
<span class="cm"> *</span>
<span class="cm"> * Iterate over the tags present in this packet, and</span>
<span class="cm"> * invoke the Print method of each tag stored in the packet.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">PrintByteTags</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The Packet API for packet tags is given below.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * \param tag the tag to store in this packet</span>
<span class="cm"> *</span>
<span class="cm"> * Add a tag to this packet. This method calls the</span>
<span class="cm"> * Tag::GetSerializedSize and, then, Tag::Serialize.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this method is const, that is, it does not</span>
<span class="cm"> * modify the state of this packet, which is fairly</span>
<span class="cm"> * un-intuitive.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">AddPacketTag</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Tag</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * \param tag the tag to remove from this packet</span>
<span class="cm"> * \returns true if the requested tag is found, false</span>
<span class="cm"> *          otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a tag from this packet. This method calls</span>
<span class="cm"> * Tag::Deserialize if the tag is found.</span>
<span class="cm"> */</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">RemovePacketTag</span><span class="p">(</span><span class="n">Tag</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * \param tag the tag to search in this packet</span>
<span class="cm"> * \returns true if the requested tag is found, false</span>
<span class="cm"> *          otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Search a matching tag and call Tag::Deserialize if it is found.</span>
<span class="cm"> */</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">PeekPacketTag</span><span class="p">(</span><span class="n">Tag</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * Remove all packet tags.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">RemoveAllPacketTags</span><span class="p">();</span>

<span class="cm">/**</span>
<span class="cm"> * \param os the stream in which we want to print data.</span>
<span class="cm"> *</span>
<span class="cm"> * Print the list of &#39;packet&#39; tags.</span>
<span class="cm"> *</span>
<span class="cm"> * \sa Packet::AddPacketTag, Packet::RemovePacketTag, Packet::PeekPacketTag,</span>
<span class="cm"> *  Packet::RemoveAllPacketTags</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">PrintPacketTags</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * \returns an object which can be used to iterate over the list of</span>
<span class="cm"> *  packet tags.</span>
<span class="cm"> */</span>
<span class="n">PacketTagIterator</span><span class="w"> </span><span class="nf">GetPacketTagIterator</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Here is a simple example illustrating the use of tags from the
code in <code class="docutils literal notranslate"><span class="pre">src/internet/model/udp-socket-impl.cc</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// pointer to a pre-existing packet</span>
<span class="n">SocketIpTtlTag</span><span class="w"> </span><span class="n">tag</span>
<span class="n">tag</span><span class="p">.</span><span class="n">SetTtl</span><span class="p">(</span><span class="n">m_ipMulticastTtl</span><span class="p">);</span><span class="w"> </span><span class="c1">// Convey the TTL from UDP layer to IP layer</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">AddPacketTag</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
</pre></div>
</div>
<p>This tag is read at the IP layer, then stripped (<code class="docutils literal notranslate"><span class="pre">src/internet/model/ipv4-l3-protocol.cc</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ttl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_defaultTtl</span><span class="p">;</span>
<span class="n">SocketIpTtlTag</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">RemovePacketTag</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ttl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tag</span><span class="p">.</span><span class="n">GetTtl</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fragmentation-and-concatenation">
<h5><span class="section-number">24.1.2.4. </span>Fragmentation and concatenation<a class="headerlink" href="#fragmentation-and-concatenation" title="Link to this heading">¶</a></h5>
<p>Packets may be fragmented or merged together.  For example, to fragment a packet
<code class="docutils literal notranslate"><span class="pre">p</span></code> of 90 bytes into two packets, one containing the first 10 bytes and the
other containing the remaining 80, one may call the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">frag0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">CreateFragment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">frag1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">CreateFragment</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">90</span><span class="p">);</span>
</pre></div>
</div>
<p>As discussed above, the packet tags from <code class="docutils literal notranslate"><span class="pre">p</span></code> will follow to both packet
fragments, and the byte tags will follow the byte ranges as needed.</p>
<p>Now, to put them back together:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">frag0</span><span class="o">-&gt;</span><span class="n">AddAtEnd</span><span class="p">(</span><span class="n">frag1</span><span class="p">);</span>
</pre></div>
</div>
<p>Now frag0 should be equivalent to the original packet <code class="docutils literal notranslate"><span class="pre">p</span></code>.  If, however, there
were operations on the fragments before being reassembled (such as tag
operations or header operations), the new packet will not be the same.</p>
</section>
<section id="enabling-metadata">
<h5><span class="section-number">24.1.2.5. </span>Enabling metadata<a class="headerlink" href="#enabling-metadata" title="Link to this heading">¶</a></h5>
<p>We mentioned above that packets, being on-the-wire representations of byte
buffers, present a problem to print out in a structured way unless the printing
function has access to the context of the header.  For instance, consider a
tcpdump-like printer that wants to pretty-print the contents of a packet.</p>
<p>To enable this usage, packets may have metadata enabled (disabled by default for
performance reasons). This class is used by the Packet class to record every
operation performed on the packet’s buffer, and provides an implementation of
<code class="docutils literal notranslate"><span class="pre">Packet::Print</span> <span class="pre">()</span></code> method that uses the metadata to analyze the content of the
packet’s buffer.</p>
<p>The metadata is also used to perform extensive sanity checks at runtime when
performing operations on a Packet. For example, this metadata is used to verify
that when you remove a header from a packet, this same header was actually
present at the front of the packet. These errors will be detected and will abort
the program.</p>
<p>To enable this operation, users will typically insert one or both of these
statements at the beginning of their programs:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Packet</span><span class="o">::</span><span class="n">EnablePrinting</span><span class="p">();</span>
<span class="n">Packet</span><span class="o">::</span><span class="n">EnableChecking</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="sample-programs">
<h4><span class="section-number">24.1.3. </span>Sample programs<a class="headerlink" href="#sample-programs" title="Link to this heading">¶</a></h4>
<p>See <code class="docutils literal notranslate"><span class="pre">src/network/examples/main-packet-header.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">src/network/examples/main-packet-tag.cc</span></code>.</p>
</section>
<section id="implementation-details">
<h4><span class="section-number">24.1.4. </span>Implementation details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h4>
<section id="private-member-variables">
<h5><span class="section-number">24.1.4.1. </span>Private member variables<a class="headerlink" href="#private-member-variables" title="Link to this heading">¶</a></h5>
<p>A Packet object’s interface provides access to some private data:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Buffer</span><span class="w"> </span><span class="n">m_buffer</span><span class="p">;</span>
<span class="n">ByteTagList</span><span class="w"> </span><span class="n">m_byteTagList</span><span class="p">;</span>
<span class="n">PacketTagList</span><span class="w"> </span><span class="n">m_packetTagList</span><span class="p">;</span>
<span class="n">PacketMetadata</span><span class="w"> </span><span class="n">m_metadata</span><span class="p">;</span>
<span class="k">mutable</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_refCount</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_globalUid</span><span class="p">;</span>
</pre></div>
</div>
<p>Each Packet has a Buffer and two Tags lists, a PacketMetadata object, and a ref
count. A static member variable keeps track of the UIDs allocated. The actual
uid of the packet is stored in the PacketMetadata.</p>
<p>Note:
that real network packets do not have a UID; the UID is therefore an instance of
data that normally would be stored as a Tag in the packet. However, it was felt
that a UID is a special case that is so often used in simulations that it would
be more convenient to store it in a member variable.</p>
</section>
<section id="buffer-implementation">
<h5><span class="section-number">24.1.4.2. </span>Buffer implementation<a class="headerlink" href="#buffer-implementation" title="Link to this heading">¶</a></h5>
<p>Class Buffer represents a buffer of bytes. Its size is automatically adjusted to
hold any data prepended or appended by the user. Its implementation is optimized
to ensure that the number of buffer resizes is minimized, by creating new
Buffers of the maximum size ever used.  The correct maximum size is learned at
runtime during use by recording the maximum size of each packet.</p>
<p>Authors of new Header or Trailer classes need to know the public API of the
Buffer class.  (add summary here)</p>
<p>The byte buffer is implemented as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">BufferData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_count</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_initialStart</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_dirtyStart</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_dirtySize</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">m_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BufferData</span><span class="w"> </span><span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_zeroAreaSize</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_start</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_size</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_count</span></code>: reference count for BufferData structure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_size</span></code>: size of data buffer stored in BufferData structure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_initialStart</span></code>: offset from start of data buffer where data
was first inserted</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_dirtyStart</span></code>: offset from start of buffer where every Buffer
which holds a reference to this BufferData instance have written data so far</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_dirtySize</span></code>: size of area where data has been written so far</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BufferData::m_data</span></code>: pointer to data buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buffer::m_zeroAreaSize</span></code>: size of zero area which extends before
<code class="docutils literal notranslate"><span class="pre">m_initialStart</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buffer::m_start</span></code>: offset from start of buffer to area used by this buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Buffer::m_size</span></code>: size of area used by this Buffer in its BufferData
structure</p></li>
</ul>
<figure class="align-default" id="id3">
<span id="buffer"></span><img alt="_images/buffer.png" src="_images/buffer.png" />
<figcaption>
<p><span class="caption-text">Implementation overview of a packet’s byte Buffer.</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This data structure is summarized in Figure <a class="reference internal" href="#buffer"><span class="std std-ref">Implementation overview of a packet’s byte Buffer.</span></a>. Each Buffer holds a
pointer to an instance of a BufferData. Most Buffers should be able to share the
same underlying BufferData and thus simply increase the BufferData’s reference
count. If they have to change the content of a BufferData inside the Dirty Area,
and if the reference count is not one, they first create a copy of the
BufferData and then complete their state-changing operation.</p>
</section>
<section id="tags-implementation">
<h5><span class="section-number">24.1.4.3. </span>Tags implementation<a class="headerlink" href="#tags-implementation" title="Link to this heading">¶</a></h5>
<p>(XXX revise me)</p>
<p>Tags are implemented by a single pointer which points to the start of a
linked list ofTagData data structures. Each TagData structure points
to the next TagData in the list (its next pointer contains zero to
indicate the end of the linked list). Each TagData contains an integer
unique id which identifies the type of the tag stored in the TagData.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">TagData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TagData</span><span class="w"> </span><span class="o">*</span><span class="n">m_next</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">m_count</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">m_data</span><span class="p">[</span><span class="n">Tags</span><span class="o">::</span><span class="n">SIZE</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Tags</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TagData</span><span class="w"> </span><span class="o">*</span><span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Adding a tag is a matter of inserting a new TagData at the head of the linked
list. Looking at a tag requires you to find the relevant TagData in the linked
list and copy its data into the user data structure. Removing a tag and updating
the content of a tag requires a deep copy of the linked list before performing
this operation.  On the other hand, copying a Packet and its tags is a matter of
copying the TagData head pointer and incrementing its reference count.</p>
<p>Tags are found by the unique mapping between the Tag type and
its underlying id. This is why at most one instance of any Tag
can be stored in a packet. The mapping between Tag type and
underlying id is performed by a registration as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* A sample Tag implementation</span>
<span class="cm"> */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyTag</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">m_streamId</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="memory-management">
<h5><span class="section-number">24.1.4.4. </span>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h5>
<p><em>Describe dataless vs. data-full packets.</em></p>
</section>
<section id="copy-on-write-semantics">
<h5><span class="section-number">24.1.4.5. </span>Copy-on-write semantics<a class="headerlink" href="#copy-on-write-semantics" title="Link to this heading">¶</a></h5>
<p>The current implementation of the byte buffers and tag list is based on COW
(Copy On Write). An introduction to COW can be found in Scott Meyer’s “More
Effective C++”, items 17 and 29). This design feature and aspects of the public
interface borrows from the packet design of the Georgia Tech Network Simulator.
This implementation of COW uses a customized reference counting smart pointer
class.</p>
<p>What COW means is that copying packets without modifying them is very cheap (in
terms of CPU and memory usage) and modifying them can be also very cheap. What
is key for proper COW implementations is being able to detect when a given
modification of the state of a packet triggers a full copy of the data prior to
the modification: COW systems need to detect when an operation is “dirty” and
must therefore invoke a true copy.</p>
<p>Dirty operations:</p>
<ul class="simple">
<li><p>ns3::Packet::AddHeader</p></li>
<li><p>ns3::Packet::AddTrailer</p></li>
<li><p>both versions of ns3::Packet::AddAtEnd</p></li>
<li><p>ns3::Packet::RemovePacketTag</p></li>
</ul>
<p>Non-dirty operations:</p>
<ul class="simple">
<li><p>ns3::Packet::AddPacketTag</p></li>
<li><p>ns3::Packet::PeekPacketTag</p></li>
<li><p>ns3::Packet::RemoveAllPacketTags</p></li>
<li><p>ns3::Packet::AddByteTag</p></li>
<li><p>ns3::Packet::FindFirstMatchingByteTag</p></li>
<li><p>ns3::Packet::RemoveAllByteTags</p></li>
<li><p>ns3::Packet::RemoveHeader</p></li>
<li><p>ns3::Packet::RemoveTrailer</p></li>
<li><p>ns3::Packet::CreateFragment</p></li>
<li><p>ns3::Packet::RemoveAtStart</p></li>
<li><p>ns3::Packet::RemoveAtEnd</p></li>
<li><p>ns3::Packet::CopyData</p></li>
</ul>
<p>Dirty operations will always be slower than non-dirty operations, sometimes by
several orders of magnitude. However, even the dirty operations have been
optimized for common use-cases which means that most of the time, these
operations will not trigger data copies and will thus be still very fast.</p>
</section>
</section>
</section>
<span id="document-error-model"></span><section id="error-model">
<h3><span class="section-number">24.2. </span>Error Model<a class="headerlink" href="#error-model" title="Link to this heading">¶</a></h3>
<p>This section documents a few error model objects, typically associated with
NetDevice models, that are maintained as part of the <code class="docutils literal notranslate"><span class="pre">network</span></code> module:</p>
<ul class="simple">
<li><p>RateErrorModel</p></li>
<li><p>ListErrorModel</p></li>
<li><p>ReceiveListErrorModel</p></li>
<li><p>BurstErrorModel</p></li>
</ul>
<p>Error models are used to indicate that a packet should be considered to
be errored, according to the underlying (possibly stochastic or
empirical) error model.</p>
<section id="model-description">
<h4><span class="section-number">24.2.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for error models live in the directory <code class="docutils literal notranslate"><span class="pre">src/packet/utils</span></code>.</p>
<p>Two types of error models are generally provided.  The first are stochastic
models.  In this case, packets are errored according to underlying
random variable distributions.  An example of this is the <code class="docutils literal notranslate"><span class="pre">RateErrorModel</span></code>.
The other type of model is a deterministic or empirical model, in which
packets are errored according to a particular prescribed pattern.
An example is the <code class="docutils literal notranslate"><span class="pre">ListErrorModel</span></code> that allows users to specify
the list of packets to be errored, by listing the specific packet UIDs.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::RateErrorModel</span></code> errors packets according to an underlying
random variable distribution, which is by default a UniformRandomVariable
distributed between 0.0 and 1.0.  The error rate and error units (bit,
byte, or packet) are set by the user.  For instance, by setting ErrorRate
to 0.1 and ErrorUnit to “Packet”, in the long run, around 10% of the
packets will be lost.</p>
<section id="design">
<h5><span class="section-number">24.2.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>Error models are <em>ns-3</em> objects and can be created using the typical
pattern of <code class="docutils literal notranslate"><span class="pre">CreateObject&lt;&gt;()</span></code>.  They have configuration attributes.</p>
<p>An ErrorModel can be applied anywhere, but are commonly deployed on
NetDevice models so that artificial losses (mimicking channel losses)
can be induced.</p>
</section>
<section id="scope-and-limitations">
<h5><span class="section-number">24.2.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h5>
<p>No known limitations.  There are no existing models that try to modify
the packet contents (e.g. apply bit or byte errors to the byte buffers).
This type of operation will likely be performance-expensive, and existing
Packet APIs may not easily support it.</p>
<p>The <em>ns-3</em> spectrum model and devices that derive from it (e.g. LTE) have
their own error model base class, found in</p>
</section>
<section id="references">
<h5><span class="section-number">24.2.1.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<p>The initial <em>ns-3</em> error models were ported from ns-2 (queue/errmodel.{cc,h})</p>
</section>
</section>
<section id="usage">
<h4><span class="section-number">24.2.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>The base class API is as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ErrorModel::IsCorrupt</span> <span class="pre">(Ptr&lt;Packet&gt;</span> <span class="pre">pkt)</span></code>:  Evaluate the packet and
return true or false whether the packet should be considered errored or not.
Some models could potentially alter the contents of the packet bit buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">ErrorModel::Reset</span> <span class="pre">()</span></code>:  Reset any state.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">ErrorModel::Enable</span> <span class="pre">()</span></code>:  Enable the model</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">ErrorModel::Disable</span> <span class="pre">()</span></code>:  Disable the model; IsCorrupt() will
always return false.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ErrorModel::IsEnabled</span> <span class="pre">()</span> <span class="pre">const</span></code>:  Return the enabled state</p></li>
</ul>
<p>Many <em>ns-3</em> NetDevices contain attributes holding pointers to error
models.  The error model is applied in the notional physical layer
processing chain of the device, and drops should show up on the <code class="docutils literal notranslate"><span class="pre">PhyRxDrop</span></code>
trace source of the device.  The following are known to include an attribute
with a pointer available to hold this type of error model:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SimpleNetDevice</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PointToPointNetDevice</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CsmaNetDevice</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VirtualNetDevice</span></code></p></li>
</ul>
<p>However, the ErrorModel could be used anywhere where packets are used</p>
<section id="helpers">
<h5><span class="section-number">24.2.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p>This model is typically not used with helpers.</p>
</section>
<section id="attributes">
<h5><span class="section-number">24.2.2.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">RateErrorModel</span></code> contains the following attributes:</p>
</section>
<section id="output">
<h5><span class="section-number">24.2.2.3. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>What kind of data does the model generate?  What are the key trace
sources?   What kind of logging output can be enabled?</p>
</section>
<section id="examples">
<h5><span class="section-number">24.2.2.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>Error models are used in the tutorial <code class="docutils literal notranslate"><span class="pre">fifth</span></code> and <code class="docutils literal notranslate"><span class="pre">sixth</span></code> programs.</p>
<p>The directory <code class="docutils literal notranslate"><span class="pre">examples/error-model/</span></code> contains an example
<code class="docutils literal notranslate"><span class="pre">simple-error-model.cc</span></code> that exercises the Rate and List error models.</p>
<p>The TCP example <code class="docutils literal notranslate"><span class="pre">examples/tcp/tcp-nsc-lfn.cc</span></code> uses the Rate error model.</p>
</section>
<section id="troubleshooting">
<h5><span class="section-number">24.2.2.5. </span>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Link to this heading">¶</a></h5>
<p>No known issues.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">24.2.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">error-model</span></code> unit test suite provides a single test case of
of a particular combination of ErrorRate and ErrorUnit for the
<code class="docutils literal notranslate"><span class="pre">RateErrorModel</span></code> applied to a <code class="docutils literal notranslate"><span class="pre">SimpleNetDevice</span></code>.</p>
</section>
<section id="acknowledgements">
<h4><span class="section-number">24.2.4. </span>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h4>
<p>The basic ErrorModel, RateErrorModel, and ListErrorModel classes were ported
from <em>ns-2</em> to <em>ns-3</em> in 2007.  The ReceiveListErrorModel was added at that
time.</p>
<p>The burst error model is due to Truc Anh N. Nguyen at the University of
Kansas (James P.G. Sterbenz &lt;<a class="reference external" href="mailto:jpgs&#37;&#52;&#48;ittc&#46;ku&#46;edu">jpgs<span>&#64;</span>ittc<span>&#46;</span>ku<span>&#46;</span>edu</a>&gt;, director, ResiliNets
Research Group (<a class="reference external" href="https://resilinets.org/">https://resilinets.org/</a>), Information and
Telecommunication Technology Center (ITTC) and Department of Electrical
Engineering and Computer Science, The University of Kansas Lawrence, KS USA).
Work supported in part by NSF FIND (Future Internet Design) Program
under grant CNS-0626918 (Postmodern Internet Architecture),
NSF grant CNS-1050226 (Multilayer Network Resilience Analysis and
Experimentation on GENI), US Department of Defense (DoD), and ITTC at
The University of Kansas.</p>
</section>
</section>
<span id="document-network-overview"></span><section id="node-and-netdevices-overview">
<h3><span class="section-number">24.3. </span>Node and NetDevices Overview<a class="headerlink" href="#node-and-netdevices-overview" title="Link to this heading">¶</a></h3>
<p>This chapter describes how <em>ns-3</em> nodes are put together, and provides a
walk-through of how packets traverse an internet-based Node.</p>
<figure class="align-default" id="id1">
<span id="node-architecture"></span><img alt="_images/node.png" src="_images/node.png" />
<figcaption>
<p><span class="caption-text">High-level node architecture</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In <em>ns-3</em>, nodes are instances of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Node</span></code>. This class may be
subclassed, but instead, the conceptual model is that we <em>aggregate</em> or insert
objects to it rather than define subclasses.</p>
<p>One might think of a bare <em>ns-3</em> node as a shell of a computer, to which one may
add NetDevices (cards) and other innards including the protocols and
applications. <a class="reference internal" href="#node-architecture"><span class="std std-ref">High-level node architecture</span></a> illustrates that <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Node</span></code>
objects contain a list of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Application</span></code> instances (initially,
the list is empty), a list of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::NetDevice</span></code> instances (initially,
the list is empty), a list of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Node::ProtocolHandler</span></code> instances,
a unique integer ID, and a system ID (for distributed simulation).</p>
<p>The design tries to avoid putting too many dependencies on the class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Node</span></code>, <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Application</span></code>, or
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::NetDevice</span></code> for the following:</p>
<ul class="simple">
<li><p>IP version, or whether IP is at all even used in the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Node</span></code>.</p></li>
<li><p>implementation details of the IP stack.</p></li>
</ul>
<p>From a software perspective, the lower interface of applications corresponds to
the C-based sockets API. The upper interface of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::NetDevice</span></code>
objects corresponds to the device independent sublayer of the Linux stack.
Everything in between can be aggregated and plumbed together as needed.</p>
<p>Let’s look more closely at the protocol demultiplexer. We want incoming frames
at layer-2 to be delivered to the right layer-3 protocol such as IPv4. The
function of this demultiplexer is to register callbacks for receiving packets.
The callbacks are indexed based on the <a class="reference external" href="http://en.wikipedia.org/wiki/EtherType">EtherType</a> in the layer-2 frame.</p>
<p>Many different types of higher-layer protocols may be connected to the
NetDevice, such as IPv4, IPv6, ARP, MPLS, IEEE 802.1x, and packet sockets.
Therefore, the use of a callback-based demultiplexer avoids the need to use a
common base class for all of these protocols, which is problematic because of
the different types of objects (including packet sockets) expected to be
registered there.</p>
</section>
<span id="document-sockets-api"></span><section id="sockets-apis">
<span id="id1"></span><h3><span class="section-number">24.4. </span>Sockets APIs<a class="headerlink" href="#sockets-apis" title="Link to this heading">¶</a></h3>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Berkeley_sockets">sockets API</a>
is a long-standing API used by user-space applications to access
network services in the kernel.  A <em>socket</em> is an abstraction, like
a Unix file handle, that allows applications to connect to other
Internet hosts and exchange reliable byte streams and unreliable
datagrams, among other services.</p>
<p><em>ns-3</em> provides two types of sockets APIs, and it is important to
understand the differences between them.  The first is a <em>native</em>
<em>ns-3</em> API, while the second uses the services of the native API to
provide a <a class="reference external" href="http://en.wikipedia.org/wiki/POSIX">POSIX-like</a>
API as part of an overall application process.  Both APIs strive
to be close to the typical sockets API that application writers
on Unix systems are accustomed to, but the POSIX variant is much
closer to a real system’s sockets API.</p>
<section id="ns-3-sockets-api">
<h4><span class="section-number">24.4.1. </span>ns-3 sockets API<a class="headerlink" href="#ns-3-sockets-api" title="Link to this heading">¶</a></h4>
<p>The native sockets API for ns-3 provides an interface to various
types of transport protocols (TCP, UDP) as well as to packet sockets
and, in the future, Netlink-like sockets.  However, users are cautioned
to understand that the semantics are <em>not</em> the exact same as
one finds in a real system (for an API which is very much aligned
to real systems, see the next section).</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Socket</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">src/network/model/socket.h</span></code>.
Readers will note that many public member functions are aligned
with real sockets function calls, and all other things being equal,
we have tried to align with a Posix sockets API.  However, note that:</p>
<ul class="simple">
<li><p>ns-3 applications handle a smart pointer to a Socket object, not
a file descriptor;</p></li>
<li><p>there is no notion of synchronous API or a <em>blocking</em> API;
in fact, the model for interaction between application and socket is
one of asynchronous I/O, which is not typically found in real systems
(more on this below);</p></li>
<li><p>the C-style socket address structures are not used;</p></li>
<li><p>the API is not a complete sockets API, such as supporting
all socket options or all function variants;</p></li>
<li><p>many calls use <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Packet</span></code> class to transfer data
between application and socket.  This may seem peculiar to
pass <em>Packets</em> across a stream socket API, but think
of these packets as just fancy byte buffers at this level (more
on this also below).</p></li>
</ul>
<section id="basic-operation-and-calls">
<h5><span class="section-number">24.4.1.1. </span>Basic operation and calls<a class="headerlink" href="#basic-operation-and-calls" title="Link to this heading">¶</a></h5>
<figure class="align-default" id="id3">
<span id="sockets-overview"></span><img alt="_images/sockets-overview.png" src="_images/sockets-overview.png" />
<figcaption>
<p><span class="caption-text">Implementation overview of native sockets API</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="creating-sockets">
<h5><span class="section-number">24.4.1.2. </span>Creating sockets<a class="headerlink" href="#creating-sockets" title="Link to this heading">¶</a></h5>
<p>An application that wants to use sockets must first create one.
On real systems using a C-based API, this is accomplished by calling <code class="xref c c-func docutils literal notranslate"><span class="pre">socket()</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">socket</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">domain</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">protocol</span><span class="p">);</span>
</pre></div>
</div>
<p>which creates a socket in the system and returns an integer descriptor.</p>
<p>In ns-3, we have no equivalent of a system call at the lower layers,
so we adopt the following model.  There are certain <em>factory</em>
objects that can create sockets.  Each factory is capable of creating
one type of socket, and if sockets of a particular type are able to
be created on a given node, then a factory that can create such sockets
must be aggregated to the Node:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">TypeId</span><span class="w"> </span><span class="n">tid</span><span class="p">);</span>
</pre></div>
</div>
<p>Examples of TypeIds to pass to this method are <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::TcpSocketFactory</span></code>,
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::PacketSocketFactory</span></code>, and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::UdpSocketFactory</span></code>.</p>
<p>This method returns a smart pointer to a Socket object.  Here is an
example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">n0</span><span class="p">;</span>
<span class="c1">// Do some stuff to build up the Node&#39;s internet stack</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span><span class="w"> </span><span class="n">localSocket</span><span class="w"> </span><span class="o">=</span>
<span class="w">   </span><span class="n">Socket</span><span class="o">::</span><span class="n">CreateSocket</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">TcpSocketFactory</span><span class="o">::</span><span class="n">GetTypeId</span><span class="p">());</span>
</pre></div>
</div>
<p>In some ns-3 code, sockets will not be explicitly created by user’s
main programs, if an ns-3 application does it.  For instance, for
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::OnOffApplication</span></code>, the function <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::OnOffApplication::StartApplication()</span></code>
performs the socket creation, and the application holds the socket
pointer.</p>
</section>
<section id="using-sockets">
<h5><span class="section-number">24.4.1.3. </span>Using sockets<a class="headerlink" href="#using-sockets" title="Link to this heading">¶</a></h5>
<p>Below is a typical sequence of socket calls for a TCP client in a
real implementation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="w"> </span><span class="n">IPPROTO_TCP</span><span class="p">);</span>
<span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
</pre></div>
</div>
<p>There are analogs to all of these calls in ns-3, but we will focus on
two aspects here.  First, most usage of sockets in real systems
requires a way to manage I/O between the application and kernel.
These models include <em>blocking sockets</em>, <em>signal-based I/O</em>,
and <em>non-blocking sockets</em> with polling.  In ns-3, we make use
of the callback mechanisms to support a fourth mode, which is
analogous to POSIX <em>asynchronous I/O</em>.</p>
<p>In this model, on the sending side, if the <code class="xref c c-func docutils literal notranslate"><span class="pre">send()</span></code> call were to
fail because of insufficient buffers, the application suspends the
sending of more data until a function registered at the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::SetSendCallback()</span></code> callback is invoked.
An application can also ask the socket how much space is available
by calling <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::GetTxAvailable()</span></code>.  A typical sequence
of events for sending data (ignoring connection setup) might be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SetSendCallback</span><span class="p">(</span><span class="n">MakeCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">HandleSendCallback</span><span class="p">));</span>
<span class="n">Send</span><span class="p">();</span>
<span class="n">Send</span><span class="p">();</span>
<span class="p">...</span>
<span class="c1">// Send fails because buffer is full</span>
<span class="c1">// Wait until HandleSendCallback is called</span>
<span class="c1">// HandleSendCallback is called by socket, since space now available</span>
<span class="n">Send</span><span class="p">();</span><span class="w"> </span><span class="c1">// Start sending again</span>
</pre></div>
</div>
<p>Similarly, on the receive side, the socket user does not block on
a call to <code class="docutils literal notranslate"><span class="pre">recv()</span></code>.  Instead, the application sets a callback
with <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::SetRecvCallback()</span></code> in which the socket will notify the
application when (and how much) there is data to be read, and
the application then calls <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::Recv()</span></code> to read the data until
no more can be read.</p>
</section>
</section>
<section id="packet-vs-buffer-variants">
<h4><span class="section-number">24.4.2. </span>Packet vs. buffer variants<a class="headerlink" href="#packet-vs-buffer-variants" title="Link to this heading">¶</a></h4>
<p>There are two basic variants of <code class="docutils literal notranslate"><span class="pre">Send()</span></code> and <code class="docutils literal notranslate"><span class="pre">Recv()</span></code> supported:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Send</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Send</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Recv</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Recv</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>The non-Packet variants are provided for legacy API reasons.  When calling
the raw buffer variant of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::Send()</span></code>, the buffer is immediately
written into a Packet and the packet variant is invoked.</p>
<p>Users may find it semantically odd to pass a Packet to a stream socket
such as TCP.  However, do not let the name bother you; think of
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::Packet</span></code> to be a fancy byte buffer.  There are a few reasons why
the Packet variants are more likely to be preferred in ns-3:</p>
<ul class="simple">
<li><p>Users can use the Tags facility of packets to, for example, encode
a flow ID or other helper data at the application layer.</p></li>
<li><p>Users can exploit the copy-on-write implementation to avoid
memory copies (on the receive side, the conversion back to a
<code class="docutils literal notranslate"><span class="pre">uint8_t*</span> <span class="pre">buf</span></code> may sometimes incur an additional copy).</p></li>
<li><p>Use of Packet is more aligned with the rest of the ns-3 API</p></li>
</ul>
</section>
<section id="sending-dummy-data">
<h4><span class="section-number">24.4.3. </span>Sending dummy data<a class="headerlink" href="#sending-dummy-data" title="Link to this heading">¶</a></h4>
<p>Sometimes, users want the simulator to just pretend that there is an
actual data payload in the packet (e.g. to calculate transmission delay)
but do not want to actually produce or consume the data.  This is
straightforward to support in ns-3; have applications call
<code class="docutils literal notranslate"><span class="pre">Create&lt;Packet&gt;</span> <span class="pre">(size);</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Create&lt;Packet&gt;</span> <span class="pre">(buffer,</span> <span class="pre">size);</span></code>.
Similarly, passing in a zero to the pointer argument in the raw buffer
variants has the same effect.  Note that, if some subsequent code tries
to read the Packet data buffer, the fake buffer will be converted to
a real (zeroed) buffer on the spot, and the efficiency will be lost there.</p>
</section>
<section id="use-of-send-vs-sendto">
<span id="socket-options"></span><h4><span class="section-number">24.4.4. </span>Use of Send() vs. SendTo()<a class="headerlink" href="#use-of-send-vs-sendto" title="Link to this heading">¶</a></h4>
<p>There are two variants of methods used to send data to the socket:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Send</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">SendTo</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">Address</span><span class="w"> </span><span class="o">&amp;</span><span class="n">toAddress</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The first method is used if the socket has already been connected
(<code class="docutils literal notranslate"><span class="pre">Socket::Connect()</span></code>) to a peer address.  In the case of stream-based
sockets like TCP, the connect call is required to bind the socket to
a peer address, and thereafter, <code class="docutils literal notranslate"><span class="pre">Send()</span></code> is typically used.  In the case of
datagram-based sockets like UDP, the socket is not required to
be connected to a peer address before sending, and the socket may be used to
send data to different destination addresses; in this case, the
<code class="docutils literal notranslate"><span class="pre">SendTo()</span></code> method is used to specify the destination address for
the datagram.</p>
</section>
<section id="id2">
<h4><span class="section-number">24.4.5. </span>Socket options<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<section id="tos-type-of-service">
<span id="type-of-service"></span><h5><span class="section-number">24.4.5.1. </span>ToS (Type of Service)<a class="headerlink" href="#tos-type-of-service" title="Link to this heading">¶</a></h5>
<p>The native sockets API for ns-3 provides two public methods
(of the Socket base class):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">SetIpTos</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ipTos</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">GetIpTos</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>to set and get, respectively, the type of service associated with the socket.
These methods are equivalent to using the IP_TOS option of BSD sockets.
Clearly, setting the type of service only applies to sockets using the IPv4 protocol.
However, users typically do not set the type of service associated with a socket
through <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::SetIpTos()</span></code> because sockets are normally created
by application helpers and users cannot get a pointer to the sockets.
Instead, users can create an address of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::InetSocketAddress</span></code>
with the desired type of service value and pass it to the application helpers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">InetSocketAddress</span><span class="w"> </span><span class="nf">destAddress</span><span class="p">(</span><span class="n">ipv4Address</span><span class="p">,</span><span class="w"> </span><span class="n">udpPort</span><span class="p">);</span>
<span class="n">destAddress</span><span class="p">.</span><span class="n">SetTos</span><span class="p">(</span><span class="n">tos</span><span class="p">);</span>
<span class="n">OnOffHelper</span><span class="w"> </span><span class="n">onoff</span><span class="p">(</span><span class="s">&quot;ns3::UdpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">destAddress</span><span class="p">);</span>
</pre></div>
</div>
<p>For this to work, the application must eventually call the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::Connect()</span></code> method to connect to the provided
destAddress and the Connect method of the particular socket type must
support setting the type of service associated with a socket (by using
the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::SetIpTos()</span></code> method). Currently, the socket
types that support setting the type of service in such a way are
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::UdpSocketImpl</span></code> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::TcpSocketBase</span></code>.</p>
<p>The type of service associated with a socket is then used to determine the value
of the Type of Service field (renamed as Differentiated Services field by RFC
2474) of the IPv4 header of the packets sent through that socket, as detailed
in the next sections.</p>
<section id="setting-the-tos-with-udp-sockets">
<h6><span class="section-number">24.4.5.1.1. </span>Setting the ToS with UDP sockets<a class="headerlink" href="#setting-the-tos-with-udp-sockets" title="Link to this heading">¶</a></h6>
<p>For IPv4 packets, the ToS field is set according to the following rules:</p>
<ul class="simple">
<li><p>If the socket is connected, the ToS field is set to the ToS value associated
with the socket.</p></li>
<li><p>If the socket is not connected, the ToS field is set to the value specified
in the destination address (of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::InetSocketAddress</span></code>) passed
to <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::SendTo()</span></code>, and the ToS value associated with the
socket is ignored.</p></li>
</ul>
</section>
<section id="setting-the-tos-with-tcp-sockets">
<h6><span class="section-number">24.4.5.1.2. </span>Setting the ToS with TCP sockets<a class="headerlink" href="#setting-the-tos-with-tcp-sockets" title="Link to this heading">¶</a></h6>
<p>For IPv4 packets, the ToS field is set to the ToS value associated with the
socket.</p>
</section>
</section>
<section id="priority">
<h5><span class="section-number">24.4.5.2. </span>Priority<a class="headerlink" href="#priority" title="Link to this heading">¶</a></h5>
<p>The native sockets API for ns-3 provides two public methods
(of the Socket base class):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">SetPriority</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">priority</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">GetPriority</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>to set and get, respectively, the priority associated with the socket.
These methods are equivalent to using the SO_PRIORITY option of BSD sockets.
Only values in the range 0..6 can be set through the above method.</p>
<p>Note that setting the type of service associated with a socket (by calling
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::SetIpTos()</span></code>) also sets the priority for the socket
to the value that the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::IpTos2Priority()</span></code> function
returns when it is passed the type of service value. This function
is implemented after the Linux rt_tos2priority function, which takes
an 8-bit value as input and returns a value which is a function of bits 3-6
(where bit 0 is the most significant bit) of the input value:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Bits 3-6</p></th>
<th class="head"><p>Priority</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0 to 3</p></td>
<td><p>0 (Best Effort)</p></td>
</tr>
<tr class="row-odd"><td><p>4 to 7</p></td>
<td><p>2 (Bulk)</p></td>
</tr>
<tr class="row-even"><td><p>8 to 11</p></td>
<td><p>6 (Interactive)</p></td>
</tr>
<tr class="row-odd"><td><p>12 to 15</p></td>
<td><p>4 (Interactive Bulk)</p></td>
</tr>
</tbody>
</table>
<p>The rationale is that bits 3-6 of the Type of Service field were interpreted
as the TOS subfield by (the obsolete) RFC 1349. Readers can refer to the
doxygen documentation of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::IpTos2Priority()</span></code>
for more information, including how DSCP values map onto priority values.</p>
<p>The priority set for a socket (as described above) is then used to determine
the priority of the packets sent through that socket, as detailed in the next
sections. Currently, the socket types that support setting the packet priority
are <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::UdpSocketImpl</span></code>, <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::TcpSocketBase</span></code> and
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::PacketSocket</span></code>. The packet priority is used, e.g., by queuing
disciplines such as the default PfifoFastQueueDisc to classify packets into
distinct queues.</p>
<section id="setting-the-priority-with-udp-sockets">
<h6><span class="section-number">24.4.5.2.1. </span>Setting the priority with UDP sockets<a class="headerlink" href="#setting-the-priority-with-udp-sockets" title="Link to this heading">¶</a></h6>
<p>If the packet is an IPv4 packet and the value to be inserted in the ToS field
is not null, then the packet is assigned a priority based on such ToS value
(according to the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::Socket::IpTos2Priority()</span></code> function). Otherwise,
the priority associated with the socket is assigned to the packet.</p>
</section>
<section id="setting-the-priority-with-tcp-sockets">
<h6><span class="section-number">24.4.5.2.2. </span>Setting the priority with TCP sockets<a class="headerlink" href="#setting-the-priority-with-tcp-sockets" title="Link to this heading">¶</a></h6>
<p>Every packet is assigned a priority equal to the priority associated with the
socket.</p>
</section>
<section id="setting-the-priority-with-packet-sockets">
<h6><span class="section-number">24.4.5.2.3. </span>Setting the priority with packet sockets<a class="headerlink" href="#setting-the-priority-with-packet-sockets" title="Link to this heading">¶</a></h6>
<p>Every packet is assigned a priority equal to the priority associated with the
socket.</p>
</section>
</section>
</section>
<section id="socket-errno">
<h4><span class="section-number">24.4.6. </span>Socket errno<a class="headerlink" href="#socket-errno" title="Link to this heading">¶</a></h4>
<p><em>to be completed</em></p>
</section>
<section id="example-programs">
<h4><span class="section-number">24.4.7. </span>Example programs<a class="headerlink" href="#example-programs" title="Link to this heading">¶</a></h4>
<p><em>to be completed</em></p>
</section>
<section id="posix-like-sockets-api">
<h4><span class="section-number">24.4.8. </span>POSIX-like sockets API<a class="headerlink" href="#posix-like-sockets-api" title="Link to this heading">¶</a></h4>
</section>
</section>
<span id="document-simple"></span><section id="simple-netdevice">
<h3><span class="section-number">24.5. </span>Simple NetDevice<a class="headerlink" href="#simple-netdevice" title="Link to this heading">¶</a></h3>
<p><em>Placeholder chapter</em></p>
</section>
<span id="document-queue"></span><section id="queues">
<h3><span class="section-number">24.6. </span>Queues<a class="headerlink" href="#queues" title="Link to this heading">¶</a></h3>
<p>This section documents the queue object, which is typically used by NetDevices
and QueueDiscs to store packets.</p>
<p>Packets stored in a queue can be managed according to different policies.
Currently, only the DropTail policy is available.</p>
<section id="model-description">
<h4><span class="section-number">24.6.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the new module lives in the directory <code class="docutils literal notranslate"><span class="pre">src/network/utils</span></code>.</p>
<p>ns3::Queue has been redesigned as a template class object to allow us to
instantiate queues storing different types of items. The unique template
type parameter specifies the type of items stored in the queue.
The only requirement on the item type is that it must provide a GetSize ()
method which returns the size of the packet included in the item.
Currently, queue items can be objects of the following classes:</p>
<ul class="simple">
<li><p>Packet</p></li>
<li><p>QueueItem and subclasses (e.g., QueueDiscItem)</p></li>
<li><p>WifiMacQueueItem</p></li>
</ul>
<p>The internal queues of the queue discs are of type Queue&lt;QueueDiscItem&gt;
(an alias of which being InternalQueue). A number of network devices
(SimpleNetDevice, PointToPointNetDevice, CsmaNetDevice) use a Queue&lt;Packet&gt;
to store packets to be transmitted. WifiNetDevices use instead queues of
type WifiMacQueue, which is a subclass of Queue storing objects of
type WifiMacQueueItem. Other devices, such as WiMax and LTE, use specialized
queues.</p>
<section id="design">
<h5><span class="section-number">24.6.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>The Queue class derives from the QueueBase class, which is a non-template
class providing all the methods that are independent of the type of the items
stored in the queue. The Queue class provides instead all the operations that
depend on the item type, such as enqueue, dequeue, peek and remove. The Queue
class also provides the ability to trace certain queue operations such as
enqueuing, dequeuing, and dropping.</p>
<p>Queue is an abstract base class and is subclassed for specific scheduling and
drop policies. Subclasses need to define the following public methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">Enqueue</span> <span class="pre">(Ptr&lt;Item&gt;</span> <span class="pre">item)</span></code>:  Enqueue a packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ptr&lt;Item&gt;</span> <span class="pre">Dequeue</span> <span class="pre">()</span></code>:  Dequeue a packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ptr&lt;Item&gt;</span> <span class="pre">Remove</span> <span class="pre">()</span></code>:  Remove a packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">Item&gt;</span> <span class="pre">Peek</span> <span class="pre">()</span></code>:  Peek a packet</p></li>
</ul>
<p>The Enqueue method does not allow to store a packet if the queue capacity is exceeded.
Subclasses may also define specialized public methods. For instance, the
WifiMacQueue class provides a method to dequeue a packet based on its tid
and MAC address.</p>
<p>There are five trace sources that may be hooked:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Enqueue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dequeue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Drop</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DropBeforeEnqueue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DropAfterDequeue</span></code></p></li>
</ul>
<p>Also, the QueueBase class defines two additional trace sources:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PacketsInQueue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BytesInQueue</span></code></p></li>
</ul>
<section id="droptail">
<h6><span class="section-number">24.6.1.1.1. </span>DropTail<a class="headerlink" href="#droptail" title="Link to this heading">¶</a></h6>
<p>This is a basic first-in-first-out (FIFO) queue that performs a tail drop
when the queue is full.</p>
<p>The DropTailQueue class defines one attribute:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize</span></code>: the maximum queue size</p></li>
</ul>
</section>
</section>
</section>
<section id="usage">
<h4><span class="section-number">24.6.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<section id="helpers">
<h5><span class="section-number">24.6.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a device helper and to configure
the queue type and attributes from the helper, such as this example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PointToPointHelper</span><span class="w"> </span><span class="n">p2p</span><span class="p">;</span>

<span class="n">p2p</span><span class="p">.</span><span class="n">SetQueue</span><span class="p">(</span><span class="s">&quot;ns3::DropTailQueue&quot;</span><span class="p">);</span>
<span class="n">p2p</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;10Mbps&quot;</span><span class="p">));</span>
<span class="n">p2p</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;2ms&quot;</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devn0n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2p</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n0n2</span><span class="p">);</span>

<span class="n">p2p</span><span class="p">.</span><span class="n">SetQueue</span><span class="p">(</span><span class="s">&quot;ns3::DropTailQueue&quot;</span><span class="p">);</span>
<span class="n">p2p</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;10Mbps&quot;</span><span class="p">));</span>
<span class="n">p2p</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;3ms&quot;</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devn1n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2p</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n1n2</span><span class="p">);</span>

<span class="n">p2p</span><span class="p">.</span><span class="n">SetQueue</span><span class="p">(</span><span class="s">&quot;ns3::DropTailQueue&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot;MaxSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;50p&quot;</span><span class="p">));</span>
<span class="n">p2p</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="n">linkDataRate</span><span class="p">));</span>
<span class="n">p2p</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="n">linkDelay</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devn2n3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2p</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">n2n3</span><span class="p">);</span>
</pre></div>
</div>
<p>Please note that the SetQueue method of the PointToPointHelper class allows
to specify “ns3::DropTailQueue” instead of “ns3::DropTailQueue&lt;Packet&gt;”. The
same holds for CsmaHelper, SimpleNetDeviceHelper and TrafficControlHelper.</p>
</section>
<section id="output">
<h5><span class="section-number">24.6.2.2. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h5>
<p>The ns-3 ascii trace helpers used by many of the NetDevices will hook
the Enqueue, Dequeue, and Drop traces of these queues and print out
trace statements, such as the following from <code class="docutils literal notranslate"><span class="pre">examples/udp/udp-echo.cc</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+ 2 /NodeList/0/DeviceList/1/$ns3::CsmaNetDevice/TxQueue/Enqueue ns3::EthernetHeader
( length/type=0x806, source=00:00:00:00:00:01, destination=ff:ff:ff:ff:ff:ff)
ns3::ArpHeader (request source mac: 00-06-00:00:00:00:00:01 source ipv4: 10.1.1.1
dest ipv4: 10.1.1.2) Payload (size=18) ns3::EthernetTrailer (fcs=0)
- 2 /NodeList/0/DeviceList/1/$ns3::CsmaNetDevice/TxQueue/Dequeue ns3::EthernetHeader
( length/type=0x806, source=00:00:00:00:00:01, destination=ff:ff:ff:ff:ff:ff)
ns3::ArpHeader (request source mac: 00-06-00:00:00:00:00:01 source ipv4: 10.1.1.1
dest ipv4: 10.1.1.2) Payload (size=18) ns3::EthernetTrailer (fcs=0)
</pre></div>
</div>
<p>which shows an enqueue “+” and dequeue “-” event at time 2 seconds.</p>
<p>Users are, of course, free to define and hook their own trace sinks to
these trace sources.</p>
</section>
<section id="examples">
<h5><span class="section-number">24.6.2.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The drop-tail queue is used in several examples, such as
<code class="docutils literal notranslate"><span class="pre">examples/udp/udp-echo.cc</span></code>.</p>
</section>
</section>
</section>
<span id="document-queue-limits"></span><section id="queue-limits">
<h3><span class="section-number">24.7. </span>Queue limits<a class="headerlink" href="#queue-limits" title="Link to this heading">¶</a></h3>
<p>This section documents the queue limits model, which is used by the traffic control
to limit the NetDevices queueing delay. It operates on the transmission path of
the network node.</p>
<p>The reduction of the NetDevices queueing delay is essential to improve the effectiveness of
Active Queue Management (AQM) algorithms.
Careful assessment of the queueing delay includes a byte-based measure of the NetDevices
queue length. In this design, traffic control can use different byte-based schemes to
limit the queueing delay. Currently the only available scheme is DynamicQueueLimits, which is
modelled after the dynamic queue limit library of Linux.</p>
<section id="model-description">
<h4><span class="section-number">24.7.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the model lives in the directory <code class="docutils literal notranslate"><span class="pre">src/network/utils</span></code>.</p>
<p>The model allows a byte-based measure of the netdevice queue. The byte-based measure
more accurately approximates the time required to empty the queue than a packet-based measure.</p>
<p>To inform the upper layers about the transmission of packets, NetDevices can call a couple
of functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">NotifyQueuedBytes</span> <span class="pre">(uint32_t</span> <span class="pre">bytes)</span></code>: Report the number of bytes queued to the device queue</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">NotifyTransmittedBytes</span> <span class="pre">(uint32_t</span> <span class="pre">bytes)</span></code>: Report the number of bytes transmitted by device</p></li>
</ul>
<p>Based on this information, the QueueLimits object can stop the transmission queue.</p>
<p>In case of multiqueue NetDevices this mechanism is available for each queue.</p>
<p>The QueueLimits model can be used on any NetDevice modelled in ns-3.</p>
<section id="design">
<h5><span class="section-number">24.7.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>An abstract base class, class QueueLimits, is subclassed for specific
byte-based limiting strategies.</p>
<p>Common operations provided by the base class QueueLimits include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Reset</span> <span class="pre">()</span></code>:  Reset queue limits state</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Completed</span> <span class="pre">(uint32_t</span> <span class="pre">count)</span></code>:  Record the number of completed bytes and recalculate the limit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">Available</span> <span class="pre">()</span> <span class="pre">const</span></code>:  Return how many bytes can be queued</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Queued</span> <span class="pre">(uint32_t</span> <span class="pre">count)</span></code>:  Record number of bytes queued</p></li>
</ul>
<section id="dynamicqueuelimits">
<h6><span class="section-number">24.7.1.1.1. </span>DynamicQueueLimits<a class="headerlink" href="#dynamicqueuelimits" title="Link to this heading">¶</a></h6>
<p>Dynamic queue limits (DQL) is a basic library implemented in the Linux kernel to limit the Ethernet
queueing delay. DQL is a general purpose queue length controller. The goal of DQL is to calculate
the limit as the minimum number of bytes needed to prevent starvation.</p>
<p>Three attributes are defined in the DynamicQueueLimits class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HoldTime</span></code>: The DQL algorithm hold time</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxLimit</span></code>: Maximum limit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinLimit</span></code>: Minimum limit</p></li>
</ul>
<p>The DQL algorithm hold time is 1 s. Reducing the HoldTime increases the responsiveness of
DQL with consequent greater number of limit variation events. Conversely, increasing the HoldTime
decreases the responsiveness of DQL with a minor number of limit variation events.
The limit calculated by DQL is in the range from MinLimit to MaxLimit.
The default values are respectively 0 and DQL_MAX_LIMIT.
Increasing the MinLimit is recommended in case of higher NetDevice transmission rate (e.g. 1 Gbps)
while reducing the MaxLimit is recommended in case of lower NetDevice transmission rate (e.g. 500 Kbps).</p>
<p>There is one trace source in DynamicQueueLimits class that may be hooked:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Limit</span></code>: Limit value calculated by DQL</p></li>
</ul>
</section>
</section>
</section>
<section id="usage">
<h4><span class="section-number">24.7.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<section id="helpers">
<h5><span class="section-number">24.7.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a traffic control helper and configure
the queue limits type and attributes from the helper, such as this example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::PfifoFastQueueDisc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Limit&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>

<span class="n">tch</span><span class="p">.</span><span class="n">SetQueueLimits</span><span class="p">(</span><span class="s">&quot;ns3::DynamicQueueLimits&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;HoldTime&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;4ms&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>then install the configuration on a NetDevices container</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tch</span><span class="p">.</span><span class="n">Install</span><span class="w"> </span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
</section>
</div>
</section>
<span id="document-nix-vector-routing"></span><section id="nix-vector-routing-documentation">
<h2><span class="section-number">25. </span>Nix-Vector Routing Documentation<a class="headerlink" href="#nix-vector-routing-documentation" title="Link to this heading">¶</a></h2>
<p>Nix-vector routing is a simulation specific routing protocol and is
intended for large network topologies.  The on-demand nature of this
protocol as well as the low-memory footprint of the nix-vector provides
improved performance in terms of memory usage and simulation run time
when dealing with a large number of nodes.</p>
<section id="model-description">
<h3><span class="section-number">25.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the NixVectorRouting module lives in
the directory <code class="docutils literal notranslate"><span class="pre">src/nix-vector-routing</span></code>.</p>
<p><em>ns-3</em> nix-vector-routing performs on-demand route computation using
a breadth-first search and an efficient route-storage data structure
known as a nix-vector.</p>
<p>When a packet is generated at a node for transmission, the route is
calculated, and the nix-vector is built.</p>
<p><strong>How is the Nix-Vector calculated?</strong>
The nix-vector stores an index for each hop along the path, which
corresponds to the neighbor-index.  This index is used to determine
which net-device and gateway should be used.</p>
<p><strong>How does the routing take place?</strong>
To route a packet, the nix-vector must be transmitted with the packet.
At each hop, the current node extracts the appropriate neighbor-index
from the nix-vector and transmits the packet through the corresponding
net-device. This continues until the packet reaches the destination.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Nix-Vector routing does not use any routing metrics (interface metrics)
during the calculation of nix-vector. It is only based on the shortest
path calculated according to BFS.</p>
</div>
<p><strong>How does Nix decide between two equally short path from source to
destination?</strong>
It depends on how the topology is constructed i.e., the order in which the
net-devices are added on a node and net-devices added on the channels
associated with current node’s net-devices. Please check the <code class="docutils literal notranslate"><span class="pre">nix-simple.cc</span></code>
example below to understand how nix-vectors are calculated.</p>
<p><strong>How does Nix reacts to topology changes?</strong>
Routes in Nix are specific to a given network topology, and are cached by
the sender node. Nix monitors the following events: Interface up/down,
Route add/removal, Address add/removal to understand if the cached routes
are valid or if they have to be purged.</p>
<p>If the topology changes while the packet is “in flight”, the associated
NixVector is invalid, and have to be rebuilt by an intermediate node.
This is possible because the NixVecor carries an “Epoch”, i.e., a counter
indicating when the NixVector has been created. If the topology changes,
the Epoch is globally updated, and any outdated NixVector is rebuilt.</p>
<p><em>ns-3</em> supports IPv4 as well as IPv6 Nix-Vector routing.</p>
<section id="scope-and-limitations">
<h4><span class="section-number">25.1.1. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>Currently, the <em>ns-3</em> model of nix-vector routing supports IPv4 and IPv6
p2p links, CSMA links and multiple WiFi networks with the same channel object.
It does not (yet) provide support for efficient adaptation to link failures.
It simply flushes all nix-vector routing caches.</p>
<p>NixVectorRouting performs a subnet matching check, but it does <strong>not</strong> check
entirely if the addresses have been appropriately assigned. In other terms,
using Nix-Vector routing, it is possible to have a working network that
violates some good practices in IP address assignments.</p>
<p>In case of IPv6, Nix assumes the link-local addresses assigned are <strong>unique</strong>.
When using the IPv6 stack, the link-local address allocation is unique by
default over the entire topology. However, if the link-local addresses are
assigned manually, the user must ensure uniqueness of link-local addresses.</p>
<p>NixVectorRouting supports routes to IPv4 and IPv6 loopback addresses on localhost.
Although it is not really intended to route to these addresses, it can do so.</p>
</section>
</section>
<section id="usage">
<h3><span class="section-number">25.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The usage pattern is the one of all the Internet routing protocols.
Since NixVectorRouting is not installed by default in the
Internet stack, it is necessary to set it in the Internet Stack
helper by using <code class="docutils literal notranslate"><span class="pre">InternetStackHelper::SetRoutingHelper</span></code>.</p>
<p>Remember to include the header file <code class="docutils literal notranslate"><span class="pre">ns3/nix-vector-routing-module.h</span></code> to
use IPv4 or IPv6 Nix-Vector routing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The previous header files <code class="docutils literal notranslate"><span class="pre">ns3/ipv4-nix-vector-helper.h</span></code> and
<code class="docutils literal notranslate"><span class="pre">ns3/ipv4-nix-vector-routing.h</span></code> are deprecated and will be removed in
the future. These files are replaced with more generic (having IPv6
capabilities) <code class="docutils literal notranslate"><span class="pre">ns3/nix-vector-helper.h</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3/nix-vector-routing.h</span></code>
respectively.</p>
</div>
<ul class="simple">
<li><p>Using IPv4 Nix-Vector Routing:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv4NixVectorHelper</span><span class="w"> </span><span class="n">nixRouting</span><span class="p">;</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">stack</span><span class="p">;</span>
<span class="n">stack</span><span class="p">.</span><span class="n">SetRoutingHelper</span><span class="p">(</span><span class="n">nixRouting</span><span class="p">);</span><span class="w">  </span><span class="c1">// has effect on the next Install()</span>
<span class="n">stack</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">allNodes</span><span class="p">);</span><span class="w">             </span><span class="c1">// allNodes is the NodeContainer</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Using IPv6 Nix-Vector Routing:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ipv6NixVectorHelper</span><span class="w"> </span><span class="n">nixRouting</span><span class="p">;</span>
<span class="n">InternetStackHelper</span><span class="w"> </span><span class="n">stack</span><span class="p">;</span>
<span class="n">stack</span><span class="p">.</span><span class="n">SetRoutingHelper</span><span class="p">(</span><span class="n">nixRouting</span><span class="p">);</span><span class="w">  </span><span class="c1">// has effect on the next Install()</span>
<span class="n">stack</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">allNodes</span><span class="p">);</span><span class="w">             </span><span class="c1">// allNodes is the NodeContainer</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The NixVectorHelper helper class helps to use NixVectorRouting functionality.
The NixVectorRouting model class can also be used directly to use Nix-Vector routing.
<code class="docutils literal notranslate"><span class="pre">ns3/nix-vector-routing-module.h</span></code> contains the header files for both the classes.</p>
</div>
<section id="examples">
<h4><span class="section-number">25.2.1. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The examples for the NixVectorRouting module lives in
the directory <code class="docutils literal notranslate"><span class="pre">src/nix-vector-routing/examples</span></code>.</p>
<p>There are examples which use both IPv4 and IPv6 networking.</p>
<ol class="arabic simple">
<li><p>nix-simple.cc</p></li>
</ol>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> *    ________</span>
<span class="cm"> *   /        \</span>
<span class="cm"> * n0 -- n1 -- n2 -- n3</span>
<span class="cm"> *</span>
<span class="cm"> * n0 IP: 10.1.1.1, 10.1.4.1</span>
<span class="cm"> * n1 IP: 10.1.1.2, 10.1.2.1</span>
<span class="cm"> * n2 IP: 10.1.2.2, 10.1.3.1, 10.1.4.2</span>
<span class="cm"> * n3 IP: 10.1.3.2</span>
<span class="cm"> */</span>
</pre></div>
</div>
<p>In this topology, we install Nix-Vector routing between source
n0 and destination n3. The shortest possible route will be
n0 -&gt; n2 -&gt; n3.</p>
<p>Let’s see how the nix-vector will be generated for this path:</p>
<p>n0 has 2 neighbors i.e. n1 and n3. n0 is connected to both using
separate net-devices. But the net-device for n0 – n1 p2p link was
created before the netdevice for n0 – n2 p2p link. Thus, n2 has
neighbor-index of 1 (n1 has 0) with respect to n0.</p>
<p>n2 has 3 neighbors i.e. n1, n3 and n0. The n2 net-device for n1 – n2
p2p link was created before the n2 net-device for n2 – n3 p2p link
which was before the n2 netdevice for n0 – n2 p2p link. This, n3
has neighbor-index of 01 (n1 has 00 and n0 has 10) with respect to n2.</p>
<p>Thus, the nix-vector for the path from n0 to n3 is 101.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This neighbor-index or nix-index has total number of bits equal to
minimum number of bits required to represent all the neighbors in
their binary form.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are multiple netdevices connected to the current netdevice
on the channel then it depends on which order netdevices were added
to the channel.</p>
</div>
<ol class="loweralpha">
<li><p>Using IPv4:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># By default IPv4 network is selected</span>
./ns3<span class="w"> </span>run<span class="w"> </span>nix-simple
</pre></div>
</div>
</li>
<li><p>Using IPv6:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use the --useIPv6 flag</span>
./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;nix-simple --useIPv6&quot;</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>nms-p2p-nix.cc</p>
<p>This example demonstrates the advantage of Nix-Vector routing as Nix
performs source-based routing (BFS) to have faster routing.</p>
<img alt="NMS P2P Network Diagram" src="_images/nms.png" />
<ol class="loweralpha">
<li><p>Using IPv4:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># By default IPv4 network is selected</span>
./ns3<span class="w"> </span>run<span class="w"> </span>nms-p2p-nix
</pre></div>
</div>
</li>
<li><p>Using IPv6:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use the --useIPv6 flag</span>
./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;nms-p2p-nix --useIPv6&quot;</span>
</pre></div>
</div>
</li>
</ol>
</li>
<li><p>nix-simple-multi-address.cc</p></li>
</ol>
<blockquote>
<div><p>This is an IPv4 example demonstrating multiple interface addresses. This
example also shows how address assignment in between the simulation causes
the all the route caches and Nix caches to flush.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># By default IPv4 network is selected</span>
./ns3<span class="w"> </span>run<span class="w"> </span>nix-simple-multi-address
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>nix-double-wifi.cc</p></li>
</ol>
<blockquote>
<div><p>This example demonstrates the working of Nix with two Wifi networks
operating on the same Wifi channel object. The example uses <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code>
for both the wifi networks.</p>
<ol class="loweralpha">
<li><p>Using IPv4:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># By default IPv4 network is selected</span>
./ns3<span class="w"> </span>run<span class="w"> </span>nix-double-wifi
<span class="c1"># Use the --enableNixLog to enable NixVectorRouting logging.</span>
./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;nix-double-wifi --enableNixLog&quot;</span>
</pre></div>
</div>
</li>
<li><p>Using IPv6:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use the --useIPv6 flag</span>
./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;nix-double-wifi --useIPv6&quot;</span>
<span class="c1"># Use the --enableNixLog to enable NixVectorRouting logging.</span>
./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;nix-double-wifi --useIPv6 --enableNixLog&quot;</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</section>
</section>
</section>
<span id="document-olsr"></span><section id="optimized-link-state-routing-olsr">
<h2><span class="section-number">26. </span>Optimized Link State Routing (OLSR)<a class="headerlink" href="#optimized-link-state-routing-olsr" title="Link to this heading">¶</a></h2>
<p>This model implements the base specification of the Optimized
Link State Routing (OLSR) protocol, which is a dynamic mobile ad hoc
unicast routing protocol.  It has been developed at the
University of Murcia (Spain) by Francisco J. Ros for NS-2, and was
ported to NS-3 by Gustavo Carneiro at INESC Porto (Portugal).</p>
<p>The implementation is based on OLSR Version 1 (<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3626.html"><strong>RFC 3626</strong></a> <a class="reference internal" href="index.html#rfc3626" id="id1"><span>[rfc3626]</span></a>) and
it is <em>not</em> compliant with OLSR Version 2 (<span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7181.html"><strong>RFC 7181</strong></a> <a class="reference internal" href="index.html#rfc7181" id="id2"><span>[rfc7181]</span></a>) or any
of the Version 2 extensions.</p>
<section id="model-description">
<h3><span class="section-number">26.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the OLSR model lives in the directory <cite>src/olsr</cite>.
As stated before, the model is based on <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3626.html"><strong>RFC 3626</strong></a> (<a class="reference internal" href="index.html#rfc3626" id="id3"><span>[rfc3626]</span></a>). Moreover, many
design choices are based on the previous ns2 model.</p>
<section id="scope-and-limitations">
<h4><span class="section-number">26.1.1. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>The model is for IPv4 only.</p>
<ul class="simple">
<li><p>Mostly compliant with OLSR as documented in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3626.html"><strong>RFC 3626</strong></a> (<a class="reference internal" href="index.html#rfc3626" id="id4"><span>[rfc3626]</span></a>),</p></li>
<li><p>The use of multiple interfaces was not supported by the NS-2 version, but is supported in NS-3;</p></li>
<li><p>OLSR does not respond to the routing event notifications corresponding to dynamic interface up and down (<code class="docutils literal notranslate"><span class="pre">ns3::RoutingProtocol::NotifyInterfaceUp</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::RoutingProtocol::NotifyInterfaceDown</span></code>) or address insertion/removal <code class="docutils literal notranslate"><span class="pre">ns3::RoutingProtocol::NotifyAddAddress</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::RoutingProtocol::NotifyRemoveAddress</span></code>).</p></li>
<li><p>Unlike the NS-2 version, does not yet support MAC layer feedback as described in <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3626.html"><strong>RFC 3626</strong></a> (<a class="reference internal" href="index.html#rfc3626" id="id5"><span>[rfc3626]</span></a>);</p></li>
</ul>
<p>Host Network Association (HNA) is supported in this implementation
of OLSR. Refer to <code class="docutils literal notranslate"><span class="pre">examples/olsr-hna.cc</span></code> to see how the API
is used.</p>
</section>
<section id="references">
<h4><span class="section-number">26.1.2. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="rfc3626" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>rfc3626<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id4">3</a>,<a role="doc-backlink" href="#id5">4</a>)</span>
<p><span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3626.html"><strong>RFC 3626</strong></a> <em>Optimized Link State Routing</em></p>
</div>
<div class="citation" id="rfc7181" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">rfc7181</a><span class="fn-bracket">]</span></span>
<p><span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7181.html"><strong>RFC 7181</strong></a> <em>The Optimized Link State Routing Protocol Version 2</em></p>
</div>
</div>
</section>
</section>
<section id="usage">
<h3><span class="section-number">26.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The usage pattern is the one of all the Internet routing protocols.
Since OLSR is not installed by default in the Internet stack, it is necessary to
set it in the Internet Stack helper by using <code class="docutils literal notranslate"><span class="pre">InternetStackHelper::SetRoutingHelper</span></code></p>
<p>Typically, OLSR is enabled in a main program by use of an OlsrHelper class that
installs OLSR into an Ipv4ListRoutingProtocol object. The following sample
commands will enable OLSR in a simulation using this helper class along with
some other routing helper objects. The setting of priority value 10, ahead of
the staticRouting priority of 0, means that OLSR will be consulted for a route
before the node’s static routing table.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span> <span class="n">c</span><span class="p">:</span>
<span class="o">...</span>
<span class="o">//</span> <span class="n">Enable</span> <span class="n">OLSR</span>
<span class="n">NS_LOG_INFO</span><span class="p">(</span><span class="s2">&quot;Enabling OLSR Routing.&quot;</span><span class="p">);</span>
<span class="n">OlsrHelper</span> <span class="n">olsr</span><span class="p">;</span>

<span class="n">Ipv4StaticRoutingHelper</span> <span class="n">staticRouting</span><span class="p">;</span>

<span class="n">Ipv4ListRoutingHelper</span> <span class="nb">list</span><span class="p">;</span>
<span class="nb">list</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">staticRouting</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nb">list</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">olsr</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="n">InternetStackHelper</span> <span class="n">internet</span><span class="p">;</span>
<span class="n">internet</span><span class="o">.</span><span class="n">SetRoutingHelper</span><span class="p">(</span><span class="nb">list</span><span class="p">);</span>
<span class="n">internet</span><span class="o">.</span><span class="n">Install</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>Once installed,the OLSR “main interface” can be set with the SetMainInterface()
command. If the user does not specify a main address, the protocol will select
the first primary IP address that it finds, starting first the loopback
interface and then the next non-loopback interface found, in order of Ipv4
interface index. The loopback address of 127.0.0.1 is not selected. In addition,
a number of protocol constants are defined in olsr-routing-protocol.cc.</p>
<p>Olsr is started at time zero of the simulation, based on a call to
Object::Start() that eventually calls OlsrRoutingProtocol::DoStart(). Note:  a
patch to allow the user to start and stop the protocol at other times would be
welcome.</p>
<section id="examples">
<h4><span class="section-number">26.2.1. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The examples are in the <code class="docutils literal notranslate"><span class="pre">src/olsr/examples/</span></code> directory. However, many other examples exists in the
general examples directory, e.g., <code class="docutils literal notranslate"><span class="pre">examples/routing/manet-routing-compare.cc</span></code>.</p>
<p>For specific examples of the HNA feature, see the examples in <code class="docutils literal notranslate"><span class="pre">src/olsr/examples/</span></code>.</p>
</section>
<section id="helpers">
<h4><span class="section-number">26.2.2. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p>A helper class for OLSR has been written.  After an IPv4 topology
has been created and unique IP addresses assigned to each node, the
simulation script writer can call one of three overloaded functions
with different scope to enable OLSR: <code class="docutils literal notranslate"><span class="pre">ns3::OlsrHelper::Install</span>
<span class="pre">(NodeContainer</span> <span class="pre">container)</span></code>; <code class="docutils literal notranslate"><span class="pre">ns3::OlsrHelper::Install</span> <span class="pre">(Ptr&lt;Node&gt;</span>
<span class="pre">node)</span></code>; or <code class="docutils literal notranslate"><span class="pre">ns3::OlsrHelper::InstallAll</span> <span class="pre">()</span></code></p>
</section>
<section id="attributes">
<h4><span class="section-number">26.2.3. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<p>In addition, the behavior of OLSR can be modified by changing certain
attributes.  The method <code class="docutils literal notranslate"><span class="pre">ns3::OlsrHelper::Set</span> <span class="pre">()</span></code> can be used
to set OLSR attributes.  These include HelloInterval, TcInterval,
MidInterval, Willingness.  Other parameters are defined as macros
in <code class="docutils literal notranslate"><span class="pre">olsr-routing-protocol.cc</span></code>.</p>
<p>The list of configurabel attributes is:</p>
<ul class="simple">
<li><p>HelloInterval (time, default 2s), HELLO messages emission interval.</p></li>
<li><p>TcInterval (time, default 5s), TC messages emission interval.</p></li>
<li><p>MidInterval (time, default 5s), MID messages emission interval.</p></li>
<li><p>HnaInterval (time, default 5s), HNA messages emission interval.</p></li>
<li><p>Willingness (enum, default olsr::Willingness::DEFAULT), Willingness of a node to carry and forward traffic for other nodes.</p></li>
</ul>
</section>
<section id="tracing">
<h4><span class="section-number">26.2.4. </span>Tracing<a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h4>
<p>The available traces are:</p>
<ul class="simple">
<li><p>Rx: Receive OLSR packet.</p></li>
<li><p>Tx: Send OLSR packet.</p></li>
<li><p>RoutingTableChanged: The OLSR routing table has changed.</p></li>
</ul>
</section>
<section id="caveats">
<h4><span class="section-number">26.2.5. </span>Caveats<a class="headerlink" href="#caveats" title="Link to this heading">¶</a></h4>
<p>Presently, OLSR is limited to use with an Ipv4ListRouting object, and does not
respond to dynamic changes to a device’s IP address or link up/down
notifications; i.e. the topology changes are due to loss/gain of connectivity
over a wireless channel.</p>
<p>The code does not present any known issue.</p>
</section>
</section>
<section id="validation">
<h3><span class="section-number">26.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The code validationhas been done through Wireshark message compliance and unit testings.</p>
</section>
</section>
<span id="document-openflow-switch"></span><section id="openflow-switch-support">
<h2><span class="section-number">27. </span>OpenFlow switch support<a class="headerlink" href="#openflow-switch-support" title="Link to this heading">¶</a></h2>
<p>ns-3 simulations can use OpenFlow switches (McKeown et al. <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>),
widely used in research.  OpenFlow switches are configurable via the
OpenFlow API, and also have an MPLS extension for quality-of-service and
service-level-agreement support. By extending these capabilities to ns-3
for a simulated OpenFlow switch that is both configurable and can use
the MPLS extension, ns-3 simulations can accurately simulate many different
switches.</p>
<p>The OpenFlow software implementation distribution is hereby referred to as
the OFSID. This is a demonstration of running OpenFlow in software that
the OpenFlow research group has made available. There is also an OFSID
that Ericsson researchers created to add MPLS capabilities; this is the
OFSID currently used with ns-3. The design will allow the users to,
with minimal effort, switch in a different OFSID that may include more
efficient code than a previous OFSID.</p>
<section id="model-description">
<h3><span class="section-number">27.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The model relies on building an external OpenFlow switch library (OFSID),
and then building some ns-3 wrappers that call out to the library.
The source code for the ns-3 wrappers lives in the directory
<code class="docutils literal notranslate"><span class="pre">src/openflow/model</span></code>.</p>
<section id="design">
<h4><span class="section-number">27.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>The OpenFlow module presents a OpenFlowSwitchNetDevice and a OpenFlowSwitchHelper for
installing it on nodes. Like the Bridge module, it takes a collection of
NetDevices to set up as ports, and it acts as the intermediary between
them, receiving a packet on one port and forwarding it on another, or all
but the received port when flooding. Like an OpenFlow switch, it maintains
a configurable flow table that can match packets by their headers and do
different actions with the packet based on how it matches. The module’s
understanding of OpenFlow configuration messages are kept the same format
as a real OpenFlow-compatible switch, so users testing Controllers via
ns-3 won’t have to rewrite their Controller to work on real
OpenFlow-compatible switches.</p>
<p>The ns-3 OpenFlow switch device models an OpenFlow-enabled switch. It is designed to
express basic use of the OpenFlow protocol, with the maintaining of a virtual
Flow Table and TCAM to provide OpenFlow-like results.</p>
<p>The functionality comes down to the Controllers, which send messages to the
switch that configure its flows, producing different effects. Controllers can
be added by the user, under the ofi namespace extending ofi::Controller. To
demonstrate this, a DropController, which creates flows for ignoring every single
packet, and LearningController, which effectively makes the switch a more complicated
BridgeNetDevice. A user versed in a standard OFSID, and/or OF protocol, can write
virtual controllers to create switches of all kinds of types.</p>
<section id="openflow-switch-model">
<h5><span class="section-number">27.1.1.1. </span>OpenFlow switch Model<a class="headerlink" href="#openflow-switch-model" title="Link to this heading">¶</a></h5>
<p>The OpenFlow switch device behaves somewhat according to the diagram setup as a classical OFSID
switch, with a few modifications made for a proper simulation environment.</p>
<p>Normal OF-enabled Switch:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| Secure Channel                  | &lt;--OF Protocol--&gt; | Controller is external |
| Hardware or Software Flow Table |
</pre></div>
</div>
<p>ns-3 OF-enabled Switch (module):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| m_controller-&gt;ReceiveFromSwitch() | &lt;--OF Protocol--&gt; | Controller is internal |
| Software Flow Table, virtual TCAM |
</pre></div>
</div>
<p>In essence, there are two differences:</p>
<p>1) No SSL, Embedded Controller: Instead of a secure channel and connecting to an
outside location for the Controller program/machine, we currently only allow a
Controller extended from ofi::Controller, an extension of an ns3::Object. This
means ns-3 programmers cannot model the SSL part of the interface or possibility
of network failure. The connection to the OpenFlowSwitch is local and there aren’t any
reasons for the channel/connection to break down. &lt;&lt;This difference may be an
option in the future. Using EmuNetDevices, it should be possible to engage an
external Controller program/machine, and thus work with controllers designed
outside of the ns-3 environment, that simply use the proper OF protocol when
communicating messages to the switch through a tap device.&gt;&gt;</p>
<p>2) Virtual Flow Table, TCAM: Typical OF-enabled switches are implemented on a hardware
TCAM. The OFSID we turn into a library includes a modelled software TCAM, that produces
the same results as a hardware TCAM. We include an attribute FlowTableLookupDelay, which
allows a simple delay of using the TCAM to be modelled. We don’t endeavor to make this
delay more complicated, based on the tasks we are running on the TCAM, that is a possible
future improvement.</p>
<p>The OpenFlowSwitch network device is aimed to model an OpenFlow switch, with a TCAM and a connection
to a controller program. With some tweaking, it can model every switch type, per OpenFlow’s
extensibility. It outsources the complexity of the switch ports to NetDevices of the user’s choosing.
It should be noted that these NetDevices must behave like practical switch ports, i.e. a Mac Address
is assigned, and nothing more. It also must support a SendFrom function so that
the OpenFlowSwitch can forward across that port.</p>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">27.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>All MPLS capabilities are implemented on the OFSID side in the OpenFlowSwitchNetDevice,
but ns-3-mpls hasn’t been integrated, so ns-3 has no way to pass in
proper MPLS packets to the OpenFlowSwitch. If it did, one would only need to make
BufferFromPacket pick up the MplsLabelStack or whatever the MPLS header
is called on the Packet, and build the MPLS header into the ofpbuf.</p>
</section>
<section id="future-work">
<h4><span class="section-number">27.1.3. </span>Future Work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h4>
</section>
<section id="references">
<h4><span class="section-number">27.1.4. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>McKeown, N.; Anderson, T.; Balakrishan, H.; Parulkar, G.; Peterson, L.; Rexford, J.; Shenker, S.; Turner, J.; OpenFlow: enabling innovation in campus networks, ACM SIGCOMM Computer Communication Review, Vol. 38, Issue 2, April 2008.</p>
</aside>
</aside>
</section>
</section>
<section id="usage">
<h3><span class="section-number">27.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The OFSID requires libxml2 (for MPLS FIB xml file parsing), and libdl (for address fault checking).</p>
<section id="building-ofsid">
<h4><span class="section-number">27.2.1. </span>Building OFSID<a class="headerlink" href="#building-ofsid" title="Link to this heading">¶</a></h4>
<p>In order to use the OpenFlowSwitch module, you must create and link the
OFSID (OpenFlow Software Implementation Distribution) to ns-3.
To do this:</p>
<ol class="arabic">
<li><p>Obtain the OFSID code.
An ns-3 specific OFSID branch is provided to ensure
operation with ns-3. Use mercurial to download this branch and ns3 to build
the library:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>hg<span class="w"> </span>clone<span class="w"> </span>http://code.nsnam.org/openflow
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>openflow
</pre></div>
</div>
<p>From the “openflow” directory, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./waf<span class="w"> </span>configure
$<span class="w"> </span>./waf<span class="w"> </span>build
</pre></div>
</div>
</li>
<li><p>Your OFSID is now built into a libopenflow.a library!
To link to an ns-3 build with this OpenFlow switch module, run from the ns-3-dev
(or whatever you have named your distribution):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests<span class="w"> </span>--with-openflow<span class="o">=</span>path/to/openflow
</pre></div>
</div>
</li>
<li><p>Under <code class="docutils literal notranslate"><span class="pre">----</span> <span class="pre">Summary</span> <span class="pre">of</span> <span class="pre">optional</span> <span class="pre">NS-3</span> <span class="pre">features:</span></code> you should see:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&quot;NS-3 OpenFlow Integration     : enabled&quot;
</pre></div>
</div>
<p>indicating the library has been linked to ns-3. Run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>build
</pre></div>
</div>
</li>
</ol>
<p>to build ns-3 and activate the OpenFlowSwitch module in ns-3.</p>
</section>
<section id="examples">
<h4><span class="section-number">27.2.2. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>For an example demonstrating its use in a simple learning controller/switch,
run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>openflow-switch
</pre></div>
</div>
<p>To see it in detailed logging, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;openflow-switch -v&quot;</span>
</pre></div>
</div>
</section>
<section id="helpers">
<h4><span class="section-number">27.2.3. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
</section>
<section id="attributes">
<h4><span class="section-number">27.2.4. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<p>The SwitchNetDevice provides following Attributes:</p>
<ul class="simple">
<li><p>FlowTableLookUpDelay:      This time gets run off the clock when making a lookup in our Flow Table.</p></li>
<li><dl class="simple">
<dt>Flags:                     OpenFlow specific configuration flags. They are defined in the ofp_config_flags enum. Choices include:</dt><dd><p>OFPC_SEND_FLOW_EXP (Switch notifies controller when a flow has expired),
OFPC_FRAG_NORMAL (Match fragment against Flow table),
OFPC_FRAG_DROP (Drop fragments),
OFPC_FRAG_REASM (Reassemble only if OFPC_IP_REASM set, which is currently impossible,
because switch implementation does not support IP reassembly)
OFPC_FRAG_MASK (Mask Fragments)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>FlowTableMissSendLength:   When the packet doesn’t match in our Flow Table, and we forward to the controller,</dt><dd><p>this sets # of bytes forwarded (packet is not forwarded in its entirety, unless specified).</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
<section id="tracing">
<h4><span class="section-number">27.2.5. </span>Tracing<a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
<section id="logging">
<h4><span class="section-number">27.2.6. </span>Logging<a class="headerlink" href="#logging" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
<section id="caveats">
<h4><span class="section-number">27.2.7. </span>Caveats<a class="headerlink" href="#caveats" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
</section>
<section id="validation">
<h3><span class="section-number">27.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>This model has one test suite which can be run as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./test.py<span class="w"> </span>--suite<span class="o">=</span>openflow
</pre></div>
</div>
</section>
</section>
<span id="document-point-to-point"></span><section id="pointtopoint-netdevice">
<h2><span class="section-number">28. </span>PointToPoint NetDevice<a class="headerlink" href="#pointtopoint-netdevice" title="Link to this heading">¶</a></h2>
<p>This is the introduction to PointToPoint NetDevice chapter, to complement the
PointToPoint model doxygen.</p>
<section id="overview-of-the-pointtopoint-model">
<h3><span class="section-number">28.1. </span>Overview of the PointToPoint model<a class="headerlink" href="#overview-of-the-pointtopoint-model" title="Link to this heading">¶</a></h3>
<p>The <em>ns-3</em> point-to-point model is of a very simple point to point data link
connecting exactly two PointToPointNetDevice devices over an
PointToPointChannel. This can be viewed as equivalent to a full duplex RS-232 or
RS-422 link with null modem and no handshaking.</p>
<p>Data is encapsulated in the Point-to-Point Protocol (PPP – RFC 1661), however
the Link Control Protocol (LCP) and associated state machine is not implemented.
The PPP link is assumed to be established and authenticated at all times.</p>
<p>Data is not framed, therefore Address and Control fields will not be found.
Since the data is not framed, there is no need to provide Flag Sequence and
Control Escape octets, nor is a Frame Check Sequence appended. All that is
required to implement non-framed PPP is to prepend the PPP protocol number for
IP Version 4 which is the sixteen-bit number 0x21 (see
<a class="reference external" href="http://www.iana.org/assignments/ppp-numbers">http://www.iana.org/assignments/ppp-numbers</a>).</p>
<p>The PointToPointNetDevice provides following Attributes:</p>
<ul class="simple">
<li><p>Address:  The ns3::Mac48Address of the device (if desired);</p></li>
<li><p>DataRate:  The data rate (ns3::DataRate) of the device;</p></li>
<li><p>TxQueue:  The transmit queue (ns3::Queue) used by the device;</p></li>
<li><p>InterframeGap:  The optional ns3::Time to wait between “frames”;</p></li>
<li><p>Rx:  A trace source for received packets;</p></li>
<li><p>Drop:  A trace source for dropped packets.</p></li>
</ul>
<p>The PointToPointNetDevice models a transmitter section that puts bits on a
corresponding channel “wire.” The DataRate attribute specifies the number of
bits per second that the device will simulate sending over the channel. In
reality no bits are sent, but an event is scheduled for an elapsed time
consistent with the number of bits in each packet and the specified DataRate.
The implication here is that the receiving device models a receiver section that
can receive any any data rate. Therefore there is no need, nor way to set a
receive data rate in this model. By setting the DataRate on the transmitter of
both devices connected to a given PointToPointChannel one can model a symmetric
channel; or by setting different DataRates one can model an asymmetric channel
(e.g., ADSL).</p>
<p>The PointToPointNetDevice supports the assignment of a “receive error model.”
This is an ErrorModel object that is used to simulate data corruption on the
link.</p>
</section>
<section id="point-to-point-channel-model">
<h3><span class="section-number">28.2. </span>Point-to-Point Channel Model<a class="headerlink" href="#point-to-point-channel-model" title="Link to this heading">¶</a></h3>
<p>The point to point net devices are connected via an PointToPointChannel. This
channel models two wires transmitting bits at the data rate specified by the
source net device. There is no overhead beyond the eight bits per byte of the
packet sent. That is, we do not model Flag Sequences, Frame Check Sequences nor
do we “escape” any data.</p>
<p>The PointToPointChannel provides following Attributes:</p>
<ul class="simple">
<li><p>Delay:  An ns3::Time specifying the propagation delay for the channel.</p></li>
</ul>
</section>
<section id="using-the-pointtopointnetdevice">
<h3><span class="section-number">28.3. </span>Using the PointToPointNetDevice<a class="headerlink" href="#using-the-pointtopointnetdevice" title="Link to this heading">¶</a></h3>
<p>The PointToPoint net devices and channels are typically created and configured
using the associated <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> object. The various ns3 device
helpers generally work in a similar way, and their use is seen in many of our
example programs and is also covered in the <em>ns-3</em> tutorial.</p>
<p>The conceptual model of interest is that of a bare computer “husk” into which
you plug net devices. The bare computers are created using a <code class="docutils literal notranslate"><span class="pre">NodeContainer</span></code>
helper. You just ask this helper to create as many computers (we call them
<code class="docutils literal notranslate"><span class="pre">Nodes</span></code>) as you need on your network:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="n">nodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Once you have your nodes, you need to instantiate a <code class="docutils literal notranslate"><span class="pre">PointToPointHelper</span></code> and
set any attributes you may want to change. Note that since this is a
point-to-point(as compared to a point-to-multipoint) there may only be two
nodes with associated net devices connected by a PointToPointChannel.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PointToPointHelper</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">;</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetDeviceAttribute</span><span class="p">(</span><span class="s">&quot;DataRate&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;5Mbps&quot;</span><span class="p">));</span>
<span class="n">pointToPoint</span><span class="p">.</span><span class="n">SetChannelAttribute</span><span class="p">(</span><span class="s">&quot;Delay&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;2ms&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Once the attributes are set, all that remains is to create the devices and
install them on the required nodes, and to connect the devices together using a
PointToPoint channel. When we create the net devices, we add them to a container
to allow you to use them in the future. This all takes just one line of code.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pointToPoint</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="pointtopoint-tracing">
<h3><span class="section-number">28.4. </span>PointToPoint Tracing<a class="headerlink" href="#pointtopoint-tracing" title="Link to this heading">¶</a></h3>
<p>Like all <em>ns-3</em> devices, the Point-to-Point Model provides a number of trace
sources. These trace sources can be hooked using your own custom trace code, or
you can use our helper functions to arrange for tracing to be enabled on devices
you specify.</p>
<section id="upper-level-mac-hooks">
<h4><span class="section-number">28.4.1. </span>Upper-Level (MAC) Hooks<a class="headerlink" href="#upper-level-mac-hooks" title="Link to this heading">¶</a></h4>
<p>From the point of view of tracing in the net device, there are several
interesting points to insert trace hooks. A convention inherited from other
simulators is that packets destined for transmission onto attached networks pass
through a single “transmit queue” in the net device. We provide trace hooks at
this point in packet flow, which corresponds (abstractly) only to a transition
from the network to data link layer, and call them collectively
the device MAC hooks.</p>
<p>When a packet is sent to the Point-to-Point net device for transmission it
always passes through the transmit queue. The transmit queue in the
PointToPointNetDevice inherits from Queue, and therefore inherits three trace
sources:</p>
<ul class="simple">
<li><p>An Enqueue operation source (see ns3::Queue::m_traceEnqueue);</p></li>
<li><p>A Dequeue operation source (see ns3::Queue::m_traceDequeue);</p></li>
<li><p>A Drop operation source (see ns3::Queue::m_traceDrop).</p></li>
</ul>
<p>The upper-level (MAC) trace hooks for the PointToPointNetDevice are, in fact,
exactly these three trace sources on the single transmit queue of the device.</p>
<p>The m_traceEnqueue event is triggered when a packet is placed on the transmit
queue. This happens at the time that ns3::PointtoPointNetDevice::Send or
ns3::PointToPointNetDevice::SendFrom is called by a higher layer to queue a
packet for transmission. An Enqueue trace event firing should be interpreted
as only indicating that a higher level protocol has sent a packet to the device.</p>
<p>The m_traceDequeue event is triggered when a packet is removed from the transmit
queue. Dequeues from the transmit queue can happen in two situations:  1) If the
underlying channel is idle when PointToPointNetDevice::Send is called, a packet
is dequeued from the transmit queue and immediately transmitted;  2) a packet
may be dequeued and immediately transmitted in an internal TransmitCompleteEvent
that functions much  like a transmit complete interrupt service routine. An
Dequeue trace event firing may be viewed as indicating that the
PointToPointNetDevice has begun transmitting a packet.</p>
</section>
<section id="lower-level-phy-hooks">
<h4><span class="section-number">28.4.2. </span>Lower-Level (PHY) Hooks<a class="headerlink" href="#lower-level-phy-hooks" title="Link to this heading">¶</a></h4>
<p>Similar to the upper level trace hooks, there are trace hooks available at the
lower levels of the net device. We call these the PHY hooks. These events fire
from the device methods that talk directly to the
PointToPointChannel.</p>
<p>The trace source m_dropTrace is called to indicate a packet that is dropped by
the device. This happens when a packet is discarded as corrupt due to a receive
error model indication (see ns3::ErrorModel and the associated attribute
“ReceiveErrorModel”).</p>
<p>The other low-level trace source fires on reception of a packet (see
ns3::PointToPointNetDevice::m_rxTrace) from the PointToPointChannel.</p>
</section>
</section>
</section>
<span id="document-propagation"></span><section id="propagation">
<span id="id1"></span><h2><span class="section-number">29. </span>Propagation<a class="headerlink" href="#propagation" title="Link to this heading">¶</a></h2>
<p>The <em>ns-3</em> <code class="docutils literal notranslate"><span class="pre">propagation</span></code> module defines two generic interfaces, namely <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PropagationLossModel</span></code>
and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PropagationDelayModel</span></code>, to model respectively the propagation loss and the propagation delay.</p>
<section id="propagationlossmodel">
<h3><span class="section-number">29.1. </span>PropagationLossModel<a class="headerlink" href="#propagationlossmodel" title="Link to this heading">¶</a></h3>
<p>Propagation loss models calculate the Rx signal power considering the Tx signal power and the
mutual Rx and Tx antennas positions.</p>
<p>A propagation loss model can be “chained” to another one, making a list. The final Rx power
takes into account all the chained models. In this way one can use a slow fading and a fast
fading model (for example), or model separately different fading effects.</p>
<p>The following propagation loss models are implemented:</p>
<blockquote>
<div><ul>
<li><p>Cost231PropagationLossModel</p></li>
<li><p>FixedRssLossModel</p></li>
<li><p>FriisPropagationLossModel</p></li>
<li><p>ItuR1411LosPropagationLossModel</p></li>
<li><p>ItuR1411NlosOverRooftopPropagationLossModel</p></li>
<li><p>JakesPropagationLossModel</p></li>
<li><p>Kun2600MhzPropagationLossModel</p></li>
<li><p>LogDistancePropagationLossModel</p></li>
<li><p>MatrixPropagationLossModel</p></li>
<li><p>NakagamiPropagationLossModel</p></li>
<li><p>OkumuraHataPropagationLossModel</p></li>
<li><p>RandomPropagationLossModel</p></li>
<li><p>RangePropagationLossModel</p></li>
<li><p>ThreeLogDistancePropagationLossModel</p></li>
<li><p>TwoRayGroundPropagationLossModel</p></li>
<li><p>ThreeGppPropagationLossModel</p>
<blockquote>
<div><ul class="simple">
<li><p>ThreeGppRMaPropagationLossModel</p></li>
<li><p>ThreeGppUMaPropagationLossModel</p></li>
<li><p>ThreeGppUmiStreetCanyonPropagationLossModel</p></li>
<li><p>ThreeGppIndoorOfficePropagationLossModel</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Other models could be available thanks to other modules, e.g., the <code class="docutils literal notranslate"><span class="pre">building</span></code> module.</p>
<p>Each of the available propagation loss models of ns-3 is explained in
one of the following subsections.</p>
<section id="friispropagationlossmodel">
<h4><span class="section-number">29.1.1. </span>FriisPropagationLossModel<a class="headerlink" href="#friispropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model implements the Friis propagation loss model. This model was first described in <a class="reference internal" href="index.html#friis" id="id2"><span>[friis]</span></a>.
The original equation was described as:</p>
<div class="math">
<p><img src="_images/math/fbc4226bc425e836f850f3b25e38dbace3826763.png" alt="\frac{P_r}{P_t} = \frac{A_r A_t}{d^2\lambda^2}"/></p>
</div><p>with the following equation for the case of an isotropic antenna with no heat loss:</p>
<div class="math">
<p><img src="_images/math/2a612b44a6814d21cc6f5bf83fe6ed7732674df1.png" alt="A_{isotr.} = \frac{\lambda^2}{4\pi}"/></p>
</div><p>The final equation becomes:</p>
<div class="math">
<p><img src="_images/math/adbc24c08a6bc5e3db45c09355a2c3a4f18c944b.png" alt="\frac{P_r}{P_t} = \frac{\lambda^2}{(4 \pi d)^2}"/></p>
</div><p>Modern extensions to this original equation are:</p>
<div class="math">
<p><img src="_images/math/022350514daba1c5377447182c64b65348be88a5.png" alt="P_r = \frac{P_t G_t G_r \lambda^2}{(4 \pi d)^2 L}"/></p>
</div><p>With:</p>
<blockquote>
<div><p><img class="math" src="_images/math/68da83d6a46cf8fc80bfabec7cba2583311f75c4.png" alt="P_t"/> : transmission power (W)</p>
<p><img class="math" src="_images/math/fd94d5e83c2be0dff440249ed5d4a57e2bdf68f2.png" alt="P_r"/> : reception power (W)</p>
<p><img class="math" src="_images/math/8a082d410f630f6fecdcb5dfe4112e4b6f5ee977.png" alt="G_t"/> : transmission gain (unit-less)</p>
<p><img class="math" src="_images/math/7b98722260306da607db691cec74a88dbb49fa53.png" alt="G_r"/> : reception gain (unit-less)</p>
<p><img class="math" src="_images/math/cefc603e5658facb747581f9567192993f21c7ab.png" alt="\lambda"/> : wavelength (m)</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> : distance (m)</p>
<p><img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> : system loss (unit-less)</p>
</div></blockquote>
<p>In the implementation, <img class="math" src="_images/math/cefc603e5658facb747581f9567192993f21c7ab.png" alt="\lambda"/> is calculated as
<img class="math" src="_images/math/647a41234f2f8291578a6dd0b9e5d824bd6bf516.png" alt="\frac{C}{f}"/>, where <img class="math" src="_images/math/7286f156d58e4d7a28f47fa9b32654bd1bfc9be5.png" alt="C = 299792458"/> m/s is the speed of light in
vacuum, and <img class="math" src="_images/math/5b7752c757e0b691a80ab8227eadb8a8389dc58a.png" alt="f"/> is the frequency in Hz which can be configured by
the user via the Frequency attribute.</p>
<p>The Friis model is valid only for propagation in free space within
the so-called far field region, which can be considered
approximately as the region for <img class="math" src="_images/math/1450904df1ca67bafde0ccee516f9b566d957456.png" alt="d &gt; 3 \lambda"/>.
The model will still return a value for <img class="math" src="_images/math/2d7c9161fd8806f90bbf0bad96002efaf2368621.png" alt="d &lt; 3 \lambda"/>, as
doing so (rather than triggering a fatal error) is practical for
many simulation scenarios. However, we stress that the values
obtained in such conditions shall not be considered realistic.</p>
<p>Related with this issue, we note that the Friis formula is
undefined for <img class="math" src="_images/math/f04c6fee0832e3776baabbbe8cfa6af3211b01e8.png" alt="d = 0"/>, and results in
<img class="math" src="_images/math/b5234ea95e6b349ba2d0fe693c84ee5aebfa1c84.png" alt="P_r &gt; P_t"/> for <img class="math" src="_images/math/a3b895292a3ee2a88abf8d98b99057feb3051630.png" alt="d &lt; \lambda / 2 \sqrt{\pi}"/>.</p>
<p>Both these conditions occur outside of the far field region, so in
principle the Friis model shall not be used in these conditions.
In practice, however, Friis is often used in scenarios where accurate
propagation modeling is not deemed important, and values of
<img class="math" src="_images/math/f04c6fee0832e3776baabbbe8cfa6af3211b01e8.png" alt="d = 0"/> can occur.</p>
<p>To allow practical use of the model in such
scenarios, we have to 1) return some value for <img class="math" src="_images/math/f04c6fee0832e3776baabbbe8cfa6af3211b01e8.png" alt="d = 0"/>, and
2) avoid large discontinuities in propagation loss values (which
could lead to artifacts such as bogus capture effects which are
much worse than inaccurate propagation loss values). The two issues
are conflicting, as, according to the Friis formula,
<img class="math" src="_images/math/e4c64e892e998c003931f94322311417fdfa4a8f.png" alt="\lim_{d \to 0}  P_r = +\infty"/>;
so if, for <img class="math" src="_images/math/f04c6fee0832e3776baabbbe8cfa6af3211b01e8.png" alt="d = 0"/>, we use a fixed loss value, we end up with an infinitely large
discontinuity, which as we discussed can cause undesirable
simulation artifacts.</p>
<p>To avoid these artifact, this implementation of the Friis model
provides an attribute called MinLoss which allows to specify the
minimum total loss (in dB) returned by the model. This is used in
such a way that
<img class="math" src="_images/math/fd94d5e83c2be0dff440249ed5d4a57e2bdf68f2.png" alt="P_r"/> continuously increases for <img class="math" src="_images/math/68096e58ee16b2bb71c56760b2c3c89e5240b661.png" alt="d \to 0"/>, until
MinLoss is reached, and then stay constant; this allow to
return a value for <img class="math" src="_images/math/f04c6fee0832e3776baabbbe8cfa6af3211b01e8.png" alt="d = 0"/> and at the same time avoid
discontinuities. The model won’t be much realistic, but at least
the simulation artifacts discussed before are avoided. The default value of
MinLoss is 0 dB, which means that by default the model will return
<img class="math" src="_images/math/9cc0dd55d8e0ce01ea9bad7feaf7689d5a733fbb.png" alt="P_r = P_t"/> for <img class="math" src="_images/math/b22fd0266ec7a22f9b0384bc47fe742377cf2b99.png" alt="d &lt;= \lambda / 2 \sqrt{\pi}"/>.
We note that this value of <img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> is outside of the far field
region, hence the validity of the model in the far field region is
not affected.</p>
</section>
<section id="tworaygroundpropagationlossmodel">
<h4><span class="section-number">29.1.2. </span>TwoRayGroundPropagationLossModel<a class="headerlink" href="#tworaygroundpropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model implements a Two-Ray Ground propagation loss model ported from NS2</p>
<p>The Two-ray ground reflection model uses the formula</p>
<div class="math">
<p><img src="_images/math/daa27a7b6e63f0f13fd31ddb936d598dab41f217.png" alt="P_r = \frac{P_t * G_t * G_r * (H_t^2 * H_r^2)}{d^4 * L}"/></p>
</div><p>The original equation in Rappaport’s book assumes <img class="math" src="_images/math/9d1c166ff6b863b8c8c2aa3f80549c0198bf66df.png" alt="L = 1"/>.
To be consistent with the free space equation, <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> is added here.</p>
<p><img class="math" src="_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/> and <img class="math" src="_images/math/567480266a1375fbc0ab5bc53e431d65985013cb.png" alt="H_r"/> are set at the respective nodes <img class="math" src="_images/math/8d051150f8669295ecdbe92367941012175a824d.png" alt="z"/> coordinate plus a model parameter
set via SetHeightAboveZ.</p>
<p>The two-ray model does not give a good result for short distances, due to the
oscillation caused by constructive and destructive combination of the two
rays. Instead the Friis free-space model is used for small distances.</p>
<p>The crossover distance, below which Friis is used, is calculated as follows:</p>
<div class="math">
<p><img src="_images/math/9c92884c0a55196c6b0d1efa546770c93fb91c06.png" alt="dCross = \frac{(4 * \pi * H_t * H_r)}{\lambda}"/></p>
</div><p>In the implementation,  <img class="math" src="_images/math/cefc603e5658facb747581f9567192993f21c7ab.png" alt="\lambda"/> is calculated as
<img class="math" src="_images/math/647a41234f2f8291578a6dd0b9e5d824bd6bf516.png" alt="\frac{C}{f}"/>, where <img class="math" src="_images/math/7286f156d58e4d7a28f47fa9b32654bd1bfc9be5.png" alt="C = 299792458"/> m/s is the speed of light in
vacuum, and <img class="math" src="_images/math/5b7752c757e0b691a80ab8227eadb8a8389dc58a.png" alt="f"/> is the frequency in Hz which can be configured by
the user via the Frequency attribute.</p>
</section>
<section id="logdistancepropagationlossmodel">
<h4><span class="section-number">29.1.3. </span>LogDistancePropagationLossModel<a class="headerlink" href="#logdistancepropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model implements a log distance propagation model.</p>
<p>The reception power is calculated with a so-called
log-distance propagation model:</p>
<div class="math">
<p><img src="_images/math/fbb7f7d378659135a5bd138663d87d6b127376fb.png" alt="L = L_0 + 10 n \log(\frac{d}{d_0})"/></p>
</div><p>where:</p>
<blockquote>
<div><p><img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> : the path loss distance exponent</p>
<p><img class="math" src="_images/math/6d0e88412087bdab68765388e1135d5a211cca20.png" alt="d_0"/> : reference distance (m)</p>
<p><img class="math" src="_images/math/16b08cdd6d17b4bda841987181703838bccd5233.png" alt="L_0"/> : path loss at reference distance (dB)</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> :  - distance (m)</p>
<p><img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> : path loss (dB)</p>
</div></blockquote>
<p>When the path loss is requested at a distance smaller than
the reference distance, the tx power is returned.</p>
</section>
<section id="threelogdistancepropagationlossmodel">
<h4><span class="section-number">29.1.4. </span>ThreeLogDistancePropagationLossModel<a class="headerlink" href="#threelogdistancepropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model implements a log distance path loss propagation model with three distance
fields. This model is the same as ns3::LogDistancePropagationLossModel
except that it has three distance fields: near, middle and far with
different exponents.</p>
<p>Within each field the reception power is calculated using the log-distance
propagation equation:</p>
<div class="math">
<p><img src="_images/math/c75e8039e45e1081449995453d0c1af9b93badf0.png" alt="L = L_0 + 10 \cdot n_0 \log_{10}(\frac{d}{d_0})"/></p>
</div><p>Each field begins where the previous ends and all together form a continuous function.</p>
<p>There are three valid distance fields: near, middle, far. Actually four: the
first from 0 to the reference distance is invalid and returns txPowerDbm.</p>
<div class="math">
<p><img src="_images/math/a3104c5a49b3d756e35365f47c0fe8c37b4bd047.png" alt="\underbrace{0 \cdots\cdots}_{=0} \underbrace{d_0 \cdots\cdots}_{n_0} \underbrace{d_1 \cdots\cdots}_{n_1} \underbrace{d_2 \cdots\cdots}_{n_2} \infty"/></p>
</div><p>Complete formula for the path loss in dB:</p>
<div class="math">
<p><img src="_images/math/0dbc73d5ec5c59e0b87c65225f8002814cff7484.png" alt="\displaystyle L =
\begin{cases}
0 &amp; d &lt; d_0 \\
L_0 + 10 \cdot n_0 \log_{10}(\frac{d}{d_0}) &amp; d_0 \leq d &lt; d_1 \\
L_0 + 10 \cdot n_0 \log_{10}(\frac{d_1}{d_0}) + 10 \cdot n_1 \log_{10}(\frac{d}{d_1}) &amp; d_1 \leq d &lt; d_2 \\
L_0 + 10 \cdot n_0 \log_{10}(\frac{d_1}{d_0}) + 10 \cdot n_1 \log_{10}(\frac{d_2}{d_1}) + 10 \cdot n_2 \log_{10}(\frac{d}{d_2})&amp; d_2 \leq d
\end{cases}"/></p>
</div><p>where:</p>
<blockquote>
<div><p><img class="math" src="_images/math/aeb35985f5dc18dd7311bcf132e4ee1730ec4a0e.png" alt="d_0, d_1, d_2"/> : three distance fields (m)</p>
<p><img class="math" src="_images/math/a200dd598fb5546a3995f7089d91b87058ee4091.png" alt="n_0, n_1, n_2"/> : path loss distance exponent for each field (unitless)</p>
<p><img class="math" src="_images/math/16b08cdd6d17b4bda841987181703838bccd5233.png" alt="L_0"/> : path loss at reference distance (dB)</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> :  - distance (m)</p>
<p><img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> : path loss (dB)</p>
</div></blockquote>
<p>When the path loss is requested at a distance smaller than the reference
distance <img class="math" src="_images/math/6d0e88412087bdab68765388e1135d5a211cca20.png" alt="d_0"/>, the tx power (with no path loss) is returned. The
reference distance defaults to 1m and reference loss defaults to
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FriisPropagationLossModel</span></code> with 5.15 GHz and is thus <img class="math" src="_images/math/16b08cdd6d17b4bda841987181703838bccd5233.png" alt="L_0"/> = 46.67 dB.</p>
</section>
<section id="jakespropagationlossmodel">
<h4><span class="section-number">29.1.5. </span>JakesPropagationLossModel<a class="headerlink" href="#jakespropagationlossmodel" title="Link to this heading">¶</a></h4>
<section id="todo">
<h5><span class="section-number">29.1.5.1. </span>ToDo<a class="headerlink" href="#todo" title="Link to this heading">¶</a></h5>
</section>
</section>
<section id="randompropagationlossmodel">
<h4><span class="section-number">29.1.6. </span>RandomPropagationLossModel<a class="headerlink" href="#randompropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>The propagation loss is totally random, and it changes each time the model is called.
As a consequence, all the packets (even those between two fixed nodes) experience a random
propagation loss.</p>
</section>
<section id="nakagamipropagationlossmodel">
<h4><span class="section-number">29.1.7. </span>NakagamiPropagationLossModel<a class="headerlink" href="#nakagamipropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This propagation loss model implements the Nakagami-m fast fading
model, which accounts for the variations in signal strength due to multipath
fading. The model does not account for the path loss due to the
distance traveled by the signal, hence for typical simulation usage it
is recommended to consider using it in combination with other models
that take into account this aspect.</p>
<p>The Nakagami-m distribution is applied to the power level. The probability density function is defined as</p>
<div class="math">
<p><img src="_images/math/0df3e689a9e4b2049baa3aa17993cb8af82831ea.png" alt="p(x; m, \omega) = \frac{2 m^m}{\Gamma(m) \omega^m} x^{2m - 1} e^{-\frac{m}{\omega} x^2} )"/></p>
</div><p>with <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> the fading depth parameter and <img class="math" src="_images/math/16cb1e006199f0853a2dc67ea814446a38beb54e.png" alt="\omega"/> the average received power.</p>
<p>It is implemented by either a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">GammaRandomVariable</span></code> or a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ErlangRandomVariable</span></code>
random variable.</p>
<p>The implementation of the model allows to specify different values of
the <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> parameter (and hence different fast fading profiles)
for three different distance ranges:</p>
<div class="math">
<p><img src="_images/math/3b2d1eb89bee184bfacdae26c3c795da9a859e55.png" alt="\underbrace{0 \cdots\cdots}_{m_0} \underbrace{d_1 \cdots\cdots}_{m_1} \underbrace{d_2 \cdots\cdots}_{m_2} \infty"/></p>
</div><p>For <img class="math" src="_images/math/5b86129132ab70546e40931c75182dfb9883645a.png" alt="m = 1"/> the Nakagami-m distribution equals the Rayleigh distribution. Thus
this model also implements Rayleigh distribution based fast fading.</p>
</section>
<section id="fixedrsslossmodel">
<h4><span class="section-number">29.1.8. </span>FixedRssLossModel<a class="headerlink" href="#fixedrsslossmodel" title="Link to this heading">¶</a></h4>
<p>This model sets a constant received power level independent of the transmit power.</p>
<p>The received power is constant independent of the transmit power; the user
must set received power level.  Note that if this loss model is chained to other loss
models, it should be the first loss model in the chain.
Else it will disregard the losses computed by loss models that precede it in the chain.</p>
</section>
<section id="matrixpropagationlossmodel">
<h4><span class="section-number">29.1.9. </span>MatrixPropagationLossModel<a class="headerlink" href="#matrixpropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>The propagation loss is fixed for each pair of nodes and doesn’t depend on their actual positions.
This model should be useful for synthetic tests. Note that by default the propagation loss is
assumed to be symmetric.</p>
</section>
<section id="rangepropagationlossmodel">
<h4><span class="section-number">29.1.10. </span>RangePropagationLossModel<a class="headerlink" href="#rangepropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This propagation loss depends only on the distance (range) between transmitter and receiver.</p>
<p>The single MaxRange attribute (units of meters) determines path loss.
Receivers at or within MaxRange meters receive the transmission at the
transmit power level. Receivers beyond MaxRange receive at power
-1000 dBm (effectively zero).</p>
</section>
<section id="okumurahatapropagationlossmodel">
<h4><span class="section-number">29.1.11. </span>OkumuraHataPropagationLossModel<a class="headerlink" href="#okumurahatapropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model is used to model open area pathloss for long distance (i.e., &gt; 1 Km).
In order to include all the possible frequencies usable by LTE we need to consider
several variants of the well known Okumura Hata model. In fact, the original Okumura
Hata model <a class="reference internal" href="index.html#hata" id="id3"><span>[hata]</span></a> is designed for frequencies ranging from 150 MHz to 1500 MHz,
the COST231 <a class="reference internal" href="index.html#cost231" id="id4"><span>[cost231]</span></a> extends it for the frequency range from 1500 MHz to 2000 MHz.
Another important aspect is the scenarios considered by the models, in fact the all
models are originally designed for urban scenario and then only the standard one and
the COST231 are extended to suburban, while only the standard one has been extended
to open areas. Therefore, the model cannot cover all scenarios at all frequencies.
In the following we detail the models adopted.</p>
<p>The pathloss expression of the COST231 OH is:</p>
<div class="math">
<p><img src="_images/math/81fcfc4406dff970c2c27cabeb4533fa34e26b7e.png" alt="L = 46.3 + 33.9\log{f} - 13.82 \log{h_\mathrm{b}} + (44.9 - 6.55\log{h_\mathrm{b}})\log{d} - F(h_\mathrm{M}) + C"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/3dfa6dc8db3099dfda30077adcbb3543ee82821b.png" alt="F(h_\mathrm{M}) = \left\{\begin{array}{ll} (1.1\log(f))-0.7 \times h_\mathrm{M} - (1.56\times \log(f)-0.8) &amp; \mbox{for medium and small size cities} \\ 3.2\times (\log{(11.75\times h_\mathrm{M}}))^2 &amp; \mbox{for large cities}\end{array} \right."/></p>
</div><div class="math">
<p><img src="_images/math/d80e36d3a1d44d022af2adab233dfb1708654ca6.png" alt="C = \left\{\begin{array}{ll} 0dB &amp; \mbox{for medium-size cities and suburban areas} \\ 3dB &amp; \mbox{for large cities}\end{array} \right."/></p>
</div><p>and</p>
<blockquote>
<div><p><img class="math" src="_images/math/5b7752c757e0b691a80ab8227eadb8a8389dc58a.png" alt="f"/> : frequency [MHz]</p>
<p><img class="math" src="_images/math/452512870427a1bcb41aeadf1d3c1bc50f4ff87b.png" alt="h_\mathrm{b}"/> : eNB height above the ground [m]</p>
<p><img class="math" src="_images/math/0b7d21e3b474e6f8e0a67b0d4ddbc522606544a7.png" alt="h_\mathrm{M}"/> : UE height above the ground [m]</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> : distance [km]</p>
<p><img class="math" src="_images/math/24ddd164064af9e0bb342cfc31b5261a287f5e8d.png" alt="log"/> : is a logarithm in base 10 (this for the whole document)</p>
</div></blockquote>
<p>This model is only for urban scenarios.</p>
<p>The pathloss expression of the standard OH in urban area is:</p>
<div class="math">
<p><img src="_images/math/02d132c6d999dc49c02989a88ba2ccdedcb5544f.png" alt="L = 69.55 + 26.16\log{f} - 13.82 \log{h_\mathrm{b}} + (44.9 - 6.55\log{h_\mathrm{b}})\log{d} - C_\mathrm{H}"/></p>
</div><p>where for small or medium sized city</p>
<div class="math">
<p><img src="_images/math/8899dbdaed43985e2eaef7a469860eba7fdc37dd.png" alt="C_\mathrm{H} = 0.8 + (1.1\log{f} - 0.7)h_\mathrm{M} -1.56\log{f}"/></p>
</div><p>and for large cities</p>
<div class="math">
<p><img src="_images/math/9cff5ef56a7b6057b023757c1c1df26aea3f9dc3.png" alt="C_\mathrm{H} = \left\{\begin{array}{ll} 8.29 (\log{(1.54h_M)})^2 -1.1 &amp; \mbox{if } 150\leq f\leq 200 \\ 3.2(\log{(11.75h_M)})^2 -4.97 &amp; \mbox{if } 200&lt;f\leq 1500\end{array} \right."/></p>
</div><p>There extension for the standard OH in suburban is</p>
<div class="math">
<p><img src="_images/math/ea79b920e386bddc0d193cc0512e56afa6a4f716.png" alt="L_\mathrm{SU} = L_\mathrm{U} - 2 \left(\log{\frac{f}{28}}\right)^2 - 5.4"/></p>
</div><p>where</p>
<blockquote>
<div><p><img class="math" src="_images/math/8d1faeed262e70774c09ea1ce2c8368010e6ab6c.png" alt="L_\mathrm{U}"/> : pathloss in urban areas</p>
</div></blockquote>
<p>The extension for the standard OH in open area is</p>
<div class="math">
<p><img src="_images/math/3c69cf393d8ad132a0ca1c6ac6ffe131bad1bf70.png" alt="L_\mathrm{O} = L_\mathrm{U} - 4.70 (\log{f})^2 + 18.33\log{f} - 40.94"/></p>
</div><p>The literature lacks of extensions of the COST231 to open area (for suburban it seems that
we can just impose C = 0); therefore we consider it a special case fo the suburban one.</p>
</section>
<section id="cost231propagationlossmodel">
<h4><span class="section-number">29.1.12. </span>Cost231PropagationLossModel<a class="headerlink" href="#cost231propagationlossmodel" title="Link to this heading">¶</a></h4>
<section id="id5">
<h5><span class="section-number">29.1.12.1. </span>ToDo<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h5>
</section>
</section>
<section id="itur1411lospropagationlossmodel">
<h4><span class="section-number">29.1.13. </span>ItuR1411LosPropagationLossModel<a class="headerlink" href="#itur1411lospropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model is designed for Line-of-Sight (LoS) short range outdoor communication in the
frequency range 300 MHz to 100 GHz.  This model provides an upper and lower bound
respectively according to the following formulas</p>
<div class="math">
<p><img src="_images/math/450fc08f0aa5344d5cc6f955d4af79feb9aa2d28.png" alt="L_\mathrm{LoS,l} = L_\mathrm{bp} + \left\{\begin{array}{ll} 20\log{\frac{d}{R_\mathrm{bp}}} &amp; \mbox{for $d \le R_\mathrm{bp}$} \\ 40\log{\frac{d}{R_\mathrm{bp}}} &amp; \mbox{for $d &gt; R_\mathrm{bp}$}\end{array} \right."/></p>
</div><div class="math">
<p><img src="_images/math/541c4bffa2c471101b4f565930bd4b4f0749e04f.png" alt="L_\mathrm{LoS,u} = L_\mathrm{bp} + 20 + \left\{\begin{array}{ll} 25\log{\frac{d}{R_\mathrm{bp}}} &amp; \mbox{for $d \le R_\mathrm{bp}$} \\ 40\log{\frac{d}{R_\mathrm{bp}}} &amp; \mbox{for $d &gt; R_\mathrm{bp}$}\end{array} \right."/></p>
</div><p>where the breakpoint distance is given by</p>
<div class="math">
<p><img src="_images/math/4f0d80065a99cd6529991d11137626bfdf466758.png" alt="R_\mathrm{bp} \approx \frac{4h_\mathrm{b}h_\mathrm{m}}{\lambda}"/></p>
</div><p>and the above parameters are</p>
<blockquote>
<div><p><img class="math" src="_images/math/cefc603e5658facb747581f9567192993f21c7ab.png" alt="\lambda"/> : wavelength [m]</p>
<p><img class="math" src="_images/math/452512870427a1bcb41aeadf1d3c1bc50f4ff87b.png" alt="h_\mathrm{b}"/> : eNB height above the ground [m]</p>
<p><img class="math" src="_images/math/757b579fe46fa4cbcd2fe057df24350b0ba55e20.png" alt="h_\mathrm{m}"/> : UE height above the ground [m]</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> : distance [m]</p>
</div></blockquote>
<p>and <img class="math" src="_images/math/d9396f4420efc504919885151b1a84abc2b49c71.png" alt="L_{bp}"/> is the value for the basic transmission loss at the break point, defined as:</p>
<div class="math">
<p><img src="_images/math/43d5ca95bbf1f8c981f57ed0de7f63ed939d85b7.png" alt="L_{bp} = \left|20\log \left(\frac{\lambda^2}{8\pi h_\mathrm{b}h\mathrm{m}}\right)\right|"/></p>
</div><p>The value used by the simulator is the average one for modeling the median pathloss.</p>
</section>
<section id="itur1411nlosoverrooftoppropagationlossmodel">
<h4><span class="section-number">29.1.14. </span>ItuR1411NlosOverRooftopPropagationLossModel<a class="headerlink" href="#itur1411nlosoverrooftoppropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This model is designed for Non-Line-of-Sight (LoS) short range outdoor communication over
rooftops in the frequency range 300 MHz to 100 GHz. This model includes several scenario-dependent
parameters, such as average street width, orientation, etc. It is advised to set the values of
these parameters manually (using the ns-3 attribute system) according to the desired scenario.</p>
<p>In detail, the model is based on <a class="reference internal" href="index.html#walfisch" id="id6"><span>[walfisch]</span></a> and <a class="reference internal" href="index.html#ikegami" id="id7"><span>[ikegami]</span></a>, where the loss is expressed
as the sum of free-space loss (<img class="math" src="_images/math/b1140e37b1362a10469ad7cd6c3b8e51fd5d7eb2.png" alt="L_{bf}"/>), the diffraction loss from rooftop to
street (<img class="math" src="_images/math/8ba505a026beb64c7889e929be2ed2581b60b695.png" alt="L_{rts}"/>) and the reduction due to multiple screen diffraction past
rows of building (<img class="math" src="_images/math/48983b8800101d98f0e5242c4ad4064fa87d1037.png" alt="L_{msd}"/>). The formula is:</p>
<div class="math">
<p><img src="_images/math/f36ad9fb6f44a511391eff1e87ab2fa3bb48a50c.png" alt="L_{NLOS1} = \left\{ \begin{array}{ll} L_{bf} + L_{rts} + L_{msd} &amp; \mbox{for } L_{rts} + L_{msd} &gt; 0 \\ L_{bf} &amp; \mbox{for } L_{rts} + L_{msd} \le 0\end{array}\right."/></p>
</div><p>The free-space loss is given by:</p>
<div class="math">
<p><img src="_images/math/5efaef2cf62ad82085a7e232b059a10350c569c2.png" alt="L_{bf} = 32.4 + 20 \log {(d/1000)} + 20\log{(f)}"/></p>
</div><p>where:</p>
<blockquote>
<div><p><img class="math" src="_images/math/5b7752c757e0b691a80ab8227eadb8a8389dc58a.png" alt="f"/> : frequency [MHz]</p>
<p><img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> : distance (where <img class="math" src="_images/math/db10afad5935d7bfdaef771f520a88131811e1bb.png" alt="d &gt; 1"/>) [m]</p>
</div></blockquote>
<p>The term <img class="math" src="_images/math/8ba505a026beb64c7889e929be2ed2581b60b695.png" alt="L_{rts}"/> takes into account the width of the street and its orientation, according to the formulas</p>
<div class="math">
<p><img src="_images/math/63af411f54a0ec44e9d7453ec828ed53e1b480ed.png" alt="L_{rts} = -8.2 - 10\log {(w)} + 10\log{(f)} + 20\log{(\Delta h_m)} + L_{ori}

L_{ori} = \left\{ \begin{array}{lll} -10 + 0.354\varphi &amp; \mbox{for } 0^{\circ} \le \varphi &lt; 35^{\circ} \\ 2.5 + 0.075(\varphi-35) &amp; \mbox{for } 35^{\circ} \le \varphi &lt; 55^{\circ} \\ 4.0 -0.114(\varphi-55) &amp; \mbox{for } 55^{\circ} \varphi \le 90^{\circ}\end{array}\right.

\Delta h_m = h_r - h_m"/></p>
</div><p>where:</p>
<blockquote>
<div><p><img class="math" src="_images/math/351739a91d32535c9d224623b329c047bbdf75e0.png" alt="h_r"/> : is the height of the rooftop [m]</p>
<p><img class="math" src="_images/math/129bbac4b57be09af5e7121eb1a35050e2099e60.png" alt="h_m"/> : is the height of the mobile [m]</p>
<p><img class="math" src="_images/math/ed710ddac707fcbc540bfe7b354ca2d900f0faa0.png" alt="\varphi"/> : is the street orientation with respect to the direct path (degrees)</p>
</div></blockquote>
<p>The multiple screen diffraction loss depends on the BS antenna height relative to the building
height and on the incidence angle. The former is selected as the higher antenna in the communication
link. Regarding the latter, the “settled field distance” is used for select the proper model;
its value is given by</p>
<div class="math">
<p><img src="_images/math/cda129fc0243f3cce479093b6faa30f9054ba51b.png" alt="d_{s} = \frac{\lambda d^2}{\Delta h_{b}^2}"/></p>
</div><p>with</p>
<blockquote>
<div><p><img class="math" src="_images/math/a86a2637e43972119c8de24b57f66060c7e55447.png" alt="\Delta h_b = h_b - h_m"/></p>
</div></blockquote>
<p>Therefore, in case of <img class="math" src="_images/math/7408c7e5edf20dec3df40940829cc730a866f060.png" alt="l &gt; d_s"/> (where <cite>l</cite> is the distance over which the building extend),
it can be evaluated according to</p>
<div class="math">
<p><img src="_images/math/07bf8b989fed91036910696855866025548035f4.png" alt="L_{msd} = L_{bsh} + k_{a} + k_{d}\log{(d/1000)} + k_{f}\log{(f)} - 9\log{(b)}

L_{bsh} = \left\{ \begin{array}{ll} -18\log{(1+\Delta h_{b})} &amp; \mbox{for } h_{b} &gt; h_{r} \\ 0 &amp; \mbox{for } h_{b} \le h_{hr} \end{array}\right.

k_a = \left\{ \begin{array}{lll}
    71.4 &amp; \mbox{for } h_{b} &gt; h_{r} \mbox{ and } f&gt;2000 \mbox{ MHz} \\
    54 &amp; \mbox{for } h_{b} &gt; h_{r} \mbox{ and } f\le2000 \mbox{ MHz} \\
    54-0.8\Delta h_b &amp; \mbox{for } h_{b} \le h_{r} \mbox{ and } d \ge 500 \mbox{ m} \\
    54-1.6\Delta h_b &amp; \mbox{for } h_{b} \le h_{r} \mbox{ and } d &lt; 500 \mbox{ m} \\
    \end{array} \right.

k_d = \left\{ \begin{array}{ll}
      18 &amp; \mbox{for } h_{b} &gt; h_{r} \\
      18 -15\frac{\Delta h_b}{h_r} &amp; \mbox{for } h_{b} \le h_{r}
      \end{array} \right.

k_f = \left\{ \begin{array}{ll}
      -8 &amp; \mbox{for } f&gt;2000 \mbox{ MHz} \\
      -4 + 0.7(f/925 -1) &amp; \mbox{for medium city and suburban centres and} f\le2000 \mbox{ MHz} \\
      -4 + 1.5(f/925 -1) &amp; \mbox{for metropolitan centres and } f\le2000 \mbox{ MHz}
      \end{array}\right."/></p>
</div><p>Alternatively, in case of <img class="math" src="_images/math/e1647efecacdc645f19e9836d9e477eae77e7f4f.png" alt="l &lt; d_s"/>, the formula is:</p>
<div class="math">
<p><img src="_images/math/3ef9821390c9aa8cbf4dc7ec2d8ee59b11d4ddb7.png" alt="L_{msd} = -10\log{\left(Q_M^2\right)}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/e9d6386cf5451f8e0e27ed341ae43f4947c2855e.png" alt="Q_M = \left\{ \begin{array}{lll}
      2.35\left(\frac{\Delta h_b}{d}\sqrt{\frac{b}{\lambda}}\right)^{0.9} &amp; \mbox{for } h_{b} &gt; h_{r} \\
      \frac{b}{d} &amp;  \mbox{for } h_{b} \approx h_{r} \\
      \frac{b}{2\pi d}\sqrt{\frac{\lambda}{\rho}}\left(\frac{1}{\theta}-\frac{1}{2\pi + \theta}\right) &amp; \mbox{for }  h_{b} &lt; h_{r}
      \end{array}\right."/></p>
</div><p>where:</p>
<div class="math">
<p><img src="_images/math/b10e3a7ad49d1df26ba211bbc32c990b5c298d7e.png" alt="\theta = arc tan \left(\frac{\Delta h_b}{b}\right)

\rho = \sqrt{\Delta h_b^2 + b^2}"/></p>
</div></section>
<section id="kun2600mhzpropagationlossmodel">
<h4><span class="section-number">29.1.15. </span>Kun2600MhzPropagationLossModel<a class="headerlink" href="#kun2600mhzpropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>This is the empirical model for the pathloss at 2600 MHz for urban areas which is described in <a class="reference internal" href="index.html#kun2600mhz" id="id8"><span>[kun2600mhz]</span></a>.
The model is as follows. Let <img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.png" alt="d"/> be the distance between the transmitter and the receiver
in meters; the pathloss <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> in dB is calculated as:</p>
<div class="math">
<p><img src="_images/math/343403ec8ac169b49f7544d9ce5f314d8776c213.png" alt="L = 36 + 26\log{d}"/></p>
</div></section>
<section id="threegpppropagationlossmodel">
<h4><span class="section-number">29.1.16. </span>ThreeGppPropagationLossModel<a class="headerlink" href="#threegpppropagationlossmodel" title="Link to this heading">¶</a></h4>
<p>The base class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code> and its derived classes implement
the path loss and shadow fading models described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>.
3GPP TR 38.901 includes multiple scenarios modeling different propagation
environments, i.e., indoor, outdoor urban and rural, for frequencies between
0.5 and 100 GHz.</p>
<p><em>Implemented features:</em></p>
<blockquote>
<div><ul class="simple">
<li><p>Path loss and shadowing models (3GPP TR 38.901, Sec. 7.4.1)</p></li>
<li><p>Autocorrelation of shadow fading (3GPP TR 38.901, Sec. 7.4.4)</p></li>
<li><p><a class="reference external" href="propagation.html#threegppchannelconditionmodel">Channel condition models</a> (3GPP TR 38.901, Sec. 7.4.2)</p></li>
<li><p>O2I Low/High Building penetration losses (3GPP TR 38.901, Sec. 7.4.3.1).
The Low/High Building penetration losses can be enabled for UEs that are in
O2I channel condition state.
For determining the O2O/O2I state in ns-3 there are two possible scenario setups:
1) ns-3 buildings and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BuildingsChannelConditionModel</span></code> are used.
Then the O2I condition is calculated based on the buildings in the scenario.
In this case losses are considered by default, however there is the option
to disable them by setting the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code>
attribute BuildingPenetrationLossesEnabled to false.
2) ns-3 buildings are not used, instead one of the 3GPP stochastic channel condition
models is used, such as: <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppRmaChannelConditionModel</span></code>,
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppUmaChannelConditionModel</span></code>, <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppUmiStreetCanyonChannelConditionModel</span></code>.
These models are extended to calculate the O2O/O2I state probabilistically.
Additionally, it is possible to configure to calculate O2I condition
deterministically based on the UE height. In both cases, the O2O/O2I is updated
at the same time as LOS/nLOS, i.e. with the same periodicity.
For other 3GPP channel condition models in ns-3 there are no O2I losses because
both TX and RX, are either indoor or outdoor, such as in the case of indoor or
V2V scenarios.
For this case, to consider O2I Low/High Losses, the attribute of the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelCondition</span></code> O2iThreshold (that indicates the ratio between
O2O and O2I states) must be set to a value different from 0. Possible values
are from 0 to 1, with 1 corresponding to 100% O2I conditions.</p></li>
</ul>
</div></blockquote>
<p><em>To be implemented:</em></p>
<blockquote>
<div><ul class="simple">
<li><p>O2I Car penetration losses (3GPP TR 38.901, Sec. 7.4.3.2).</p></li>
<li><p>Spatial consistent update of the channel states (3GPP TR 38.901 Sec. 7.6.3.3)</p></li>
</ul>
</div></blockquote>
<p><strong>Configuration</strong></p>
<p>The <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code> instance is paired with a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelConditionModel</span></code>
instance used to retrieve the LOS/NLOS channel condition. By default, a 3GPP
channel condition model related to the same scenario is set (e.g., by default,
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppRmaPropagationLossModel</span></code> is paired with
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppRmaChannelConditionModel</span></code>), but it can be configured using
the method SetChannelConditionModel. The channel condition models are stored inside the
<code class="docutils literal notranslate"><span class="pre">propagation</span></code> module, for a limitation of the current spectrum API and to avoid
a circular dependency between the spectrum and the <code class="docutils literal notranslate"><span class="pre">propagation</span></code> modules. Please
note that it is necessary to install at least one <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelConditionModel</span></code> when
using any <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code> subclass. Please look below for more
information about the Channel Condition models.</p>
<p>The operating frequency has to be set using the attribute “Frequency”,
otherwise an assert is raised. The addition of the shadow fading component can
be enabled/disabled through the attribute “ShadowingEnabled”.
Other scenario-related parameters can be configured through attributes of the
derived classes.</p>
<p>One other attribute, “EnforceParameterRanges”, can be set to true if the
model is configured with parameters that fall outside of the applicability
range specified in TR38.901.  By default, the simulator will only warn
(if logging is enabled) if a value is outside of the applicability range.
If this parameter is set to true, the simulation will abort with an
error message (instead of just logging a warning) if the applicability range
is exceeded.</p>
<p><strong>Implementation details</strong></p>
<p>The method DoCalcRxPower computes the propagation loss considering the path loss
and the shadow fading (if enabled). The path loss is computed by the method
GetLossLos or GetLossNlos depending on the LOS/NLOS channel condition, and their
implementation is left to the derived classes. The shadow fading is computed by
the method GetShadowing, which generates an additional random loss component
characterized by Gaussian distribution with zero mean and scenario-specific
standard deviation. Subsequent shadowing components of each BS-UT link are
correlated as described in 3GPP TR 38.901, Sec. 7.4.4 <a class="footnote-reference brackets" href="#id29" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>.</p>
<p><em>Note 1</em>: The TR defines height ranges for UTs and BSs, depending on the chosen
propagation model (for the exact values, please see below in the specific model
documentation). If the user does not set correct values, the model will emit
a warning but perform the calculation anyway.</p>
<p><em>Note 2</em>: The 3GPP model is originally intended to be used to represent BS-UT
links. However, in ns-3, we may need to compute the pathloss between two BSs
or UTs to evaluate the interference. We have decided to support this case by
considering the tallest node as a BS and the smallest as a UT. As a consequence,
the height values may be outside the validity range of the chosen class:
therefore, an inaccuracy warning may be printed, but it can be ignored.</p>
<p>There are four derived class, each one implementing the propagation model for a different scenario:</p>
<section id="threegpprmapropagationlossmodel">
<h5><span class="section-number">29.1.16.1. </span>ThreeGppRMaPropagationLossModel<a class="headerlink" href="#threegpprmapropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>This class implements the LOS/NLOS path loss and shadow fading models described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.1-1 for the RMa scenario.
It supports frequencies between 0.5 and 30 GHz.
It is possible to configure some scenario-related parameters through the attributes AvgBuildingHeight and AvgStreetWidth.</p>
<p>As specified in the TR, the 2D distance between the transmitter and the receiver
should be between 10 m and 10 km for the LOS case, or between 10 m and 5 km for
the NLOS case, otherwise the model may not be accurate (a warning message is
printed if the user has enabled logging on the model, or the simulation aborts, depending on whether “EnforceParameterRanges” is set to true). Also, the height of the
base station (hBS) should be between 10 m and 150 m, while the height of the
user terminal (hUT) should be between 1 m and 10 m.</p>
</section>
<section id="threegppumapropagationlossmodel">
<h5><span class="section-number">29.1.16.2. </span>ThreeGppUMaPropagationLossModel<a class="headerlink" href="#threegppumapropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.1-1 for the UMa scenario. It supports frequencies
between 0.5 and 100 GHz.</p>
<p>As specified in the TR, the 2D distance between the transmitter and the receiver
should be between 10 m and 5 km both for the LOS and NLOS cases, otherwise the model may not be
accurate (a warning message is printed if the user has enabled logging on the model, or the simulation aborts, depending on whether “EnforceParameterRanges” is set to true).
Also, the height of the base station (hBS) should be 25 m and the height of the
user terminal (hUT) should be between 1.5 m and 22.5 m.</p>
</section>
<section id="threegppumistreetcanyonpropagationlossmodel">
<h5><span class="section-number">29.1.16.3. </span>ThreeGppUmiStreetCanyonPropagationLossModel<a class="headerlink" href="#threegppumistreetcanyonpropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.1-1 for the UMi-Street Canyon scenario. It
supports frequencies between 0.5 and 100 GHz.</p>
<p>As specified in the TR, the 2D distance between the transmitter and the receiver
should be between 10 m and 5 km both for the LOS and NLOS cases, otherwise the model may not be
accurate (a warning message is printed if the user has enabled logging on
the model, or the simulation aborts, depending on whether “EnforceParameterRanges” is set to true). Also, the height of the base station (hBS) should be 10 m and the
height of the user terminal (hUT) should be between 1.5 m and 10 m (the validity
range is reduced because we assume that the height of the UT nodes is always
lower that the height of the BS nodes).</p>
</section>
<section id="threegppindoorofficepropagationlossmodel">
<h5><span class="section-number">29.1.16.4. </span>ThreeGppIndoorOfficePropagationLossModel<a class="headerlink" href="#threegppindoorofficepropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.1-1 for the Indoor-Office scenario. It supports
frequencies between 0.5 and 100 GHz.</p>
<p>As specified in the TR, the 3D distance between the transmitter and the receiver
should be between 1 m and 150 m both for the LOS and NLOS cases, otherwise the
model may not be accurate (a warning log message is printed if the user has
enabled logging on the model, or the simulation aborts, depending on whether “EnforceParameterRanges” is set to true).</p>
</section>
<section id="testing">
<h5><span class="section-number">29.1.16.5. </span>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h5>
<p>The test suite <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModelsTestSuite</span></code> provides test cases for the classes
implementing the 3GPP propagation loss models.
The test cases <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppRmaPropagationLossModelTestCase</span></code>,
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppUmaPropagationLossModelTestCase</span></code>,
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppUmiPropagationLossModelTestCase</span></code> and
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppIndoorOfficePropagationLossModelTestCase</span></code> compute the path loss between two nodes and compares it with the value obtained using the formulas in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.1-1.
The test case <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppShadowingTestCase</span></code> checks if the shadowing is correctly computed by testing the deviation of the overall propagation loss from the path loss. The test is carried out for all the scenarios, both in LOS and NLOS condition.</p>
</section>
</section>
</section>
<section id="channelconditionmodel">
<h3><span class="section-number">29.2. </span>ChannelConditionModel<a class="headerlink" href="#channelconditionmodel" title="Link to this heading">¶</a></h3>
<p>The loss models require to know if two nodes are in Line-of-Sight (LoS) or if
they are not. The interface for that is represented by this class. The main
method is GetChannelCondition (a, b), which returns a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelCondition</span></code> object
containing the information about the channel state.</p>
<p>We modeled the LoS condition in two ways: (i) by using a probabilistic model
specified by the 3GPP (), and (ii) by using an ns-3 specific
building-aware model, which checks the space position of the BSs and the UTs.
For what regards the first option, the probability is independent of the node
location: in other words, following the 3GPP model, two UT spatially separated
by an epsilon may have different LoS conditions. To take into account mobility,
we have inserted a parameter called “UpdatePeriod,” which indicates how often a
3GPP-based channel condition has to be updated. By default, this attribute is
set to 0, meaning that after the channel condition is generated, it is never
updated. With this default value, we encourage the users to run multiple
simulations with different seeds to get statistical significance from the data.
For the users interested in using mobile nodes, we suggest changing this
parameter to a value that takes into account the node speed and the desired
accuracy. For example, lower-speed node conditions may be updated in terms of
seconds, while high-speed UT or BS may be updated more often.</p>
<p>The two approach are coded, respectively, in the classes:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppChannelConditionModel</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BuildingsChannelConditionModel</span></code> (see the <code class="docutils literal notranslate"><span class="pre">building</span></code> module documentation for further details)</p></li>
</ul>
<section id="threegppchannelconditionmodel">
<h4><span class="section-number">29.2.1. </span>ThreeGppChannelConditionModel<a class="headerlink" href="#threegppchannelconditionmodel" title="Link to this heading">¶</a></h4>
<p>This is the base class for the 3GPP channel condition models.
It provides the possibility to updated the condition of each channel periodically,
after a given time period which can be configured through the attribute “UpdatePeriod”.
If “UpdatePeriod” is set to 0, the channel condition is never updated.
It has five derived classes implementing the channel condition models described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a> for different propagation scenarios.</p>
<section id="threegpprmachannelconditionmodel">
<h5><span class="section-number">29.2.1.1. </span>ThreeGppRmaChannelConditionModel<a class="headerlink" href="#threegpprmachannelconditionmodel" title="Link to this heading">¶</a></h5>
<p>This implements the statistical channel condition model described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.2-1, for the RMa scenario.</p>
</section>
<section id="threegppumachannelconditionmodel">
<h5><span class="section-number">29.2.1.2. </span>ThreeGppUmaChannelConditionModel<a class="headerlink" href="#threegppumachannelconditionmodel" title="Link to this heading">¶</a></h5>
<p>This implements the statistical channel condition model described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.2-1, for the UMa scenario.</p>
</section>
<section id="threegppumistreetcanyonchannelconditionmodel">
<h5><span class="section-number">29.2.1.3. </span>ThreeGppUmiStreetCanyonChannelConditionModel<a class="headerlink" href="#threegppumistreetcanyonchannelconditionmodel" title="Link to this heading">¶</a></h5>
<p>This implements the statistical channel condition model described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.2-1, for the UMi-Street Canyon scenario.</p>
</section>
<section id="threegppindoormixedofficechannelconditionmodel">
<h5><span class="section-number">29.2.1.4. </span>ThreeGppIndoorMixedOfficeChannelConditionModel<a class="headerlink" href="#threegppindoormixedofficechannelconditionmodel" title="Link to this heading">¶</a></h5>
<p>This implements the statistical channel condition model described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.2-1, for the Indoor-Mixed office scenario.</p>
</section>
<section id="threegppindooropenofficechannelconditionmodel">
<h5><span class="section-number">29.2.1.5. </span>ThreeGppIndoorOpenOfficeChannelConditionModel<a class="headerlink" href="#threegppindooropenofficechannelconditionmodel" title="Link to this heading">¶</a></h5>
<p>This implements the statistical channel condition model described in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.2-1, for the Indoor-Open office scenario.</p>
</section>
</section>
<section id="id22">
<h4><span class="section-number">29.2.2. </span>Testing<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h4>
<p>The test suite <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelConditionModelsTestSuite</span></code> contains a single test case:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppChannelConditionModelTestCase</span></code>, which tests all the 3GPP channel condition models. It determines the channel condition between two nodes multiple times, estimates the LOS probability, and compares it with the value given by the formulas in 3GPP TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a>, Table 7.4.2-1</p></li>
</ul>
</section>
</section>
<section id="propagationdelaymodel">
<h3><span class="section-number">29.3. </span>PropagationDelayModel<a class="headerlink" href="#propagationdelaymodel" title="Link to this heading">¶</a></h3>
<p>The following propagation delay models are implemented:</p>
<ul class="simple">
<li><p>ConstantSpeedPropagationDelayModel</p></li>
<li><p>RandomPropagationDelayModel</p></li>
</ul>
<section id="constantspeedpropagationdelaymodel">
<h4><span class="section-number">29.3.1. </span>ConstantSpeedPropagationDelayModel<a class="headerlink" href="#constantspeedpropagationdelaymodel" title="Link to this heading">¶</a></h4>
<p>In this model, the signal travels with constant speed.
The delay is calculated according with the transmitter and receiver positions.
The Euclidean distance between the Tx and Rx antennas is used.
Beware that, according to this model, the Earth is flat.</p>
</section>
<section id="randompropagationdelaymodel">
<h4><span class="section-number">29.3.2. </span>RandomPropagationDelayModel<a class="headerlink" href="#randompropagationdelaymodel" title="Link to this heading">¶</a></h4>
<p>The propagation delay is totally random, and it changes each time the model is called.
All the packets (even those between two fixed nodes) experience a random delay.
As a consequence, the packets order is not preserved.</p>
</section>
</section>
<section id="models-for-vehicular-environments">
<h3><span class="section-number">29.4. </span>Models for vehicular environments<a class="headerlink" href="#models-for-vehicular-environments" title="Link to this heading">¶</a></h3>
<p>The 3GPP TR 37.885 <a class="footnote-reference brackets" href="#id30" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>37885<span class="fn-bracket">]</span></a> specifications extends the channel modeling framework
described in TR 38.901 <a class="footnote-reference brackets" href="#id29" id="id25" role="doc-noteref"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></a> to simulate wireless channels in vehicular environments.
The extended framework supports frequencies between 0.5 to 100 GHz and provides
the possibility to simulate urban and highway propagation environments.
To do so, new propagation loss and channel condition models, as well as new
parameters for the fast fading model, are provided.</p>
<section id="vehicular-channel-condition-models">
<span id="sec-3gpp-v2v-ch-cond"></span><h4><span class="section-number">29.4.1. </span>Vehicular channel condition models<a class="headerlink" href="#vehicular-channel-condition-models" title="Link to this heading">¶</a></h4>
<p>To properly capture channel dynamics in vehicular environments, three different
channel conditions have been identified:</p>
<blockquote>
<div><ul class="simple">
<li><p>LOS (Line Of Sight): represents the case in which the direct path between
the transmitter and the receiver is not blocked</p></li>
<li><p>NLOSv (Non Line Of Sight vehicle): when the direct path
between the transmitter and the receiver is blocked by a vehicle</p></li>
<li><p>NLOS (Non Line Of Sight): when the direct path is blocked by a building</p></li>
</ul>
</div></blockquote>
<p>TR 37.885 includes two models that can be used to determine the condition of
the wireless channel between a pair of nodes, the first for urban and the second
for highway environments.
Each model includes both a deterministic and a stochastic part, and works as
follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The model determines the presence of buildings obstructing the direct path
between the communicating nodes. This is done in a deterministic way, looking at
the possible interceptions between the direct path and the buildings.
If the path is obstructed, the channel condition is set to NLOS.</p></li>
<li><p>If not, the model determines the presence of vehicles obstructing the
direct path. This is done using a probabilistic model, which is specific
for the scenario of interest. If the path is obstructed, the channel
condition is set to NLOSv, otherwise is set to LOS.</p></li>
</ol>
</div></blockquote>
<p>These models have been implemented by extending the interface
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelConditionModel</span></code> with the following classes. They have been included in
the <code class="docutils literal notranslate"><span class="pre">building</span></code> module, because they make use of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Buildings</span></code> objects to determine
the presence of obstructions caused by buildings.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppV2vUrbanChannelConditionModel</span></code>: implements the model
described in Table 6.2-1 of TR 37.885 for the urban scenario.</p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppV2vHighwayChannelConditionModel</span></code>: implements the model
described in Table 6.2-1 of TR 37.885 for the highway scenario.</p></li>
</ul>
</div></blockquote>
<p>These models rely on <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Buildings</span></code> objects to determine the presence
of obstructing buildings. When considering large scenarios with a large number of
buildings, this process may become computationally demanding and dramatically
increase the simulation time.
To solve this problem, we implemented two fully-probabilistic models
that can be used as an alternative to the ones included in TR 37.885.
These models are based on the work carried out by M. Boban et al. <a class="reference internal" href="index.html#boban2016modeling" id="id26"><span>[Boban2016Modeling]</span></a>,
which derived a statistical representation of the three channel conditions,
With the fully-probabilistic models there is no need to determine the presence of blocking
buildings in a deterministic way, and therefore the computational effort is
reduced.
To determine the channel condition, these models account for the propagation
environment, i.e., urban or highway, as well as for the density of vehicles in the
scenario, which can be high, medium, or low.</p>
<p>The classes implementing the fully-probabilistic models are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ProbabilisticV2vUrbanChannelConditionModel</span></code>: implements the model
described in <a class="reference internal" href="index.html#boban2016modeling" id="id27"><span>[Boban2016Modeling]</span></a> for the urban scenario.</p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ProbabilisticV2vHighwayChannelConditionModel</span></code>: implements the model
described in <a class="reference internal" href="index.html#boban2016modeling" id="id28"><span>[Boban2016Modeling]</span></a> for the highway scenario.</p></li>
</ul>
</div></blockquote>
<p>Both the classes own the attribute “Density”, which can be used to select the
proper value depending on the scenario that have to be simulated.
Differently from the hybrid models described above, these classes have been
included in the <code class="docutils literal notranslate"><span class="pre">propagation</span></code> module, since they do not have any dependency on the
<code class="docutils literal notranslate"><span class="pre">building</span></code> module.</p>
<p><strong>NOTE:</strong> Both the hybrid and the fully-probabilistic models supports the
modeling of outdoor scenarios, no support is provided for the modeling of
indoor scenarios.</p>
</section>
<section id="vehicular-propagation-loss-models">
<h4><span class="section-number">29.4.2. </span>Vehicular propagation loss models<a class="headerlink" href="#vehicular-propagation-loss-models" title="Link to this heading">¶</a></h4>
<p>The propagation models described in TR 37.885 determines the attenuation caused
by path loss and shadowing by considering the propagation environment and the
channel condition.</p>
<p>These models have been implemented by extending the interface
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code> with the following classes, which
are part of the <code class="docutils literal notranslate"><span class="pre">propagation</span></code> module:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppV2vUrbanPropagationLossModel</span></code>: implements the models
defined in Table 6.2.1-1 of TR 37.885 for the urban scenario.</p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppV2vHighwayPropagationLossModel</span></code>: implements the models
defined in Table 6.2.1-1 of TR 37.885 for the highway scenario.</p></li>
</ul>
</div></blockquote>
<p>As for all the classes extending the interface <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code>,
they have to be paired with an instance of the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelConditionModel</span></code>
which is used to determine the channel condition.
This is done by setting the attribute <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ChannelConditionModel</span></code>.
To build the channel modeling framework described in TR 37.885,
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppV2vUrbanChannelConditionModel</span></code> or
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppV2vHighwayChannelConditionModel</span></code> should be used, but users
are allowed to test any other combination.</p>
</section>
<section id="vehicular-fast-fading-model">
<span id="sec-3gpp-v2v-ff"></span><h4><span class="section-number">29.4.3. </span>Vehicular fast fading model<a class="headerlink" href="#vehicular-fast-fading-model" title="Link to this heading">¶</a></h4>
<p>The fast fading model described in Sec. 6.2.3 of TR 37.885 is based on the one
specified in TR 38.901, whose implementation is provided in the <code class="docutils literal notranslate"><span class="pre">spectrum</span></code> module
(see the <a class="reference internal" href="index.html#gpp-fast-fading-model"><span class="std std-ref">spectrum module documentation</span></a>).
This model is general and includes different parameters which can
be tuned to simulate multiple propagation environments.
To better model the channel dynamics in vehicular environments, TR 37.885
provides new sets of values for these parameters, specific for
vehicle-to-vehicle transmissions in urban and highway scenarios.
To select the parameters for vehicular scenarios, it is necessary to set
the attribute “Scenario” of the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppChannelModel</span></code> using the value
“V2V-Urban” or “V2V-Highway”.</p>
<p>edditionally, TR 37.885 specifies a new equation to compute the Doppler component,
which accounts for the mobility of both nodes, as well as scattering
from the environment.
In particular, the scattering effect is considered by deviating the Doppler
frequency by a random value, whose distribution depends on the parameter <img class="math" src="_images/math/44218e075ff340d5528d65b5bc8562c93aa700e3.png" alt="v_{scatt}"/>.
TR 37.885 specifies that <img class="math" src="_images/math/44218e075ff340d5528d65b5bc8562c93aa700e3.png" alt="v_{scatt}"/> should be set to the maximum speed of the
vehicles in the layout and, if <img class="math" src="_images/math/8db3899f7a1795ec31fed3c06fba7f4d79eaa049.png" alt="v_{scatt} = 0"/>, the scattering effect is not considered.
The Doppler equation is implemented in the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ThreeGppSpectrumPropagationLossModel</span></code>.
By means of the attribute “vScatt”, it is possible to adjust the value of
<img class="math" src="_images/math/8db3899f7a1795ec31fed3c06fba7f4d79eaa049.png" alt="v_{scatt} = 0"/> (by default, the value is set to 0).</p>
</section>
<section id="example">
<h4><span class="section-number">29.4.4. </span>Example<a class="headerlink" href="#example" title="Link to this heading">¶</a></h4>
<p>We implemented the example <code class="docutils literal notranslate"><span class="pre">three-gpp-v2v-channel-example.cc</span></code> which shows how to
configure the different classes to simulate wireless propagation in vehicular
scenarios, it can be found in the folder <code class="docutils literal notranslate"><span class="pre">examples/channel-models</span></code>.</p>
<p>We considered two communicating vehicles moving within the scenario, and
computed the SNR experienced during the entire simulation, with a time
resolution of 10 ms.
The vehicles are equipped with 2x2 antenna arrays modeled using the
<a class="reference internal" href="index.html#gpp-antenna-model"><span class="std std-ref">3GPP antenna model</span></a>.
The bearing and the downtilt angles are properly configured and the
optimal beamforming vectors are computed at the beginning of the simulation.</p>
<p>The simulation script accepts the following command line parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>frequency</em>: the operating frequency in Hz</p></li>
<li><p><em>txPow</em>: the transmission power in dBm</p></li>
<li><p><em>noiseFigure</em>: the noise figure in dB</p></li>
<li><p><em>scenario</em>: the simulation scenario, “V2V-Urban” or “V2V-Highway”</p></li>
</ul>
</div></blockquote>
<p>The “V2V-Urban” scenario simulates urban environment with a rectangular grid of
buildings. The vehicles moves with a waypoint mobility model. They start from
the same position and travel in the same direction, along the main street.
The first vehicle moves at 60 km/h and the second at 30 km/h.
At a certain point, the first vehicle turns left while the second continues on
the main street.</p>
<p>The “V2V-Highway” scenario simulates an highway environment in which the
two vehicles travel on the same lane, in the same direction, and keep a safety
distance of 20 m. They maintain a constant speed of 140 km/h.</p>
<p>The example generates the output file <code class="docutils literal notranslate"><span class="pre">example-output.txt</span></code>. Each row of the
file is organized as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">Time[s]</span> <span class="pre">TxPosX[m]</span> <span class="pre">TxPosY[m]</span> <span class="pre">RxPosX[m]</span> <span class="pre">RxPosY[m]</span> <span class="pre">ChannelState</span> <span class="pre">SNR[dB]</span> <span class="pre">Pathloss[dB]</span></code></p>
<p>We also provide the bash script <code class="docutils literal notranslate"><span class="pre">three-gpp-v2v-channel-example.sh</span></code> which reads the
output file and generates two figures:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>map.gif, a GIF representing the simulation scenario and vehicle mobility;</p></li>
<li><p>snr.png, which represents the behavior of the SNR.</p></li>
</ol>
</div></blockquote>
</section>
</section>
<section id="references">
<h3><span class="section-number">29.5. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="friis" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">friis</a><span class="fn-bracket">]</span></span>
<p>Friis, H.T., “A Note on a Simple Transmission Formula,” Proceedings of the IRE , vol.34, no.5, pp.254,256, May 1946</p>
</div>
<div class="citation" id="hata" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">hata</a><span class="fn-bracket">]</span></span>
<p>M.Hata, “Empirical formula for propagation loss in land mobile radio
services”, IEEE Trans. on Vehicular Technology, vol. 29, pp. 317-325, 1980</p>
</div>
<div class="citation" id="cost231" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">cost231</a><span class="fn-bracket">]</span></span>
<p>“Digital Mobile Radio: COST 231 View on the Evolution Towards 3rd Generation Systems”, Commission of the European Communities, L-2920, Luxembourg, 1989</p>
</div>
<div class="citation" id="walfisch" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">walfisch</a><span class="fn-bracket">]</span></span>
<p>J.Walfisch and H.L. Bertoni, “A Theoretical model of UHF propagation in urban environments,” in IEEE Trans. Antennas Propagat., vol.36, 1988, pp.1788- 1796</p>
</div>
<div class="citation" id="ikegami" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">ikegami</a><span class="fn-bracket">]</span></span>
<p>F.Ikegami, T.Takeuchi, and S.Yoshida, “Theoretical prediction of mean field strength for Urban Mobile Radio”, in IEEE Trans. Antennas Propagat., Vol.39, No.3, 1991</p>
</div>
<div class="citation" id="kun2600mhz" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">kun2600mhz</a><span class="fn-bracket">]</span></span>
<p>Sun Kun, Wang Ping, Li Yingze, “Path loss models for suburban scenario at 2.3GHz, 2.6GHz and 3.5GHz”,
in Proc. of the 8th International Symposium on Antennas, Propagation and EM Theory (ISAPE),  Kunming,  China, Nov 2008.</p>
</div>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>38901<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id10">2</a>,<a role="doc-backlink" href="#id11">3</a>,<a role="doc-backlink" href="#id12">4</a>,<a role="doc-backlink" href="#id13">5</a>,<a role="doc-backlink" href="#id14">6</a>,<a role="doc-backlink" href="#id15">7</a>,<a role="doc-backlink" href="#id16">8</a>,<a role="doc-backlink" href="#id17">9</a>,<a role="doc-backlink" href="#id18">10</a>,<a role="doc-backlink" href="#id19">11</a>,<a role="doc-backlink" href="#id20">12</a>,<a role="doc-backlink" href="#id21">13</a>,<a role="doc-backlink" href="#id23">14</a>,<a role="doc-backlink" href="#id25">15</a>)</span>
<p>3GPP. 2018. TR 38.901, Study on channel model for frequencies from 0.5 to 100 GHz, V15.0.0. (2018-06).</p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">37885</a><span class="fn-bracket">]</span></span>
<p>3GPP. 2019. TR 37.885, Study on evaluation methodology of new Vehicle-to-Everything (V2X) use cases for LTE and NR, V15.3.0. (2019-06).</p>
</aside>
</aside>
<div role="list" class="citation-list">
<div class="citation" id="boban2016modeling" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Boban2016Modeling<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id26">1</a>,<a role="doc-backlink" href="#id27">2</a>,<a role="doc-backlink" href="#id28">3</a>)</span>
<p>M. Boban,  X. Gong, and  W. Xu, “Modeling the evolution
of line-of-sight blockage for V2V channels,” in IEEE 84th Vehicular Technology
Conference (VTC-Fall), 2016.</p>
</div>
</div>
</section>
</section>
<span id="document-spectrum"></span><section id="spectrum-module">
<span id="sec-spectrum-module"></span><h2><span class="section-number">30. </span>Spectrum Module<a class="headerlink" href="#spectrum-module" title="Link to this heading">¶</a></h2>
<p>The Spectrum module aims at providing support for modeling the frequency-dependent
aspects of communications in <em>ns-3</em>.
The model was first introduced in
<a class="reference internal" href="index.html#baldo2009spectrum" id="id1"><span>[Baldo2009Spectrum]</span></a>, and has been enhanced and refined over the years.</p>
<figure class="align-center" id="id39">
<span id="fig-spectrum-analyzer-example"></span><img alt="_images/spectrum-analyzer-example.png" src="_images/spectrum-analyzer-example.png" />
<figcaption>
<p><span class="caption-text">Spectrogram produced by a spectrum analyzer in a scenario
involving wifi signals interfered by a microwave oven, as simulated
by the example <code class="docutils literal notranslate"><span class="pre">adhoc-aloha-ideal-phy-with-microwave-oven</span></code>.</span><a class="headerlink" href="#id39" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="model-description">
<h3><span class="section-number">30.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The module provides:</p>
<ul class="simple">
<li><p>a set of classes for modeling signals and</p></li>
<li><p>a Channel/PHY interface based on a power spectral density
signal representation that is technology-independent</p></li>
<li><p>two technology-independent Channel implementations based on the Channel/PHY interface</p></li>
<li><p>a set of basic PHY model implementations based on the Channel/PHY interface</p></li>
</ul>
<p>The source code for the spectrum module is located at <code class="docutils literal notranslate"><span class="pre">src/spectrum</span></code>.</p>
<section id="design">
<h4><span class="section-number">30.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<section id="signal-model">
<h5><span class="section-number">30.1.1.1. </span>Signal model<a class="headerlink" href="#signal-model" title="Link to this heading">¶</a></h5>
<p>The signal model is implemented by the
<code class="docutils literal notranslate"><span class="pre">SpectrumSignalParameters</span></code> class. This class provides the following
information for a signal being transmitted/received by PHY devices:</p>
<ul class="simple">
<li><p>a reference to the transmitting PHY device</p></li>
<li><p>a reference to the antenna model used by the transmitting PHY device
to transmit this signal</p></li>
<li><p>the duration of the signal</p></li>
<li><p>its Power Spectral Density (PSD) of the signal, which is assumed to be constant for
the duration of the signal.</p></li>
</ul>
<p>The PSD is represented as a set of discrete scalar values each
corresponding to a certain subband in frequency. The set of frequency subbands
to which the PSD refers to is defined by an instance of the
<code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> class. The PSD itself is implemented as an instance
of the <code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code> class which contains a reference to the
associated <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> class instance. The <code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code>
class provides several arithmetic operators to allow to perform calculations
with PSD instances. Additionally, the <code class="docutils literal notranslate"><span class="pre">SpectrumConverter</span></code> class
provides means for the conversion of <code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code> instances from
one <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> to another.</p>
<p>For a more formal mathematical description of the signal model just
described, the reader is referred to <a class="reference internal" href="index.html#baldo2009spectrum" id="id2"><span>[Baldo2009Spectrum]</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SpectrumSignalParameters</span></code> class is meant to include only
information that is valid for all signals; as such, it is not meant to
be modified to add technology-specific information (such as type of
modulation and coding schemes used, info on preambles and reference
signals, etc). Instead, such information shall be put in a new class
that inherits from <code class="docutils literal notranslate"><span class="pre">SpectrumSignalParameters</span></code> and extends it with
any technology-specific information that is needed. This design
is intended to model the fact that in the real world we have signals
of different technologies being simultaneously transmitted and
received over the air.</p>
</section>
<section id="channel-phy-interface">
<h5><span class="section-number">30.1.1.2. </span>Channel/PHY interface<a class="headerlink" href="#channel-phy-interface" title="Link to this heading">¶</a></h5>
<p>The spectrum Channel/PHY interface is defined by the base classes <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code>
and <code class="docutils literal notranslate"><span class="pre">SpectrumPhy</span></code>. Their interaction simulates the transmission and
reception of signals over the medium. The way this interaction works is depicted in <a class="reference internal" href="#fig-spectrum-channel-phy-interface"><span class="std std-ref">Sequence diagram showing the interaction between SpectrumPhy and SpectrumChannel</span></a>:</p>
<figure class="align-center" id="id40">
<span id="fig-spectrum-channel-phy-interface"></span><img alt="_images/spectrum-channel-phy-interface.png" src="_images/spectrum-channel-phy-interface.png" />
<figcaption>
<p><span class="caption-text">Sequence diagram showing the interaction between SpectrumPhy and SpectrumChannel</span><a class="headerlink" href="#id40" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="spectrum-channel-implementations">
<h5><span class="section-number">30.1.1.3. </span>Spectrum Channel implementations<a class="headerlink" href="#spectrum-channel-implementations" title="Link to this heading">¶</a></h5>
<p>The module provides two <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code> implementations:
<code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code>. They
both provide this functionality:</p>
<blockquote>
<div><ul class="simple">
<li><p>Propagation loss modeling, in three forms:</p>
<ul>
<li><p>you can plug models based on <code class="docutils literal notranslate"><span class="pre">PropagationLossModel</span></code> on these
channels. Only linear models (where the loss value does not
depend on the transmission power) can be used.
These models are single-frequency in the sense that the loss value is
applied equally to all components of the power spectral density.</p></li>
<li><p>you can plug models based on <code class="docutils literal notranslate"><span class="pre">SpectrumPropagationLossModel</span></code> on these
channels. These models can have frequency-dependent loss, i.e.,
a separate loss value is calculated and applied to each component
of the power spectral density.</p></li>
<li><p>you can plug models based on <code class="docutils literal notranslate"><span class="pre">PhasedArraySpectrumPropagationLossModel</span></code>
on these channels. These models can have frequency-dependent loss, i.e.,
a separate loss value is calculated and applied to each component
of the power spectral density. Additionally, these models support
the phased antenna array at the transmitter and the receiver, i.e.,
ns-3 antenna type <code class="docutils literal notranslate"><span class="pre">PhasedArrayModel</span></code>.</p></li>
</ul>
</li>
<li><p>Propagation delay modeling, by plugging a model based on
<code class="docutils literal notranslate"><span class="pre">PropagationDelayModel</span></code>. The delay is independent of frequency and
applied to the signal as a whole. Delay modeling is implemented by
scheduling the <code class="docutils literal notranslate"><span class="pre">StartRx</span></code> event with a delay respect to the
<code class="docutils literal notranslate"><span class="pre">StartTx</span></code> event.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> are
quite similar, the main difference is that
<code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> allows to use different
<code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> instances with the same channel instance, by
automatically taking care of the conversion of PSDs among the
different models.</p>
</section>
<section id="example-model-implementations">
<span id="sec-example-model-implementations"></span><h5><span class="section-number">30.1.1.4. </span>Example model implementations<a class="headerlink" href="#example-model-implementations" title="Link to this heading">¶</a></h5>
<p>The spectrum module provides some basic implementation of several components that
are mainly intended as a proof-of-concept and as an example for
building custom models with the spectrum module. Here is a brief list
of the available implementations:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SpectrumModel300Khz300GhzLog</span></code> and
<code class="docutils literal notranslate"><span class="pre">SpectrumModelIsm2400MhzRes1Mhz</span></code> are two example <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> implementations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HalfDuplexIdealPhy</span></code>: a basic PHY model using a gaussian
interference model (implemented in <code class="docutils literal notranslate"><span class="pre">SpectrumInterference</span></code>)
together with an error model based on Shannon capacity (described
in <a class="reference internal" href="index.html#baldo2009spectrum" id="id3"><span>[Baldo2009Spectrum]</span></a> and implemented in <code class="docutils literal notranslate"><span class="pre">SpectrumErrorModel</span></code>. This PHY
uses the <code class="docutils literal notranslate"><span class="pre">GenericPhy</span></code> interface. Its additional custom signal
parameters are defined in <code class="docutils literal notranslate"><span class="pre">HalfDuplexIdealPhySignalParameters</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WifiSpectrumValueHelper</span></code> is an helper object that makes it easy
to create <code class="docutils literal notranslate"><span class="pre">SpectrumValues</span></code> representing PSDs and RF filters for
the wifi technology.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AlohaNoackNetDevice</span></code>: a minimal NetDevice that allows to send
packets over <code class="docutils literal notranslate"><span class="pre">HalfDuplexIdealPhy</span></code> (or other PHY model based on
the  <code class="docutils literal notranslate"><span class="pre">GenericPhy</span></code> interface).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SpectrumAnalyzer</span></code>, <code class="docutils literal notranslate"><span class="pre">WaveformGenerator</span></code> and <code class="docutils literal notranslate"><span class="pre">MicrowaveOven</span></code> are examples of PHY
models other than communication devices - the names should be
self-explaining.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="references">
<h4><span class="section-number">30.1.2. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="baldo2009spectrum" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Baldo2009Spectrum<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id3">3</a>)</span>
<p>N. Baldo and M. Miozzo, “Spectrum-aware Channel and PHY layer modeling for ns3”,
Proceedings of ICST NSTools 2009, Pisa, Italy</p>
</div>
</div>
</section>
</section>
<section id="usage">
<h3><span class="section-number">30.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The main use case of the spectrum model is for developers who want to
develop a new model for the PHY layer of some wireless technology to
be used within ns-3.
Here are some notes on how the spectrum module is expected to be used.</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SpectrumPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code> are abstract base classes. Real
code will use classes that inherit from these classes.</p></li>
<li><p>If you are implementing a new model for some wireless
technology of your interest, and want to use the spectrum module,
you’ll typically create your own module and make it depend on the
spectrum module. Then you typically have to implement:</p>
<blockquote>
<div><ul class="simple">
<li><p>a child class of <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> which defines the (sets of) frequency
subbands used by the considered wireless technology. <strong>Note</strong>:
instances of <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> are typically statically allocated,
in order to allow several <code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code> instances to reference
the same <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> instance.</p></li>
<li><p>a child class of <code class="docutils literal notranslate"><span class="pre">SpectrumPhy</span></code> which will handle transmission and
reception of signals (including, if appropriate, interference
and error modeling).</p></li>
<li><p>a child class of <code class="docutils literal notranslate"><span class="pre">SpectrumSignalParameters</span></code> which will contain
all the information needed to model the signals for the wireless
technology being considered that is not already provided by the
base <code class="docutils literal notranslate"><span class="pre">SpectrumSignalParameters</span></code> class. Examples of such
information are the type of modulation and coding schemes used,
the PHY preamble format, info on the pilot/reference signals, etc.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The available <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code> implementations
(<code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code>,
are quite generic. Chances are you can use them as-is. Whether you
prefer one or the other it is just a matter of whether you will
have a single SpectrumModel or multiple ones in your
simulations.</p></li>
<li><p>Typically, there will be a single SpectrumChannel instance to which
several SpectrumPhy instances are plugged. The rule of thumb is
that all PHYs that are interfering with each other shall be plugged
on the same channel. Multiple SpectrumChannel instances are
expected to be used mainly when simulating completely orthogonal
channels; for example, when simulating the uplink and downlink
of a Frequency Division Duplex system, it is a good choice to use
two SpectrumChannel instances in order to reduce computational
complexity.</p></li>
<li><p>Different types of SpectrumPhy (i.e., instances of different child
classes) can be plugged on the same SpectrumChannel instance. This
is one of the main features of the
spectrum module, to support inter-technology interference. For
example, if you implement a WifiSpectrumPhy and a
BluetoothSpectrumPhy, and plug both on a SpectrumChannel, then you’ll
be able to simulate interference between wifi and bluetooth and
vice versa.</p></li>
<li><p>Different child classes of <code class="docutils literal notranslate"><span class="pre">SpectrumSignalParameters</span></code> can coexist
in the same simulation, and be transmitted over the same channel
object.  Again, this is part of the support for inter-technology
interference. A PHY device model is expected to use the
<code class="docutils literal notranslate"><span class="pre">DynamicCast&lt;&gt;</span></code> operator to determine if a signal is of a certain
type it can attempt to receive. If not, the signal is normally
expected to be considered as interference.</p></li>
</ul>
</div></blockquote>
<section id="helpers">
<h4><span class="section-number">30.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p>The helpers provided in <code class="docutils literal notranslate"><span class="pre">src/spectrum/helpers</span></code> are mainly intended
for the example implementations described in <a class="reference internal" href="#sec-example-model-implementations"><span class="std std-ref">Example model implementations</span></a>.
If you are developing your custom model based on the
spectrum framework, you will probably prefer to define your own
helpers.</p>
</section>
<section id="attributes">
<h4><span class="section-number">30.2.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><p>Both <code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and
<code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> have an attribute <code class="docutils literal notranslate"><span class="pre">MaxLossDb</span></code> which
can use to avoid propagating signals affected by very high
propagation loss. You can use this to reduce the complexity of
interference calculations. Just be careful to choose a value that
does not make the interference calculations inaccurate.</p></li>
<li><p>The example implementations described in <a class="reference internal" href="#sec-example-model-implementations"><span class="std std-ref">Example model implementations</span></a> also have several attributes.</p></li>
</ul>
</div></blockquote>
</section>
<section id="output">
<h4><span class="section-number">30.2.3. </span>Output<a class="headerlink" href="#output" title="Link to this heading">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><p>Both <code class="docutils literal notranslate"><span class="pre">SingleModelSpectrumChannel</span></code> and
<code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> provide a trace source called
<code class="docutils literal notranslate"><span class="pre">PathLoss</span></code> which is fired whenever a new path loss value is
calculated. <strong>Note</strong>: only single-frequency path loss is accounted
for, see the attribute description.</p></li>
<li><p>The example implementations described in <a class="reference internal" href="#sec-example-model-implementations"><span class="std std-ref">Example model implementations</span></a> also provide some trace sources.</p></li>
<li><p>The helper class <code class="docutils literal notranslate"><span class="pre">SpectrumAnalyzerHelper</span></code> can be conveniently
used to generate an output text file containing the spectrogram
produced by a SpectrumAnalyzer instance. The format is designed to
be easily plotted with <code class="docutils literal notranslate"><span class="pre">gnuplot</span></code>. For example, if your run the
example <code class="docutils literal notranslate"><span class="pre">adhoc-aloha-ideal-phy-with-microwave-oven</span></code> you will get
an output file called <code class="docutils literal notranslate"><span class="pre">spectrum-analyzer-output-3-0.tr</span></code>. From
this output file, you can generate a figure similar to
<a class="reference internal" href="#fig-spectrum-analyzer-example"><span class="std std-ref">Spectrogram produced by a spectrum analyzer in a scenario
involving wifi signals interfered by a microwave oven, as simulated
by the example adhoc-aloha-ideal-phy-with-microwave-oven.</span></a> by executing the following
gnuplot commands:</p></li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unset surface
set pm3d at s
set palette
set key off
set view 50,50
set xlabel &quot;time (ms)&quot;
set ylabel &quot;freq (MHz)&quot;
set zlabel &quot;PSD (dBW/Hz)&quot; offset 15,0,0
splot &quot;./spectrum-analyzer-output-3-0.tr&quot; using ($1*1000.0):($2/1e6):(10*log10($3))
</pre></div>
</div>
</section>
<section id="examples">
<h4><span class="section-number">30.2.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The example programs in <code class="docutils literal notranslate"><span class="pre">src/spectrum/examples/</span></code> allow to see the
example implementations described in <a class="reference internal" href="#sec-example-model-implementations"><span class="std std-ref">Example model implementations</span></a> in action.</p>
</section>
<section id="troubleshooting">
<h4><span class="section-number">30.2.5. </span>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Link to this heading">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><p><strong>Disclaimer on inter-technology interference</strong>: the spectrum model
makes it very easy to implement an inter-technology interference
model, but this does not guarantee
that the resulting model is accurate. For example, the gaussian
interference model implemented in the <code class="docutils literal notranslate"><span class="pre">SpectrumInterference</span></code> class can be used
to calculate inter-technology interference, however the results might not be valid in some
scenarios, depending on the actual waveforms involved, the number
of interferers, etc. Moreover, it is very important to use error
models that are consistent with the interference model. The
responsibility of ensuring that the models being used are correct
is left to the user.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="testing">
<h3><span class="section-number">30.3. </span>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h3>
<p>In this section we describe the test suites that are provided within
the spectrum module.</p>
<section id="spectrumvalue-test">
<h4><span class="section-number">30.3.1. </span>SpectrumValue test<a class="headerlink" href="#spectrumvalue-test" title="Link to this heading">¶</a></h4>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">spectrum-value</span></code> verifies the correct functionality of the arithmetic
operators implemented by the <code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code> class. Each test case
corresponds to a different operator. The test passes if the result
provided by the operator implementation is equal to the reference
values which were calculated offline by hand. Equality is verified
within a tolerance of <img class="math" src="_images/math/7e21945d9e6e712189e545e2144022340947d5fa.png" alt="10^{-6}"/> which is to account for
numerical errors.</p>
</section>
<section id="spectrumconverter-test">
<h4><span class="section-number">30.3.2. </span>SpectrumConverter test<a class="headerlink" href="#spectrumconverter-test" title="Link to this heading">¶</a></h4>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">spectrum-converter</span></code> verifies the correct
functionality of the <code class="docutils literal notranslate"><span class="pre">SpectrumConverter</span></code> class. Different test cases
correspond to the conversion of different <code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code> instances
to different <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code> instances. Each test passes if the
<code class="docutils literal notranslate"><span class="pre">SpectrumValue</span></code> instance resulting from the conversion is equal to the reference
values which were calculated offline by hand. Equality is verified
within a tolerance of <img class="math" src="_images/math/7e21945d9e6e712189e545e2144022340947d5fa.png" alt="10^{-6}"/> which is to account for
numerical errors.</p>
<p>Describe how the model has been tested/validated.  What tests run in the
test suite?  How much API and code is covered by the tests?  Again,
references to outside published work may help here.</p>
</section>
<section id="interference-test">
<h4><span class="section-number">30.3.3. </span>Interference test<a class="headerlink" href="#interference-test" title="Link to this heading">¶</a></h4>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">spectrum-interference</span></code> verifies the correct
functionality of the <code class="docutils literal notranslate"><span class="pre">SpectrumInterference</span></code> and
<code class="docutils literal notranslate"><span class="pre">ShannonSpectrumErrorModel</span></code> in a scenario involving four
signals (an intended signal plus three interferers). Different test
cases are created corresponding to different PSDs of the intended
signal and different amount of transmitted bytes. The test passes if
the output of the error model (successful or failed) coincides with
the expected one which was determine offline by manually calculating
the achievable rate using Shannon’s formula.</p>
</section>
<section id="idealphy-test">
<h4><span class="section-number">30.3.4. </span>IdealPhy test<a class="headerlink" href="#idealphy-test" title="Link to this heading">¶</a></h4>
<p>The test verifies that <code class="docutils literal notranslate"><span class="pre">AlohaNoackNetDevice</span></code> and
<code class="docutils literal notranslate"><span class="pre">HalfDuplexIdealPhy</span></code> work properly when installed in a node. The
test recreates a scenario with two nodes (a TX and a RX) affected by a path loss such
that a certain SNR is obtained. The TX node transmits with a
pre-determined PHY rate and with an application layer rate which is
larger than the PHY rate, so as to saturate the
channel. <code class="docutils literal notranslate"><span class="pre">PacketSocket</span></code> is used in order to avoid protocol
overhead. Different
test cases correspond to different PHY rate and SNR values. For each
test case, we calculated offline (using Shannon’s formula) whether
the PHY rate is achievable or not. Each test case passes if the
following conditions are satisfied:</p>
<blockquote>
<div><ul class="simple">
<li><p>if the PHY rate is achievable, the application throughput shall be within
<img class="math" src="_images/math/db747a742f16f548182e8483e6603e72bc887b78.png" alt="1\%"/> of the PHY rate;</p></li>
<li><p>if the PHY rate is not achievable, the application throughput shall
be zero.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="additional-models">
<h3><span class="section-number">30.4. </span>Additional Models<a class="headerlink" href="#additional-models" title="Link to this heading">¶</a></h3>
<section id="tv-transmitter-model">
<h4><span class="section-number">30.4.1. </span>TV Transmitter Model<a class="headerlink" href="#tv-transmitter-model" title="Link to this heading">¶</a></h4>
<p>A TV Transmitter model is implemented by the <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitter</span></code> class.
This model enables transmission of realistic TV signals to be simulated and can
be used for interference modeling. It provides a customizable power spectral
density (PSD) model, with configurable attributes including the type of
modulation (with models for analog, 8-VSB, and COFDM), signal bandwidth,
power spectral density level, frequency, and transmission duration. A helper
class, <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitterHelper</span></code>, is also provided to assist users in
setting up simulations.</p>
<section id="main-model-class">
<h5><span class="section-number">30.4.1.1. </span>Main Model Class<a class="headerlink" href="#main-model-class" title="Link to this heading">¶</a></h5>
<p>The main TV Transmitter model class, <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitter</span></code>, provides a
user-configurable PSD model that can be transmitted on the <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code>.
It inherits from <code class="docutils literal notranslate"><span class="pre">SpectrumPhy</span></code> and is comprised of attributes and methods to
create and transmit the signal on the channel.</p>
<figure class="align-center" id="id41">
<span id="spectrum-tv-cofdm"></span><img alt="_images/spectrum-tv-cofdm.png" src="_images/spectrum-tv-cofdm.png" />
<figcaption>
<p><span class="caption-text">8K COFDM signal spectrum generated from <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitter</span></code> (Left) and
theoretical COFDM signal spectrum <a class="reference internal" href="index.html#koppcofdm" id="id4"><span>[KoppCOFDM]</span></a> (Right)</span><a class="headerlink" href="#id41" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>One of the user-configurable attributes is the type of modulation for the TV
transmitter to use. The options are 8-VSB (Eight-Level Vestigial Sideband
Modulation) which is notably used in the North America ATSC digital television
standard, COFDM (Coded Orthogonal Frequency Division Multiplexing) which is
notably used in the DVB-T and ISDB-T digital television standards adopted by
various countries around the world, and analog modulation which is a legacy
technology but is still being used by some countries today. To accomplish
realistic PSD models for these modulation types, the signals’ PSDs were
approximated from real standards and developed into models that are scalable by
frequency and power. The COFDM PSD is approximated from Figure 12 (8k mode) of
<a class="reference internal" href="index.html#koppcofdm" id="id5"><span>[KoppCOFDM]</span></a>, the 8-VSB PSD is approximated from Figure 3 of <a class="reference internal" href="index.html#baron8vsb" id="id6"><span>[Baron8VSB]</span></a>, and the
analog PSD is approximated from Figure 4 of <a class="reference internal" href="index.html#qualcommanalog" id="id7"><span>[QualcommAnalog]</span></a>. Note that the
analog model is approximated from the NTSC standard, but other analog modulation
standards such as PAL have similar signals. The approximated COFDM PSD model is
in 8K mode. The other configurable attributes are the start frequency,
signal/channel bandwidth, base PSD, antenna type, starting time,
and transmit duration.</p>
<p><code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitter</span></code> uses <code class="docutils literal notranslate"><span class="pre">IsotropicAntennaModel</span></code> as its antenna model by
default, but any model that inherits from <code class="docutils literal notranslate"><span class="pre">AntennaModel</span></code> is selectable, so
directional antenna models can also be used. The propagation loss models used
in simulation are configured in the <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code> that the user chooses to
use. Terrain and spherical Earth/horizon effects may be supported in future ns-3
propagation loss models.</p>
<p>After the attributes are set, along with the <code class="docutils literal notranslate"><span class="pre">SpectrumChannel</span></code>,
<code class="docutils literal notranslate"><span class="pre">MobilityModel</span></code>, and node locations, the PSD of the TV transmitter signal can
be created and transmitted on the channel.</p>
</section>
<section id="helper-class">
<span id="sec-tv-helper-class"></span><h5><span class="section-number">30.4.1.2. </span>Helper Class<a class="headerlink" href="#helper-class" title="Link to this heading">¶</a></h5>
<p>The helper class, <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitterHelper</span></code>, consists of features to
assist users in setting up TV transmitters for their simulations. Functionality
is also provided to easily simulate real-world scenarios.</p>
<figure class="align-center" id="id42">
<span id="spectrum-tv-8vsb"></span><img alt="_images/spectrum-tv-8vsb.png" src="_images/spectrum-tv-8vsb.png" />
<figcaption>
<p><span class="caption-text">North America ATSC channel 19 &amp; 20 signals generated using
<code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitterHelper</span></code> (Left) and theoretical 8-VSB signal
<a class="reference internal" href="index.html#baron8vsb" id="id8"><span>[Baron8VSB]</span></a> (Right). Note that the theoretical signal is not shown in dB
while the ns-3 generated signals are.</span><a class="headerlink" href="#id42" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Using this helper class, users can easily set up TV transmitters right after
configuring attributes. Multiple transmitters can be created at a time. Also
included are real characteristics of specific geographic regions that can be
used to run realistic simulations. The regions currently included are
North America, Europe, and Japan. The frequencies and bandwidth of each TV
channel for each these regions are provided.</p>
<figure class="align-center" id="id43">
<span id="spectrum-tv-rand-geo-points"></span><img alt="_images/spectrum-tv-rand-geo-points.png" src="_images/spectrum-tv-rand-geo-points.png" />
<figcaption>
<p><span class="caption-text">Plot from MATLAB implementation of CreateRegionalTvTransmitters method in
<code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitterHelper</span></code>. Shows 100 random points on Earth’s surface
(with altitude 0) corresponding to TV transmitter locations within a 2000 km
radius of 35° latitude and -100° longitude.</span><a class="headerlink" href="#id43" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>A method (CreateRegionalTvTransmitters) is provided that enables users to
randomly generate multiple TV transmitters from a specified region with a given
density within a chosen radius around a point on Earth’s surface. The region,
which determines the channel frequencies of the generated TV transmitters, can
be specified to be one of the three provided, while the density determines the
amount of transmitters generated. The TV transmitters’ antenna heights
(altitude) above Earth’s surface can also be randomly generated to be within a
given maximum altitude. This method models Earth as a perfect sphere, and
generated location points are referenced accordingly in Earth-Centered
Earth-Fixed Cartesian coordinates. Note that bodies of water on Earth are not
considered in location point generation–TV transmitters can be generated
anywhere on Earth around the origin point within the chosen maximum radius.</p>
</section>
<section id="id9">
<h5><span class="section-number">30.4.1.3. </span>Examples<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h5>
<p>Two example simulations are provided that demonstrate the functionality of the
TV transmitter model. <code class="docutils literal notranslate"><span class="pre">tv-trans-example</span></code> simulates two 8-VSB TV transmitters
with adjacent channel frequencies. <code class="docutils literal notranslate"><span class="pre">tv-trans-regional-example</span></code> simulates
randomly generated COFDM TV transmitters (modeling the DVB-T standard)
located around the Paris, France area with channel frequencies and bandwidths
corresponding to the European television channel allocations.</p>
</section>
<section id="id10">
<h5><span class="section-number">30.4.1.4. </span>Testing<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">tv-spectrum-transmitter</span></code> test suite verifies the accuracy of the
spectrum/PSD model in <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitter</span></code> by testing if the maximum power
spectral density, start frequency, and end frequency comply with expected values
for various test cases.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tv-helper-distribution</span></code> test suite verifies the functionality of the
method in <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitterHelper</span></code> that generates a random number of TV
transmitters based on the given density (low, medium, or high) and maximum
number of TV channels. It verifies that the number of TV transmitters generated
does not exceed the expected bounds.</p>
<p>The CreateRegionalTvTransmitters method in <code class="docutils literal notranslate"><span class="pre">TvSpectrumTransmitterHelper</span></code>
described in <a class="reference internal" href="#sec-tv-helper-class"><span class="std std-ref">Helper Class</span></a> uses two methods from the
<code class="docutils literal notranslate"><span class="pre">GeographicPositions</span></code> class in the Mobility module to generate the random
Cartesian points on or above earth’s surface around an origin point which
correspond to TV transmitter positions. The first method converts Earth
geographic coordinates to Earth-Centered Earth-Fixed (ECEF) Cartesian
coordinates, and is tested in the <code class="docutils literal notranslate"><span class="pre">geo-to-cartesian</span></code> test suite by comparing
(with 10 meter tolerance) its output with the output of the geographic to ECEF
conversion function <a class="reference internal" href="index.html#matlabgeo" id="id11"><span>[MatlabGeo]</span></a> of the MATLAB Mapping Toolbox for numerous
test cases. The other used method generates random ECEF Cartesian points around
the given geographic origin point, and is tested in the <code class="docutils literal notranslate"><span class="pre">rand-cart-around-geo</span></code>
test suite by verifying that the generated points do not exceed the given
maximum distance radius from the origin point.</p>
</section>
</section>
<section id="gpp-tr-38-901-fast-fading-model">
<span id="gpp-fast-fading-model"></span><h4><span class="section-number">30.4.2. </span>3GPP TR 38.901 fast fading model<a class="headerlink" href="#gpp-tr-38-901-fast-fading-model" title="Link to this heading">¶</a></h4>
<p>The framework described by TR 38.901 <a class="reference internal" href="index.html#tr38901" id="id12"><span>[TR38901]</span></a> is a 3D statistical Spatial
Channel Model supporting different propagation environments (e.g., urban,
rural, indoor), multi-antenna operations and the modeling of wireless channels
between 0.5 and 100 GHz.
The overall channel is represented by the matrix <img class="math" src="_images/math/b4db224ff96ddbaef4e281b74893a8a4faf763ea.png" alt="H(t,\tau)"/>, in which each
entry H <sub>u,s</sub> <img class="math" src="_images/math/b45fb41b4735b72ad32163e8a30338c79a0ab096.png" alt="(t,\tau)"/> corresponds to the impulse response of the channel between the
s-th element of the transmitting antenna and the u-th element of the receiving
antenna. H <sub>u,s</sub> <img class="math" src="_images/math/b45fb41b4735b72ad32163e8a30338c79a0ab096.png" alt="(t,\tau)"/> is generated by the superposition of N different multi-path
components, called clusters, each of which composed of M different rays.
The channel matrix generation procedure accounts for large and small scale
propagation phenomena. The classes ThreeGppSpectrumPropagationLossModel and
ThreeGppChannelModel included in the spectrum module takes care of the generation
of the channel coefficients and the computation of the frequency-dependent
propagation loss.</p>
<section id="implementation">
<h5><span class="section-number">30.4.2.1. </span>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h5>
<p>Our implementation is described in <a class="reference internal" href="index.html#zugno" id="id13"><span>[Zugno]</span></a>. It is based on the model described
in <a class="reference internal" href="index.html#zhang" id="id14"><span>[Zhang]</span></a>, but the code has been refactored, extended, and aligned to TR 38.901
<a class="reference internal" href="index.html#tr38901" id="id15"><span>[TR38901]</span></a>.
The fundamental assumption behind this model is the channel reciprocity, i.e.,
the impulse response of the channel between node a and node b is the same as
between node b and node a.
To deal with the equivalence of the channel between a and b, no matter who is
the transmitter and who is the receiver, the model considers the pair of nodes
to be composed by one “s” and one “u” node. The channel matrix, as well as other
parameters, are saved and used under the assumption that, within a pair, the
definition of the “s” and “u” node will always be the same. For more details,
please have a look at the documentation of the classes
ThreeGppChannelModel and ThreeGppSpectrumPropagationLossModel.</p>
<p><strong>Note:</strong></p>
<blockquote>
<div><ul>
<li><p>Currently, no error model is provided; a link-to-system campaign may be
needed to incorporate it in existing modules.</p></li>
<li><p>The model does not include any spatial consistency update procedure
(see <a class="reference internal" href="index.html#tr38901" id="id16"><span>[TR38901]</span></a>, Sec. 7.6.1). The implementation of this feature is left
as future work.</p></li>
<li><p>Issue regarding the blockage model: according to 3GPP TR 38.901 v15.0.0
(2018-06) section 7.6.4.1, the blocking region for self-blocking is provided
in LCS.</p>
<p>However, here, clusterAOA and clusterZOA are in GCS and blocking check is
performed for self-blocking similar to non-self blocking, that is in GCS.
One would expect the angles to be transposed to LCS before checking
self-blockage.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="threegppspectrumpropagationlossmodel">
<h5><span class="section-number">30.4.2.2. </span>ThreeGppSpectrumPropagationLossModel<a class="headerlink" href="#threegppspectrumpropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>The class ThreeGppSpectrumPropagationLossModel implements the
PhasedArraySpectrumPropagationLossModel interface and enables the modeling of frequency
dependent propagation phenomena while taking into account the specific pair of the
phased antenna array at the transmitter and the receiver. The main method is
DoCalcRxPowerSpectralDensity, which takes as input the power spectral density (PSD)
of the transmitted signal, the mobility models of the transmitting node and receiving node,
and the phased antenna array of the transmitting node, and of the receiving node.
Finally, it returns the PSD of the received signal.</p>
<p>Procedure used to compute the PSD of to compute the PSD of the received signal:</p>
<p>1. Retrieve the beamforming vectors
To account for the beamforming, ThreeGppSpectrumPropagationLossModel has to
retrieve the beamforming vectors of the transmitting and receiving antennas.
The method DoCalcRxPowerSpectralDensity uses the antenna objects
that are passed as parameters for both the transmitting and receiving devices,
and calls the method GetCurrentBeamformingVector to retrieve the beamforming vectors
of these antenna objects.</p>
<p>2. Retrieve the channel matrix and the channel params
The ThreeGppSpectrumPropagationLossModel relies on the ThreeGppChannelModel class
to obtain the channel matrix and channel parameters.
In particular, it makes use of the method GetChannel,
which returns a ChannelMatrix object containing the channel
matrix, the generation time, the node pair, and the phased antenna array pair among
which is created this channel matrix.
Apart from the function GetChannel, there is a function called GetParams which
returns a ChannelParams object containing the channel parameters.
Notice that the channel information is split into these two structures
(ChannelMatrix and ChannelParams) to support multiple collocate phased antenna arrays at
TX/RX node. ChannelParams (also its specialization ThreeGppChannelParams structure)
contains parameters which are common for all channels among
the same RX/TX node pair, while ChannelMatrix contains the channel matrix for the specific pair
of the phased antenna arrays of TX/RX nodes.
For example, if the TX and the RX node have multiple collocated antenna arrays,
then there will be multiple channel matrices among this pair of nodes for different pairs
of antenna arrays of the TX and the RX node.
These channel matrices that are among the same pair of nodes have common channel parameters,
i.e., they share the same channel condition, cluster powers, cluster delays,
AoD, AoA, ZoD, ZoA, K_factor, delay spread, etc.
On the other hand, each pair of TX and RX antenna arrays has a specific channel matrix
and fading, which depends on the actual antenna element positions and field patterns of
each pair of antennas array subpartitions.
The ThreeGppChannelModel instance is automatically
created in the the ThreeGppSpectrumPropagationLossModel constructor and it can
be configured using the method SetChannelModelAttribute ().</p>
<p>Notice that in MultiModelSpectrumChannel in StartTx function we added a
condition that checks whether the TX/RX SpectrumPhy instances belong to different
TX/RX nodes. This is needed to avoid pathloss models calculations among
the phased antenna arrays of the same node, because there are no models yet
in ns-3 that support the calculation of this kind of interference.</p>
<p>4. Compute the long term component
The method GetLongTerm returns the long term component obtained by multiplying
the channel matrix and the beamforming vectors. To reduce the computational
load, the long term components associated to the different channels are
stored in the m_longTermMap and recomputed only if the associated channel
matrix is updated or if the transmitting and/or receiving beamforming vectors
have changed. Given the channel reciprocity assumption, for each node pair a
single long term component is saved in the map.</p>
<p>5. Apply the small scale fading and compute the channel gain
The method CalcBeamformingGain computes the channel gain in each sub-band and
applies it to the PSD of the transmitted signal to obtain the received PSD.
To compute the sub-band gain, it accounts for the Doppler phenomenon and the
time dispersion effect on each cluster.
In order to reduce the computational load, the Doppler component of each
cluster is computed considering only the central ray.
Also, as specified <a class="reference internal" href="index.html#sec-3gpp-v2v-ff"><span class="std std-ref">here</span></a>, it is possible to account for
the effect of environmental scattering following the model described in Sec. 6.2.3
of 3GPP TR 37.885.
This is done by deviating the Doppler frequency by a random value, whose
distribution depends on the parameter <img class="math" src="_images/math/44218e075ff340d5528d65b5bc8562c93aa700e3.png" alt="v_{scatt}"/>.
The value of <img class="math" src="_images/math/44218e075ff340d5528d65b5bc8562c93aa700e3.png" alt="v_{scatt}"/> can be configured using the attribute “vScatt”
(by default it is set to 0, so that the scattering effect is not considered).</p>
</section>
<section id="threegppchannelmodel">
<h5><span class="section-number">30.4.2.3. </span>ThreeGppChannelModel<a class="headerlink" href="#threegppchannelmodel" title="Link to this heading">¶</a></h5>
<p>The class ThreeGppChannelModel implements the channel matrix generation procedure
described in Sec. of <a class="reference internal" href="index.html#tr38901" id="id17"><span>[TR38901]</span></a>.
The main method is GetChannel, which takes as input the mobility models of
the transmitter and receiver nodes, the associated antenna objects,
and returns a ChannelMatrix object containing:</p>
<ul class="simple">
<li><p>the channel matrix of size UxSxN, where U is the number of receiving antenna elements, S is the number of transmitting antenna elements and N is the number of clusters</p></li>
<li><p>the clusters delays, as an array of size N</p></li>
<li><p>the clusters arrival and departure angles, as a 2D array in which each row corresponds to a direction (AOA, ZOA, AOD, ZOD) and each column corresponds to a different cluster</p></li>
<li><p>a time stamp indicating the time at which the channel matrix was generated</p></li>
<li><p>the node IDs</p></li>
<li><p>other channel parameters</p></li>
</ul>
<p>The ChannelMatrix objects are saved
in the map m_channelMap and updated when the coherence time
expires, or in case the LOS/NLOS channel condition changes.
The coherence time can be configured through
the attribute “UpdatePeriod”, and should be chosen by taking into account all the
factors that affects the channel variability, such as mobility, frequency,
propagation scenario, etc. By default, it is set to 0, which means that the
channel is recomputed only when the LOS/NLOS condition changes.
It is possible to configure the propagation scenario and the operating frequency
of interest through the attributes “Scenario” and “Frequency”, respectively.</p>
<p><strong>Blockage model:</strong> 3GPP TR 38.901 also provides an optional
feature that can be used to model the blockage effect due to the
presence of obstacles, such as trees, cars or humans, at the level
of a single cluster. This differs from a complete blockage, which
would result in an LOS to NLOS transition. Therefore, when this
feature is enabled, an additional attenuation is added to certain
clusters, depending on their angle of arrival. There are two possi-
ble methods for the computation of the additional attenuation, i.e.,
stochastic (Model A) and geometric (Model B). In this work, we
used the implementation provided by <a class="reference internal" href="index.html#zhang" id="id18"><span>[Zhang]</span></a>, which
uses the stochastic method. In particular, the model is implemented by the
method CalcAttenuationOfBlockage, which computes the additional attenuation.
The blockage feature can be disable through the attribute “Blockage”. Also, the
attributes “NumNonselfBlocking”, “PortraitMode” and “BlockerSpeed” can be used
to configure the model.</p>
</section>
<section id="id19">
<h5><span class="section-number">30.4.2.4. </span>Testing<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h5>
<p>The test suite ThreeGppChannelTestSuite includes three test cases:</p>
<ul>
<li><p>ThreeGppChannelMatrixComputationTest checks if the channel matrix has the
correct dimensions and if it correctly normalized</p></li>
<li><p>ThreeGppChannelMatrixUpdateTest, which checks if the channel matrix
is correctly updated when the coherence time exceeds</p></li>
<li><p>ThreeGppSpectrumPropagationLossModelTest, which tests the functionalities
of the class ThreeGppSpectrumPropagationLossModel. It builds a simple
network composed of two nodes, computes the power spectral density
received by the receiving node, and</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Checks if the long term components for the direct and
the reverse link are the same,</p></li>
<li><p>Checks if the long term component is updated when changing
the beamforming vectors,</p></li>
<li><p>Checks if the long term is updated when changing the channel matrix</p></li>
</ol>
</div></blockquote>
</li>
</ul>
<p><strong>Note:</strong> TR 38.901 includes a calibration procedure that can be used to validate
the model, but it requires some additional features which are not currently
implemented, thus is left as future work.</p>
</section>
<section id="id20">
<h5><span class="section-number">30.4.2.5. </span>References<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="baron8vsb" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Baron8VSB<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id8">2</a>)</span>
<p>Baron, Stanley. “First-Hand:Digital Television: The Digital
Terrestrial Television Broadcasting (DTTB) Standard.” IEEE Global History
Network. &lt;http://www.ieeeghn.org/wiki/index.php/First-Hand:Digital_Television:_The_Digital_Terrestrial_Television_Broadcasting_(DTTB)_Standard&gt;.</p>
</div>
<div class="citation" id="koppcofdm" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>KoppCOFDM<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>Kopp, Carlo. “High Definition Television.” High Definition
Television. Air Power Australia. &lt;<a class="reference external" href="http://www.ausairpower.net/AC-1100.html">http://www.ausairpower.net/AC-1100.html</a>&gt;.</p>
</div>
<div class="citation" id="matlabgeo" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">MatlabGeo</a><span class="fn-bracket">]</span></span>
<p>“Geodetic2ecef.” Convert Geodetic to Geocentric (ECEF)
Coordinates. The MathWorks, Inc.
&lt;<a class="reference external" href="http://www.mathworks.com/help/map/ref/geodetic2ecef.html">http://www.mathworks.com/help/map/ref/geodetic2ecef.html</a>&gt;.</p>
</div>
<div class="citation" id="qualcommanalog" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">QualcommAnalog</a><span class="fn-bracket">]</span></span>
<p>Stephen Shellhammer, Ahmed Sadek, and Wenyi Zhang.
“Technical Challenges for Cognitive Radio in the TV White Space Spectrum.”
Qualcomm Incorporated.</p>
</div>
<div class="citation" id="tr38901" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>TR38901<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id12">1</a>,<a role="doc-backlink" href="#id15">2</a>,<a role="doc-backlink" href="#id16">3</a>,<a role="doc-backlink" href="#id17">4</a>,<a role="doc-backlink" href="#id21">5</a>,<a role="doc-backlink" href="#id24">6</a>,<a role="doc-backlink" href="#id29">7</a>,<a role="doc-backlink" href="#id32">8</a>,<a role="doc-backlink" href="#id33">9</a>,<a role="doc-backlink" href="#id34">10</a>,<a role="doc-backlink" href="#id35">11</a>)</span>
<p>3GPP. 2018. TR 38.901. Study on channel for frequencies from 0.5 to
100 GHz. V.15.0.0. (2018-06).</p>
</div>
<div class="citation" id="zhang" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Zhang<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id14">1</a>,<a role="doc-backlink" href="#id18">2</a>)</span>
<p>Menglei Zhang, Michele Polese, Marco Mezzavilla, Sundeep Rangan,
Michele Zorzi. “ns-3 Implementation of the 3GPP MIMO Channel Model for
Frequency Spectrum above 6 GHz”. In Proceedings of the Workshop on ns-3
(WNS3 ‘17). 2017.</p>
</div>
<div class="citation" id="zugno" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">Zugno</a><span class="fn-bracket">]</span></span>
<p>Tommaso Zugno, Michele Polese, Natale Patriciello, Biljana Bojovic,
Sandra Lagen, Michele Zorzi. “Implementation of a Spatial Channel Model for
ns-3”. Submitted to the Workshop on ns-3 (WNS3 ‘20). 2020.
Available: <a class="reference external" href="https://arxiv.org/abs/2002.09341">https://arxiv.org/abs/2002.09341</a></p>
</div>
</div>
</section>
</section>
<section id="two-ray-fading-model">
<h4><span class="section-number">30.4.3. </span>Two-Ray fading model<a class="headerlink" href="#two-ray-fading-model" title="Link to this heading">¶</a></h4>
<p>The model aims to provide a performance-oriented alternative to the 3GPP TR 38.901
framework <a class="reference internal" href="index.html#tr38901" id="id21"><span>[TR38901]</span></a> which is implemented in the <code class="docutils literal notranslate"><span class="pre">ThreeGppSpectrumPropagationLossModel</span></code> and
<code class="docutils literal notranslate"><span class="pre">ThreeGppChannelModel</span></code> classes and whose implementation is described in <a class="reference internal" href="index.html#zugno2020" id="id22"><span>[Zugno2020]</span></a>.
The overall design follows the general approach of <a class="reference internal" href="index.html#polese2018" id="id23"><span>[Polese2018]</span></a>, with aim of providing
the means for computing a 3GPP TR 38.901-like end-to-end channel gain by combining
several statistical terms. The frequency range of applicability is the same as
that of <a class="reference internal" href="index.html#tr38901" id="id24"><span>[TR38901]</span></a>, i.e., 0.5 - 100 GHz.</p>
<section id="use-cases">
<h5><span class="section-number">30.4.3.1. </span>Use-cases<a class="headerlink" href="#use-cases" title="Link to this heading">¶</a></h5>
<p>The use-cases for this channel model comprise large-scale MIMO simulations involving a high
number of nodes (100+), such as multi-cell LTE and 5G deployments in dense urban areas, for which
the full 3GPP TR 38.901 does not represent a viable option.</p>
</section>
<section id="implementation-tworayspectrumpropagationlossmodel">
<h5><span class="section-number">30.4.3.2. </span>Implementation - <code class="docutils literal notranslate"><span class="pre">TwoRaySpectrumPropagationLossModel</span></code><a class="headerlink" href="#implementation-tworayspectrumpropagationlossmodel" title="Link to this heading">¶</a></h5>
<p>The computation of the channel gain is taken care of by the <code class="docutils literal notranslate"><span class="pre">TwoRaySpectrumPropagationLossModel</span></code>
class. In particular, the latter samples a statistical term which combines:</p>
<ul class="simple">
<li><p>The array and beamforming gain, computed as outlined in <a class="reference internal" href="index.html#rebato2018" id="id25"><span>[Rebato2018]</span></a> using the
<code class="docutils literal notranslate"><span class="pre">CalcBeamformingGain</span></code> function. This term supports the presence of multiple
antenna elements both at the transmitter and at the receiver and arbitrary antenna
radiation patterns. Specifically, the array gain is compute as:</p></li>
</ul>
<div class="math">
<p><img src="_images/math/e26fd6d9c5ee2cbb335e965d715b9a07a694cb9f.png" alt="G_{\mathrm{AA}}(\theta, \varphi)=\left|\boldsymbol{a}^{\mathrm{T}}(\theta, \varphi)
\boldsymbol{w}\left(\theta_0, \varphi_0\right)\right|^2=\left|\mathrm{AF}_{\mathrm{v}}(\theta,
\varphi)\right|^2\left|\mathrm{AF}_{\mathrm{h}}(\theta, \varphi)\right|^2 G(\theta, \varphi),"/></p>
</div><p>where:</p>
<div class="math">
<p><img src="_images/math/7beca67d690f30abff5728ce522365b10979694d.png" alt="\operatorname{AF}_{\mathrm{v}}(\theta, \varphi)=\frac{1}{\sqrt{N_{\mathrm{v}}}}
\sum_{m=0}^{N_{\mathrm{v}}-1} e^{j k d_{\mathrm{v}} m\left(\cos \theta-\cos \theta_0\right)}"/></p>
</div><p>and:</p>
<div class="math">
<p><img src="_images/math/0dffef7b4577ab6ca82c4537eea3d0d0ce1a9dc8.png" alt="\operatorname{AF}_{\mathrm{h}}(\theta, \varphi)=\frac{1}{\sqrt{N_{\mathrm{h}}}}
\sum_{n=0}^{N_{\mathrm{h}}-1} e^{j k d_{\mathrm{h}} n\left(\sin \theta
\sin \varphi-\sin \theta_0 \sin \varphi_0\right)}"/></p>
</div><p>In turn, <img class="math" src="_images/math/03cc80dc71b6a17b84b092d0115b07c4afa5b29a.png" alt="N_h"/>, <img class="math" src="_images/math/6c038ecad945fdd2cf11beb34d0beb5527bd5118.png" alt="N_v"/> are the number of horizontal and vertical antenna
elements respectively, <img class="math" src="_images/math/4f8bce6a8ff24ab905d397e289b532267a7cc402.png" alt="d_h"/>, <img class="math" src="_images/math/0bb20e2f6671bc3f6732605a56c0d6f32cf4a77e.png" alt="d_v"/> are the element spacing in the
horizontal and vertical direction respectively. The figures below depict the resulting
array radiation pattern versus the relative azimuth of transmitter and receiver, for antenna
arrays featuring 3GPP TR 38.901 (<code class="docutils literal notranslate"><span class="pre">ThreeGppAntennaModel</span></code>, top) and isotropic
(<code class="docutils literal notranslate"><span class="pre">IsotropicAntennaModel</span></code>, bottom) antenna elements, respectively.
These figures match the corresponding plots of <a class="reference internal" href="index.html#asplund" id="id26"><span>[Asplund]</span></a>.</p>
<figure class="align-center" id="id44">
<span id="fig-two-ray-spectrum-loss-model-3gpp-radiation-pattern"></span><a class="reference internal image-reference" href="_images/two-ray-spectrum-loss-model-3gpp-radiation-pattern.png"><img alt="_images/two-ray-spectrum-loss-model-3gpp-radiation-pattern.png" src="_images/two-ray-spectrum-loss-model-3gpp-radiation-pattern.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text">Radiation pattern produced by the <code class="docutils literal notranslate"><span class="pre">CalcBeamformingGain</span></code> method when using
antenna arrays featuring <code class="docutils literal notranslate"><span class="pre">ThreeGppAntennaModel</span></code> antenna elements, for various
Uniform Planar Array (UPA) configurations.</span><a class="headerlink" href="#id44" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id45">
<span id="fig-two-ray-spectrum-loss-model-iso-radiation-pattern"></span><a class="reference internal image-reference" href="_images/two-ray-spectrum-loss-model-iso-radiation-pattern.png"><img alt="_images/two-ray-spectrum-loss-model-iso-radiation-pattern.png" src="_images/two-ray-spectrum-loss-model-iso-radiation-pattern.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text">Radiation pattern produced by the <code class="docutils literal notranslate"><span class="pre">CalcBeamformingGain</span></code> method when using
antenna arrays featuring <code class="docutils literal notranslate"><span class="pre">IsotropicAntennaModel</span></code> antenna elements, for various
Uniform Planar Array (UPA) configurations.</span><a class="headerlink" href="#id45" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Whenever the link is in NLOS, a penalty factor is introduced, to account for beam
misalignment due to the lack of a dominant multipath component <a class="reference internal" href="index.html#kulkarni" id="id27"><span>[Kulkarni]</span></a>.</p>
<ul class="simple">
<li><p>A fast fading term, sampled using the Fluctuating Two Ray (FTR) model distribution <a class="reference internal" href="index.html#romero" id="id28"><span>[Romero]</span></a>.
The latter is a fading model which is more general than typical ones, taking into account two
dominant specular components and a mixture of scattered paths. As, a consequence it has
been shown to provide a better fit to fading phenomena at mmWaves. The model parameters
are automatically picked once the simulation scenario is set, using a lookup table which
associates the simulation parameters (such as carrier frequency and LOS condition) to the
FTR parameters providing the best fit to the corresponding TR 38.901 channel statistics.
As a consequence, this channel model can be used for all the frequencies which are
supported by the 38.901 model, i.e., 0.5-100 GHz. The calibration has been done by
first obtaining the statistics of the channel gain due to the small-scale fading in
the 3GPP model, using an ad hoc simulation script
(<code class="docutils literal notranslate"><span class="pre">src/spectrum/examples/three-gpp-two-ray-channel-calibration.cc</span></code>). Then, this information
has been used as a reference to estimate the FTR parameters yielding the closest
(in a goodness-of-fit sense) fading realizations, using a custom Python script
(<code class="docutils literal notranslate"><span class="pre">src/spectrum/utils/two-ray-to-three-gpp-ch-calibration.py</span></code>).</p></li>
</ul>
<p><strong>Note:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>To then obtain a full channel model characterization, the model is intended to be
used in conjunction of the path loss and shadowing capability provided by the
<code class="docutils literal notranslate"><span class="pre">ThreeGppPropagationLossModel</span></code> class.
Indeed, the goal of this model is to provide channel realizations which are as close
as possible to ones of <a class="reference internal" href="index.html#tr38901" id="id29"><span>[TR38901]</span></a>, but at a fraction of the complexity. Since the
path loss and shadowing terms are not computationally demanding anyway, the ones of
<a class="reference internal" href="index.html#zugno2020" id="id30"><span>[Zugno2020]</span></a> have been kept;</p></li>
<li><p>Currently, the value of NLoS beamforming factor penalty factor is taken from
the preliminary work of <a class="reference internal" href="index.html#kulkarni" id="id31"><span>[Kulkarni]</span></a> and it is scenario-independent; As future
work, the possibility of using scenario-dependent penalty factors will be
investigated.</p></li>
</ul>
</div></blockquote>
</section>
<section id="calibration">
<h5><span class="section-number">30.4.3.3. </span>Calibration<a class="headerlink" href="#calibration" title="Link to this heading">¶</a></h5>
<p>The purpose of the calibration procedures is to compute offline a look-up table which
associates the FTR fading model parameters with the simulation parameters.
In particular, the <a class="reference internal" href="index.html#tr38901" id="id32"><span>[TR38901]</span></a> fading distributions depend on:</p>
<ul class="simple">
<li><p>The scenario (RMa, UMa, UMi-StreetCanyon, InH-OfficeOpen, InH-OfficeMixed);</p></li>
<li><p>The LOS condition (LoS/NLoS); and</p></li>
<li><p>The carrier frequency.</p></li>
</ul>
<p>As a consequence, the calibration output is a map which associates LoS condition and
scenario to a list of carrier frequency-FTR parameters values. The latter represent the
FTR parameters yielding channel realizations which exhibit the closest statistics to <a class="reference internal" href="index.html#tr38901" id="id33"><span>[TR38901]</span></a>.</p>
<p>The actual calibration is a two-step procedure which:</p>
<p>1. First generates reference channel gain curves using the
<code class="docutils literal notranslate"><span class="pre">src/spectrum/examples/three-gpp-two-ray-channel-calibration.cc</span></code> simulation script.
Specifically, the script samples <code class="docutils literal notranslate"><span class="pre">numRealizations</span></code> channel realizations and computes for each of them
the end-to-end channel gain by setting the speed of the TX and RX pair to <img class="math" src="_images/math/31fdf41b39df23c95e52c5aef07f59d9adf82f3c.png" alt="0"/>, disabling the shadowing
and fixing the LOS condition. In such a way, any variation around the mean is due to the small-scale fading only.
The channel gain samples are produced, and returned on output conditioned on the value of
<code class="docutils literal notranslate"><span class="pre">enableOutput</span></code>, for each combination of LoS condition, channel model scenario and carrier frequency. The
latter cover the whole <a class="reference internal" href="index.html#tr38901" id="id34"><span>[TR38901]</span></a> frequency range of 0.5 - 100 GHz with a relatively sparse resolution
(500 MHz), since the dependency of the fading distribution with respect to the carrier frequency is actually
relatively weak.</p>
<figure class="align-center" id="id46">
<span id="fig-three-gpp-gain-reference-gain-vs-fc"></span><a class="reference internal image-reference" href="_images/three-gpp-gain-reference-gain-vs-fc.png"><img alt="_images/three-gpp-gain-reference-gain-vs-fc.png" src="_images/three-gpp-gain-reference-gain-vs-fc.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text">Empirical CDF of the reference channel gains obtained using the  <code class="docutils literal notranslate"><span class="pre">three-gpp-two-ray-channel-calibration</span></code>
simulation script when keeping a fixed LoS condition and channel scenario and varying the carrier
frequency only.</span><a class="headerlink" href="#id46" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>2. Then, the output of the above script is parsed by the <code class="docutils literal notranslate"><span class="pre">two-ray-to-three-gpp-ch-calibration.py</span></code>
Python companion script. In particular, reference ECDFs are obtained from the channel gains sampled using the
model of <a class="reference internal" href="index.html#tr38901" id="id35"><span>[TR38901]</span></a>. In turn, the reference ECDFs (one for each LoS condition, channel model scenario
and carrier frequency combination) are compared to FTR distributions ECDFs obtained using different values
of the parameters. Finally, the parameters which provide the best fit (in a goodness-of-fit sense) for
the specific scenario, LOS condition and carrier frequency are found. The parameters to test are picked initially
by performing an exhaustive search within a discrete grid of possible values, and then by iteratively refining
the previous search runs by scanning the neighborhood of the most recent identified values.
In such regard, the Anderson-Darling statistical test is used to rank the various FTR distributions
and eventually pick the one providing the closest approximation to the reference statistics.</p>
</section>
<section id="id36">
<h5><span class="section-number">30.4.3.4. </span>Testing<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h5>
<p>The test suite <code class="docutils literal notranslate"><span class="pre">TwoRaySplmTestSuite</span></code> includes three test cases:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FtrFadingModelAverageTest</span></code>, which checks that the average of the Fluctuating Two Ray (FTR)
fading model realizations is consistent with the theoretical value provided in <a class="reference internal" href="index.html#romero" id="id37"><span>[Romero]</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayResponseTest</span></code>, which checks that the overall array response at boresight computed by the ù
<code class="docutils literal notranslate"><span class="pre">CalcBeamformingGain</span></code> function coincides with the expected theoretical values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OverallGainAverageTest</span></code>, which checks that the average overall channel gain obtained using the
<code class="docutils literal notranslate"><span class="pre">DoCalcRxPowerSpectralDensity</span></code> method of the <code class="docutils literal notranslate"><span class="pre">TwoRaySpectrumPropagationLossModel</span></code> class is close
(it is, after all, a simplified and performance-oriented model) to the one obtained using
the <code class="docutils literal notranslate"><span class="pre">ThreeGppSpectrumPropagationLossModel</span></code> and <code class="docutils literal notranslate"><span class="pre">ThreeGppChannelModel</span></code> classes.</p></li>
</ul>
</section>
<section id="id38">
<h5><span class="section-number">30.4.3.5. </span>References<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="zugno2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Zugno2020<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id22">1</a>,<a role="doc-backlink" href="#id30">2</a>)</span>
<p>Zugno, Tommaso, Michele Polese, Natale Patriciello, Biljana Bojović,
Sandra Lagen, Michele Zorzi. “Implementation of a spatial channel model for ns-3.”
In Proceedings of the 2020 Workshop on ns-3, pp. 49-56. 2020.</p>
</div>
<div class="citation" id="polese2018" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">Polese2018</a><span class="fn-bracket">]</span></span>
<p>Michele Polese, Michele Zorzi. “Impact of channel models on
the end-to-end performance of mmwave cellular networks”. In: 2018 IEEE 19th
International Workshop on Signal Processing Advances in Wireless Communications
(SPAWC).</p>
</div>
<div class="citation" id="rebato2018" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">Rebato2018</a><span class="fn-bracket">]</span></span>
<p>Rebato, Mattia, Laura Resteghini, Christian Mazzucco, Michele Zorzi.
“Study of realistic antenna patterns in 5G mmWave cellular scenarios”. In: 2018
IEEE International Conference on Communications (ICC).</p>
</div>
<div class="citation" id="romero" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Romero<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id28">1</a>,<a role="doc-backlink" href="#id37">2</a>)</span>
<p>Romero-Jerez, Juan M., F. Javier Lopez-Martinez, José F. Paris,
Andrea J. Goldsmith. “The fluctuating two-ray fading model: Statistical
characterization and performance analysis”. In: IEEE Transactions on Wireless
Communications 16.7 (2017).</p>
</div>
<div class="citation" id="kulkarni" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Kulkarni<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id27">1</a>,<a role="doc-backlink" href="#id31">2</a>)</span>
<p>Kulkarni, Mandar N., Eugene Visotsky, Jeffrey G. Andrews. “Correction
factor for analysis of MIMO wireless networks with highly directional beamforming.”,
IEEE Wireless Communications Letters, 2018</p>
</div>
<div class="citation" id="asplund" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">Asplund</a><span class="fn-bracket">]</span></span>
<p>Asplund, Henrik, David Astely, Peter von Butovitsch, Thomas Chapman,
Mattias Frenne, Farshid Ghasemzadeh, Måns Hagström et al. Advanced Antenna Systems
for 5G Network Deployments: Bridging the Gap Between Theory and Practice.
Academic Press, 2020.</p>
</div>
</div>
</section>
</section>
</section>
</section>
<span id="document-sixlowpan"></span><section id="lowpan-transmission-of-ipv6-packets-over-ieee-802-15-4-networks">
<h2><span class="section-number">31. </span>6LoWPAN: Transmission of IPv6 Packets over IEEE 802.15.4 Networks<a class="headerlink" href="#lowpan-transmission-of-ipv6-packets-over-ieee-802-15-4-networks" title="Link to this heading">¶</a></h2>
<p>This chapter describes the implementation of <em>ns-3</em> model for the
compression of IPv6 packets over IEEE 802.15.4-Based Networks
as specified by <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a> (“Transmission of IPv6 Packets over IEEE 802.15.4 Networks”)
and <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6282.html"><strong>RFC 6282</strong></a> (“Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks”).</p>
<section id="model-description">
<h3><span class="section-number">31.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the sixlowpan module lives in the directory <code class="docutils literal notranslate"><span class="pre">src/sixlowpan</span></code>.</p>
<section id="design">
<h4><span class="section-number">31.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<p>The model design does not follow strictly the standard from an architectural
standpoint, as it does extend it beyond the original scope by supporting also
other kinds of networks.</p>
<p>Other than that, the module strictly follows <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a> and <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6282.html"><strong>RFC 6282</strong></a>, with the
exception that HC2 encoding is not supported, as it has been superseded by IPHC and NHC
compression type (<span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6282.html"><strong>RFC 6282</strong></a>).</p>
<p>IPHC sateful (context-based) compression is supported but, since <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6775.html"><strong>RFC 6775</strong></a>
(“Neighbor Discovery Optimization for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs)”)
is not yet implemented, it is necessary to add the context to the nodes manually.</p>
<p>This is possible though the <code class="docutils literal notranslate"><span class="pre">SixLowPanHelper::AddContext</span></code> function.
Mind that installing different contexts in different nodes will lead to decompression failures.</p>
<section id="netdevice">
<h5><span class="section-number">31.1.1.1. </span>NetDevice<a class="headerlink" href="#netdevice" title="Link to this heading">¶</a></h5>
<p>The whole module is developed as a transparent NetDevice, which can act as a
proxy between IPv6 and any NetDevice (the module has been successfully tested
with PointToPointNedevice, CsmaNetDevice and LrWpanNetDevice).</p>
<p>For this reason, the module implements a virtual NetDevice, and all the calls are passed
without modifications to the underlying NetDevice. The only important difference is in
GetMtu behaviour. It will always return <em>at least</em> 1280 bytes, as is the minimum IPv6 MTU.</p>
<p>The module does provide some attributes and some tracesources.
The attributes are:</p>
<ul class="simple">
<li><p>Rfc6282 (boolean, default true), used to activate HC1 (<span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a>) or IPHC (<span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6282.html"><strong>RFC 6282</strong></a>) compression.</p></li>
<li><p>OmitUdpChecksum (boolean, default true), used to activate UDP checksum compression in IPHC.</p></li>
<li><p>FragmentReassemblyListSize (integer, default 0), indicating the number of packets that can be reassembled at the same time. If the limit is reached, the oldest packet is discarded. Zero means infinite.</p></li>
<li><p>FragmentExpirationTimeout (Time, default 60 seconds), being the timeout to wait for further fragments before discarding a partial packet.</p></li>
<li><p>CompressionThreshold (unsigned 32 bits integer, default 0), minimum compressed payload size.</p></li>
<li><p>ForceEtherType (boolean, default false).</p></li>
<li><p>EtherType (unsigned 16 bits integer, default 0xFFFF), to force a particular L2 EtherType.</p></li>
<li><p>UseMeshUnder (boolean, default false), it enables mesh-under flood routing.</p></li>
<li><p>MeshUnderRadius (unsigned 8 bits integer, default 10), the maximum number of hops that a packet will be forwarded.</p></li>
<li><p>MeshCacheLength (unsigned 16 bits integer, default 10), the length of the cache for each source.</p></li>
<li><p>MeshUnderJitter (ns3::UniformRandomVariable[Min=0.0|Max=10.0]), the jitter in ms a node uses to forward mesh-under packets - used to prevent collisions.</p></li>
</ul>
<p>The CompressionThreshold attribute is similar to Contiki’s SICSLOWPAN_CONF_MIN_MAC_PAYLOAD
option. If a compressed packet size is less than the threshold, the uncompressed version is
used (plus one byte for the correct dispatch header).
This option is useful when a MAC requires a minimum frame size (e.g., ContikiMAC) and the
compression would violate the requirement.</p>
<p>The last two attributes are needed to use the module with a NetDevice other than 802.15.4, as
neither IANA or IEEE did reserve an EtherType for 6LoWPAN. As a consequence there might be a
conflict with the L2 multiplexer/demultiplexer which is based on EtherType. The default
value is 0xFFFF, which is reserved by IEEE (see <a class="reference internal" href="index.html#iana802" id="id1"><span>[IANA802]</span></a> and <a class="reference internal" href="index.html#ethertype" id="id2"><span>[Ethertype]</span></a>).
The default module behaviour is to not change the EtherType, however this would not work with
any NetDevice actually understanding and using the EtherType.</p>
<p>Note that the <cite>ForceEtherType</cite> parameter have also a direct effect on the MAC address kind the
module is expecting to handle:
* ForceEtherType true: Mac48Address (Ethernet, WiFi, etc.).
* ForceEtherType false: Mac16Address or Mac64Address (IEEE 802.15.4).</p>
<p>Note that using 6LoWPAN over any NetDevice other than 802.15.4 will produce valid .pcap files,
but they will not be correctly dissected by Wireshark.
The reason lies on the fact that 6LoWPAN was really meant to be used only over 802.15.4, so
Wireshark dissectors will not even try to decode 6LoWPAN headers on top of protocols other than
802.15.4.</p>
<p>The Trace sources are:</p>
<ul class="simple">
<li><p>Tx - exposing packet (including 6LoWPAN header), SixLoWPanNetDevice Ptr, interface index.</p></li>
<li><p>Rx - exposing packet (including 6LoWPAN header), SixLoWPanNetDevice Ptr, interface index.</p></li>
<li><p>Drop - exposing DropReason, packet (including 6LoWPAN header), SixLoWPanNetDevice Ptr, interface index.</p></li>
</ul>
<p>The Tx and Rx traces are called as soon as a packet is received or sent. The Drop trace is
invoked when a packet (or a fragment) is discarded.</p>
</section>
<section id="mesh-under-routing">
<h5><span class="section-number">31.1.1.2. </span>Mesh-Under routing<a class="headerlink" href="#mesh-under-routing" title="Link to this heading">¶</a></h5>
<p>The module provides a very simple mesh-under routing <a class="reference internal" href="index.html#shelby" id="id3"><span>[Shelby]</span></a>, implemented as a flooding
(a mesh-under routing protocol is a routing system implemented below IP).</p>
<p>This functionality can be activated through the UseMeshUnder attribute and fine-tuned using
the MeshUnderRadius and MeshUnderJitter attributes.</p>
<p>Note that flooding in a PAN generates a lot of overhead, which is often not wanted.
Moreover, when using the mesh-under facility, ALL the packets are sent without acknowledgment
because, at lower level, they are sent to a broadcast address.</p>
<p>At node level, each packet is re-broadcasted if its BC0 Sequence Number is not in the cache of the
recently seen packets. The cache length (by default 10) can be changed through the MeshCacheLength
attribute.</p>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">31.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<section id="context-based-compression">
<h5><span class="section-number">31.1.2.1. </span>Context-based compression<a class="headerlink" href="#context-based-compression" title="Link to this heading">¶</a></h5>
<p>IPHC sateful (context-based) compression is supported but, since <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6775.html"><strong>RFC 6775</strong></a>
(“Neighbor Discovery Optimization for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs)”)
is not yet implemented, it is necessary to add the context to the nodes manually.</p>
</section>
<section id="lowpam-nd">
<h5><span class="section-number">31.1.2.2. </span>6LoWPAM-ND<a class="headerlink" href="#lowpam-nd" title="Link to this heading">¶</a></h5>
<p>Future versions of this module will support <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6775.html"><strong>RFC 6775</strong></a>, however no timeframe is guaranteed.</p>
</section>
<section id="id4">
<h5><span class="section-number">31.1.2.3. </span>Mesh-under routing<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h5>
<p>It would be a good idea to improve the mesh-under flooding by providing the following:</p>
<ul class="simple">
<li><p>Adaptive hop-limit calculation,</p></li>
<li><p>Adaptive forwarding jitter,</p></li>
<li><p>Use of direct (non mesh) transmission for packets directed to 1-hop neighbors.</p></li>
</ul>
</section>
<section id="mixing-compression-types-in-a-pan">
<h5><span class="section-number">31.1.2.4. </span>Mixing compression types in a PAN<a class="headerlink" href="#mixing-compression-types-in-a-pan" title="Link to this heading">¶</a></h5>
<p>The IPv6/MAC addressing scheme defined in <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6282.html"><strong>RFC 6282</strong></a> and <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a> is different.
One adds the PanId in the pseudo-MAC address (4944) and the other doesn’t (6282).</p>
<p>The expected use cases (confirmed by the RFC editor) is to <em>never</em> have a mixed environment
where part of the nodes are using HC1 and part IPHC because this would lead to confusion on
what the IPv6 address of a node is.</p>
<p>Due to this, the nodes configured to use IPHC will drop the packets compressed with HC1
and vice-versa. The drop is logged in the drop trace as <code class="docutils literal notranslate"><span class="pre">DROP_DISALLOWED_COMPRESSION</span></code>.</p>
</section>
<section id="using-6lowpan-with-ipv4-or-other-l3-protocols">
<h5><span class="section-number">31.1.2.5. </span>Using 6LoWPAN with IPv4 (or other L3 protocols)<a class="headerlink" href="#using-6lowpan-with-ipv4-or-other-l3-protocols" title="Link to this heading">¶</a></h5>
<p>As the name implies, 6LoWPAN can handle only IPv6 packets. Any other protocol will be discarded.
Moreover, 6LoWPAN assumes that the network is uniform, as is all the devices connected by the
same same channel are using 6LoWPAN. Mixed environments are not supported by the standard.
The reason is simple: 802.15.4 frame doesn’t have a “protocol” field. As a consequence,
there is no demultiplexing at MAC layer and the protocol carried by L2 frames must be known
in advance.</p>
<p>In the <em>ns-3</em> implementation it is possible, but not advisable, to violate this requirement
if the underlying NetDevice is capable of discriminating different protocols. As an example,
CsmaNetDevice can carry IPv4 and 6LoWPAN at the same time. However, this configuration has
not been tested.</p>
</section>
</section>
<section id="references">
<h4><span class="section-number">31.1.3. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<div role="list" class="citation-list">
<div class="citation" id="iana802" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">IANA802</a><span class="fn-bracket">]</span></span>
<p>IANA, assigned IEEE 802 numbers: <a class="reference external" href="http://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xml">http://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xml</a></p>
</div>
<div class="citation" id="ethertype" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Ethertype</a><span class="fn-bracket">]</span></span>
<p>IEEE Ethertype numbers: <a class="reference external" href="http://standards.ieee.org/develop/regauth/ethertype/eth.txt">http://standards.ieee.org/develop/regauth/ethertype/eth.txt</a></p>
</div>
<div class="citation" id="shelby" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Shelby</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="26">
<li><p>Shelby and C. Bormann, 6LoWPAN: The Wireless Embedded Internet. Wiley, 2011. [Online]. Available: <a class="reference external" href="https://books.google.it/books?id=3Nm7ZCxscMQC">https://books.google.it/books?id=3Nm7ZCxscMQC</a></p></li>
</ol>
</div>
</div>
</section>
</section>
<section id="usage">
<h3><span class="section-number">31.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<section id="enabling-sixlowpan">
<h4><span class="section-number">31.2.1. </span>Enabling sixlowpan<a class="headerlink" href="#enabling-sixlowpan" title="Link to this heading">¶</a></h4>
<p>Add <code class="docutils literal notranslate"><span class="pre">sixlowpan</span></code> to the list of modules built with <em>ns-3</em>.</p>
</section>
<section id="helper">
<h4><span class="section-number">31.2.2. </span>Helper<a class="headerlink" href="#helper" title="Link to this heading">¶</a></h4>
<p>The helper is patterned after other device helpers.</p>
</section>
<section id="examples">
<h4><span class="section-number">31.2.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>The following example can be found in <code class="docutils literal notranslate"><span class="pre">src/sixlowpan/examples/</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">example-sixlowpan.cc</span></code>:  A simple example showing end-to-end data transfer.</p></li>
</ul>
<p>In particular, the example enables a very simplified end-to-end data
transfer scenario, with a CSMA network forced to carry 6LoWPAN compressed packets.</p>
</section>
<section id="tests">
<h4><span class="section-number">31.2.4. </span>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h4>
<p>The test provided checks the connection between two UDP clients and the correctness of the received packets.</p>
</section>
</section>
<section id="validation">
<h3><span class="section-number">31.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>The model has been validated against WireShark, checking whatever the packets are correctly
interpreted and validated.</p>
</section>
</section>
<span id="document-topology"></span><section id="topology-input-readers">
<h2><span class="section-number">32. </span>Topology Input Readers<a class="headerlink" href="#topology-input-readers" title="Link to this heading">¶</a></h2>
<p>The topology modules aim at reading a topology file generated by an automatic topology generator.</p>
<p>The process is divided in two steps:</p>
<ul class="simple">
<li><p>running a topology generator to build a topology file</p></li>
<li><p>reading the topology file and build a ns-3 simulation</p></li>
</ul>
<p>Hence, model is focused on being able to read correctly the various topology formats.</p>
<p>Currently there are three models:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::OrbisTopologyReader</span></code> for <a class="reference external" href="https://web.archive.org/web/20181102004219/http://sysnet.ucsd.edu/~pmahadevan/topo_research/topo.html">Orbis</a> 0.7 traces</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::InetTopologyReader</span></code> for <a class="reference external" href="http://topology.eecs.umich.edu/inet/">Inet</a> 3.0 traces</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::RocketfuelTopologyReader</span></code> for <a class="reference external" href="http://www.cs.washington.edu/research/networking/rocketfuel/">Rocketfuel</a> traces</p></li>
</ul>
<p>An helper <code class="docutils literal notranslate"><span class="pre">ns3::TopologyReaderHelper</span></code> is provided to assist on trivial tasks.</p>
<p>In some cases it might not be simple to identify which <em>ns-3</em> node corresponds to a given node in the
topology file. To simplify this task, each node created by <code class="docutils literal notranslate"><span class="pre">ns3::TopologyReaderHelper</span></code> has a name.
The name format is “&lt;TopologyReader&gt;/NodeName/&lt;label&gt;” where “&lt;TopologyReader&gt;” is either
“InetTopology”, “OrbisTopology”, or “RocketFuelTopology”, and “&lt;label&gt;” is the identifier of the
node in the topology file (can be either a number or a string, depending on the file type).
Assuming that there are 10 nodes, labeled with number starting from 0, the code could be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">nodeNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nodeNumber</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">nodeNumber</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Names</span><span class="p">::</span><span class="n">Find</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;InetTopology/NodeName/&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="p">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">nodeNumber</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Do</span> <span class="n">something</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A good source for topology data is also <a class="reference external" href="http://www.caida.org/projects/ark/">Archipelago</a>.</p>
<p>The current Archipelago <a class="reference external" href="http://data.caida.org/datasets/topology/ipv4.allpref24-aslinks/">Measurements</a>, monthly updated, are stored in the CAIDA website using
a complete notation and triple data source, one for each working group.</p>
<p>A different and more compact notation reporting only the AS-relationships (a sort of more
Orbis-like format) is here: <a class="reference external" href="http://www.caida.org/data/active/as-relationships/index.xml">as-relationships</a>.</p>
<p>The compact notation can be easily stripped down to a pure Orbis format, just removing
the double relationships (the compact format use one-way links, while Orbis use two-way
links) and pruning the 3rd parameter. Note that with the compact data Orbis can then be
used create a rescaled version of the topology, thus being the most effective way
(to my best knowledge) to make an internet-like topology.</p>
<p>Examples can be found in the directory <code class="docutils literal notranslate"><span class="pre">src/topology-read/examples/</span></code></p>
</section>
<span id="document-traffic-control"></span><section id="traffic-control-layer">
<h2><span class="section-number">33. </span>Traffic Control Layer<a class="headerlink" href="#traffic-control-layer" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-traffic-control-layer"></span><section id="traffic-control-layer">
<h3><span class="section-number">33.1. </span>Traffic Control Layer<a class="headerlink" href="#traffic-control-layer" title="Link to this heading">¶</a></h3>
<p>The Traffic Control layer aims at introducing an equivalent of the Linux Traffic
Control infrastructure into ns-3. The Traffic Control layer sits in between
the NetDevices (L2) and any network protocol (e.g. IP). It is in charge of processing
packets and performing actions on them: scheduling, dropping, marking, policing, etc.</p>
<section id="introducing-the-traffic-control-layer">
<h4><span class="section-number">33.1.1. </span>Introducing the Traffic Control Layer<a class="headerlink" href="#introducing-the-traffic-control-layer" title="Link to this heading">¶</a></h4>
<p>The Traffic Control layer intercepts both outgoing packets flowing downwards from
the network layer to the network device and incoming packets flowing in the opposite
direction. Currently, only outgoing packets are processed by the Traffic Control layer.
In particular, outgoing packets are enqueued in a queuing discipline, which can perform
multiple actions on them.</p>
<p>In the following, more details are given about how the Traffic Control layer intercepts
outgoing and incoming packets and, more in general, about how the packets traverse the
network stack.</p>
<section id="transmitting-packets">
<h5><span class="section-number">33.1.1.1. </span>Transmitting packets<a class="headerlink" href="#transmitting-packets" title="Link to this heading">¶</a></h5>
<p>The IPv{4,6} interfaces uses the aggregated object TrafficControlLayer to send
down packets, instead of calling NetDevice::Send() directly. After the analysis
and the process of the packet, when the backpressure mechanism allows it,
TrafficControlLayer will call the Send() method on the right NetDevice.</p>
</section>
<section id="receiving-packets">
<h5><span class="section-number">33.1.1.2. </span>Receiving packets<a class="headerlink" href="#receiving-packets" title="Link to this heading">¶</a></h5>
<p>The callback chain that (in the past) involved IPv{4,6}L3Protocol and NetDevices,
through ReceiveCallback, is extended to involve TrafficControlLayer. When an
IPv{4,6}Interface is added in the IPv{4,6}L3Protocol, the callback chain is
configured to have the following packet exchange:</p>
<p>NetDevice –&gt; Node –&gt; TrafficControlLayer –&gt; IPv{4,6}L3Protocol</p>
</section>
</section>
<section id="brief-description-of-old-node-device-protocol-interactions">
<h4><span class="section-number">33.1.2. </span>Brief description of old node/device/protocol interactions<a class="headerlink" href="#brief-description-of-old-node-device-protocol-interactions" title="Link to this heading">¶</a></h4>
<p>The main question that we would like to answer in the following paragraphs is:
how a ns-3 node can send/receive packets?</p>
<p>If we analyze any example out there, the ability of the node to receive/transmit
packets derives from the interaction of two helper:</p>
<ul class="simple">
<li><p>L2 Helper (something derived from NetDevice)</p></li>
<li><p>L3 Helper (usually from Internet module)</p></li>
</ul>
<section id="l2-helper-main-operations">
<h5><span class="section-number">33.1.2.1. </span>L2 Helper main operations<a class="headerlink" href="#l2-helper-main-operations" title="Link to this heading">¶</a></h5>
<p>Any good L2 Helper will do the following operations:</p>
<ul class="simple">
<li><p>Create n netdevices (n&gt;1)</p></li>
<li><p>Attach a channel between these devices</p></li>
<li><p>Call Node::AddDevice ()</p></li>
</ul>
<p>Obviously the last point is the most important.</p>
<p>Node::AddDevice (network/model/node.cc:128) assigns an interface index to the
device, calls NetDevice::SetNode, sets the receive callback of the device to
Node::NonPromiscReceiveFromDevice. Then, it schedules NetDevice::Initialize() method at
Seconds(0.0), then notify the registered DeviceAdditionListener handlers (not used BY ANYONE).</p>
<p>Node::NonPromiscReceiveFromDevice calls Node::ReceiveFromDevice.</p>
<p>Node::ReceiveFromDevice iterates through ProtocolHandlers, which are callbacks
which accept as signature:</p>
<p>ProtocolHandler (Ptr&lt;NetDevice&gt;, Ptr&lt;const Packet&gt;, protocol, from_addr, to_addr, packetType).</p>
<p>If device, protocol number and promiscuous flag corresponds, the handler is
invoked.</p>
<p>Who is responsible to set ProtocolHandler ? We will analyze that in the next
section.</p>
</section>
<section id="l3-helper">
<h5><span class="section-number">33.1.2.2. </span>L3 Helper<a class="headerlink" href="#l3-helper" title="Link to this heading">¶</a></h5>
<p>We have only internet which provides network protocol (IP). That module splits
the operations between two helpers: InternetStackHelper and Ipv{4,6}AddressHelper.</p>
<p>InternetStackHelper::Install (internet/helper/internet-stack-helper.cc:423)
creates and aggregates protocols {ArpL3,Ipv4L3,Icmpv4}Protocol. It creates the
routing protocol, and if Ipv6 is enabled it adds {Ipv6L3,Icmpv6L4}Protocol. In
any case, it instantiates and aggregates an UdpL4Protocol object, along with a
PacketSocketFactory.
Ultimately, it creates the required objects and aggregates them to the node.</p>
<p>Let’s assume an Ipv4 environment (things are the same for Ipv6).</p>
<p>Ipv4AddressHelper::Assign (src/internet/helper/ipv4-address-helper.cc:131)
registers the handlers. The process is a bit long. The method is called with
a list of NetDevice. For each of them, the node and Ipv4L3Protocol pointers are
retrieved; if an Ipv4Interface is already registered for the device, on that the
address is set. Otherwise, the method Ipv4L3Protocol::AddInterface is called,
before adding the address.</p>
</section>
<section id="ip-interfaces">
<h5><span class="section-number">33.1.2.3. </span>IP interfaces<a class="headerlink" href="#ip-interfaces" title="Link to this heading">¶</a></h5>
<p>In Ipv4L3Protocol::AddInterface (src/internet/model/ipv4-l3-protocol.cc:300)
two protocol handlers are installed: one that react to ipv4 protocol number,
and one that react to arp protocol number (Ipv4L3Protocol::Receive and
ArpL3Protocol::Receive, respectively). The interface is then created,
initialized, and returned.</p>
<p>Ipv4L3Protocol::Receive (src/internet/model/ipv4-l3-protocol.cc:472) iterates
through the interface. Once it finds the Ipv4Interface which has the same device
as the one passed as argument, invokes the rxTrace callback. If the interface is
down, the packet is dropped. Then, it removes the header and trim any residual
frame padding. If checksum is not OK, it drops the packet. Otherwise, forward
the packet to the raw sockets (not used). Then, it ask the routing protocol what
is the destiny of that packet. The choices are: Ipv4L3Protocol::{IpForward,
IpMulticastForward,LocalDeliver,RouteInputError}.</p>
</section>
</section>
</section>
<span id="document-queue-discs"></span><section id="queue-disciplines">
<h3><span class="section-number">33.2. </span>Queue disciplines<a class="headerlink" href="#queue-disciplines" title="Link to this heading">¶</a></h3>
<section id="model-description">
<h4><span class="section-number">33.2.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>Packets received by the Traffic Control layer for transmission to a netdevice
can be passed to a queueing discipline (queue disc) to perform scheduling and
policing.  The <em>ns-3</em> term “queue disc” corresponds to what Linux calls a “qdisc”.
A netdevice can have a single (root) queue disc installed on it.
Installing a queue disc on a netdevice is not mandatory. If a netdevice does
not have a queue disc installed on it, the traffic control layer sends the packets
directly to the netdevice. This is the case, for instance, of the loopback netdevice.</p>
<p>As in Linux, queue discs may be simple queues or may be complicated hierarchical
structures.  A queue disc may contain distinct elements:</p>
<ul class="simple">
<li><p>queues, which actually store the packets waiting for transmission</p></li>
<li><p>classes, which permit the definition of different treatments for different subdivisions of traffic</p></li>
<li><p>filters, which determine the queue or class which a packet is destined to</p></li>
</ul>
<p>Linux uses the terminology “classful qdiscs” or “classless qdiscs” to describe
how packets are handled.  This use of the term “class” should be distinguished
from the C++ language “class”.  In general, the below discussion uses “class”
in the Linux, not C++, sense, but there are some uses of the C++ term, so
please keep in mind the dual use of this term in the below text.</p>
<p>Notice that a child queue disc must be attached to every class and a packet
filter is only able to classify packets of a single protocol. Also, while in Linux
some queue discs (e.g., fq-codel) use an internal classifier and do not make use of
packet filters, in ns-3 every queue disc including multiple queues or multiple classes
needs an external filter to classify packets (this is to avoid having the traffic-control
module depend on other modules such as internet).</p>
<p>Queue disc configuration vary from queue disc to queue disc. A typical taxonomy divides
queue discs in classful (i.e., support classes) and classless (i.e., do not support
classes). More recently, after the appearance of multi-queue devices (such as Wi-Fi),
some multi-queue aware queue discs have been introduced. Multi-queue aware queue discs
handle as many queues (or queue discs – without using classes) as the number of
transmission queues used by the device on which the queue disc is installed.
An attempt is made, also, to classify each packet similarly in the queue disc and within
the device (i.e., to keep the packet classification consistent across layers).</p>
<p>The traffic control layer interacts with a queue disc in a simple manner: after requesting
to enqueue a packet, the traffic control layer requests the qdisc to “run”, i.e., to
dequeue a set of packets, until a predefined number (“quota”) of packets is dequeued
or the netdevice stops the queue disc.  A netdevice shall
stop the queue disc when its transmission queue does not have room for another
packet. Also, a netdevice shall wake the queue disc when it detects that there
is room for another packet in its transmission queue, but the transmission queue
is stopped. Waking a queue disc is equivalent to make it run.</p>
<p>Every queue disc collects statistics about the total number of packets/bytes
received from the upper layers (in case of root queue disc) or from the parent
queue disc (in case of child queue disc), enqueued, dequeued, requeued, dropped,
dropped before enqueue, dropped after dequeue, marked, and stored in the queue disc and
sent to the netdevice or to the parent queue disc. Note that packets that are
dequeued may be requeued, i.e., retained by the traffic control infrastructure,
if the netdevice is not ready to receive them. Requeued packets are not part
of the queue disc. The following identities hold:</p>
<ul class="simple">
<li><p>dropped = dropped before enqueue + dropped after dequeue</p></li>
<li><p>received = dropped before enqueue + enqueued</p></li>
<li><p>queued = enqueued - dequeued</p></li>
<li><p>sent = dequeued - dropped after dequeue (- 1 if there is a requeued packet)</p></li>
</ul>
<p>Separate counters are also kept for each possible reason to drop a packet.
When a packet is dropped by an internal queue, e.g., because the queue is full,
the reason is “Dropped by internal queue”. When a packet is dropped by a child
queue disc, the reason is “(Dropped by child queue disc) “ followed by the
reason why the child queue disc dropped the packet.</p>
<p>The QueueDisc base class provides the SojournTime trace source, which provides
the sojourn time of every packet dequeued from a queue disc, including packets
that are dropped or requeued after being dequeued. The sojourn time is taken
when the packet is dequeued from the queue disc, hence it does not account for
the additional time the packet is retained within the queue disc in case it is
requeued.</p>
<section id="design">
<h5><span class="section-number">33.2.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h5>
<p>A C++ abstract base class, class QueueDisc, is subclassed to implement a specific
queue disc. A subclass is required to implement the following methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">DoEnqueue</span> <span class="pre">(Ptr&lt;QueueDiscItem&gt;</span> <span class="pre">item)</span></code>:  Enqueue a packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ptr&lt;QueueDiscItem&gt;</span> <span class="pre">DoDequeue</span> <span class="pre">()</span></code>:  Dequeue a packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">CheckConfig</span> <span class="pre">()</span> <span class="pre">const</span></code>: Check if the configuration is correct</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">InitializeParams</span> <span class="pre">()</span></code>: Initialize queue disc parameters</p></li>
</ul>
<p>and may optionally override the default implementation of the following method:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Ptr&lt;const</span> <span class="pre">QueueDiscItem&gt;</span> <span class="pre">DoPeek</span> <span class="pre">()</span> <span class="pre">const</span></code>: Peek the next packet to extract</p></li>
</ul>
<p>The default implementation of the <code class="docutils literal notranslate"><span class="pre">DoPeek</span></code> method is based on the qdisc_peek_dequeued
function of the Linux kernel, which dequeues a packet and retains it in the
queue disc as a requeued packet. This approach is recommended
especially for queue discs for which it is not obvious what is the next
packet that will be dequeued (e.g., queue discs having multiple internal
queues or child queue discs or queue discs that drop packets after dequeue).
Therefore, unless the subclass redefines the <code class="docutils literal notranslate"><span class="pre">DoPeek</span></code> method, calling <code class="docutils literal notranslate"><span class="pre">Peek</span></code> causes
the next packet to be dequeued from the queue disc, though the packet is still
considered to be part of the queue disc and the dequeue trace is fired when
Dequeue is called and the packet is actually extracted from the queue disc.</p>
<p>The C++ base class QueueDisc implements:</p>
<ul class="simple">
<li><p>methods to add/get a single queue, class or filter and methods to get the number of installed queues, classes or filters</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">Classify</span></code> method which classifies a packet by processing the list of filters until a filter able to classify the packet is found</p></li>
<li><p>methods to extract multiple packets from the queue disc, while handling transmission (to the device) failures by requeuing packets</p></li>
</ul>
<p>The base class QueueDisc provides many trace sources:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Enqueue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dequeue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Requeue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Drop</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Mark</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PacketsInQueue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BytesInQueue</span></code></p></li>
</ul>
<p>The C++ base class QueueDisc holds the list of attached queues, classes and filter
by means of three vectors accessible through attributes (InternalQueueList,
QueueDiscClassList and PacketFilterList).</p>
<p>Internal queues are implemented as (subclasses of) Queue objects. A Queue stores
QueueItem objects, which consist of just a Ptr&lt;Packet&gt;. Since a queue disc has to
store at least the destination address and the protocol number for each enqueued
packet, a new C++ class, QueueDiscItem, is derived from QueueItem to store such
additional information for each packet. Thus, internal queues are implemented as
Queue objects storing QueueDiscItem objects. Also, there could be the need to store
further information depending on the network layer protocol of the packet. For
instance, for IPv4 and IPv6 packets it is needed to separately store the header
and the payload, so that header fields can be manipulated, e.g., to support
Explicit Congestion Notification as defined in RFC 3168.  To this end,
subclasses <code class="docutils literal notranslate"><span class="pre">Ipv4QueueDiscItem</span></code> and <code class="docutils literal notranslate"><span class="pre">Ipv6QueueDiscItem</span></code> are derived from
<code class="docutils literal notranslate"><span class="pre">QueueDiscItem</span></code> to additionally store the IP header and provide protocol
specific operations such as ECN marking.</p>
<p>Classes (in the Linux sense of the term) are implemented via the QueueDiscClass class, which consists of a pointer
to the attached queue disc. Such a pointer is accessible through the QueueDisc attribute.
Classful queue discs needing to set parameters for their classes can subclass
QueueDiscClass and add the required parameters as attributes.</p>
<p>An abstract base class, PacketFilter, is subclassed to implement specific filters.
Subclasses are required to implement two virtual private pure methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">CheckProtocol</span> <span class="pre">(Ptr&lt;QueueDiscItem&gt;</span> <span class="pre">item)</span> <span class="pre">const</span></code>: check whether the filter is able to classify packets of the same protocol as the given packet</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">DoClassify</span> <span class="pre">(Ptr&lt;QueueDiscItem&gt;</span> <span class="pre">item)</span> <span class="pre">const</span></code>: actually classify the packet</p></li>
</ul>
<p>PacketFilter provides a public method, <code class="docutils literal notranslate"><span class="pre">Classify</span></code>, which first calls <code class="docutils literal notranslate"><span class="pre">CheckProtocol</span></code>
to check that the protocol of the packet matches the protocol of the filter and then
calls <code class="docutils literal notranslate"><span class="pre">DoClassify</span></code>. Specific filters subclassed from PacketFilter should not be
placed in the traffic-control module but in the module corresponding to the protocol
of the classified packets.</p>
</section>
</section>
<section id="usage">
<h4><span class="section-number">33.2.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>The traffic control layer is automatically created and inserted on an <code class="docutils literal notranslate"><span class="pre">ns3::Node</span></code> object
when typical device and internet module helpers are used.  By default, the
<code class="docutils literal notranslate"><span class="pre">InternetStackHelper::Install()</span></code> method aggregates a TrafficControlLayer object to every
node. When invoked to assign an IPv{4,6} address to a device, the Ipv{4,6}AddressHelper,
besides creating an Ipv{4,6}Interface, also installs the default qdisc
on the device, unless a queue disc has been already installed.
For single-queue NetDevices (such as PointToPoint, Csma and Simple), the default root
qdisc is FqCoDel. For multi-queue NetDevices (such as Wifi), the default root qdisc is
Mq with as many FqCoDel child qdiscs as the number of device queues.</p>
<p>To install a queue disc other than the default one, it is necessary to install such queue
disc before an IP address is assigned to the device. Alternatively, the default queue disc
can be removed from the device after assigning an IP address, by using the
Uninstall method of the TrafficControlHelper C++ class, and then installing a different
queue disc on the device.  By uninstalling without adding a new queue disc, it is also possible
to have no queue disc installed on a device.</p>
<p>Note that if no queue disc is installed on an underlying device, the traffic
control layer will still respect flow control signals provided by the device, if
any.  Specifically, if no queue disc is installed on a device, and the device is
stopped, then any packet for that device will be dropped in the traffic control
layer, and the device’s drop trace will not record the drop – instead, the TcDrop
drop trace in the traffic control layer will record the drop.</p>
<p>Flow control can be disabled for the devices that support it by using the
<code class="docutils literal notranslate"><span class="pre">DisableFlowControl</span></code> method of their helpers.  If there is no queue disc
installed on the device, and the device is not performing flow control, then
packets will immediately transit the traffic control layer and be sent to the
device, regardless or not of whether the device’s internal queue can accept it,
and the traffic control layer’s TcDrop trace will not be called.</p>
<section id="helpers">
<h5><span class="section-number">33.2.2.1. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a traffic control helper and to configure type
and attributes of queue discs, queues, classes and filters from the helper, For example,
the pfifo_fast can be configured as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::PfifoFastQueueDisc&quot;</span><span class="p">);</span>
<span class="n">tch</span><span class="p">.</span><span class="n">AddInternalQueues</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::DropTailQueue&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MaxSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;1000p&quot;</span><span class="p">));</span>
<span class="n">QueueDiscContainer</span><span class="w"> </span><span class="n">qdiscs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code adds three internal queues to the root queue disc of type PfifoFast.
With the above configuration, the config path of the root queue disc installed on the j-th
device of the i-th node (the index of a device is the same as in DeviceList) is:</p>
<p>/NodeList/[i]/$ns3::TrafficControlLayer/RootQueueDiscList/[j]</p>
<p>and the config path of the second internal queue is:</p>
<p>/NodeList/[i]/$ns3::TrafficControlLayer/RootQueueDiscList/[j]/InternalQueueList/1</p>
<p>For this helper’s configuration to take effect, it should be added to the ns-3 program after
<code class="docutils literal notranslate"><span class="pre">InternetStackHelper::Install()</span></code> is called, but before IP addresses are configured using
<code class="docutils literal notranslate"><span class="pre">Ipv{4,6}AddressHelper</span></code>. For an example program, see examples/traffic-control/traffic-control.cc.</p>
<p>If it is desired to install no queue disc on a device, it is necessary to use the Uninstall
method of the TrafficControlHelper:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="n">tch</span><span class="p">.</span><span class="n">Uninstall</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the Uninstall method must be called after <code class="docutils literal notranslate"><span class="pre">InternetStackHelper::Install()</span></code> is called
and after that IP addresses are configured using <code class="docutils literal notranslate"><span class="pre">Ipv{4,6}AddressHelper</span></code>. For an example program,
see src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc (look at the <code class="docutils literal notranslate"><span class="pre">Ns3TcpCwndTestCase2::DoRun</span></code> method).
Note also that this method does not uninstall the traffic control layer but instead
removes the root queue disc on the device but keeps the traffic control layer present.
Also, note that removing the root queue disc on a device supporting flow control does not disable
the flow control. As mentioned above, this requires to call the DisableFlowControl method of the
device helper, so that the device is created without support for the flow control.</p>
</section>
</section>
<section id="implementation-details">
<h4><span class="section-number">33.2.3. </span>Implementation details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h4>
<p>In Linux, the struct netdev_queue is used to store information about a single
transmission queue of a device: status (i.e., whether it has been stopped or not),
data used by techniques such as Byte Queue Limits and a qdisc pointer field that
is mainly used to solve the following problems:</p>
<ul class="simple">
<li><p>if a device transmission queue is (almost) empty, identify the queue disc to wake</p></li>
<li><p>if a packet will be enqueued in a given device transmission queue, identify the queue disc which the packet must be enqueued into</p></li>
</ul>
<p>The latter problem arises because Linux attempts to determine the device transmission
queue which a packet will be enqueued into before passing the packet to a queue disc.
This is done by calling a specific function of the device driver, if implemented, or
by employing fallback mechanisms (such as hashing of the addresses) otherwise. The
identifier of the selected device transmission queue is stored in the queue_mapping field of the struct sk_buff, so that both the queue disc and the device driver can
get the same information. In ns-3, such identifier is stored in a member of the
QueueDiscItem class.</p>
<p>The NetDeviceQueue class in ns-3 is the equivalent of the Linux struct netdev_queue.
The qdisc field of the Linux struct netdev_queue, however, cannot be
similarly stored in a NetDeviceQueue object, because it would make the network module
depend on the traffic-control module. Instead, this information is stored in the
TrafficControlLayer object aggregated to each node. In particular, a TrafficControlLayer
object holds a struct NetDeviceInfo which stores, for each NetDevice, a pointer to the
root queue disc installed on the device, a pointer to the netdevice queue interface
(see below) aggregated to the device, and a vector of pointers (one for each device
transmission queue) to the queue discs to activate when the above
problems occur. The traffic control layer takes care of configuring such a vector
at initialization time, based on the “wake mode” of the root queue disc. If the
wake mode of the root queue disc is WAKE_ROOT, then all the elements of the vector
are pointers to the root queue disc. If the wake mode of the root queue disc is
WAKE_CHILD, then each element of the vector is a pointer to a distinct child queue
disc. This requires that the number of child queue discs matches the number of
netdevice queues. It follows that the wake mode of a classless queue disc must
necessarily be WAKE_ROOT. These two configurations are illustrated by the figures below.</p>
<p><a class="reference internal" href="#fig-classful-queue-disc"><span class="std std-ref">Setup of a queue disc (wake mode: WAKE_ROOT)</span></a> below shows how the TrafficControlLayer map looks like in
case of a classful root queue disc whose wake mode is WAKE_ROOT.</p>
<figure class="align-default" id="id1">
<span id="fig-classful-queue-disc"></span><img alt="_images/classful-queue-disc.png" src="_images/classful-queue-disc.png" />
<figcaption>
<p><span class="caption-text">Setup of a queue disc (wake mode: WAKE_ROOT)</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-multi-queue-aware-queue-disc"><span class="std std-ref">Setup of a multi-queue aware queue disc</span></a> below shows instead how the TrafficControlLayer
map looks like in case of a classful root queue disc whose wake mode is WAKE_CHILD.</p>
<figure class="align-default" id="id2">
<span id="fig-multi-queue-aware-queue-disc"></span><img alt="_images/multi-queue-aware-queue-disc.png" src="_images/multi-queue-aware-queue-disc.png" />
<figcaption>
<p><span class="caption-text">Setup of a multi-queue aware queue disc</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>A NetDeviceQueueInterface object is used by the traffic control layer to access the
information stored in the NetDeviceQueue objects, retrieve the number of transmission
queues of the device and get the transmission queue selected for the transmission of a
given packet. A NetDeviceQueueInterface object must be therefore aggregated to all the
devices having an interface supporting the traffic control layer (i.e., an IPv4 or IPv6
interface). In particular:</p>
<ul class="simple">
<li><p>a NetDeviceQueueInterface object is aggregated to all the devices by the NetDevice
helper classes, at <code class="docutils literal notranslate"><span class="pre">Install</span></code> time.  See, for example, the implementation in the
method <code class="docutils literal notranslate"><span class="pre">CsmaHelper::InstallPriv()</span></code>.</p></li>
<li><p>when notified that a netdevice queue interface has been aggregated, traffic control aware devices can cache the pointer to the netdevice queue interface created by the traffic control layer into a member variable. Also, multi-queue devices can set the number of device transmission queues and set the select queue callback through the netdevice queue interface</p></li>
<li><p>at initialization time, the traffic control (after calling device-&gt;Initialize () to ensure that the netdevice has set the number of device transmission queues, if it has to do so) completes the installation of the queue discs by setting the wake callbacks on the device transmission queues (through the netdevice queue interface). Also, the traffic control calls the Initialize method of the root queue discs.  This initialization of queue discs triggers calls to the <code class="docutils literal notranslate"><span class="pre">CheckConfig</span></code> and <code class="docutils literal notranslate"><span class="pre">InitializeParams</span></code> methods of the queue disc.</p></li>
</ul>
<section id="requeue">
<h5><span class="section-number">33.2.3.1. </span>Requeue<a class="headerlink" href="#requeue" title="Link to this heading">¶</a></h5>
<p>In Linux, a packet dequeued from a queue disc can be requeued (i.e., stored somewhere
and sent to the device at a later time) in some circumstances. Firstly, the function
used to dequeue a packet (dequeue_skb) actually dequeues a packet only if the device
is multi-queue or the (unique) device queue is not stopped. If a packet has been
dequeued from the queue disc, it is passed to the sch_direct_xmit function for
transmission to the device. This function checks whether the device queue the packet is destined
to is stopped, in which case the packet is requeued. Otherwise, the packet is sent to the device.
If the device returns NETDEV_TX_BUSY, the packet is requeued. However, it is advised that
the function called to send a packet to the device (ndo_start_xmit) should always
return NETDEV_TX_OK, which means that the packet is consumed by the device driver
and thus needs not to be requeued. However, the ndo_start_xmit function of the device
driver is allowed to return NETDEV_TX_BUSY (and hence the packet is requeued) when
there is no room for the received packet in the device queue, despite the queue is
not stopped. This case is considered as a corner case or an hard error, and should be avoided.</p>
<p>ns-3 implements the requeue mechanism in a similar manner, the only difference being
that packets are not requeued when such corner cases occur. Basically, the method used
to dequeue a packet (QueueDisc::DequeuePacket) actually dequeues a packet only if the
device is multi-queue or the (unique) device queue is not stopped. If a packet has been
dequeued from the queue disc, it is passed to the QueueDisc::Transmit method for
transmission to the device. This method checks whether the device queue the packet is destined
to is stopped, in which case the packet is requeued. Otherwise, the packet is sent to the device.
We request netdevices to stop a device queue when it is not able to store another packet,
so as to avoid the situation in which a packet is received that cannot be enqueued while
the device queue is not stopped. Should such a corner case occur, the netdevice drops
the packet but, unlike Linux, the value returned by NetDevice::Send is ignored and the
packet is not requeued.</p>
<p>The way the requeue mechanism is implemented in ns-3 has the following implications:</p>
<ul class="simple">
<li><p>if the underlying device has a single queue, no packet will ever be requeued. Indeed, if the device queue is not stopped when QueueDisc::DequeuePacket is called, it will not be stopped also when QueueDisc::Transmit is called, hence the packet is not requeued (recall that a packet is not requeued after being sent to the device, as the value returned by NetDevice::Send is ignored).</p></li>
<li><p>if the underlying device does not implement flow control, i.e., it does not stop its queue(s), no packet will ever be requeued (recall that a packet is only requeued by QueueDisc::Transmit when the device queue the packet is destined to is stopped)</p></li>
</ul>
<p>It turns out that packets may only be requeued when the underlying device is multi-queue
and supports flow control.</p>
</section>
</section>
</section>
<span id="document-fifo"></span><section id="fifo-queue-disc">
<h3><span class="section-number">33.3. </span>Fifo queue disc<a class="headerlink" href="#fifo-queue-disc" title="Link to this heading">¶</a></h3>
<section id="model-description">
<h4><span class="section-number">33.3.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>FifoQueueDisc implements the FIFO (First-In First-Out) policy.
Packets are enqueued in the unique internal queue, which is implemented
as a DropTail queue. The queue disc capacity can be specified in terms of
either packets or bytes, depending on the value of the Mode attribute.</p>
<p>User is allowed to provide an internal queue before the queue disc is initialized.
If no internal queue is provided, one DropTail queue having the same capacity
of the queue disc is created by default. No packet filter can be added to a
FifoQueueDisc.</p>
<section id="attributes">
<h5><span class="section-number">33.3.1.1. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The FifoQueueDisc class holds the following attribute:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The maximum number of packets/bytes the queue disc can hold. The default value is 1000 packets.</p></li>
</ul>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.3.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The fifo model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FifoQueueDiscTestSuite</span></code> class defined
in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/test/fifo-queue-disc-test-suite.cc</span></code>. The test aims to
check that the capacity of the queue disc is not exceeded and packets are dequeued
in the correct order.</p>
</section>
</section>
<span id="document-pfifo-fast"></span><section id="pfifo-fast-queue-disc">
<h3><span class="section-number">33.4. </span>pfifo_fast queue disc<a class="headerlink" href="#pfifo-fast-queue-disc" title="Link to this heading">¶</a></h3>
<section id="model-description">
<h4><span class="section-number">33.4.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>PfifoFastQueueDisc behaves like pfifo_fast, which is the default queue disc
enabled on Linux systems (init systems such as systemd may override such default
setting). Packets are enqueued in three priority bands (implemented
as FIFO droptail queues) based on their priority (users can read
<a class="reference internal" href="index.html#socket-options"><span class="std std-ref">Use of Send() vs. SendTo()</span></a> for details on how to set packet priority).
The four least significant bits of the priority are used to determine
the selected band according to the following table:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Priority &amp; 0xf</p></th>
<th class="head"><p>Band</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>The system behaves similar to three ns3::DropTail queues operating
together, in which packets from higher priority bands are always
dequeued before a packet from a lower priority band is dequeued.</p>
<p>The queue disc capacity, i.e., the maximum number of packets that can
be enqueued in the queue disc, is set through the MaxSize attribute, which
plays the same role as txqueuelen in Linux. If no internal queue is
provided, three DropTail queues having each a capacity equal to MaxSize are
created by default. User is allowed to provide queues, but they must be
three, operate in packet mode and each have a capacity not less
than MaxSize. No packet filter can be added to a PfifoFastQueueDisc.</p>
<section id="attributes">
<h5><span class="section-number">33.4.1.1. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The PfifoFastQueueDisc class holds a single attribute:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The maximum number of packets accepted by the queue disc. The default value is 1000.</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">33.4.1.2. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>Various examples located in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples</span></code> (e.g., codel-vs-pfifo-asymmetric.cc)
shows how to configure and install a PfifoFastQueueDisc on internet nodes.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.4.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The pfifo_fast model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PfifoFastQueueDiscTestSuite</span></code> class defined
in <code class="docutils literal notranslate"><span class="pre">src/test/ns3tc/pfifo-fast-queue-disc-test-suite.cc</span></code>. The suite includes 4 test cases:</p>
<ul class="simple">
<li><p>Test 1: The first test checks whether IPv4 packets are enqueued in the correct band based on the TOS byte</p></li>
<li><p>Test 2: The second test checks whether IPv4 packets are enqueued in the correct band based on the TOS byte</p></li>
<li><p>Test 3: The third test checks that the queue disc cannot enqueue more packets than its limit</p></li>
<li><p>Test 4: The fourth test checks that packets that the filters have not been able to classify are enqueued into the default band of 1</p></li>
</ul>
</section>
</section>
<span id="document-prio"></span><section id="prio-queue-disc">
<h3><span class="section-number">33.5. </span>Prio queue disc<a class="headerlink" href="#prio-queue-disc" title="Link to this heading">¶</a></h3>
<section id="model-description">
<h4><span class="section-number">33.5.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>PrioQueueDisc implements a strict priority policy, where packets are dequeued from
a band only if higher priority bands are all empty. PrioQueueDisc is a classful
queue disc and can have an arbitrary number of bands, each of which is handled by a
queue disc of any kind. The capacity of PrioQueueDisc is not limited; packets can
only be dropped by child queue discs (which may have a limited capacity).
If no packet filter is installed or able to classify a packet, then the
packet is enqueued into a priority band based on its priority (modulo 16), which
is used as an index into an array called priomap. Users can read <a class="reference internal" href="index.html#socket-options"><span class="std std-ref">Use of Send() vs. SendTo()</span></a>
for details on how to set the packet priority. If a packet is classified
by an installed packet filter and the returned value <code class="docutils literal notranslate"><span class="pre">i</span></code> is non-negative and less than the
number of priority bands, then the packet is enqueued into the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th priority band.
Otherwise, the packet is enqueued into the priority band specified by the first element
of the priomap array.</p>
<p>If no queue disc class is added by the user before the queue disc is initialized,
three child queue discs of type FifoQueueDisc are automatically added. It has to
be noted that PrioQueueDisc needs at least two child queue discs.</p>
<section id="attributes">
<h5><span class="section-number">33.5.1.1. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The PrioQueueDisc class holds the following attribute:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Priomap:</span></code> The priority to band mapping. The default value is the same mapping as the (fixed) one used by PfifoFastQueueDisc.</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">33.5.1.2. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>An example of how to configure PrioQueueDisc with custom child queue discs and priomap
is provided by <cite>queue-discs-benchmark.cc</cite> located in <code class="docutils literal notranslate"><span class="pre">examples/traffic-control</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::PrioQueueDisc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Priomap&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1&quot;</span><span class="p">));</span>
<span class="n">TrafficControlHelper</span><span class="o">::</span><span class="n">ClassIdList</span><span class="w"> </span><span class="n">cid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">AddQueueDiscClasses</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::QueueDiscClass&quot;</span><span class="p">);</span>
<span class="n">tch</span><span class="p">.</span><span class="n">AddChildQueueDisc</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">cid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ns3::FifoQueueDisc&quot;</span><span class="p">);</span>
<span class="n">tch</span><span class="p">.</span><span class="n">AddChildQueueDisc</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">cid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;ns3::RedQueueDisc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The code above adds two classes (bands) to a PrioQueueDisc. The highest priority one
is a FifoQueueDisc, the other one is a RedQueueDisc. The attribute Priomap is set to
an array containing only 0 and 1 (since PrioQueueDisc only has two bands).</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.5.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>PrioQueueDisc is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PrioQueueDiscTestSuite</span></code> class defined
in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/test/prio-queue-disc-test-suite.cc</span></code>. The test aims to
check that: i) packets are enqueued in the correct band based on their priority and
the priomap or according to the value returned by the installed packet filter;
ii) packets are dequeued in the correct order.</p>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>prio-queue-disc
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;PrioQueueDisc&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=prio-queue-disc&quot;</span>
</pre></div>
</div>
</section>
</section>
<span id="document-tbf"></span><section id="tbf-queue-disc">
<h3><span class="section-number">33.6. </span>TBF queue disc<a class="headerlink" href="#tbf-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the TBF (<a class="reference internal" href="index.html#ref1" id="id1"><span>[Ref1]</span></a>) queue disc implementation
in <em>ns-3</em>. The TBF model in ns-3 is ported based on Linux kernel code implemented by
A. Kuznetsov and D. Torokhov.</p>
<p>TBF is a qdisc that allows controlling the bandwidth of the output according
to a set rate with the possibility of managing burst conditions also. The TBF implementation
consists of a bucket (buffer) having a limited capacity into which tokens (normally representing a
unit of bytes or a single packet of predetermined size) are added at a fixed rate ‘r’ called the
token rate. Whenever a packet arrives into the tx queue (fifo by default), the bucket is checked
to see if there are appropriate number of tokens that is equivalent to the length of the packet in
bytes. If yes, then the tokens are removed and the packet is passed for transmission. If no, then
packets will have to wait until there are sufficient tokens in the bucket. This data conformance
can be thus put into three possible scenarios <a class="reference internal" href="index.html#ref3" id="id2"><span>[Ref3]</span></a>:</p>
<ol class="arabic simple">
<li><p>Data rate = Token rate : Packets pass without delay.</p></li>
<li><p>Data rate &lt; Token rate : The tokens might accumulate and the bucket might become
full. Then, the next packets to enter TBF will be transmitted right away without
having any limit applied to them, until the bucket is empty. This is called a burst
condition and in TBF the burst parameter defines the size of the bucket. In order
to overcome this problem and provide better control over the bursts, TBF
implements a second bucket which is smaller and generally the same size as the
MTU. This second bucket cannot store large amount of tokens, but its
replenishing rate will be a lot faster than the one of the big bucket. This second
rate is called ‘peakRate’ and it will determine the maximum rate of a burst.</p></li>
<li><p>Data rate &gt; Token rate : This causes the TBF algorithm to throttle itself for a while as
soon as the bucket gets empty. This is called an ‘overlimit situation’ <a class="reference internal" href="index.html#ref2" id="id3"><span>[Ref2]</span></a>. In this situation,
some of the packets will be blocked until enough tokens are available at which time a schedule for
the waking of the queue will be done. If packets keep coming in, at a larger rate, then the
packets will start to get dropped when the total number of bytes exceeds the QueueLimit.</p></li>
</ol>
<section id="model-description">
<h4><span class="section-number">33.6.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The TBF queue disc does not require packet filters, does not admit internal queues
and uses a single child queue disc. If the user does not provide a child queue disc,
a Fifo queue disc operating in the same mode (packet or byte) as the TBF queue disc
and having a size equal to the TBF QueueLimit attribute is created. Otherwise, the
capacity of the TBF queue disc is determined by the capacity of the child queue disc.</p>
<p>There are two token buckets: first bucket and second bucket. The size of the
first bucket called ‘Burst’ should always be greater than the size of the second
bucket called the Mtu (which is usually the size of a single packet). But the
‘PeakRate’ which is the second bucket’s token rate should be always greater than
the ‘Rate’ which is the first bucket’s token rate.</p>
<p>If the PeakRate is zero, then the second bucket does not exist. In order to activate
the second bucket, both the Mtu and PeakRate values have to be greater than zero. If
the Mtu value is zero at initialization time, then if a NetDevice exits, the Mtu’s
value will be equal to the Mtu of the NetDevice. But if no NetDevice exists, then
the QueueDisc will complain thus prompting the user to set the Mtu value.</p>
<p>The source code for the TBF model is located in the directory <code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code>
and consists of 2 files <cite>tbf-queue-disc.h</cite> and <cite>tbf-queue-disc.cc</cite> defining a TbfQueueDisc
class.</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TbfQueueDisc</span></code>: This class implements the main TBF algorithm:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">TbfQueueDisc::DoEnqueue()</span></code>: This routine enqueue’s the incoming packet if the queue is not full and drops the packet otherwise.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TbfQueueDisc::DoPeek()</span></code>: This routine peeks for the top item in the queue and if the queue is not empty, it returns the topmost item.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TbfQueueDisc::DoDequeue()</span></code>: This routine performs the dequeuing of packets according to the following logic:</p>
<ul>
<li><p>It calls <code class="docutils literal notranslate"><span class="pre">TbfQueueDisc::Peek()</span></code> and calculates the size of the packet to be dequeued in bytes.</p></li>
<li><p>Then it calculates the time difference ‘delta’, which is the time elapsed since the last update of tokens in the buckets.</p></li>
<li><p>If the second bucket exists, the number of tokens are updated according to the ‘PeakRate’ and ‘delta’.</p></li>
<li><p>From this second bucket a number of tokens equal to the size of the packet to be dequeued is subtracted.</p></li>
<li><p>Now the number of tokens in the first bucket are updated according to ‘Rate’ and ‘delta’.</p></li>
<li><p>From this first bucket a number of tokens equal to the size of the packet to be dequeued is subtracted.</p></li>
<li><p>If after this, both the first and second buckets have tokens greater than zero, then the packet is dequeued.</p></li>
<li><p>Else, an event to <code class="docutils literal notranslate"><span class="pre">QueueDisc::Run()</span></code> is scheduled after a time period when enough tokens will be present for the dequeue operation.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<section id="references">
<h5><span class="section-number">33.6.1.1. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="ref1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Ref1</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple">
<li><p>Kuznetsov and D. Torokhov; Linux Cross Reference Source Code; Available online at <a class="reference external" href="https://raw.githubusercontent.com/torvalds/linux/8efd0d9c316af470377894a6a0f9ff63ce18c177/net/sched/sch_tbf.c">https://raw.githubusercontent.com/torvalds/linux/8efd0d9c316af470377894a6a0f9ff63ce18c177/net/sched/sch_tbf.c</a>.</p></li>
</ol>
</div>
<div class="citation" id="ref2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Ref2</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="10">
<li><p>Vehent; Journey to the Center of the Linux Kernel: Traffic Control, Shaping and QoS; Available online at <a class="reference external" href="http://wiki.linuxwall.info/doku.php/en:resources:dossiers:networking:traffic_control#tbf_-_token_bucket_filter">http://wiki.linuxwall.info/doku.php/en:resources:dossiers:networking:traffic_control#tbf_-_token_bucket_filter</a>.</p></li>
</ol>
</div>
<div class="citation" id="ref3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Ref3</a><span class="fn-bracket">]</span></span>
<p>Practical IP Network QoS: TBF queuing discipline; Available online at <a class="reference external" href="https://web.archive.org/web/20200516025221/http://web.opalsoft.net/qos/default.php">https://web.archive.org/web/20200516025221/http://web.opalsoft.net/qos/default.php</a>.</p>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.6.1.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The key attributes that the TbfQueueDisc class holds include the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The maximum number of packets/bytes the queue disc can hold. The default value is 1000 packets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Burst:</span></code> Size of the first bucket, in bytes. The default value is 125000 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Mtu:</span></code> Size of second bucket defaults to the MTU of the attached NetDevice, if any, or 0 otherwise.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Rate:</span></code> Rate at which tokens enter the first bucket. The default value is 125KB/s.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PeakRate:</span></code> Rate at which tokens enter the second bucket. The default value is 0KB/s, which means that there is no second bucket.</p></li>
</ul>
</section>
<section id="tracesources">
<h5><span class="section-number">33.6.1.3. </span>TraceSources<a class="headerlink" href="#tracesources" title="Link to this heading">¶</a></h5>
<p>The TbfQueueDisc class provides the following trace sources:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TokensInFirstBucket:</span></code> Number of First Bucket Tokens in bytes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TokensInSecondBucket:</span></code> Number of Second Bucket Tokens in bytes</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">33.6.1.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The example for TBF is <cite>tbf-example.cc</cite> located in <code class="docutils literal notranslate"><span class="pre">examples/traffic-control/</span></code>.  The command to run the file (the invocation below shows the available command-line options) is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">..</span><span class="w"> </span><span class="n">sourcecode</span><span class="o">::</span><span class="w"> </span><span class="n">bash</span>
</pre></div>
</div>
<blockquote>
<div><p>$ ./ns3 run “tbf-example –PrintHelp”
$ ./ns3 run “tbf-example –burst=125000 –rate=1Mbps –peakRate=1.5Mbps”</p>
</div></blockquote>
<p>The expected output from the previous commands are traced value changes in the number of tokens in the first and second buckets.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.6.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The TBF model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">TbfQueueDiscTestSuite</span></code> class defined in <cite>src/traffic-control/test/tbf-queue-disc-test-suite.cc</cite>. The suite includes 4 test cases:</p>
<ul class="simple">
<li><p>Test 1: Simple Enqueue/Dequeue with verification of attribute setting and subtraction of tokens from the buckets.</p></li>
<li><p>Test 2: When DataRate == FirstBucketTokenRate; packets should pass smoothly.</p></li>
<li><p>Test 3: When DataRate &gt;&gt;&gt; FirstBucketTokenRate; some packets should get blocked and waking of queue should get scheduled.</p></li>
<li><p>Test 4: When DataRate &lt; FirstBucketTokenRate; burst condition, peakRate is set so that bursts are controlled.</p></li>
</ul>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">..</span><span class="w"> </span><span class="n">sourcecode</span><span class="o">::</span><span class="w"> </span><span class="n">bash</span>
</pre></div>
</div>
<blockquote>
<div><p>$ ./ns3 configure –enable-examples –enable-tests
$ ./ns3 build
$ ./test.py -s tbf-queue-disc</p>
</div></blockquote>
<p>or</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">..</span><span class="w"> </span><span class="n">sourcecode</span><span class="o">::</span><span class="w"> </span><span class="n">bash</span>
</pre></div>
</div>
<blockquote>
<div><p>$ NS_LOG=”TbfQueueDisc” ./ns3 run “test-runner –suite=tbf-queue-disc”</p>
</div></blockquote>
</section>
</section>
<span id="document-red"></span><section id="red-queue-disc">
<h3><span class="section-number">33.7. </span>RED queue disc<a class="headerlink" href="#red-queue-disc" title="Link to this heading">¶</a></h3>
<section id="model-description">
<h4><span class="section-number">33.7.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>Random Early Detection (RED) is a queue discipline that aims to provide
early signals to transport protocol congestion control (e.g. TCP) that
congestion is imminent, so that they back off their rate gracefully
rather than with a bunch of tail-drop losses (possibly incurring
TCP timeout).  The model in ns-3 is a port of Sally Floyd’s ns-2
RED model.</p>
<p>Note that, starting from ns-3.25, RED is no longer a queue variant and
cannot be installed as a NetDevice queue. Instead, RED is a queue disc
and must be installed in the context of the traffic control (see the
examples mentioned below).</p>
<p>The RED queue disc does not require packet filters, does not admit
child queue discs and uses a single internal queue. If not provided by
the user, a DropTail queue operating in the same mode (packet or byte)
as the queue disc and having a size equal to the RED MaxSize attribute
is created. Otherwise, the capacity of the queue disc is determined by
the capacity of the internal queue provided by the user.</p>
<section id="adaptive-random-early-detection-ared">
<h5><span class="section-number">33.7.1.1. </span>Adaptive Random Early Detection (ARED)<a class="headerlink" href="#adaptive-random-early-detection-ared" title="Link to this heading">¶</a></h5>
<p>ARED is a variant of RED with two main features: (i) automatically sets Queue
weight, MinTh and MaxTh and (ii) adapts maximum drop probability. The model
in ns-3 contains implementation of both the features, and is a port of Sally
Floyd’s ns-2 ARED model. Note that the user is allowed to choose and explicitly
configure the simulation by selecting feature (i) or feature (ii), or both.</p>
</section>
<section id="feng-s-adaptive-red">
<h5><span class="section-number">33.7.1.2. </span>Feng’s Adaptive RED<a class="headerlink" href="#feng-s-adaptive-red" title="Link to this heading">¶</a></h5>
<p>Feng’s Adaptive RED is a variant of RED that adapts the maximum drop
probability. The model in ns-3 contains implementation of this feature, and is a
port of ns-2 Feng’s Adaptive RED model.</p>
</section>
<section id="nonlinear-random-early-detection-nlred">
<h5><span class="section-number">33.7.1.3. </span>Nonlinear Random Early Detection (NLRED)<a class="headerlink" href="#nonlinear-random-early-detection-nlred" title="Link to this heading">¶</a></h5>
<p>NLRED is a variant of RED in which the linear packet dropping function of
RED is replaced by a nonlinear quadratic function. This approach makes packet
dropping gentler for light traffic load and aggressive for heavy traffic load.</p>
</section>
<section id="explicit-congestion-notification-ecn">
<h5><span class="section-number">33.7.1.4. </span>Explicit Congestion Notification (ECN)<a class="headerlink" href="#explicit-congestion-notification-ecn" title="Link to this heading">¶</a></h5>
<p>This RED model supports an ECN mode of operation to notify endpoints of
congestion that may be developing in a bottleneck queue, without resorting
to packet drops. Such a mode is enabled by setting the UseEcn attribute to
true (it is false by default) and only affects incoming packets with the
ECT bit set in their header. When the average queue length is between the
minimum and maximum thresholds, an incoming packet is marked instead of being
dropped. When the average queue length is above the maximum threshold, an
incoming packet is marked (instead of being dropped) only if the UseHardDrop
attribute is set to false (it is true by default).</p>
<p>The implementation of support for ECN marking is done in such a way as
to not impose an internet module dependency on the traffic control module.
The RED model does not directly set ECN bits on the header, but delegates
that job to the QueueDiscItem class.  As a result, it is possible to
use RED queues for other non-IP QueueDiscItems that may or may not support
the <code class="docutils literal notranslate"><span class="pre">Mark</span> <span class="pre">()</span></code> method.</p>
</section>
<section id="references">
<h5><span class="section-number">33.7.1.5. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<p>The RED queue disc aims to be close to the results cited in:
S.Floyd, K.Fall <a class="reference external" href="http://icir.org/floyd/papers/redsims.ps">http://icir.org/floyd/papers/redsims.ps</a></p>
<p>ARED queue implementation is based on the algorithm provided in:
S. Floyd et al, <a class="reference external" href="http://www.icir.org/floyd/papers/adaptiveRed.pdf">http://www.icir.org/floyd/papers/adaptiveRed.pdf</a></p>
<p>Feng’s Adaptive RED queue implementation is based on the algorithm
provided in:
W. C. Feng et al, <a class="reference external" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=752150">http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=752150</a></p>
<p>NLRED queue implementation is based on the algorithm provided in:
Kaiyu Zhou et al, <a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1389128606000879">http://www.sciencedirect.com/science/article/pii/S1389128606000879</a></p>
<p>The addition of explicit congestion notification (ECN) to IP:
K. K. Ramakrishnan et al, <a class="reference external" href="https://tools.ietf.org/html/rfc3168">https://tools.ietf.org/html/rfc3168</a></p>
</section>
<section id="attributes">
<h5><span class="section-number">33.7.1.6. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The RED queue contains a number of attributes that control the RED
policies:</p>
<ul class="simple">
<li><p>MaxSize</p></li>
<li><p>MeanPktSize</p></li>
<li><p>IdlePktSize</p></li>
<li><p>Wait (time)</p></li>
<li><p>Gentle mode</p></li>
<li><p>MinTh, MaxTh</p></li>
<li><p>Queue weight</p></li>
<li><p>LInterm</p></li>
<li><p>LinkBandwidth</p></li>
<li><p>LinkDelay</p></li>
<li><p>UseEcn</p></li>
<li><p>UseHardDrop</p></li>
</ul>
<p>In addition to RED attributes, ARED queue requires following attributes:</p>
<ul class="simple">
<li><p>ARED (Boolean attribute. Default: false)</p></li>
<li><p>AdaptMaxP (Boolean attribute to adapt m_curMaxP. Default: false)</p></li>
<li><p>Target Delay (time)</p></li>
<li><p>Interval (time)</p></li>
<li><p>LastSet (time)</p></li>
<li><p>Top (upper limit of m_curMaxP)</p></li>
<li><p>Bottom (lower limit of m_curMaxP)</p></li>
<li><p>Alpha (increment parameter for m_curMaxP)</p></li>
<li><p>Beta (decrement parameter for m_curMaxP)</p></li>
<li><p>RTT</p></li>
</ul>
<p>In addition to RED attributes, Feng’s Adaptive RED queue requires following
attributes:</p>
<ul class="simple">
<li><p>FengAdaptive  (Boolean attribute, Default: false)</p></li>
<li><p>Status        (status of current queue length, Default: Above)</p></li>
<li><p>FengAlpha     (increment parameter for m_curMaxP, Default: 3)</p></li>
<li><p>FengBeta      (decrement parameter for m_curMaxP, Default: 2)</p></li>
</ul>
<p>The following attribute should be turned on to simulate NLRED queue disc:</p>
<ul class="simple">
<li><p>NLRED (Boolean attribute. Default: false)</p></li>
</ul>
<p>Consult the ns-3 documentation for explanation of these attributes.</p>
</section>
<section id="simulating-ared">
<h5><span class="section-number">33.7.1.7. </span>Simulating ARED<a class="headerlink" href="#simulating-ared" title="Link to this heading">¶</a></h5>
<p>To switch on ARED algorithm, the attribute ARED must be set to true,
as done in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples/adaptive-red-tests.cc</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::ARED&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>Setting ARED to true implicitly configures both: (i) automatic setting
of Queue weight, MinTh and MaxTh and (ii) adapting m_curMaxP.</p>
<p>NOTE: To explicitly configure (i) or (ii), set ARED attribute to false
and follow the procedure described next:</p>
<p>To configure (i); Queue weight, MinTh and MaxTh, all must be set to 0,
as done in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples/adaptive-red-tests.cc</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::QW&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::MinTh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::MaxTh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>To configure (ii); AdaptMaxP must be set to true, as done in
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples/adaptive-red-tests.cc</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::AdaptMaxP&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="simulating-feng-s-adaptive-red">
<h5><span class="section-number">33.7.1.8. </span>Simulating Feng’s Adaptive RED<a class="headerlink" href="#simulating-feng-s-adaptive-red" title="Link to this heading">¶</a></h5>
<p>To switch on Feng’s Adaptive RED algorithm, the attribute FengAdaptive must be
set to true, as done in <code class="docutils literal notranslate"><span class="pre">examples/traffic-control/red-vs-fengadaptive.cc</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::FengAdaptive&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="simulating-nlred">
<h5><span class="section-number">33.7.1.9. </span>Simulating NLRED<a class="headerlink" href="#simulating-nlred" title="Link to this heading">¶</a></h5>
<p>To switch on NLRED algorithm, the attribute NLRED must be set to true,
as shown below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::RedQueueDisc::NLRED&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="examples">
<h5><span class="section-number">33.7.1.10. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The RED queue example is found at <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples/red-tests.cc</span></code>.</p>
<p>ARED queue examples can be found at:
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples/adaptive-red-tests.cc</span></code> and
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples/red-vs-ared.cc</span></code></p>
<p>Feng’s Adaptive RED example can be found at:
<code class="docutils literal notranslate"><span class="pre">examples/traffic-control/red-vs-fengadaptive.cc</span></code></p>
<p>NLRED queue example can be found at:
<code class="docutils literal notranslate"><span class="pre">examples/traffic-control/red-vs-nlred.cc</span></code></p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.7.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The RED model has been validated and the report is currently stored
at: <a class="reference external" href="https://github.com/downloads/talau/ns-3-tcp-red/report-red-ns3.pdf">https://github.com/downloads/talau/ns-3-tcp-red/report-red-ns3.pdf</a></p>
</section>
</section>
<span id="document-codel"></span><section id="codel-queue-disc">
<h3><span class="section-number">33.8. </span>CoDel queue disc<a class="headerlink" href="#codel-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the CoDel (<a class="reference internal" href="index.html#nic12" id="id1"><span>[Nic12]</span></a>, <a class="reference internal" href="index.html#nic14" id="id2"><span>[Nic14]</span></a>) queue disc implementation
in <em>ns-3</em>.</p>
<p>Developed by Kathleen Nichols and Van Jacobson as a solution to the
bufferbloat <a class="reference internal" href="index.html#buf14" id="id3"><span>[Buf14]</span></a> problem, CoDel (Controlled Delay Management) is a queuing
discipline that uses a packet’s sojourn time (time in queue) to make
decisions on packet drops.</p>
<p>Note that, starting from ns-3.25, CoDel is no longer a queue variant and
cannot be installed as a NetDevice queue. Instead, CoDel is a queue disc
and must be installed in the context of the traffic control (see the
examples mentioned below).</p>
<section id="model-description">
<h4><span class="section-number">33.8.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the CoDel model is located in the directory <code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code>
and consists of 2 files <cite>codel-queue-disc.h</cite> and <cite>codel-queue-disc.cc</cite> defining a CoDelQueueDisc
class and a helper CoDelTimestampTag class. The code was ported to <em>ns-3</em> by
Andrew McGregor based on Linux kernel code implemented by Dave Täht and Eric Dumazet.</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">CoDelQueueDisc</span></code>: This class implements the main CoDel algorithm:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::DoEnqueue()</span></code>: This routine tags a packet with the current time before pushing it into the queue.  The timestamp tag is used by <code class="docutils literal notranslate"><span class="pre">CoDelQueue::DoDequeue()</span></code> to compute the packet’s sojourn time.  If the queue is full upon the packet arrival, this routine will drop the packet and record the number of drops due to queue overflow, which is stored in <cite>m_dropOverLimit</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::ShouldDrop()</span></code>: This routine is <code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::DoDequeue()</span></code>’s helper routine that determines whether a packet should be dropped or not based on its sojourn time.  If the sojourn time goes above <cite>m_target</cite> and remains above continuously for at least <cite>m_interval</cite>, the routine returns <code class="docutils literal notranslate"><span class="pre">true</span></code> indicating that it is OK to drop the packet. Otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::DoDequeue()</span></code>: This routine performs the actual packet drop based on <code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::ShouldDrop()</span></code>’s return value and schedules the next drop/mark.</p></li>
</ul>
</li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">CoDelTimestampTag</span></code>: This class implements the timestamp tagging for a packet.  This tag is used to compute the packet’s sojourn time (the difference between the time the packet is dequeued and the time it is pushed into the queue).</p></li>
</ul>
<p>There are 2 branches to <code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::DoDequeue()</span></code>:</p>
<ol class="arabic">
<li><p>If the queue is currently in the dropping state, which means the sojourn time has remained above <cite>m_target</cite> for more than <cite>m_interval</cite>, the routine determines if it’s OK to leave the dropping state or it’s time for the next drop/mark. When <code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::ShouldDrop()</span></code> returns <code class="docutils literal notranslate"><span class="pre">false</span></code>, the queue can move out of the dropping state (set <cite>m_dropping</cite> to <code class="docutils literal notranslate"><span class="pre">false</span></code>).  Otherwise, the queue continuously drops/marks packets and updates the time for next drop (<cite>m_dropNext</cite>) until one of the following conditions is met:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The queue is empty, upon which the queue leaves the dropping state and exits <code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::ShouldDrop()</span></code> routine;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::ShouldDrop()</span></code> returns <code class="docutils literal notranslate"><span class="pre">false</span></code> (meaning the sojourn time goes below <cite>m_target</cite>) upon which the queue leaves the dropping state;</p></li>
<li><p>It is not yet time for next drop/mark (<cite>m_dropNext</cite> is less than current time) upon which the queue waits for the next packet dequeue to check the condition again.</p></li>
</ol>
</div></blockquote>
</li>
<li><p>If the queue is not in the dropping state, the routine enters the dropping state and drop/mark the first packet if <code class="docutils literal notranslate"><span class="pre">CoDelQueueDisc::ShouldDrop()</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> (meaning the sojourn time has gone above <cite>m_target</cite> for at least <cite>m_interval</cite> for the first time or it has gone above again after the queue leaves the dropping state).</p></li>
</ol>
<p>The CoDel queue disc does not require packet filters, does not admit
child queue discs and uses a single internal queue. If not provided by
the user, a DropTail queue operating in the same mode (packet or byte)
as the queue disc and having a size equal to the CoDel MaxSize attribute
is created. Otherwise, the capacity of the queue disc is determined by
the capacity of the internal queue provided by the user.</p>
<section id="references">
<h5><span class="section-number">33.8.1.1. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="nic12" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Nic12</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="11">
<li><p>Nichols and V. Jacobson, Controlling Queue Delay, ACM Queue, Vol. 10 No. 5, May 2012.  Available online at <a class="reference external" href="http://queue.acm.org/detail.cfm?id=2209336">http://queue.acm.org/detail.cfm?id=2209336</a>.</p></li>
</ol>
</div>
<div class="citation" id="nic14" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Nic14</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="11">
<li><p>Nichols and V. Jacobson, Internet-Draft:  Controlled Delay Active Queue Management, March 2014.  Available online at <a class="reference external" href="https://datatracker.ietf.org/doc/html/draft-nichols-tsvwg-codel-02">https://datatracker.ietf.org/doc/html/draft-nichols-tsvwg-codel-02</a>.</p></li>
</ol>
</div>
<div class="citation" id="buf14" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Buf14</a><span class="fn-bracket">]</span></span>
<p>Bufferbloat.net.  Available online at <a class="reference external" href="http://www.bufferbloat.net/">http://www.bufferbloat.net/</a>.</p>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.8.1.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The key attributes that the CoDelQueue class holds include the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The maximum number of packets/bytes the queue can hold. The default value is 1500 * DEFAULT_CODEL_LIMIT, which is 1500 * 1000 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinBytes:</span></code> The CoDel algorithm minbytes parameter. The default value is 1500 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Interval:</span></code> The sliding-minimum window. The default value is 100 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Target:</span></code> The CoDel algorithm target queue delay. The default value is 5 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseEcn:</span></code> True to use ECN (packets are marked instead of being dropped). The default value is false.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CeThreshold:</span></code> The CoDel CE threshold for marking packets. Disabled by default.</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">33.8.1.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The first example is <cite>codel-vs-pfifo-basic-test.cc</cite> located in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples</span></code>.  To run the file (the first invocation below shows the available
command-line options):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;codel-vs-pfifo-basic-test --PrintHelp&quot;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;codel-vs-pfifo-basic-test --queueType=CoDel --pcapFileName=codel.pcap --cwndTrFileName=cwndCodel.tr&quot;</span>
</pre></div>
</div>
<p>The expected output from the previous commands are two files: <cite>codel.pcap</cite> file and <cite>cwndCoDel.tr</cite> (ASCII trace) file The .pcap file can be analyzed using
wireshark or tcptrace:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>tcptrace<span class="w"> </span>-l<span class="w"> </span>-r<span class="w"> </span>-n<span class="w"> </span>-W<span class="w"> </span>codel.pcap
</pre></div>
</div>
<p>The second example is <cite>codel-vs-pfifo-asymmetric.cc</cite> located in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples</span></code>.  This example is intended to model a typical cable modem
deployment scenario.  To run the file:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;codel-vs-pfifo-asymmetric --PrintHelp&quot;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span>codel-vs-pfifo-asymmetric
</pre></div>
</div>
<p>The expected output from the previous commands is six pcap files:</p>
<ul class="simple">
<li><p>codel-vs-pfifo-asymmetric-CoDel-server-lan.pcap</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-router-wan.pcap</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-router-lan.pcap</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-cmts-wan.pcap</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-cmts-lan.pcap</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-host-lan.pcap</p></li>
</ul>
<p>One attribute file:</p>
<ul class="simple">
<li><p>codel-vs-pfifo-asymmetric-CoDel.attr</p></li>
</ul>
<p>Five ASCII trace files:</p>
<ul class="simple">
<li><p>codel-vs-pfifo-asymmetric-CoDel-drop.tr</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-drop-state.tr</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-sojourn.tr</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-length.tr</p></li>
<li><p>codel-vs-pfifo-asymmetric-CoDel-cwnd.tr</p></li>
</ul>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.8.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The CoDel model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">CoDelQueueDiscTestSuite</span></code> class defined in <cite>src/traffic-control/test/codel-queue-test-suite.cc</cite>.  The suite includes 5 test cases:</p>
<ul class="simple">
<li><p>Test 1: The first test checks the enqueue/dequeue with no drops and makes sure that CoDel attributes can be set correctly.</p></li>
<li><p>Test 2: The second test checks the enqueue with drops due to queue overflow.</p></li>
<li><p>Test 3: The third test checks the NewtonStep() arithmetic against explicit port of Linux implementation</p></li>
<li><p>Test 4: The fourth test checks the ControlLaw() against explicit port of Linux implementation</p></li>
<li><p>Test 5: The fifth test checks the enqueue/dequeue with drops according to CoDel algorithm</p></li>
<li><p>Test 6: The sixth test checks the enqueue/dequeue with marks according to CoDel algorithm</p></li>
</ul>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>codel-queue-disc
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;CoDelQueueDisc&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=codel-queue-disc&quot;</span>
</pre></div>
</div>
</section>
</section>
<span id="document-fq-codel"></span><section id="fqcodel-queue-disc">
<span id="sec-fq-codel"></span><h3><span class="section-number">33.9. </span>FqCoDel queue disc<a class="headerlink" href="#fqcodel-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the FqCoDel (<a class="reference internal" href="index.html#hoe16" id="id1"><span>[Hoe16]</span></a>) queue disc implementation in <em>ns-3</em>.</p>
<p>The FlowQueue-CoDel (FQ-CoDel) algorithm is a combined packet scheduler and
Active Queue Management (AQM) algorithm developed as part of the
bufferbloat-fighting community effort (<a class="reference internal" href="index.html#buf16" id="id2"><span>[Buf16]</span></a>).
FqCoDel classifies incoming packets into different queues (by default, 1024
queues are created), which are served according to a modified Deficit Round
Robin (DRR) queue scheduler. Each queue is managed by the CoDel AQM algorithm.
FqCoDel distinguishes between “new” queues (which don’t build up a standing
queue) and “old” queues, that have queued enough data to be around for more
than one iteration of the round-robin scheduler.</p>
<p>FqCoDel is installed by default on single-queue NetDevices (such as PointToPoint,
Csma and Simple). Also, on multi-queue devices (such as Wifi), the default root
qdisc is Mq with as many FqCoDel child queue discs as the number of device queues.</p>
<section id="model-description">
<h4><span class="section-number">33.9.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the FqCoDel queue disc is located in the directory
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code> and consists of 2 files <cite>fq-codel-queue-disc.h</cite>
and <cite>fq-codel-queue-disc.cc</cite> defining a FqCoDelQueueDisc class and a helper
FqCoDelFlow class. The code was ported to <em>ns-3</em> based on Linux kernel code
implemented by Eric Dumazet.
Set associative hashing is also based on the Linux kernel <a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8475045">CAKE</a> queue management code.
Set associative hashing is used to reduce the number of hash collisions in
comparison to choosing queues normally with a simple hash. For a given number of
queues, set associative hashing has fewer collisions than a traditional
hash, as long as the number of flows is lesser than the number of queues.
Essentially, it makes the queue management system more efficient. Set associative
hashing is a vital component of CAKE, which is another popular flow management
algorithm that is implemented in Linux and is being tested for FqCoDel.
Furthermore, this module can be directly used with CAKE when its other
components are implemented in ns-3. The only changes needed to incorporate this
new hashing scheme are in the SetAssociativeHash and DoEnqueue methods,
as described below.</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FqCoDelQueueDisc</span></code>: This class implements the main FqCoDel algorithm:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">FqCoDelQueueDisc::DoEnqueue()</span></code>: If no packet filter has been configured, this routine calls the QueueDiscItem::Hash() method to classify the given packet into an appropriate queue. Otherwise, the configured filters are used to classify the packet. If the filters are unable to classify the packet, the packet is dropped. Otherwise, an option is provided if set associative hashing is to be used.The packet is now handed over to the CoDel algorithm for timestamping. Then, if the queue is not currently active (i.e., if it is not in either the list of new or the list of old queues), it is added to the end of the list of new queues, and its deficit is initiated to the configured quantum. Otherwise,  the queue is left in its current queue list. Finally, the total number of enqueued packets is compared with the configured limit, and if it is above this value (which can happen since a packet was just enqueued), packets are dropped from the head of the queue with the largest current byte count until the number of dropped packets reaches the configured drop batch size or the backlog of the queue has been halved. Note that this in most cases means that the packet that was just enqueued is not among the packets that get dropped, which may even be from a different queue.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FqCoDelQueueDisc::SetAssociativeHash()</span></code>: An outer hash is identified for the given packet. This corresponds to the set into which the packet is to be enqueued. A set consists of a group of queues. The set determined by outer hash is enumerated; if a queue corresponding to this packet’s flow is found (we use per-queue tags to achieve this), or in case of an inactive queue, or if a new queue can be created for this set without exceeding the maximum limit, the index of this queue is returned. Otherwise, all queues of this full set are active and correspond to flows different from the current packet’s flow. In such cases, the index of first queue of this set is returned. We don’t consider creating new queues for the packet in these cases, since this approach may waste resources in the long run. The situation highlighted is a guaranteed collision and cannot be avoided without increasing the overall number of queues.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FqCoDelQueueDisc::DoDequeue()</span></code>: The first task performed by this routine is selecting a queue from which to dequeue a packet. To this end, the scheduler first looks at the list of new queues; for the queue at the head of that list, if that queue has a negative deficit (i.e., it has already dequeued at least a quantum of bytes), it is given an additional amount of deficit, the queue is put onto the end of the list of old queues, and the routine selects the next queue and starts again. Otherwise, that queue is selected for dequeue. If the list of new queues is empty, the scheduler proceeds down the list of old queues in the same fashion (checking the deficit, and either selecting the queue for dequeuing, or increasing deficit and putting the queue back at the end of the list). After having selected a queue from which to dequeue a packet, the CoDel algorithm is invoked on that queue. As a result of this, one or more packets may be discarded from the head of the selected queue, before the packet that should be dequeued is returned (or nothing is returned if the queue is or becomes empty while being handled by the CoDel algorithm). Finally, if the CoDel algorithm does not return a packet, then the queue must be empty, and the scheduler does one of two things: if the queue selected for dequeue came from the list of new queues, it is moved to the end of the list of old queues.  If instead it came from the list of old queues, that queue is removed from the list, to be added back (as a new queue) the next time a packet for that queue arrives. Then (since no packet was available for dequeue), the whole dequeue process is restarted from the beginning. If, instead, the scheduler did get a packet back from the CoDel algorithm, it subtracts the size of the packet from the byte deficit for the selected queue and returns the packet as the result of the dequeue operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FqCoDelQueueDisc::FqCoDelDrop()</span></code>: This routine is invoked by <code class="docutils literal notranslate"><span class="pre">FqCoDelQueueDisc::DoEnqueue()</span></code> to drop packets from the head of the queue with the largest current byte count. This routine keeps dropping packets until the number of dropped packets reaches the configured drop batch size or the backlog of the queue has been halved.</p></li>
</ul>
</li>
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FqCoDelFlow</span></code>: This class implements a flow queue, by keeping its current status (whether it is in the list of new queues, in the list of old queues or inactive) and its current deficit.</p></li>
</ul>
<p>In Linux, by default, packet classification is done by hashing (using a Jenkins
hash function) the 5-tuple of IP protocol, source and destination IP
addresses and port numbers (if they exist). This value modulo
the number of queues is salted by a random value
selected at initialization time, to prevent possible DoS attacks if the hash
is predictable ahead of time. Alternatively, any other packet filter can be
configured.
In <em>ns-3</em>, packet classification is performed in the same way as in Linux.
Neither internal queues nor classes can be configured for an FqCoDel
queue disc.</p>
<section id="possible-next-steps">
<h5><span class="section-number">33.9.1.1. </span>Possible next steps<a class="headerlink" href="#possible-next-steps" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>what to do if ECT(1) and either/both ECT(0) and NotECT are in the same flow queue (hash collisions or tunnels)– our L4S traffic flows will avoid this situation by supporting AccECN and ECN++ (and if it happens in practice, the CoDel logic will just apply two separate thresholds)</p></li>
<li><p>adding a ramp marking response instead of step threshold</p></li>
<li><p>adding a floor value (to suppress marks if the queue length is below a certain number of bytes or packets)</p></li>
<li><p>adding a heuristic such as in PIE to avoid marking a packet if it arrived to an empty flow queue (check on ingress, remember at egress time)</p></li>
</ul>
</section>
<section id="references">
<h5><span class="section-number">33.9.1.2. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="hoe16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Hoe16</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="20">
<li><p>Hoeiland-Joergensen, P. McKenney, D. Taht, J. Gettys and E. Dumazet, The FlowQueue-CoDel Packet Scheduler and Active Queue Management Algorithm, IETF draft.  Available online at <a class="reference external" href="https://tools.ietf.org/html/draft-ietf-aqm-fq-codel">https://tools.ietf.org/html/draft-ietf-aqm-fq-codel</a></p></li>
</ol>
</div>
<div class="citation" id="buf16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Buf16</a><span class="fn-bracket">]</span></span>
<p>Bufferbloat.net.  Available online at <a class="reference external" href="http://www.bufferbloat.net/">http://www.bufferbloat.net/</a>.</p>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.9.1.3. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The key attributes that the FqCoDelQueue class holds include the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UseEcn:</span></code> True to use ECN (packets are marked instead of being dropped)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Interval:</span></code> The interval parameter to be used on the CoDel queues. The default value is 100 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Target:</span></code> The target parameter to be used on the CoDel queues. The default value is 5 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The limit on the maximum number of packets stored by FqCoDel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Flows:</span></code> The number of flow queues managed by FqCoDel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DropBatchSize:</span></code> The maximum number of packets dropped from the fat flow.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Perturbation:</span></code> The salt used as an additional input to the hash function used to classify packets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CeThreshold</span></code> The FqCoDel CE threshold for marking packets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseL4s</span></code> True to use L4S (only ECT1 packets are marked at CE threshold)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EnableSetAssociativeHash:</span></code> The parameter used to enable set associative hash.</p></li>
</ul>
<p>Perturbation is an optional configuration attribute and can be used to generate
different hash outcomes for different inputs.  For instance, the tuples
used as input to the hash may cause hash collisions (mapping to the same
bucket) for a given set of inputs, but by changing the perturbation value,
the same hash inputs now map to distinct buckets.</p>
<p>Note that the quantum, i.e., the number of bytes each queue gets to dequeue on
each round of the scheduling algorithm, is set by default to the MTU size of the
device (at initialisation time). The <code class="docutils literal notranslate"><span class="pre">FqCoDelQueueDisc::SetQuantum</span> <span class="pre">()</span></code> method
can be used (at any time) to configure a different value.</p>
</section>
<section id="examples">
<h5><span class="section-number">33.9.1.4. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a traffic control helper and to configure type
and attributes of queue disc and filters from the helper. For example, FqCodel
can be configured as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::FqCoDelQueueDisc&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DropBatchSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">                                             </span><span class="s">&quot;Perturbation&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">256</span><span class="p">));</span>
<span class="n">QueueDiscContainer</span><span class="w"> </span><span class="n">qdiscs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
<p>The example for FqCoDel’s L4S mode is <cite>FqCoDel-L4S-example.cc</cite> located in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples</span></code>.  To run the file (the first invocation below shows the available
command-line options):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;FqCoDel-L4S-example --PrintHelp&quot;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;FqCoDel-L4S-example --scenarioNum=5&quot;</span>
</pre></div>
</div>
<p>The expected output from the previous command are .dat files.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.9.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The FqCoDel model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FqCoDelQueueDiscTestSuite</span></code> class defined in <cite>src/test/ns3tc/codel-queue-test-suite.cc</cite>.  The suite includes 5 test cases:</p>
<ul class="simple">
<li><p>Test 1: The first test checks that packets that cannot be classified by any available filter are dropped.</p></li>
<li><p>Test 2: The second test checks that IPv4 packets having distinct destination addresses are enqueued into different flow queues. Also, it checks that packets are dropped from the fat flow in case the queue disc capacity is exceeded.</p></li>
<li><p>Test 3: The third test checks the dequeue operation and the deficit round robin-based scheduler.</p></li>
<li><p>Test 4: The fourth test checks that TCP packets with distinct port numbers are enqueued into different flow queues.</p></li>
<li><p>Test 5: The fifth test checks that UDP packets with distinct port numbers are enqueued into different flow queues.</p></li>
<li><p>Test 6: The sixth test checks that the packets are marked correctly.</p></li>
<li><p>Test 7: The seventh test checks the working of set associative hashing and its linear probing capabilities by using TCP packets with different hashes enqueued into different sets and queues.</p></li>
<li><p>Test 8: The eighth test checks the L4S mode of FqCoDel where ECT1 packets are marked at CE threshold (target delay does not matter) while ECT0 packets continue to be marked at target delay (CE threshold does not matter).</p></li>
</ul>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>fq-codel-queue-disc
</pre></div>
</div>
<p>or:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;FqCoDelQueueDisc&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=fq-codel-queue-disc&quot;</span>
</pre></div>
</div>
<p>Set associative hashing is tested by generating a probability collision graph.
This graph is then overlapped with the theoretical graph provided in the original
CAKE paper (refer to Figure 1 from <a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8475045">CAKE</a>).
The generated graph is linked below:</p>
<img alt="Generated Collision Probability Graph" src="_images/collision_prob.jpeg" />
<p>The overlapped graph is also linked below:</p>
<img alt="Overlapped Image with the graph from CAKE paper" src="_images/overlapped.jpeg" />
<p>The steps to replicate this graph are available on this <a class="reference external" href="https://github.com/AB261/Set-Associative-Hash-fqCodel">link</a>.</p>
</section>
</section>
<span id="document-cobalt"></span><section id="cobalt-queue-disc">
<h3><span class="section-number">33.10. </span>Cobalt queue disc<a class="headerlink" href="#cobalt-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the COBALT (CoDel BLUE Alternate) (<a class="reference internal" href="index.html#cake16" id="id1"><span>[Cake16]</span></a>) queue disc
implementation in <em>ns-3</em>.</p>
<p>COBALT queue disc is an integral component of CAKE smart queue management system.
It is a combination of the CoDel (<a class="reference internal" href="index.html#kath17" id="id2"><span>[Kath17]</span></a>) and BLUE (<a class="reference internal" href="index.html#blue02" id="id3"><span>[BLUE02]</span></a>) Active Queue
Management algorithms.</p>
<section id="model-description">
<h4><span class="section-number">33.10.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the COBALT model is located in the directory
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code> and consists of 2 files: <cite>cobalt-queue-disc.h</cite> and
<cite>cobalt-queue-disc.cc</cite> defining a CobaltQueueDisc class and a helper
CobaltTimestampTag class. The code was ported to <em>ns-3</em> by Vignesh Kanan,
Harsh Lara, Shefali Gupta, Jendaipou Palmei and Mohit P. Tahiliani based on
the Linux kernel code.</p>
<p>Stefano Avallone and Pasquale Imputato helped in verifying the correctness of
COBALT model in <em>ns-3</em> by comparing the results obtained from it to those obtained
from the Linux model of COBALT. A detailed comparison of ns-3 model of COBALT with
Linux model of COBALT is provided in (<a class="reference internal" href="index.html#cobalt19" id="id4"><span>[Cobalt19]</span></a>).</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">CobaltQueueDisc</span></code>: This class implements the main
Cobalt algorithm:</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CobaltQueueDisc::DoEnqueue</span> <span class="pre">()</span></code>: This routine tags a packet with the
current time before pushing it into the queue.  The timestamp tag is used by
<code class="docutils literal notranslate"><span class="pre">CobaltQueue::DoDequeue()</span></code> to compute the packet’s sojourn time.  If the
queue is full upon the packet arrival, this routine will drop the packet and
record the number of drops due to queue overflow, which is stored in
<cite>m_stats.qLimDrop</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CobaltQueueDisc::ShouldDrop</span> <span class="pre">()</span></code>: This routine is
<code class="docutils literal notranslate"><span class="pre">CobaltQueueDisc::DoDequeue()</span></code>’s helper routine that determines whether a
packet should be dropped or not based on its sojourn time. If L4S mode is
enabled then if the packet is ECT1 is checked and if delay is greater than
CE threshold then the packet is marked and returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.
If the sojourn time goes above <cite>m_target</cite> and remains above continuously
for at least <cite>m_interval</cite>, the routine returns <code class="docutils literal notranslate"><span class="pre">true</span></code> indicating that it
is OK to drop the packet. <code class="docutils literal notranslate"><span class="pre">Otherwise,</span> <span class="pre">it</span> <span class="pre">returns</span> <span class="pre">``false</span></code>.  If L4S mode
is turned off and CE threshold marking is enabled, then if the delay is
greater than CE threshold, packet is marked. This routine
decides if a packet should be dropped based on the dropping state of
CoDel and drop probability of BLUE.  The idea is to have both algorithms
running in parallel and their effectiveness is decided by their respective
parameters (Pdrop of BLUE and dropping state of CoDel). If either of them
decide to drop the packet, the packet is dropped.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CobaltQueueDisc::DoDequeue</span> <span class="pre">()</span></code>: This routine performs the actual packet
<code class="docutils literal notranslate"><span class="pre">drop</span> <span class="pre">based</span> <span class="pre">on</span> <span class="pre">``CobaltQueueDisc::ShouldDrop()</span></code>’s return value and
schedules the next drop. Cobalt will decrease BLUE’s drop probability
if the queue is empty. This will ensure that the queue does not underflow.
Otherwise Cobalt will take the next packet from the queue and calculate
its drop state by running CoDel and BLUE in parallel till there are none
left to drop.</p></li>
</ul>
<section id="references">
<h5><span class="section-number">33.10.1.1. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="cake16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Cake16</a><span class="fn-bracket">]</span></span>
<p>Linux implementation of Cobalt as a part of the cake framework.
Available online at
<a class="reference external" href="https://github.com/dtaht/sch_cake/blob/master/sch_cake.c">https://github.com/dtaht/sch_cake/blob/master/sch_cake.c</a>.</p>
</div>
<div class="citation" id="kath17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Kath17</a><span class="fn-bracket">]</span></span>
<p>Controlled Delay Active Queue Management
(draft-ietf-aqm-fq-codel-07)
Available online at
<a class="reference external" href="https://tools.ietf.org/html/draft-ietf-aqm-codel-07">https://tools.ietf.org/html/draft-ietf-aqm-codel-07</a>.</p>
</div>
<div class="citation" id="blue02" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">BLUE02</a><span class="fn-bracket">]</span></span>
<p>Feng, W. C., Shin, K. G., Kandlur, D. D., &amp; Saha, D. (2002).
The BLUE
Active Queue Management Algorithms. IEEE/ACM Transactions on Networking
(ToN), 10(4), 513-528.</p>
</div>
<div class="citation" id="cobalt19" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">Cobalt19</a><span class="fn-bracket">]</span></span>
<p>Jendaipou Palmei, Shefali Gupta, Pasquale Imputato, Jonathan
Morton,  Mohit P. Tahiliani, Stefano Avallone and Dave Taht (2019).
Design and Evaluation of COBALT Queue Discipline. IEEE International
Symposium on Local and Metropolitan Area Networks (LANMAN), July 2019.</p>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.10.1.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The key attributes that the CobaltQueue Disc class holds include the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The maximum number of packets/bytes accepted by this queue disc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Interval:</span></code> The sliding-minimum window. The default value is 100 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Target:</span></code> The Cobalt algorithm target queue delay. The default value is 5 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pdrop:</span></code> Value of drop probability.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Increment:</span></code> Increment value of drop probability. Default value is 1./256 .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Decrement:</span></code> Decrement value of drop probability. Default value is 1./4096 .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CeThreshold:</span></code> The CoDel CE threshold for marking packets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseL4s:</span></code> True to use L4S (only ECT1 packets are marked at CE threshold).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Count:</span></code> Cobalt count.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DropState:</span></code> Dropping state of Cobalt. Default value is false.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sojourn:</span></code> Per packet time spent in the queue.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DropNext:</span></code> Time until next packet drop.</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">33.10.1.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>An example program named <cite>cobalt-vs-codel.cc</cite> is located in
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples</span></code>. Use the following command to run the program.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./ns3 run cobalt-vs-codel
</pre></div>
</div>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.10.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The COBALT model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">CobaltQueueDiscTestSuite</span></code> class
defined in <cite>src/traffic-control/test/cobalt-queue-test-suite.cc</cite>.
The suite includes 2 test cases:</p>
<ul class="simple">
<li><p>Test 1: Simple enqueue/dequeue with no drops.</p></li>
<li><p>Test 2: Change of BLUE’s drop probability upon queue full
(Activation of Blue).</p></li>
<li><p>Test 3: This test verifies ECN marking.</p></li>
<li><p>Test 4: CE threshold marking test.</p></li>
</ul>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./ns3 configure --enable-examples --enable-tests
$ ./ns3 build
$ ./test.py -s cobalt-queue-disc
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ NS_LOG=&quot;CobaltQueueDisc&quot; ./ns3 run &quot;test-runner --suite=cobalt-queue-disc&quot;
</pre></div>
</div>
</section>
</section>
<span id="document-fq-cobalt"></span><section id="fqcobalt-queue-disc">
<span id="sec-fq-cobalt"></span><h3><span class="section-number">33.11. </span>FqCobalt queue disc<a class="headerlink" href="#fqcobalt-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the FqCobalt (<a class="reference internal" href="index.html#pal19" id="id1"><span>[Pal19]</span></a>) queue disc implementation in <em>ns-3</em>.</p>
<p>The FlowQueue-Cobalt (FQ-Cobalt) algorithm is similar to FlowQueue-CoDel (FQ-CoDel) algorithm available in :<a class="reference internal" href="index.html#sec-fq-codel"><span class="std std-ref">FqCoDel queue disc</span></a>.
The documentation for Cobalt is available in
<code class="docutils literal notranslate"><span class="pre">ns-3-dev/src/traffic-control/doc/cobalt.rst</span></code>.</p>
<p>FqCobalt is one of the key components of the CAKE smart queue management framework  (<a class="reference internal" href="index.html#hoe18" id="id2"><span>[Hoe18]</span></a>).  The COBALT AQM is preferred to the CoDel AQM for CAKE because
it adds a heuristic called BLUE to cover cases in which the CoDel control
law is too sluggish to respond to queue growth.</p>
<section id="model-description">
<h4><span class="section-number">33.11.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the FqCobalt queue disc is located in the directory
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code> and consists of 2 files <cite>fq-cobalt-queue-disc.h</cite>
and <cite>fq-cobalt-queue-disc.cc</cite> defining a FqCobaltQueueDisc class and a helper
FqCobaltFlow class. The code was ported to <em>ns-3</em> based on Linux kernel code
implemented by Jonathan Morton
(<a class="reference external" href="https://github.com/torvalds/linux/blob/master/net/sched/sch_cake.c">https://github.com/torvalds/linux/blob/master/net/sched/sch_cake.c</a>).</p>
<p>The Model Description is similar to the FqCoDel documentation mentioned above.</p>
<section id="references">
<h5><span class="section-number">33.11.1.1. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="pal19" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Pal19</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="10">
<li><p>Palmei, S. Gupta, P. Imputato, J. Morton, M. Tahiliani, S. Avallone, and D. Taht, Design and Evaluation of COBALT Queue Discipline, 2019 IEEE International Symposium on Local and Metropolitan Area Networks (LANMAN), Paris, France, 2019.</p></li>
</ol>
</div>
<div class="citation" id="hoe18" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Hoe18</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="20">
<li><p>Hoiland-Jørgensen, D. Taht and J. Morton, “Piece of CAKE: A Comprehensive Queue Management Solution for Home Gateways,” 2018 IEEE International Symposium on Local and Metropolitan Area Networks (LANMAN), Washington, DC, USA, 2018.</p></li>
</ol>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.11.1.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>Most of the key attributes are similar to the FqCoDel implementation mentioned above.  One difference is the absence of the <code class="docutils literal notranslate"><span class="pre">MinBytes</span></code> parameter.</p>
<p>Some additional parameters implemented as attributes are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Pdrop:</span></code> Value of drop probability.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Increment:</span></code> Increment value of drop probability. Default value is 1./256 .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Decrement:</span></code> Decrement value of drop probability. Default value is 1./4096 .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BlueThreshold:</span></code> The threshold after which Blue is enabled. Default value is 400ms.</p></li>
</ul>
<p>Note that if the user wants to disable Blue Enhancement then the user can set
it to a large value; for example, to <cite>Time::Max ()</cite>.</p>
</section>
<section id="examples">
<h5><span class="section-number">33.11.1.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a traffic control helper and to configure
the type
and attributes of the queue disc and filters from the helper.
For example, <cite>FqCobalt</cite> can be configured as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::FqCobaltQueueDisc&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;DropBatchSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="w">                     </span><span class="s">&quot;Perturbation&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">256</span><span class="p">));</span>
<span class="n">QueueDiscContainer</span><span class="w"> </span><span class="n">qdiscs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.11.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The FqCobalt model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FqCobaltQueueDiscTestSuite</span></code> class defined in <cite>src/test/ns3tc/codel-queue-test-suite.cc</cite>.</p>
<p>The tests are similar to the ones for FqCoDel queue disc mentioned in first section of this document.
The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>fq-cobalt-queue-disc
</pre></div>
</div>
<p>or:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;FqCobaltQueueDisc&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=fq-cobalt-queue-disc&quot;</span>
</pre></div>
</div>
</section>
</section>
<span id="document-pie"></span><section id="pie-queue-disc">
<h3><span class="section-number">33.12. </span>PIE queue disc<a class="headerlink" href="#pie-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the PIE (<a class="reference internal" href="index.html#pan13" id="id1"><span>[Pan13]</span></a>, <a class="reference internal" href="index.html#pan16" id="id2"><span>[Pan16]</span></a>) queue disc implementation
in <em>ns-3</em>.</p>
<p>Proportional Integral controller Enhanced (PIE) is a queuing discipline that aims to
solve the bufferbloat <a class="reference internal" href="index.html#buf14" id="id3"><span>[Buf14]</span></a> problem. The model in ns-3 is a port of Preethi
Natarajan’s ns-2 PIE model.</p>
<section id="model-description">
<h4><span class="section-number">33.12.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the PIE model is located in the directory <code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code>
and consists of 2 files <cite>pie-queue-disc.h</cite> and <cite>pie-queue-disc.cc</cite> defining a PieQueueDisc
class. The code was ported to <em>ns-3</em> by Mohit P. Tahiliani, Shravya K. S. and Smriti Murali
based on ns-2 code implemented by Preethi Natarajan, Rong Pan, Chiara Piglione, Greg White
and Takashi Hayakawa. The implementation was aligned with RFC 8033 by Vivek Jain and Mohit
P. Tahiliani for the ns-3.32 release, with additional unit test cases contributed by Bhaskar Kataria.</p>
<ul class="simple">
<li><p>class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PieQueueDisc</span></code>: This class implements the main PIE algorithm:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">PieQueueDisc::DoEnqueue()</span></code>: This routine checks whether the queue is full, and if so, drops the packets and records the number of drops due to queue overflow. If queue is not full then if ActiveThreshold is set then it checks if queue delay is higher than ActiveThreshold and if it is then, this routine calls <code class="docutils literal notranslate"><span class="pre">PieQueueDisc::DropEarly()</span></code>, and depending on the value returned, the incoming packet is either enqueued or dropped.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PieQueueDisc::DropEarly()</span></code>: The decision to enqueue or drop the packet is taken by invoking this routine, which returns a boolean value; false indicates enqueue and true indicates drop.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PieQueueDisc::CalculateP()</span></code>: This routine is called at a regular interval of <cite>m_tUpdate</cite> and updates the drop probability, which is required by <code class="docutils literal notranslate"><span class="pre">PieQueueDisc::DropEarly()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PieQueueDisc::DoDequeue()</span></code>: This routine calculates queue delay using timestamps (by default) or, optionally with the <cite>UseDequeRateEstimator</cite> attribute enabled, calculates the average departure rate to estimate queue delay. A queue delay estimate required for updating the drop probability in <code class="docutils literal notranslate"><span class="pre">PieQueueDisc::CalculateP()</span></code>. Starting with the ns-3.32 release, the default approach to calculate queue delay has been changed to use timestamps.</p></li>
</ul>
</li>
</ul>
<section id="references">
<h5><span class="section-number">33.12.1.1. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="pan13" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Pan13</a><span class="fn-bracket">]</span></span>
<p>Pan, R., Natarajan, P., Piglione, C., Prabhu, M. S., Subramanian, V., Baker, F., &amp; VerSteeg, B. (2013, July). PIE: A lightweight control scheme to address the bufferbloat problem. In High Performance Switching and Routing (HPSR), 2013 IEEE 14th International Conference on (pp. 148-155). IEEE.  Available online at <a class="reference external" href="https://www.ietf.org/mail-archive/web/iccrg/current/pdfB57AZSheOH.pdf">https://www.ietf.org/mail-archive/web/iccrg/current/pdfB57AZSheOH.pdf</a>.</p>
</div>
<div class="citation" id="pan16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Pan16</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="18">
<li><p>Pan, P. Natarajan, F. Baker, G. White, B. VerSteeg, M.S. Prabhu, C. Piglione, V. Subramanian, Internet-Draft: PIE: A lightweight control scheme to address the bufferbloat problem, April 2016.  Available online at <a class="reference external" href="https://tools.ietf.org/html/draft-ietf-aqm-pie-07">https://tools.ietf.org/html/draft-ietf-aqm-pie-07</a>.</p></li>
</ol>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.12.1.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The key attributes that the PieQueue class holds include the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> The maximum number of bytes or packets the queue can hold.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeanPktSize:</span></code> Mean packet size in bytes. The default value is 1000 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tupdate:</span></code> Time period to calculate drop probability. The default value is 30 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Supdate:</span></code> Start time of the update timer. The default value is 0 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DequeueThreshold:</span></code> Minimum queue size in bytes before dequeue rate is measured. The default value is 10000 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QueueDelayReference:</span></code> Desired queue delay. The default value is 20 ms.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxBurstAllowance:</span></code> Current max burst allowance in seconds before random drop. The default value is 0.1 seconds.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A:</span></code> Value of alpha. The default value is 0.125.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B:</span></code> Value of beta. The default value is 1.25.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseDequeueRateEstimator:</span></code> Enable/Disable usage of Dequeue Rate Estimator (Default: false).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseEcn:</span></code> True to use ECN. Packets are marked instead of being dropped (Default: false).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MarkEcnThreshold:</span></code> ECN marking threshold (Default: 10% as suggested in RFC 8033).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseDerandomization:</span></code> Enable/Disable Derandomization feature mentioned in RFC 8033 (Default: false).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseCapDropAdjustment:</span></code> Enable/Disable Cap Drop Adjustment feature mentioned in RFC 8033 (Default: true).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ActiveThreshold:</span></code> Threshold for activating PIE (disabled by default).</p></li>
</ul>
</section>
<section id="examples">
<h5><span class="section-number">33.12.1.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>The example for PIE is <cite>pie-example.cc</cite> located in <code class="docutils literal notranslate"><span class="pre">src/traffic-control/examples</span></code>.  To run the file (the first invocation below shows the available
command-line options):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;pie-example --PrintHelp&quot;</span>
$<span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;pie-example --writePcap=1&quot;</span>
</pre></div>
</div>
<p>The expected output from the previous commands are ten .pcap files.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.12.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The PIE model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">PieQueueDiscTestSuite</span></code> class defined in <cite>src/traffic-control/test/pie-queue-test-suite.cc</cite>. The suite includes the following test cases:</p>
<ul class="simple">
<li><p>Test 1: simple enqueue/dequeue with defaults, no drops</p></li>
<li><p>Test 2: more data with defaults, unforced drops but no forced drops</p></li>
<li><p>Test 3: same as test 2, but with higher QueueDelayReference</p></li>
<li><p>Test 4: same as test 2, but with reduced dequeue rate</p></li>
<li><p>Test 5: same dequeue rate as test 4, but with higher Tupdate</p></li>
<li><p>Test 6: same as test 2, but with UseDequeueRateEstimator enabled</p></li>
<li><p>Test 7: test with CapDropAdjustment disabled</p></li>
<li><p>Test 8: test with CapDropAdjustment enabled</p></li>
<li><p>Test 9: PIE queue disc is ECN enabled, but packets are not ECN capable</p></li>
<li><p>Test 10: Packets are ECN capable, but PIE queue disc is not ECN enabled</p></li>
<li><p>Test 11: Packets and PIE queue disc both are ECN capable</p></li>
<li><p>Test 12: test with Derandomization enabled</p></li>
<li><p>Test 13: same as test 11 but with accumulated drop probability set below the low threshold</p></li>
<li><p>Test 14: same as test 12 but with accumulated drop probability set above the high threshold</p></li>
<li><p>Test 15: Tests Active/Inactive feature, ActiveThreshold set to a high value so PIE never starts.</p></li>
<li><p>Test 16: Tests Active/Inactive feature, ActiveThreshold set to a low value so PIE starts early.</p></li>
</ul>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>pie-queue-disc
</pre></div>
</div>
<p>or alternatively (to see logging statements in a debug build):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;PieQueueDisc&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=pie-queue-disc&quot;</span>
</pre></div>
</div>
</section>
</section>
<span id="document-fq-pie"></span><section id="fq-pie-queue-disc">
<h3><span class="section-number">33.13. </span>FQ-PIE queue disc<a class="headerlink" href="#fq-pie-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the FQ-PIE (<a class="reference internal" href="index.html#ram19" id="id1"><span>[Ram19]</span></a>) queue disc implementation in <em>ns-3</em>.</p>
<p>The FQ-PIE queue disc combines the Proportional Integral Controller Enhanced
(PIE) AQM algorithm with the FlowQueue scheduler that is part of FQ-CoDel
(also available in <em>ns-3</em>). FQ-PIE was introduced to Linux kernel version 5.6.</p>
<section id="model-description">
<h4><span class="section-number">33.13.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>The source code for the <code class="docutils literal notranslate"><span class="pre">FqPieQueueDisc</span></code> is located in the directory
<code class="docutils literal notranslate"><span class="pre">src/traffic-control/model</span></code> and consists of 2 files <cite>fq-pie-queue-disc.h</cite>
and <cite>fq-pie-queue-disc.cc</cite> defining a FqPieQueueDisc class and a helper
FqPieFlow class. The code was ported to <em>ns-3</em> based on Linux kernel code
implemented by Mohit P. Tahiliani.</p>
<p>This model calculates drop probability independently in each flow queue.
One difficulty, as pointed out by <a class="reference internal" href="index.html#cablelabs14" id="id2"><span>[CableLabs14]</span></a>, is that PIE calculates
drop probability based on the departure rate of a (flow) queue, which may
be more highly variable than the aggregate queue.  An alternative, which
CableLabs has called SFQ-PIE, is to calculate an overall drop probability
for the entire queue structure, and then scale this drop probability based
on the ratio of the queue depth of each flow queue compared with the depth
of the current largest queue.  This ns-3 model does not implement the
SFQ-PIE variant described by CableLabs.</p>
<section id="references">
<h5><span class="section-number">33.13.1.1. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<div role="list" class="citation-list">
<div class="citation" id="ram19" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Ram19</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="7">
<li><p>Ramakrishnan, M. Bhasi, V. Saicharan, L. Monis, S. D. Patil and M. P. Tahiliani, “FQ-PIE Queue Discipline in the Linux Kernel: Design, Implementation and Challenges,” 2019 IEEE 44th LCN Symposium on Emerging Topics in Networking (LCN Symposium), Osnabrueck, Germany, 2019, pp. 117-124,</p></li>
</ol>
</div>
<div class="citation" id="cablelabs14" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">CableLabs14</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="7">
<li><p>White, Active Queue Management in DOCSIS 3.X Cable Modems, CableLabs white paper, May 2014.</p></li>
</ol>
</div>
</div>
</section>
<section id="attributes">
<h5><span class="section-number">33.13.1.2. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h5>
<p>The key attributes that the FqPieQueue class holds include the following.
First, there are PIE-specific attributes that are copied into the individual
PIE flow queues:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UseEcn:</span></code> Whether to use ECN marking</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MarkEcnThreshold:</span></code> ECN marking threshold (RFC 8033 suggests 0.1 (i.e., 10%) default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseL4s:</span></code> Whether to use L4S (only mark ECT1 packets at CE threshold)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeanPktSize:</span></code> Constant used to roughly convert bytes to packets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A:</span></code> Alpha value in PIE algorithm drop probability calculation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B:</span></code> Beta value in PIE algorithm drop probability calculation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tupdate:</span></code> Time period to calculate drop probability</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Supdate:</span></code> Start time of the update timer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DequeueThreshold:</span></code> Minimum queue size in bytes before dequeue rate is measured</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QueueDelayReference:</span></code> AQM latency target</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxBurstAllowance:</span></code> AQM max burst allowance before random drop</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseDequeueRateEstimator:</span></code> Enable/Disable usage of Dequeue Rate Estimator</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseCapDropAdjustment:</span></code> Enable/Disable Cap Drop Adjustment feature mentioned in RFC 8033</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UseDerandomization:</span></code> Enable/Disable Derandomization feature mentioned in RFC 8033</p></li>
</ul>
<p>Second, there are QueueDisc level, or FQ-specific attributes::
* <code class="docutils literal notranslate"><span class="pre">MaxSize:</span></code> Maximum number of packets in the queue disc
* <code class="docutils literal notranslate"><span class="pre">Flows:</span></code> Maximum number of flow queues
* <code class="docutils literal notranslate"><span class="pre">DropBatchSize:</span></code> Maximum number of packets dropped from the fat flow
* <code class="docutils literal notranslate"><span class="pre">Perturbation:</span></code> Salt value used as hash input when classifying flows
* <code class="docutils literal notranslate"><span class="pre">EnableSetAssociativeHash:</span></code> Enable or disable set associative hash
* <code class="docutils literal notranslate"><span class="pre">SetWays:</span></code> Size of a set of queues in set associative hash</p>
</section>
<section id="examples">
<h5><span class="section-number">33.13.1.3. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a traffic control helper and to configure
the type and attributes of queue disc and filters from the helper. For example, FqPIE
can be configured as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::FqPieQueueDisc&quot;</span><span class="p">,</span>
<span class="w">                     </span><span class="s">&quot;DropBatchSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">                     </span><span class="s">&quot;Perturbation&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">256</span><span class="p">));</span>
<span class="n">QueueDiscContainer</span><span class="w"> </span><span class="n">qdiscs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.13.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The FqPie model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FqPieQueueDiscTestSuite</span></code> class defined in <cite>src/test/ns3tc/fq-pie-queue-test-suite.cc</cite>.</p>
<p>The tests are similar to the ones for FqCoDel queue disc mentioned in first section of this document.
The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>fq-pie-queue-disc
</pre></div>
</div>
<p>or:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;FqPieQueueDisc&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=fq-pie-queue-disc&quot;</span>
</pre></div>
</div>
</section>
</section>
<span id="document-mq"></span><section id="mq-queue-disc">
<h3><span class="section-number">33.14. </span>Mq queue disc<a class="headerlink" href="#mq-queue-disc" title="Link to this heading">¶</a></h3>
<p>This chapter describes the mq queue disc implementation in <em>ns-3</em>.</p>
<p>mq is a classful multiqueue dummy scheduler developed to best fit the multiqueue
traffic control API in Linux. The mq scheduler presents device transmission queues as
classes, allowing to attach different queue discs to them, which are grafted to the
device transmission queues.</p>
<p>Mq is installed by default on multi-queue devices (such as Wifi) with as many FqCodel
child queue discs as the number of device queues.</p>
<section id="model-description">
<h4><span class="section-number">33.14.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h4>
<p>mq is a multi-queue aware queue disc, meaning that it has as many child queue discs as
the number of device transmission queues. Each child queue disc maps to a distinct
device transmission queue. Every packet is enqueued into the child queue disc which
maps to the device transmission queue in which the device will enqueue
the packet.</p>
<p>In <em>ns-3</em>, <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MqQueueDisc</span></code> has a wake mode of WAKE_CHILD, which means that the
traffic control layer enqueues packets directly into one of the child queue discs
(multi-queue devices can provide a callback to inform the traffic control layer of
the device transmission queue that will be selected for a given packet). Therefore,
<code class="docutils literal notranslate"><span class="pre">MqQueueDisc::DoEnqueue</span> <span class="pre">()</span></code> shall never be called (in fact, it raises a fatal error).
Given that dequeuing packets is triggered by enqueuing a packet in the queue disc or
by the device invoking the wake callback, it turns out that <code class="docutils literal notranslate"><span class="pre">MqQueueDisc::DoDequeue</span> <span class="pre">()</span></code>
is never called as well (in fact, it raises a fatal error, too).</p>
<p>The mq queue disc does not require packet filters, does not admit internal queues
and must have as many child queue discs as the number of device transmission queues.</p>
<section id="examples">
<h5><span class="section-number">33.14.1.1. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h5>
<p>A typical usage pattern is to create a traffic control helper used to add the required number of
queue disc classes, attach child queue discs to the classes and (if needed) add packet filters to the
child queue discs. The following code shows how to install an mq queue disc having FqCodel child queue
discs:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TrafficControlHelper</span><span class="w"> </span><span class="n">tch</span><span class="p">;</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">SetRootQueueDisc</span><span class="p">(</span><span class="s">&quot;ns3::MqQueueDisc&quot;</span><span class="p">);</span>
<span class="n">TrafficControlHelper</span><span class="o">::</span><span class="n">ClassIdList</span><span class="w"> </span><span class="n">cls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">AddQueueDiscClasses</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">numTxQueues</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::QueueDiscClass&quot;</span><span class="p">);</span>
<span class="n">tch</span><span class="p">.</span><span class="n">AddChildQueueDiscs</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">cls</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::FqCoDelQueueDisc&quot;</span><span class="p">);</span>
<span class="n">QueueDiscContainer</span><span class="w"> </span><span class="n">qdiscs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tch</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the child queue discs attached to the classes do not necessarily have to be of the same type.</p>
</section>
</section>
<section id="validation">
<h4><span class="section-number">33.14.2. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h4>
<p>The mq model is tested using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">WifiAcMappingTestSuite</span></code> class defined in
<cite>src/test/wifi-ac-mapping-test-suite.cc</cite>. The suite considers a node with a QoS-enabled
wifi device (which has 4 transmission queues) and includes 4 test cases:</p>
<ul class="simple">
<li><p>Test 1: EF-marked packets are enqueued in the queue disc which maps to the AC_VI queue</p></li>
<li><p>Test 2: AF11-marked packets are enqueued in the queue disc which maps to the AC_BK queue</p></li>
<li><p>Test 3: AF32-marked packets are enqueued in the queue disc which maps to the AC_BE queue</p></li>
<li><p>Test 4: CS7-marked packets are enqueued in the queue disc which maps to the AC_VO queue</p></li>
</ul>
<p>The test suite can be run using the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./ns3<span class="w"> </span>configure<span class="w"> </span>--enable-examples<span class="w"> </span>--enable-tests
$<span class="w"> </span>./ns3<span class="w"> </span>build
$<span class="w"> </span>./test.py<span class="w"> </span>-s<span class="w"> </span>ns3-wifi-ac-mapping
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">NS_LOG</span><span class="o">=</span><span class="s2">&quot;WifiAcMappingTest&quot;</span><span class="w"> </span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;test-runner --suite=ns3-wifi-ac-mapping&quot;</span>
</pre></div>
</div>
</section>
</section>
</div>
</section>
<span id="document-uan"></span><section id="uan-framework">
<h2><span class="section-number">34. </span>UAN Framework<a class="headerlink" href="#uan-framework" title="Link to this heading">¶</a></h2>
<p>The main goal of the UAN Framework is to enable researchers to
model a variety of underwater network scenarios.  The UAN model
is broken into four main parts:  The channel, PHY, MAC and
Autonomous Underwater Vehicle (AUV) models.</p>
<p>The need for underwater wireless communications exists in applications such as remote control in offshore oil industry <a class="footnote-reference brackets" href="#id24" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, pollution monitoring in environmental systems, speech transmission between divers, mapping of the ocean floor, mine counter measures <a class="footnote-reference brackets" href="#id25" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id27" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>, seismic monitoring of ocean faults as well as climate changes monitoring. Unfortunately, making on-field measurements is very expensive and there are no commonly accepted standard to base on. Hence, the priority to make research work going on, it is to realize a complete simulation framework that researchers can use to experiment, make tests and make performance evaluation and comparison.</p>
<p>The NS-3 UAN module is a first step in this direction, trying to offer a reliable and realistic tool. In fact, the UAN module offers accurate modelling of the underwater acoustic channel, a model of the WHOI acoustic modem (one of the widely used acoustic modems) <a class="footnote-reference brackets" href="#id29" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> and its communications performance, and some MAC protocols.</p>
<section id="model-description">
<h3><span class="section-number">34.1. </span>Model Description<a class="headerlink" href="#model-description" title="Link to this heading">¶</a></h3>
<p>The source code for the UAN Framework lives in the directory
<code class="docutils literal notranslate"><span class="pre">src/uan</span></code> and in <code class="docutils literal notranslate"><span class="pre">src/energy</span></code> for the contribution on
the li-ion battery model.</p>
<p>The UAN Framework is composed of two main parts:</p>
<ul class="simple">
<li><p>the AUV mobility models, including Electric motor propelled AUV (REMUS class <a class="footnote-reference brackets" href="#id26" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id27" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> ) and Seaglider <a class="footnote-reference brackets" href="#id28" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> models</p></li>
<li><p>the energy models, including AUV energy models, AUV energy sources (batteries) and an acoustic modem energy model</p></li>
</ul>
<p>As enabling component for the energy models, a Li-Ion batteries energy source has been implemented basing on <a class="footnote-reference brackets" href="#id30" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id31" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</p>
<section id="design">
<h4><span class="section-number">34.1.1. </span>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h4>
<section id="uan-propagation-models">
<h5><span class="section-number">34.1.1.1. </span>UAN Propagation Models<a class="headerlink" href="#uan-propagation-models" title="Link to this heading">¶</a></h5>
<p>Modelling of the underwater acoustic channel has been an active
area of research for quite some time.  Given the complications involved,
surface and bottom interactions, varying speed of sound, etc…, the detailed
models in use for ocean acoustics research are much too complex
(in terms of runtime) for use in network level simulations.  We have
attempted to provide the often used models as well as make an attempt to bridge, in part, the gap between
complicated ocean acoustic models and network level simulation.  The three propagation
models included are the ideal channel model, the Thorp propagation model and
the Bellhop propagation model (Available as an addition).</p>
<p>All of the Propagation Models follow the same simple interface in <code class="docutils literal notranslate"><span class="pre">ns3::UanPropModel</span></code>.
The propagation models provide a power delay profile (PDP) and pathloss
information.  The PDP is retrieved using the GetPdp method which returns type UanPdp.
<code class="docutils literal notranslate"><span class="pre">ns3::UanPdp</span></code> utilises a tapped delay line model for the acoustic channel.
The UanPdp class is a container class for Taps, each tap has a delay and amplitude
member corresponding to the time of arrival (relative to the first tap arrival time)
and amplitude.   The propagation model also provides pathloss between the source
and receiver in dB re 1uPa.  The PDP and pathloss can then be used to find the
received signal power over a duration of time (i.e. received signal power in
a symbol duration and ISI which interferes with neighbouring signals).  Both
UanPropModelIdeal and UanPropModelThorp return a single impulse for a PDP.</p>
<ol class="loweralpha simple">
<li><p>Ideal Channel Model <code class="docutils literal notranslate"><span class="pre">ns3::UanPropModelIdeal</span></code></p></li>
</ol>
<p>The ideal channel model assumes 0 pathloss inside a cylindrical area with bounds
set by attribute.  The ideal channel model also assumes an impulse PDP.</p>
<ol class="loweralpha simple" start="2">
<li><p>Thorp Propagation Model <code class="docutils literal notranslate"><span class="pre">ns3::UanPropModelThorp</span></code></p></li>
</ol>
<p>The Thorp Propagation Model calculates pathloss using the well-known Thorp approximation.
This model is similar to the underwater channel model implemented in ns2 as described here:</p>
<p>Harris, A. F. and Zorzi, M. 2007. Modeling the underwater acoustic channel in ns2. In Proceedings
of the 2nd international Conference on Performance Evaluation Methodologies and Tools
(Nantes, France, October 22 - 27, 2007). ValueTools, vol. 321. ICST (Institute for Computer
Sciences Social-Informatics and Telecommunications Engineering), ICST, Brussels, Belgium, 1-8.</p>
<p>The frequency used in calculation however, is the center frequency of the modulation as found from
ns3::UanTxMode.  The Thorp Propagation Model also assumes an impulse channel response.</p>
<ol class="loweralpha simple" start="3">
<li><p>Bellhop Propagation Model <code class="docutils literal notranslate"><span class="pre">ns3::UanPropModelBh</span></code> (Available as an addition)</p></li>
</ol>
<p>The Bellhop propagation model reads propagation information from a database.  A configuration
file describing the location, and resolution of the archived information must be supplied via
attributes.  We have included a utility, create-dat, which can create these data files using the Bellhop
Acoustic Ray Tracing software (<a class="reference external" href="http://oalib.hlsresearch.com/">http://oalib.hlsresearch.com/</a>).</p>
<p>The create-dat utility requires a Bellhop installation to run.  Bellhop takes
environment information about the channel, such as sound speed profile, surface height
bottom type, water depth, and uses a Gaussian ray tracing algorithm to determine
propagation information.  Arrivals from Bellhop are grouped together into equal length
taps (the arrivals in a tap duration are coherently summed).  The maximum taps are then
aligned to take the same position in the PDP.  The create-dat utility averages together
several runs and then normalizes the average such that the sum of all taps is 1.  The same
configuration file used to create the data files using create-dat should be passed via
attribute to the Bellhop Propagation Model.</p>
<p>The Bellhop propagation model is available as a patch.  The link address will be
made available here when it is posted online.  Otherwise email <a class="reference external" href="mailto:lentracy&#37;&#52;&#48;gmail&#46;com">lentracy<span>&#64;</span>gmail<span>&#46;</span>com</a>
for more information.</p>
</section>
<section id="uan-phy-model-overview">
<h5><span class="section-number">34.1.1.2. </span>UAN PHY Model Overview<a class="headerlink" href="#uan-phy-model-overview" title="Link to this heading">¶</a></h5>
<p>The PHY has been designed to allow for relatively easy extension
to new networking scenarios.  We feel this is important as, to date,
there has been no commonly accepted network level simulation model
for underwater networks.  The lack of commonly accepted network simulation
tools has resulted in a wide array of simulators and models used to report
results in literature.  The lack of standardization makes comparing results
nearly impossible.</p>
<p>The main component of the PHY Model is the generic
PHY class, <code class="docutils literal notranslate"><span class="pre">ns3::UanPhyGen</span></code>.  The PHY class’s general responsibility
is to handle packet acquisition, error determination, and forwarding of successful
packets up to the MAC layer.  The Generic PHY uses two models for determination
of signal to noise ratio (SINR) and packet error rate (PER).  The
combination of the PER and SINR models determine successful reception
of packets.  The PHY model connects to the channel via a Transducer class.
The Transducer class is responsible for tracking all arriving packets and
departing packets over the duration of the events. How the PHY class and the PER and SINR models
respond to packets is based on the “Mode” of the transmission as described by the <code class="docutils literal notranslate"><span class="pre">ns3::UanTxMode</span></code>
class.</p>
<p>When a MAC layer sends down a packet to the PHY for transmission it specifies a “mode number” to
be used for the transmission.  The PHY class accepts, as an attribute, a list of supported modes.  The
mode number corresponds to an index in the supported modes.  The UanTxMode contains simple modulation
information and a unique string id.  The generic PHY class will only acquire arriving packets which
use a mode which is in the supported modes list of the PHY.  The mode along with received signal power,
and other pertinent attributes (e.g. possibly interfering packets and their modes) are passed to the SINR
and PER models for calculation of SINR and probability of error.</p>
<p>Several simple example PER and SINR models have been created.
a) The PER models
- Default (simple) PER model (<code class="docutils literal notranslate"><span class="pre">ns3::UanPhyPerGenDefault</span></code>):  The Default PER model tests the packet against a threshold and
assumes error (with prob. 1) if the SINR is below the threshold or success if the SINR is above
the threshold
- Micromodem FH-FSK PER (<code class="docutils literal notranslate"><span class="pre">ns3::UanPhyPerUmodem</span></code>).  The FH-FSK PER model calculates probability of error assuming a
rate 1/2 convolutional code with constraint length 9 and a CRC check capable of correcting
up to 1 bit error.  This is similar to what is used in the receiver of the WHOI Micromodem.</p>
<p>b) SINR models
- Default Model (<code class="docutils literal notranslate"><span class="pre">ns3::UanPhyCalcSinrDefault</span></code>), The default SINR model assumes that all transmitted energy is captured at the receiver
and that there is no ISI.  Any received signal power from interferes acts as additional ambient noise.
- FH-FSK SINR Model (<code class="docutils literal notranslate"><span class="pre">ns3::UanPhyCalcSinrFhFsk</span></code>), The WHOI Micromodem operating in FH-FSK mode uses a predetermined hopping
pattern that is shared by all nodes in the network.  We model this by only including signal
energy receiving within one symbol time (as given by <code class="docutils literal notranslate"><span class="pre">ns3::UanTxMode</span></code>) in calculating the
received signal power.  A channel clearing time is given to the FH-FSK SINR model via attribute.
Any signal energy arriving in adjacent signals (after a symbol time and the clearing time) is
considered ISI and is treated as additional ambient noise.   Interfering signal arrivals inside
a symbol time (any symbol time) is also counted as additional ambient noise
- Frequency filtered SINR (<code class="docutils literal notranslate"><span class="pre">ns3::UanPhyCalcSinrDual</span></code>).  This SINR model calculates SINR in the same manner
as the default model.  This model however only considers interference if there is an overlap in frequency
of the arriving packets as determined by UanTxMode.</p>
<p>In addition to the generic PHY a dual phy layer is also included (<code class="docutils literal notranslate"><span class="pre">ns3::UanPhyDual</span></code>).  This wraps two
generic phy layers together to model a net device which includes two receivers.  This was primarily
developed for UanMacRc, described in the next section.</p>
</section>
<section id="uan-mac-model-overview">
<h5><span class="section-number">34.1.1.3. </span>UAN MAC Model Overview<a class="headerlink" href="#uan-mac-model-overview" title="Link to this heading">¶</a></h5>
<p>Over the last several years there have been a myriad of underwater MAC proposals
in the literature.  We have included three MAC protocols with this distribution:
a) CW-MAC, a MAC protocol which uses a slotted contention window similar in nature to
the IEEE 802.11 DCF.  Nodes have a constant contention window measured in slot times (configured
via attribute).  If the channel is sensed busy, then nodes backoff by randomly (uniform distribution) choose
a slot to transmit in.  The slot time durations are also configured via attribute.  This MAC was described in</p>
<p>Parrish N.; Tracy L.; Roy S. Arabshahi P.; and Fox, W.,  System Design Considerations for Undersea Networks:
Link and Multiple Access Protocols , IEEE Journal on Selected Areas in Communications (JSAC), Special
Issue on Underwater Wireless Communications and Networks, Dec. 2008.</p>
<p>b) RC-MAC (<code class="docutils literal notranslate"><span class="pre">ns3::UanMacRc</span></code> <code class="docutils literal notranslate"><span class="pre">ns3::UanMacRcGw</span></code>) a reservation channel protocol which dynamically divides
the available bandwidth into a data channel and a control channel.  This MAC protocol
assumes there is a gateway node which all network traffic is destined for.  The current
implementation assumes a single gateway and a single network neighborhood (a single hop network).
RTS/CTS handshaking is used and time is divided into cycles.  Non-gateway nodes transmit RTS packets
on the control channel in parallel to data packet transmissions which were scheduled in the previous cycle
at the start of a new cycle, the gateway responds on the data channel with a CTS packet which includes
packet transmission times of data packets for received RTS packets in the previous cycle as well as bandwidth
allocation information.  At the end of a cycle ACK packets are transmitted for received data packets.</p>
<p>When a publication is available it will be cited here.</p>
<ol class="loweralpha simple" start="3">
<li><p>Simple ALOHA (<code class="docutils literal notranslate"><span class="pre">ns3::UanMacAloha</span></code>)  Nodes transmit at will.</p></li>
</ol>
</section>
<section id="auv-mobility-models">
<h5><span class="section-number">34.1.1.4. </span>AUV mobility models<a class="headerlink" href="#auv-mobility-models" title="Link to this heading">¶</a></h5>
<p>The AUV mobility models have been designed as in the follows.</p>
<section id="use-cases">
<h6><span class="section-number">34.1.1.4.1. </span>Use cases<a class="headerlink" href="#use-cases" title="Link to this heading">¶</a></h6>
<p>The user will be able to:</p>
<ul class="simple">
<li><p>program the AUV to navigate over a path of waypoints</p></li>
<li><p>control the velocity of the AUV</p></li>
<li><p>control the depth of the AUV</p></li>
<li><p>control the direction of the AUV</p></li>
<li><p>control the pitch of the AUV</p></li>
<li><p>tell the AUV to emerge or submerge to a specified depth</p></li>
</ul>
</section>
<section id="auv-mobility-models-design">
<h6><span class="section-number">34.1.1.4.2. </span>AUV mobility models design<a class="headerlink" href="#auv-mobility-models-design" title="Link to this heading">¶</a></h6>
<p>Implement a model of the navigation of AUV. This involves implementing two classes modelling the two major categories of AUVs: electric motor propelled (like REMUS class <a class="footnote-reference brackets" href="#id26" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id27" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>) and “sea gliders” <a class="footnote-reference brackets" href="#id28" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.
The classic AUVs are submarine-like devices, propelled by an electric motor linked with a propeller. Instead, the “sea glider” class exploits small changes in its buoyancy that, in conjunction with wings, can convert vertical motion to horizontal. So, a glider will reach a point into the water by describing a “saw-tooth” movement.
Modelling the AUV navigation, involves in considering a real-world AUV class thus, taking into account maximum speed, directional capabilities, emerging and submerging times.
Regarding the sea gliders, it is modelled the characteristic saw-tooth movement, with AUV’s speed driven by buoyancy and glide angle.</p>
<figure class="align-default" id="id38">
<span id="auvmobilitymodel"></span><img alt="_images/auvmobility-classes.png" src="_images/auvmobility-classes.png" />
<figcaption>
<p><span class="caption-text">AUV’s mobility model classes overview</span><a class="headerlink" href="#id38" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>An <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::AuvMobilityModel</span></code> interface has been designed to give users a generic interface to access AUV’s navigation functions.
The AuvMobilityModel interface is implemented by the RemusMobilityModel and the GliderMobilityModel classes. The AUV’s mobility models organization it is shown in <a class="reference internal" href="#auvmobilitymodel"><span class="std std-ref">AUV’s mobility model classes overview</span></a>.
Both models use a constant velocity movement, thus the AuvMobilityModel interface derives from the ConstantVelocityMobilityModel. The two classes hold the navigation parameters for the two different AUVs, like maximum pitch angles, maximum operating depth, maximum and minimum speed values. The Glider model holds also some extra parameters like maximum buoyancy values, and maximum and minimum glide slopes.
Both classes, RemusMobilityModel and GliderMobilityModel, handle also the AUV power consumption, utilizing the relative power models.
Has been modified the WaypointMobilityModel to let it use a generic underlying ConstantVelocityModel to validate the waypoints and, to keep trace of the node’s position. The default model is the classic ConstantVelocityModel but, for example in case of REMUS mobility model, the user can install the AUV mobility model into the waypoint model and then validating the waypoints against REMUS navigation constraints.</p>
</section>
</section>
<section id="energy-models">
<h5><span class="section-number">34.1.1.5. </span>Energy models<a class="headerlink" href="#energy-models" title="Link to this heading">¶</a></h5>
<p>The energy models have been designed as in the follows.</p>
<section id="id13">
<h6><span class="section-number">34.1.1.5.1. </span>Use cases<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h6>
<p>The user will be able to:</p>
<ul class="simple">
<li><p>use a specific power profile for the acoustic modem</p></li>
<li><p>use a specific energy model for the AUV</p></li>
<li><p>trace the power consumption of AUV navigation, through AUV’s energy model</p></li>
<li><p>trace the power consumption underwater acoustic communications, through acoustic modem power profile</p></li>
</ul>
<p>We have integrated the Energy Model with the UAN module, to implement energy handling. We have implemented a specific energy model for the two AUV classes and, an energy source for Lithium batteries. This will be really useful for researchers to keep trace of the AUV operational life.
We have implemented also an acoustic modem power profile, to keep trace of its power consumption. This can be used to compare protocols specific power performance. In order to use such power profile, the acoustic transducer physical layer has been modified to use the modem power profile. We have decoupled the physical layer from the transducer specific energy model, to let the users change the different energy models without changing the physical layer.</p>
</section>
<section id="auv-energy-models">
<h6><span class="section-number">34.1.1.5.2. </span>AUV energy models<a class="headerlink" href="#auv-energy-models" title="Link to this heading">¶</a></h6>
<p>Basing on the Device Energy Model interface, it has been implemented a specific energy model for the two AUV classes (REMUS and Seaglider). This models reproduce the AUV’s specific power consumption to give users accurate information. This model can be naturally used to evaluates the AUV operating life, as well as mission-related power consumption, etc. Have been developed two AUV energy models:</p>
<ul class="simple">
<li><p>GliderEnergyModel, computes the power consumption of the vehicle based on the current buoyancy value and vertical speed <a class="footnote-reference brackets" href="#id28" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></li>
<li><p>RemusEnergyModel, computes the power consumption of the vehicle based on the current speed, as it is propelled by a brush-less electric motor</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO extend a little bit</p>
</div>
</section>
<section id="auv-energy-sources">
<h6><span class="section-number">34.1.1.5.3. </span>AUV energy sources<a class="headerlink" href="#auv-energy-sources" title="Link to this heading">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>[TODO]</p>
</div>
</section>
<section id="acoustic-modem-energy-model">
<h6><span class="section-number">34.1.1.5.4. </span>Acoustic modem energy model<a class="headerlink" href="#acoustic-modem-energy-model" title="Link to this heading">¶</a></h6>
<p>Basing on the Device Energy Model interface, has been implemented a generic energy model for acoustic modem. The model allows to trace four modem’s power-states: Sleep, Idle, Receiving, Transmitting. The default parameters for the energy model are set to fit those of the WHOI <img class="math" src="_images/math/4a3598141469c2555591e66606a1b86d4ec6dca9.png" alt="\mu"/>-modem. The class follows pretty closely the RadioEnergyModel class as the transducer behaviour is pretty close to that of a Wi-Fi radio.</p>
<p>The default power consumption values implemented into the model are as follows <a class="footnote-reference brackets" href="#id29" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Modem State</p></td>
<td><p>Power Consumption</p></td>
</tr>
<tr class="row-even"><td><p>TX</p></td>
<td><p>50 W</p></td>
</tr>
<tr class="row-odd"><td><p>RX</p></td>
<td><p>158 mW</p></td>
</tr>
<tr class="row-even"><td><p>Idle</p></td>
<td><p>158 mW</p></td>
</tr>
<tr class="row-odd"><td><p>Sleep</p></td>
<td><p>5.8 mW</p></td>
</tr>
</tbody>
</table>
</section>
<section id="uan-module-energy-modifications">
<h6><span class="section-number">34.1.1.5.5. </span>UAN module energy modifications<a class="headerlink" href="#uan-module-energy-modifications" title="Link to this heading">¶</a></h6>
<p>The UAN module has been modified in order to utilize the implemented energy classes. Specifically, it has been modified the physical layer of the UAN module. It Has been implemented an UpdatePowerConsumption method that takes the modem’s state as parameter. It checks if an energy source is installed into the node and, in case, it then use the AcousticModemEnergyModel to update the power consumption with the current modem’s state. The modem power consumption’s update takes place whenever the modem changes its state.</p>
<p>A user should take into account that, if the power consumption handling is enabled (if the node has an energy source installed), all the communications processes will terminate whether the node depletes all the energy source.</p>
</section>
<section id="li-ion-batteries-model">
<h6><span class="section-number">34.1.1.5.6. </span>Li-Ion batteries model<a class="headerlink" href="#li-ion-batteries-model" title="Link to this heading">¶</a></h6>
<p>A generic Li-Ion battery model has been implemented based on <a class="footnote-reference brackets" href="#id30" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id31" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>. The model can be fitted to any type of Li-Ion battery simply changing the model’s parameters The default values are fitted for the Panasonic CGR18650DA Li-Ion Battery <a class="footnote-reference brackets" href="#id32" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.
[TODO insert figure]
As shown in figure the model approximates very well the Li-Ion cells.
Regarding Seagliders, the batteries used into the AUV are Electrochem 3B36 Lithium / Sulfuryl Chloride cells <a class="footnote-reference brackets" href="#id33" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. Also with this cell type, the model seems to approximates the different discharge curves pretty well, as shown in the figure.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>should I insert the li-ion model details here? I think it is better to put them into an Energy-related chapter..</p>
</div>
</section>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">34.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>The framework is designed to simulate AUV’s behaviour. We have modeled the navigation and power consumption behaviour of REMUS class and Seaglider AUVs.
The communications stack, associated with the AUV, can be modified depending on simulation needs. Usually, the default underwater stack is being used, composed of an half duplex acoustic modem, an Aloha MAC protocol and a generic physical layer.</p>
<p>Regarding the AUV energy consumption, the user should be aware that the level of accuracy differs for the two classes:</p>
<ul class="simple">
<li><p>Seaglider, high level of accuracy, thanks to the availability of detailed information on AUV’s components and behaviour <a class="footnote-reference brackets" href="#id28" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id33" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. Have been modeled both the navigation power consumption and the Li battery packs (according to <a class="footnote-reference brackets" href="#id28" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>).</p></li>
<li><p>REMUS, medium level of accuracy, due to the lack of publicly available information on AUV’s components. We have approximated the power consumption of the AUV’s motor with a linear behaviour and, the energy source uses an ideal model (BasicEnergySource) with a power capacity equal to that specified in <a class="footnote-reference brackets" href="#id27" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</section>
<section id="future-work">
<h4><span class="section-number">34.1.3. </span>Future Work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h4>
<p>Some ideas could be :</p>
<ul class="simple">
<li><p>insert a data logging capability</p></li>
<li><p>modify the framework to use sockets (enabling the possibility to use applications)</p></li>
<li><p>introduce some more MAC protocols</p></li>
<li><p>modify the physical layer to let it consider the Doppler spread (problematic in underwater environments)</p></li>
<li><p>introduce OFDM modulations</p></li>
</ul>
</section>
<section id="references">
<h4><span class="section-number">34.1.4. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h4>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>BINGHAM, D.; DRAKE, T.; HILL, A.; LOTT, R.; The Application of Autonomous Underwater Vehicle (AUV) Technology in the Oil Industry – Vision and Experiences, URL: <a class="reference external" href="http://www.fig.net/pub/fig_2002/Ts4-4/TS4_4_bingham_etal.pdf">http://www.fig.net/pub/fig_2002/Ts4-4/TS4_4_bingham_etal.pdf</a></p>
</aside>
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>AUVfest2008: Underwater mines; URL: <a class="reference external" href="http://oceanexplorer.noaa.gov/explorations/08auvfest/background/mines/mines.html">http://oceanexplorer.noaa.gov/explorations/08auvfest/background/mines/mines.html</a></p>
</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id10">2</a>,<a role="doc-backlink" href="#id36">3</a>)</span>
<p>Hydroinc (acquired by Huntington Ingalls Industries) Products; URL: <a class="reference external" href="https://tsd.huntingtoningalls.com/what-we-do/unmanned-systems/unmanned-underwater-vehicles/">https://tsd.huntingtoningalls.com/what-we-do/unmanned-systems/unmanned-underwater-vehicles/</a></p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id11">3</a>,<a role="doc-backlink" href="#id23">4</a>)</span>
<p>WHOI, Autonomous Underwater Vehicle, REMUS; URL: <a class="reference external" href="http://www.whoi.edu/page.do?pid=29856">http://www.whoi.edu/page.do?pid=29856</a></p>
</aside>
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id12">2</a>,<a role="doc-backlink" href="#id14">3</a>,<a role="doc-backlink" href="#id20">4</a>,<a role="doc-backlink" href="#id22">5</a>,<a role="doc-backlink" href="#id35">6</a>)</span>
<p>Eriksen, C.C., T.J. Osse, R.D. Light, T. Wen, T.W. Lehman, P.L. Sabin, J.W. Ballard, and A.M.
Chiodi. Seaglider: A Long-Range Autonomous Underwater Vehicle for Oceanographic Research,
IEEE Journal of Oceanic Engineering, 26, 4, October 2001.
URL: <a class="reference external" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=972073&amp;userType=inst">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=972073&amp;userType=inst</a></p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id15">2</a>)</span>
<p>L. Freitag, M. Grund, I. Singh, J. Partan, P. Koski, K. Ball, and W. Hole, The whoi
micro-modem: an acoustic communications and navigation system for multiple platforms,
In Proc. IEEE OCEANS05 Conf, 2005. URL: <a class="reference external" href="http://ieeexplore.ieee.org/iel5/10918/34367/01639901.pdf">http://ieeexplore.ieee.org/iel5/10918/34367/01639901.pdf</a></p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id8">1</a>,<a role="doc-backlink" href="#id16">2</a>)</span>
<p>C. M. Shepherd, “Design of Primary and Secondary Cells - Part 3.
Battery discharge equation,” U.S. Naval Research Laboratory, 1963</p>
</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id17">2</a>)</span>
<p>Tremblay, O.; Dessaint, L.-A.; Dekkiche, A.-I., “A Generic Battery Model for the
Dynamic Simulation of Hybrid Electric Vehicles,” Ecole de Technologie Superieure,
Universite du Quebec, 2007 URL: <a class="reference external" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4544139">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4544139</a></p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id18">1</a>,<a role="doc-backlink" href="#id34">2</a>,<a role="doc-backlink" href="#id37">3</a>)</span>
<p>Panasonic CGR18650DA Datasheet, URL: <a class="reference external" href="http://www.panasonic.com/industrial/includes/pdf/Panasonic_LiIon_CGR18650DA.pdf">http://www.panasonic.com/industrial/includes/pdf/Panasonic_LiIon_CGR18650DA.pdf</a></p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id19">1</a>,<a role="doc-backlink" href="#id21">2</a>)</span>
<p>Electrochem 3B36 Datasheet, URL: <a class="reference external" href="http://www.electrochem.com.cn/products/Primary/HighRate/CSC/3B36.pdf">http://www.electrochem.com.cn/products/Primary/HighRate/CSC/3B36.pdf</a></p>
</aside>
</aside>
</section>
</section>
<section id="usage">
<h3><span class="section-number">34.2. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>The main way that users who write simulation scripts will typically
interact with the UAN Framework is through the helper API and through
the publicly visible attributes of the model.</p>
<p>The helper API is defined in <code class="docutils literal notranslate"><span class="pre">src/uan/helper/acoustic-modem-energy-model-helper.{cc,h}</span></code> and in <code class="docutils literal notranslate"><span class="pre">/src/uan/helper/...{cc,h}</span></code>.</p>
<p>The example folder <code class="docutils literal notranslate"><span class="pre">src/uan/examples/</span></code> contain some basic code that shows how to set up and use the models.
further examples can be found into the Unit tests in <code class="docutils literal notranslate"><span class="pre">src/uan/test/...cc</span></code></p>
<section id="examples">
<h4><span class="section-number">34.2.1. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>Examples of the Framework’s usage can be found into the examples folder. There are mobility related examples and UAN related ones.</p>
<section id="mobility-model-examples">
<h5><span class="section-number">34.2.1.1. </span>Mobility Model Examples<a class="headerlink" href="#mobility-model-examples" title="Link to this heading">¶</a></h5>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">auv-energy-model</span></code>:</dt><dd><p>In this example we show the basic usage of an AUV energy model.
Specifically, we show how to create a generic node, adding to it a basic energy source
and consuming energy from the energy source. In this example we show the basic usage of
an AUV energy model.</p>
<p>The Seaglider AUV power consumption depends on buoyancy and vertical speed values, so we simulate a 20 seconds movement at 0.3 m/s of vertical speed and 138g of buoyancy. Then a 20 seconds movement at 0.2 m/s of vertical speed and 138g of buoyancy and then a stop of 5 seconds.</p>
<p>The required energy will be drained by the model basing on the given buoyancy/speed values, from the energy source installed onto the node. We finally register a callback to the TotalEnergyConsumption traced value.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">auv-mobility</span></code>:</dt><dd><p>In this example we show how to use the AuvMobilityHelper to install an AUV mobility model into a (set of) node. Then we make the AUV to submerge to a depth of 1000 meters. We then set a callback function called on reaching of the target depth.
The callback then makes the AUV to emerge to water surface (0 meters). We set also a callback function called on reaching of the target depth.
The emerge callback then, stops the AUV.</p>
<p>During the whole navigation process, the AUV’s position is tracked by the TracePos function and plotted into a Gnuplot graph.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">waypoint-mobility</span></code>:</dt><dd><p>We show how to use the WaypointMobilityModel with a non-standard ConstantVelocityMobilityModel.
We first create a waypoint model with an underlying RemusMobilityModel setting the mobility trace with two waypoints.
We then create a waypoint model with an underlying GliderMobilityModel setting the waypoints separately with the AddWaypoint method.
The AUV’s position is printed out every seconds.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="uan-examples">
<h5><span class="section-number">34.2.1.2. </span>UAN Examples<a class="headerlink" href="#uan-examples" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">li-ion-energy-source</span></code></dt><dd><p>In this simple example, we show how to create and drain energy from a LiIonEnergySource.
We make a series of discharge calls to the energy source class, with different current drain and durations, until all the energy is depleted from the cell (i.e. the voltage of the cell goes below the threshold level).
Every 20 seconds we print out the actual cell voltage to verify that it follows the discharge curve <a class="footnote-reference brackets" href="#id32" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.
At the end of the example it is verified that after the energy depletion call, the cell voltage is below the threshold voltage.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uan-energy-auv</span></code></dt><dd><p>This is a comprehensive example where all the project’s components are used.
We setup two nodes, one fixed surface gateway equipped with an acoustic modem and a moving Seaglider AUV with an acoustic modem too.
Using the waypoint mobility model with an underlying GliderMobilityModel, we make the glider descend to -1000 meters and then emerge to the water surface.
The AUV sends a generic 17-bytes packet every 10 seconds during the navigation process. The gateway receives the packets and stores the total bytes amount.
At the end of the simulation are shown the energy consumptions of the two nodes and the networking stats.</p>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<section id="helpers">
<h4><span class="section-number">34.2.2. </span>Helpers<a class="headerlink" href="#helpers" title="Link to this heading">¶</a></h4>
<p>In this section we give an overview of the available helpers and their behaviour.</p>
<section id="acousticmodemenergymodelhelper">
<h5><span class="section-number">34.2.2.1. </span>AcousticModemEnergyModelHelper<a class="headerlink" href="#acousticmodemenergymodelhelper" title="Link to this heading">¶</a></h5>
<p>This helper installs AcousticModemEnergyModel into UanNetDevice objects only. It requires an UanNetDevice and an EnergySource as input objects.</p>
<p>The helper creates an AcousticModemEnergyModel with default parameters and associate it with the given energy source. It configures an EnergyModelCallback and an EnergyDepletionCallback. The depletion callback can be configured as a parameter.</p>
</section>
<section id="auvgliderhelper">
<h5><span class="section-number">34.2.2.2. </span>AuvGliderHelper<a class="headerlink" href="#auvgliderhelper" title="Link to this heading">¶</a></h5>
<p>Installs into a node (or set of nodes) the Seaglider’s features:</p>
<ul class="simple">
<li><p>waypoint model with underlying glider mobility model</p></li>
<li><p>glider energy model</p></li>
<li><p>glider energy source</p></li>
<li><p>micro modem energy model</p></li>
</ul>
<p>The glider mobility model is the GliderMobilityModel with default parameters.
The glider energy model is the GliderEnergyModel with default parameters.</p>
<p>Regarding the energy source, the Seaglider features two battery packs, one for motor power and one for digital-analog power.
Each pack is composed of 12 (10V) and 42 (24V) lithium chloride DD-cell batteries, respectively <a class="footnote-reference brackets" href="#id28" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. The total power capacity is around 17.5 MJ (3.9 MJ + 13.6 MJ).
In the original version of the Seaglider there was 18 + 63 D-cell with a total power capacity of 10MJ.</p>
<p>The packs design is as follows:</p>
<ul class="simple">
<li><p>10V - 3 in-series string x 4 strings = 12 cells - typical capacity ~100 Ah</p></li>
<li><p>24V - 7 in-series-strings x 6 strings = 42 cells - typical capacity ~150 Ah</p></li>
</ul>
<p>Battery cells are Electrochem 3B36, with 3.6 V nominal voltage and 30.0 Ah nominal capacity.
The 10V battery pack is associated with the electronic devices, while the 24V one is associated with the pump motor.</p>
<p>The micro modem energy model is the MicroModemEnergyModel with default parameters.</p>
</section>
<section id="auvremushelper">
<h5><span class="section-number">34.2.2.3. </span>AuvRemusHelper<a class="headerlink" href="#auvremushelper" title="Link to this heading">¶</a></h5>
<p>Install into a node (or set of nodes) the REMUS features:</p>
<ul class="simple">
<li><p>waypoint model with REMUS mobility model validation</p></li>
<li><p>REMUS energy model</p></li>
<li><p>REMUS energy source</p></li>
<li><p>micro modem energy model</p></li>
</ul>
<p>The REMUS mobility model is the RemusMobilityModel with default parameters.
The REMUS energy model is the RemusEnergyModel with default parameters.</p>
<p>Regarding the energy source, the REMUS features a rechargeable lithium ion battery pack rated 1.1 kWh &#64; 27 V (40 Ah) in operating conditions (specifications from <a class="footnote-reference brackets" href="#id26" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> and Hydroinc European salesman).
Since more detailed information about battery pack were not publicly available, the energy source used is a BasicEnergySource.</p>
<p>The micro modem energy model is the MicroModemEnergyModel with default parameters.</p>
</section>
</section>
<section id="attributes">
<h4><span class="section-number">34.2.3. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
<section id="tracing">
<h4><span class="section-number">34.2.4. </span>Tracing<a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
<section id="logging">
<h4><span class="section-number">34.2.5. </span>Logging<a class="headerlink" href="#logging" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
<section id="caveats">
<h4><span class="section-number">34.2.6. </span>Caveats<a class="headerlink" href="#caveats" title="Link to this heading">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO</p>
</div>
</section>
</section>
<section id="validation">
<h3><span class="section-number">34.3. </span>Validation<a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>This model has been tested with three UNIT test:</p>
<ul class="simple">
<li><p>auv-energy-model</p></li>
<li><p>auv-mobility</p></li>
<li><p>li-ion-energy-source</p></li>
</ul>
<section id="auv-energy-model">
<h4><span class="section-number">34.3.1. </span>Auv Energy Model<a class="headerlink" href="#auv-energy-model" title="Link to this heading">¶</a></h4>
<p>Includes test cases for single packet energy consumption, energy depletion, Glider and REMUS energy consumption.
The unit test can be found in <code class="docutils literal notranslate"><span class="pre">src/uan/test/auv-energy-model-test.cc</span></code>.</p>
<p>The single packet energy consumption test do the following:</p>
<ul class="simple">
<li><p>creates a two node network, one surface gateway and one fixed node at -500 m of depth</p></li>
<li><p>install the acoustic communication stack with energy consumption support into the nodes</p></li>
<li><p>a packet is sent from the underwater node to the gateway</p></li>
<li><p>it is verified that both, the gateway and the fixed node, have consumed the expected amount of energy from their sources</p></li>
</ul>
<p>The energy depletion test do the following steps:</p>
<ul class="simple">
<li><p>create a node with an empty energy source</p></li>
<li><p>try to send a packet</p></li>
<li><p>verify that the energy depletion callback has been invoked</p></li>
</ul>
<p>The Glider energy consumption test do the following:</p>
<ul class="simple">
<li><p>create a node with glider capabilities</p></li>
<li><p>make the vehicle to move to a predetermined waypoint</p></li>
<li><p>verify that the energy consumed for the navigation is correct, according to the glider specifications</p></li>
</ul>
<p>The REMUS energy consumption test do the following:</p>
<ul class="simple">
<li><p>create a node with REMUS capabilities</p></li>
<li><p>make the vehicle to move to a predetermined waypoint</p></li>
<li><p>verify that the energy consumed for the navigation is correct, according to the REMUS specifications</p></li>
</ul>
</section>
<section id="auv-mobility">
<h4><span class="section-number">34.3.2. </span>Auv Mobility<a class="headerlink" href="#auv-mobility" title="Link to this heading">¶</a></h4>
<p>Includes test cases for glider and REMUS mobility models.
The unit test can be found in <code class="docutils literal notranslate"><span class="pre">src/uan/test/auv-mobility-test.cc</span></code>.</p>
<ul class="simple">
<li><p>create a node with glider capabilities</p></li>
<li><p>set a specified velocity vector and verify if the resulting buoyancy is the one that is supposed to be</p></li>
<li><p>make the vehicle to submerge to a specified depth and verify if, at the end of the process the position is the one that is supposed to be</p></li>
<li><p>make the vehicle to emerge to a specified depth and verify if, at the end of the process the position is the one that is supposed to be</p></li>
<li><p>make the vehicle to navigate to a specified point, using direction, pitch and speed settings and, verify if at the end of the process the position is the one that is supposed to be</p></li>
<li><p>make the vehicle to navigate to a specified point, using a velocity vector and, verify if at the end of the process the position is the one that is supposed to be</p></li>
</ul>
<p>The REMUS mobility model test do the following:
* create a node with glider capabilities
* make the vehicle to submerge to a specified depth and verify if, at the end of the process the position is the one that is supposed to be
* make the vehicle to emerge to a specified depth and verify if, at the end of the process the position is the one that is supposed to be
* make the vehicle to navigate to a specified point, using direction, pitch and speed settings and, verify if at the end of the process the position is the one that is supposed to be
* make the vehicle to navigate to a specified point, using a velocity vector and, verify if at the end of the process the position is the one that is supposed to be</p>
</section>
<section id="li-ion-energy-source">
<h4><span class="section-number">34.3.3. </span>Li-Ion Energy Source<a class="headerlink" href="#li-ion-energy-source" title="Link to this heading">¶</a></h4>
<p>Includes test case for Li-Ion energy source.
The unit test can be found in <code class="docutils literal notranslate"><span class="pre">src/energy/test/li-ion-energy-source-test.cc</span></code>.</p>
<p>The test case verify that after a well-known discharge time with constant current drain, the cell voltage has followed the datasheet discharge curve <a class="footnote-reference brackets" href="#id32" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
</section>
<span id="document-wifi"></span><section id="wi-fi-module">
<h2><span class="section-number">35. </span>Wi-Fi Module<a class="headerlink" href="#wi-fi-module" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-wifi-design"></span><section id="design-documentation">
<h3><span class="section-number">35.1. </span>Design Documentation<a class="headerlink" href="#design-documentation" title="Link to this heading">¶</a></h3>
<p><em>ns-3</em> nodes can contain a collection of NetDevice objects, much like an actual
computer contains separate interface cards for Ethernet, Wifi, Bluetooth, etc.
This chapter describes the <em>ns-3</em> WifiNetDevice and related models. By adding
WifiNetDevice objects to <em>ns-3</em> nodes, one can create models of 802.11-based
infrastructure and ad hoc networks.</p>
<section id="overview-of-the-model">
<h4><span class="section-number">35.1.1. </span>Overview of the model<a class="headerlink" href="#overview-of-the-model" title="Link to this heading">¶</a></h4>
<p>The WifiNetDevice models a wireless network interface controller based
on the IEEE 802.11 standard <a class="reference internal" href="index.html#ieee80211" id="id1"><span>[ieee80211]</span></a>. We will go into more detail below but in brief,
<em>ns-3</em> provides models for these aspects of 802.11:</p>
<ul class="simple">
<li><p>basic 802.11 DCF with <strong>infrastructure</strong> and <strong>adhoc</strong> modes</p></li>
<li><p><strong>802.11a</strong>, <strong>802.11b</strong>, <strong>802.11g</strong>, <strong>802.11n</strong> (both 2.4 and 5 GHz bands), <strong>802.11ac</strong>, <strong>802.11ax</strong> (2.4, 5 and 6 GHz bands) and <strong>802.11be</strong> physical layers</p></li>
<li><p><strong>MSDU aggregation</strong> and <strong>MPDU aggregation</strong> extensions of 802.11n, and both can be combined together (two-level aggregation)</p></li>
<li><p>802.11ax <strong>DL OFDMA</strong> and <strong>UL OFDMA</strong> (including support for the MU EDCA Parameter Set)</p></li>
<li><p>802.11be <strong>Multi-link</strong> discovery and setup</p></li>
<li><p>QoS-based EDCA and queueing extensions of <strong>802.11e</strong></p></li>
<li><p>the ability to use different propagation loss models and propagation delay models,
please see the chapter on <a class="reference internal" href="index.html#propagation"><span class="std std-ref">Propagation</span></a> for more detail</p></li>
<li><p>packet error models and frame detection models that have been validated
against link simulations and other references</p></li>
<li><p>various rate control algorithms including <strong>Aarf, Arf, Cara, Onoe, Rraa,
ConstantRate, Minstrel and Minstrel-HT</strong></p></li>
<li><p>802.11s (mesh), described in another chapter</p></li>
<li><p>802.11p and WAVE (vehicular), described in another chapter</p></li>
</ul>
<p>The set of 802.11 models provided in <em>ns-3</em> attempts to provide an accurate
MAC-level implementation of the 802.11 specification and to provide a
packet-level abstraction of the PHY-level for different PHYs, corresponding to
802.11a/b/e/g/n/ac/ax/be specifications.</p>
<p>In <em>ns-3</em>, nodes can have multiple WifiNetDevices on separate channels, and the
WifiNetDevice can coexist with other device types.
With the use of the <strong>SpectrumWifiPhy</strong> framework, one can also build scenarios
involving cross-channel interference or multiple wireless technologies on
a single channel.</p>
<p>The source code for the WifiNetDevice and its models lives in the directory
<code class="docutils literal notranslate"><span class="pre">src/wifi</span></code>.</p>
<p>The implementation is modular and provides roughly three sublayers of models:</p>
<ul class="simple">
<li><p>the <strong>PHY layer models</strong>: they model amendment-specific and common
PHY layer operations and functions.</p></li>
<li><p>the so-called <strong>MAC low models</strong>: they model functions such as medium
access (DCF and EDCA), frame protection (RTS/CTS) and acknowledgment (ACK/BlockAck).
In <em>ns-3</em>, the lower-level MAC is comprised of a <strong>Frame Exchange Manager</strong> hierarchy,
a <strong>Channel Access Manager</strong> and a <strong>MAC middle</strong> entity.</p></li>
<li><p>the so-called <strong>MAC high models</strong>: they implement non-time-critical processes
in Wifi such as the MAC-level beacon generation, probing, and association
state machines, and a set of <strong>Rate control algorithms</strong>.  In the literature,
this sublayer is sometimes called the <strong>upper MAC</strong> and consists of more
software-oriented implementations vs. time-critical hardware implementations.</p></li>
</ul>
<p>Next, we provide a design overview of each layer, shown in
Figure <a class="reference internal" href="#wifi-architecture"><span class="std std-ref">WifiNetDevice architecture</span></a>. For 802.11be Multi-Link Devices (MLDs),
there as many instances of WifiPhy, FrameExchangeManager and ChannelAccessManager
as the number of links.</p>
<figure class="align-default" id="id39">
<span id="wifi-architecture"></span><img alt="_images/WifiArchitecture.png" src="_images/WifiArchitecture.png" />
<figcaption>
<p><span class="caption-text"><em>WifiNetDevice architecture</em></span><a class="headerlink" href="#id39" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="mac-high-models">
<h5><span class="section-number">35.1.1.1. </span>MAC high models<a class="headerlink" href="#mac-high-models" title="Link to this heading">¶</a></h5>
<p>There are presently three <strong>MAC high models</strong> that provide for the three
(non-mesh; the mesh equivalent, which is a sibling of these with common
parent <code class="docutils literal notranslate"><span class="pre">ns3::WifiMac</span></code>, is not discussed here) Wi-Fi topological
elements - Access Point (AP) (<code class="docutils literal notranslate"><span class="pre">ns3::ApWifiMac</span></code>),
non-AP Station (STA) (<code class="docutils literal notranslate"><span class="pre">ns3::StaWifiMac</span></code>), and STA in an Independent
Basic Service Set (IBSS) - also commonly referred to as an ad hoc
network (<code class="docutils literal notranslate"><span class="pre">ns3::AdhocWifiMac</span></code>).</p>
<p>The simplest of these is <code class="docutils literal notranslate"><span class="pre">ns3::AdhocWifiMac</span></code>, which implements a
Wi-Fi MAC that does not perform any kind of beacon generation,
probing, or association. The <code class="docutils literal notranslate"><span class="pre">ns3::StaWifiMac</span></code> class implements
an active probing and association state machine that handles automatic
re-association whenever too many beacons are missed. Finally,
<code class="docutils literal notranslate"><span class="pre">ns3::ApWifiMac</span></code> implements an AP that generates periodic
beacons, and that accepts every attempt to associate.</p>
<p>These three MAC high models share a common parent in
<code class="docutils literal notranslate"><span class="pre">ns3::WifiMac</span></code>, which exposes, among other MAC
configuration, an attribute <code class="docutils literal notranslate"><span class="pre">QosSupported</span></code> that allows
configuration of 802.11e/WMM-style QoS support.</p>
<p>There are also several <strong>rate control algorithms</strong> that can be used by the
MAC low layer.  A complete list of available rate control algorithms is
provided in a separate section.</p>
</section>
<section id="mac-low-layer">
<h5><span class="section-number">35.1.1.2. </span>MAC low layer<a class="headerlink" href="#mac-low-layer" title="Link to this heading">¶</a></h5>
<p>The <strong>MAC low layer</strong> is split into three main components:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::FrameExchangeManager</span></code> a class hierarchy which implement the frame exchange
sequences introduced by the supported IEEE 802.11 amendments. It also handles
frame aggregation, frame retransmissions, protection and acknowledgment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::ChannelAccessManager</span></code> which implements the DCF and EDCAF
functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::Txop</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::QosTxop</span></code> which handle the packet queue.
The <code class="docutils literal notranslate"><span class="pre">ns3::Txop</span></code> object is used by high MACs that are not QoS-enabled,
and for transmission of frames (e.g., of type Management)
that the standard says should access the medium using the DCF.
<code class="docutils literal notranslate"><span class="pre">ns3::QosTxop</span></code> is used by QoS-enabled high MACs.</p></li>
</ol>
</section>
<section id="phy-layer-models">
<h5><span class="section-number">35.1.1.3. </span>PHY layer models<a class="headerlink" href="#phy-layer-models" title="Link to this heading">¶</a></h5>
<p>In short, the physical layer models are mainly responsible for modeling
the reception of packets and for tracking energy consumption.  There
are typically three main components to packet reception:</p>
<ul class="simple">
<li><p>each packet received is probabilistically evaluated for successful or
failed reception.  The probability depends on the modulation, on
the signal to noise (and interference) ratio for the packet, and on
the state of the physical layer (e.g. reception is not possible while
transmission or sleeping is taking place);</p></li>
<li><p>an object exists to track (bookkeeping) all received signals so that
the correct interference power for each packet can be computed when
a reception decision has to be made; and</p></li>
<li><p>one or more error models corresponding to the modulation and standard
are used to look up probability of successful reception.</p></li>
</ul>
<p><em>ns-3</em> offers users a choice between two physical layer models, with a
base interface defined in the <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> class.  The YansWifiPhy
class implements a simple physical layer model, which is described
in a paper entitled
<a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/1190455.1190467?download=true">Yet Another Network Simulator</a>
The acronym <em>Yans</em> derives from this paper title.  The SpectrumWifiPhy
class is a more advanced implementation based on the Spectrum framework
used for other <em>ns-3</em> wireless models.  Spectrum allows a fine-grained
frequency decomposition of the signal, and permits scenarios to
include multiple technologies coexisting on the same channel.</p>
</section>
</section>
<section id="scope-and-limitations">
<h4><span class="section-number">35.1.2. </span>Scope and Limitations<a class="headerlink" href="#scope-and-limitations" title="Link to this heading">¶</a></h4>
<p>The IEEE 802.11 standard <a class="reference internal" href="index.html#ieee80211" id="id2"><span>[ieee80211]</span></a> is a large specification,
and not all aspects are covered by <em>ns-3</em>; the documentation of <em>ns-3</em>’s
conformance by itself would lead to a very long document.  This section
attempts to summarize compliance with the standard and with behavior
found in practice.</p>
<p>The physical layer and channel models operate on a per-packet basis, with
no frequency-selective propagation nor interference effects when using
the default YansWifiPhy model.  Directional antennas are also not
supported at this time.  For additive white Gaussian noise (AWGN)
scenarios, or wideband interference scenarios, performance is governed
by the application of analytical models (based on modulation and factors
such as channel width) to the received signal-to-noise ratio, where noise
combines the effect of thermal noise and of interference from other Wi-Fi
packets.  Interference from other wireless technologies is only modeled
when the SpectrumWifiPhy is used.
The following details pertain to the physical layer and channel models:</p>
<ul class="simple">
<li><p>802.11n/ac/ax/be beamforming is not supported</p></li>
<li><p>802.11n RIFS is not supported</p></li>
<li><p>802.11 PCF/HCF/HCCA are not implemented</p></li>
<li><p>Channel Switch Announcement is not supported</p></li>
<li><p>Authentication and encryption are missing</p></li>
<li><p>Processing delays are not modeled</p></li>
<li><p>Cases where RTS/CTS and ACK are transmitted using HT/VHT/HE/EHT formats are not supported</p></li>
<li><p>Energy consumption model does not consider MIMO</p></li>
<li><p>802.11ax preamble puncturing is supported by the PHY but is currently not exploited by the MAC</p></li>
<li><p>Only minimal MU-MIMO is supported (ideal PHY assumed, no MAC layer yet)</p></li>
</ul>
<p>At the MAC layer, most of the main functions found in deployed Wi-Fi
equipment for 802.11a/b/e/g/n/ac/ax/be are implemented, but there are scattered instances
where some limitations in the models exist. Support for 802.11n, ac, ax and be is evolving.</p>
<p>Some implementation choices that are not imposed by the standard are listed below:</p>
<ul class="simple">
<li><p>BSSBasicRateSet for 802.11b has been assumed to be 1-2 Mbit/s</p></li>
<li><p>BSSBasicRateSet for 802.11a/g has been assumed to be 6-12-24 Mbit/s</p></li>
<li><p>OperationalRateSet is assumed to contain all mandatory rates (see
<a class="reference external" href="https://gitlab.com/nsnam/ns-3-dev/-/issues/183">issue 183</a>)</p></li>
<li><p>The wifi manager always selects the lowest basic rate for management frames.</p></li>
</ul>
</section>
<section id="design-details">
<h4><span class="section-number">35.1.3. </span>Design Details<a class="headerlink" href="#design-details" title="Link to this heading">¶</a></h4>
<p>The remainder of this section is devoted to more in-depth design descriptions
of some of the Wi-Fi models.  Users interested in skipping to the section
on usage of the wifi module (<a class="reference internal" href="index.html#sec-wifi-user-doc"><span class="std std-ref">User Documentation</span></a>) may do so at this point.
We organize these more detailed sections from the bottom-up, in terms of
layering, by describing the channel and PHY models first, followed by
the MAC models.</p>
<p>We focus first on the choice between physical layer frameworks.  <em>ns-3</em>
contains support for a Wi-Fi-only physical layer model called YansWifiPhy
that offers no frequency-level decomposition of the signal.  For simulations
that involve only Wi-Fi signals on the Wi-Fi channel, and that do not
involve frequency-dependent propagation loss or fading models, the default
YansWifiPhy framework is a suitable choice.  For simulations involving
mixed technologies on the same channel, or frequency dependent effects,
the SpectrumWifiPhy is more appropriate.  The two frameworks are very
similarly configured.</p>
<p>The SpectrumWifiPhy framework uses the <a class="reference internal" href="index.html#sec-spectrum-module"><span class="std std-ref">Spectrum Module</span></a> channel
framework.</p>
<p>The YansWifiChannel is the only concrete channel model class in
the <em>ns-3</em> wifi module.  The
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code> implementation uses the propagation loss and
delay models provided within the <em>ns-3</em> <a class="reference internal" href="index.html#propagation"><span class="std std-ref">Propagation</span></a> module.
In particular, a number of propagation models can be added (chained together,
if multiple loss models are added) to the channel object, and a propagation
delay model also added. Packets sent from a <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> object
onto the channel with a particular signal power, are copied to all of the
other <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> objects after the signal power is reduced due
to the propagation loss model(s), and after a delay corresponding to
transmission (serialization) delay and propagation delay due to
any channel propagation delay model (typically due to speed-of-light
delay between the positions of the devices).</p>
<p>Only objects of <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> may be attached to a
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code>; therefore, objects modeling other
(interfering) technologies such as LTE are not allowed. Furthermore,
packets from different channels do not interact; if a channel is logically
configured for e.g. channels 5 and 6, the packets do not cause
adjacent channel interference (even if their channel numbers overlap).</p>
<section id="wifiphy-and-related-models">
<h5><span class="section-number">35.1.3.1. </span>WifiPhy and related models<a class="headerlink" href="#wifiphy-and-related-models" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> is an abstract base class representing the 802.11
physical layer functions.  Packets passed to this object (via a
<code class="docutils literal notranslate"><span class="pre">Send()</span></code> method) are sent over a channel object, and
upon reception, the receiving PHY object decides (based on signal power
and interference) whether the packet was successful or not.  This class
also provides a number of callbacks for notifications of physical layer
events, exposes a notion of a state machine that can be monitored for
MAC-level processes such as carrier sense, and handles sleep/wake/off models
and energy consumption.  The <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> hooks to the <code class="docutils literal notranslate"><span class="pre">ns3::FrameExchangeManager</span></code>
object in the WifiNetDevice.</p>
<p>There are currently two implementations of the <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code>: the
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> and the <code class="docutils literal notranslate"><span class="pre">ns3::SpectrumWifiPhy</span></code>.  They each work in
conjunction with five other objects:</p>
<ul class="simple">
<li><p><strong>PhyEntity</strong>: Contains the amendment-specific part of the PHY processing</p></li>
<li><p><strong>WifiPpdu</strong>: Models the amendment-specific PHY protocol data unit (PPDU)</p></li>
<li><p><strong>WifiPhyStateHelper</strong>:  Maintains the PHY state machine</p></li>
<li><p><strong>InterferenceHelper</strong>:  Tracks all packets observed on the channel</p></li>
<li><p><strong>ErrorModel</strong>:  Computes a probability of error for a given SNR</p></li>
</ul>
<section id="phyentity">
<h6><span class="section-number">35.1.3.1.1. </span>PhyEntity<a class="headerlink" href="#phyentity" title="Link to this heading">¶</a></h6>
<section id="a-bit-of-background">
<h6 aria-level="7"><span class="section-number">35.1.3.1.1.1. </span>A bit of background<a class="headerlink" href="#a-bit-of-background" title="Link to this heading">¶</a></h6>
<p>Some restructuring of <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> and <code class="docutils literal notranslate"><span class="pre">ns3::WifiMode</span></code> (among others) was necessary
considering the size and complexity of the corresponding files.
In addition, adding and maintaining new PHY amendments had become a complex
task (especially those implemented inside other modules, e.g. DMG).
The adopted solution was to have <code class="docutils literal notranslate"><span class="pre">PhyEntity</span></code> classes that contain the “clause”
specific (i.e. HT/VHT/HE/EHT etc) parts of the PHY process.</p>
<p>The notion of “PHY entity” is in the standard at the beginning of each PHY
layer description clause, e.g. section 21.1.1 of IEEE 802.11-2016:</p>
<p>::
Clause 21 specifies the <strong>PHY entity</strong> for a very high throughput (VHT) orthogonal
frequency division multiplexing (OFDM) system.</p>
<p><em>Note that there is already such a name inside the wave module
(e.g. ``WaveNetDevice::AddPhy``) to designate the WifiPhys on each 11p channel,
but the wording is only used within the classes and there is no file using
that name, so no ambiguity in using the name for 802.11 amendments.</em></p>
</section>
<section id="architecture">
<h6 aria-level="7"><span class="section-number">35.1.3.1.1.2. </span>Architecture<a class="headerlink" href="#architecture" title="Link to this heading">¶</a></h6>
<p>The abstract base class <code class="docutils literal notranslate"><span class="pre">ns3::PhyEntity</span></code> enables to have a unique set of APIs
to be used by each PHY entity, corresponding to the different amendments of
the IEEE 802.11 standard. The currently implemented PHY entities are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::DsssPhy</span></code>: PHY entity for DSSS and HR/DSSS (11b)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::OfdmPhy</span></code>: PHY entity for OFDM (11a and 11p)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::ErpOfdmPhy</span></code>: PHY entity for ERP-OFDM (11g)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HtPhy</span></code>: PHY entity for HT (11n)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::VhtPhy</span></code>: PHY entity for VHT (11ac)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HePhy</span></code>: PHY entity for HE (11ax)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::EhtPhy</span></code>: PHY entity for EHT (11be)</p></li>
</ul>
<p>Their inheritance diagram is given in Figure <a class="reference internal" href="#phyentity-hierarchy"><span class="std std-ref">PhyEntity hierarchy</span></a> and
closely follows the standard’s logic, e.g. section 21.1.1 of IEEE 802.11-2016:</p>
<p>::
The VHT PHY is <strong>based</strong> on the HT PHY defined in Clause 19, which <strong>in turn</strong>
is <strong>based</strong> on the OFDM PHY defined in Clause 17.</p>
<figure class="align-default" id="id40">
<span id="phyentity-hierarchy"></span><img alt="_images/PhyEntityHierarchy.png" src="_images/PhyEntityHierarchy.png" />
<figcaption>
<p><span class="caption-text"><em>PhyEntity hierarchy</em></span><a class="headerlink" href="#id40" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Such an architecture enables to handle the following operations in an amendment-
specific manner:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WifiMode</span></code> handling and data/PHY rate computation,</p></li>
<li><p>PPDU field size and duration computation, and</p></li>
<li><p>Transmit and receive paths.</p></li>
</ul>
</section>
</section>
<section id="wifippdu">
<h6><span class="section-number">35.1.3.1.2. </span>WifiPpdu<a class="headerlink" href="#wifippdu" title="Link to this heading">¶</a></h6>
<p>In the same vein as <code class="docutils literal notranslate"><span class="pre">PhyEntity</span></code>, the <code class="docutils literal notranslate"><span class="pre">ns3::WifiPpdu</span></code> base class has been
specialized into the following amendment-specific PPDUs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::DsssPpdu</span></code>: PPDU for DSSS and HR/DSSS (11b)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::OfdmPpdu</span></code>: PPDU for OFDM (11a and 11p)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::ErpOfdmPpdu</span></code>: PPDU for ERP-OFDM (11g)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HtPpdu</span></code>: PPDU for HT (11n)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::VhtPpdu</span></code>: PPDU for VHT (11ac)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::HePpdu</span></code>: PPDU for HE (11ax)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::EhtPpdu</span></code>: PPDU for EHT (11be)</p></li>
</ul>
<p>Their inheritance diagram is given in Figure <a class="reference internal" href="#wifippdu-hierarchy"><span class="std std-ref">WifiPpdu hierarchy</span></a> and
closely follows the standard’s logic, e.g. section 21.3.8.1 of IEEE 802.11-2016:</p>
<p>::
To maintain compatibility with non-VHT STAs, specific non-VHT fields are defined
that can be received by non-VHT STAs compliant with <strong>Clause 17</strong> [OFDM] or <strong>Clause 19</strong> [HT].</p>
<figure class="align-default" id="id41">
<span id="wifippdu-hierarchy"></span><img alt="_images/WifiPpduHierarchy.png" src="_images/WifiPpduHierarchy.png" />
<figcaption>
<p><span class="caption-text"><em>WifiPpdu hierarchy</em></span><a class="headerlink" href="#id41" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="yanswifiphy-and-wifiphystatehelper">
<h6><span class="section-number">35.1.3.1.3. </span>YansWifiPhy and WifiPhyStateHelper<a class="headerlink" href="#yanswifiphy-and-wifiphystatehelper" title="Link to this heading">¶</a></h6>
<p>Class <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> is responsible for taking packets passed to
it from the MAC (the <code class="docutils literal notranslate"><span class="pre">ns3::FrameExchangeManager</span></code> object) and sending them onto the
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code> to which it is attached.  It is also responsible
to receive packets from that channel, and, if reception is deemed to have
been successful, to pass them up to the MAC.</p>
<p>The energy of the signal intended to be received is
calculated from the transmission power and adjusted based on the Tx gain
of the transmitter, Rx gain of the receiver, and any path loss propagation
model in effect.</p>
<p>Class <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhyStateHelper</span></code> manages the state machine of the PHY
layer, and allows other objects to hook as <em>listeners</em> to monitor PHY
state.  The main use of listeners is for the MAC layer to know when
the PHY is busy or not (for transmission and collision avoidance).</p>
<p>The PHY layer can be in one of these states:</p>
<ol class="arabic simple">
<li><p>TX: the PHY is currently transmitting a signal on behalf of its associated
MAC</p></li>
<li><p>RX: the PHY is synchronized on a signal and is waiting until it has received
its last bit to forward it to the MAC.</p></li>
<li><p>CCA_BUSY: the PHY is issuing a PHY-CCA.indication(BUSY) indication for the primary channel.</p></li>
<li><p>IDLE: the PHY is not in the TX, RX, or CCA_BUSY states.</p></li>
<li><p>SWITCHING: the PHY is switching channels.</p></li>
<li><p>SLEEP: the PHY is in a power save mode and cannot send nor receive frames.</p></li>
<li><p>OFF: the PHY is powered off and cannot send nor receive frames.</p></li>
</ol>
<p>Packet reception works as follows.  For <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, most of the logic
is implemented in the <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code> base class.  The <code class="docutils literal notranslate"><span class="pre">YansWifiChannel</span></code> calls
<code class="docutils literal notranslate"><span class="pre">WifiPhy::StartReceivePreamble</span> <span class="pre">()</span></code>. The latter calls
<code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceivePreamble</span> <span class="pre">()</span></code> of the appropriate PHY entity
to start packet reception, but first
there is a check of the packet’s notional signal power level against a
threshold value stored in the attribute <code class="docutils literal notranslate"><span class="pre">WifiPhy::RxSensitivity</span></code>.  Any
packet with a power lower than RxSensitivity will be dropped with no
further processing.  The default value is -101 dBm, which is the thermal
noise floor for 20 MHz signal at room temperature.  The purpose of this
attribute is two-fold:  1) very weak signals that will not affect the
outcome will otherwise consume simulation memory and event processing, so
they are discarded, and 2) this value can be adjusted upwards to function as
a basic carrier sense threshold limitation for experiments involving
spatial reuse considerations.  Users are cautioned about the behavior of
raising this threshold; namely, that all packets with power below this
threshold will be discarded upon reception.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">StartReceivePreamble</span> <span class="pre">()</span></code>, the packet is immediately added
to the interference helper for signal-to-noise
tracking, and then further reception steps are decided upon the state of
the PHY.  In the case that the PHY is transmitting, for instance, the
packet will be dropped.  If the PHY is IDLE, or if the PHY is receiving and
an optional FrameCaptureModel is being used (and the packet is within
the capture window), then <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartPreambleDetectionPeriod</span> <span class="pre">()</span></code> is called next.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartPreambleDetectionPeriod</span> <span class="pre">()</span></code> will typically schedule an event,
<code class="docutils literal notranslate"><span class="pre">PhyEntity::EndPreambleDetectionPeriod</span> <span class="pre">()</span></code>, to occur at
the notional end of the first OFDM symbol, to check whether the preamble
has been detected.  As of revisions to the model in ns-3.30, any state
machine transitions from IDLE state are suppressed until after the preamble
detection event.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PhyEntity::EndPreambleDetectionPeriod</span> <span class="pre">()</span></code> method will check, with a preamble detection
model, whether the signal is strong enough to be received, and if so,
an event <code class="docutils literal notranslate"><span class="pre">PhyEntity::EndReceiveField</span> <span class="pre">()</span></code> is scheduled for the end of the
preamble and the PHY is put into the CCA_BUSY state. Currently, there is only a
simple threshold-based preamble detection model in ns-3,
called <code class="docutils literal notranslate"><span class="pre">ThresholdPreambleDetectionModel</span></code>.  If there is no preamble detection
model, the preamble is assumed to have been detected.
It is important to note that, starting with the ns-3.30 release, the default
in the WifiPhyHelper is to add the <code class="docutils literal notranslate"><span class="pre">ThresholdPreambleDetectionModel</span></code> with
a threshold RSSI of -82 dBm, and a threshold SNR of 4 dB.  Both the RSSI
and SNR must be above these respective values for the preamble to be
successfully detected.  The default sensitivity has been reduced in ns-3.30
compared with that of previous releases, so some packet receptions that were
previously successful will now fail on this check.  More details on the
modeling behind this change are provided in <a class="reference internal" href="index.html#lanante2019" id="id3"><span>[lanante2019]</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PhyEntity::EndReceiveField</span> <span class="pre">()</span></code> method will check the correct reception
of the current preamble and header field and, if so, calls <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceiveField</span> <span class="pre">()</span></code>
for the next field,
otherwise the reception is aborted and PHY is put either in IDLE state or in CCA_BUSY state,
depending on whether a PHY-CCA.indication(BUSY) is being issued on not for the primary channel
.</p>
<p>The next event at <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceiveField</span> <span class="pre">()</span></code> checks, using the interference
helper and error model, whether the header was successfully decoded, and if so,
a <code class="docutils literal notranslate"><span class="pre">PhyRxPayloadBegin</span></code> callback (equivalent to the PHY-RXSTART primitive)
is triggered. The PHY header is often transmitted
at a lower modulation rate than is the payload. The portion of the packet
corresponding to the PHY header is evaluated for probability of error
based on the observed SNR.  The InterferenceHelper object returns a value
for “probability of error (PER)” for this header based on the SNR that has
been tracked by the InterferenceHelper.  The <code class="docutils literal notranslate"><span class="pre">PhyEntity</span></code> then draws
a random number from a uniform distribution and compares it against the
PER and decides success or failure.</p>
<p>This is iteratively performed up to the beginning of the data field
upon which <code class="docutils literal notranslate"><span class="pre">PhyEntity::StartReceivePayload</span> <span class="pre">()</span></code> is called.</p>
<p>Even if packet objects received by the PHY are not part of the reception
process, they are tracked by the InterferenceHelper object for purposes
of SINR computation and making clear channel assessment decisions.
If, in the course of reception, a packet is errored or dropped due to
the PHY being in a state in which it cannot receive a packet, the packet
is added to the interference helper, and the aggregate of the energy of
all such signals is compared against an energy detection threshold to
determine whether the PHY should enter a CCA_BUSY state.</p>
<p>A PHY-CCA.indication(BUSY) is issued if a signal occupying the primary channel with a received
power above <code class="docutils literal notranslate"><span class="pre">WifiPhy::CcaSensitivity</span></code> (defaulted to -82 dBm) has been received by the PHY or if the
measured energy on the primary channel is higher than the energy detection threshold <code class="docutils literal notranslate"><span class="pre">WifiPhy::CcaEdThreshold</span></code>
(defaulted to -62 dBm).</p>
<p>When channel bonding is used, CCA indication for signals not occupying the primary channel is also reported.
Since 802.11ac and above needs to sense CCA sensitivity for secondary channels larger than 20 MHz, CCA sensitivity thresholds
can be adjusted per secondary channel width using <code class="docutils literal notranslate"><span class="pre">VhtConfiguration::SecondaryCcaSensitivityThresholds</span></code> attribute.</p>
<p>For 802.11ax and above, and if the operational bandwidth is equal or larger than 40 MHz, each 20 MHz subchannel of the operational bandwidth
is being sensed and PHY-CCA.indication also reports a CCA_BUSY duration indication for each of these 20 MHz subchannel. A zero duration for
a given 20 MHz subchannel indicates the 20 MHz subchannel is IDLE.</p>
<p>The above describes the case in which the packet is a single MPDU.  For
more recent Wi-Fi standards using MPDU aggregation, <code class="docutils literal notranslate"><span class="pre">StartReceivePayload</span></code>
schedules an event for reception of each individual MPDU (<code class="docutils literal notranslate"><span class="pre">ScheduleEndOfMpdus</span></code>),
which then forwards each MPDU as they arrive up to FrameExchangeManager, if the
reception of the MPDU has been successful. Once the A-MPDU reception is finished,
FrameExchangeManager is also notified about the amount of successfully received MPDUs.</p>
</section>
<section id="interferencehelper">
<h6><span class="section-number">35.1.3.1.4. </span>InterferenceHelper<a class="headerlink" href="#interferencehelper" title="Link to this heading">¶</a></h6>
<p>The InterferenceHelper is an object that tracks all incoming packets and
calculates probability of error values for packets being received, and
also evaluates whether and for how long energy on the channel rises above
a given threshold.</p>
<p>The basic operation of probability of error calculations is shown in Figure
<a class="reference internal" href="#snir"><span class="std std-ref">SNIR function over time</span></a>.  Packets are represented as bits (not symbols) in the <em>ns-3</em>
model, and the InterferenceHelper breaks the packet into one or more
“chunks”, each with a different signal to noise (and interference) ratio
(SNIR).  Each chunk is separately evaluated by asking for the probability
of error for a given number of bits from the error model in use.  The
InterferenceHelper builds an aggregate “probability of error” value
based on these chunks and their duration, and returns this back to
the <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code> for a reception decision.</p>
<figure class="align-default" id="id42">
<span id="snir"></span><img alt="_images/snir.png" src="_images/snir.png" />
<figcaption>
<p><span class="caption-text"><em>SNIR function over time</em></span><a class="headerlink" href="#id42" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>From the SNIR function we can derive the Bit Error Rate (BER) and Packet
Error Rate (PER) for
the modulation and coding scheme being used for the transmission.</p>
<p>If MIMO is used and the number of spatial streams is lower than the number
of active antennas at the receiver, then a gain is applied to the calculated
SNIR as follows (since STBC is not used):</p>
<div class="math">
<p><img src="_images/math/0f97e17f4081ee66e266aed9d4a079023e580bc0.png" alt="gain (dB) = 10 \log(\frac{RX \ antennas}{spatial \ streams})"/></p>
</div><p>Having more TX antennas can be safely ignored for AWGN. The resulting gain is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">antennas</span><span class="w">   </span><span class="n">NSS</span><span class="w">    </span><span class="n">gain</span>
<span class="mi">2</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">2</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="w">       </span><span class="mi">1</span><span class="w">   </span><span class="mf">4.8</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="w">       </span><span class="mi">2</span><span class="w">   </span><span class="mf">1.8</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">3</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="w">       </span><span class="mi">3</span><span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">1</span><span class="w">     </span><span class="mi">6</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">2</span><span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">3</span><span class="w">   </span><span class="mf">1.2</span><span class="w"> </span><span class="n">dB</span>
<span class="mi">4</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">4</span><span class="w">       </span><span class="mi">4</span><span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="n">dB</span>
<span class="p">...</span>
</pre></div>
</div>
</section>
<section id="errorratemodel">
<h6><span class="section-number">35.1.3.1.5. </span>ErrorRateModel<a class="headerlink" href="#errorratemodel" title="Link to this heading">¶</a></h6>
<p><em>ns-3</em> makes a packet error or success decision based on the input received
SNR of a frame and based on any possible interfering frames that may overlap
in time; i.e. based on the signal-to-noise (plus interference) ratio, or
SINR.  The relationship between packet error ratio (PER) and SINR in <em>ns-3</em>
is defined by the <code class="docutils literal notranslate"><span class="pre">ns3::ErrorRateModel</span></code>, of which there are several.
The PER is a function of the frame’s modulation and coding (MCS), its SINR,
and the specific ErrorRateModel configured for the MCS.</p>
<p><em>ns-3</em> has updated its default ErrorRateModel over time.  The current
(as of ns-3.33 release) model for recent OFDM-based standards (i.e.,
802.11n/ac/ax), is the <code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code>.  The default
for 802.11a/g is the <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code>, and the default for
802.11b is the <code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code>.  The error rate model for
recent standards was updated during the ns-3.33 release cycle (previously,
it was the <code class="docutils literal notranslate"><span class="pre">ns3::NistErrorRateModel</span></code>).</p>
<p>The error models are described in more detail in outside references.  The
current OFDM model is based on work published in <a class="reference internal" href="index.html#patidar2017" id="id4"><span>[patidar2017]</span></a>, using
link simulations results from the MATLAB WLAN Toolbox, and validated against
IEEE TGn results <a class="reference internal" href="index.html#erceg2004" id="id5"><span>[erceg2004]</span></a>.  For publications related to other error models,
please refer to <a class="reference internal" href="index.html#pei80211ofdm" id="id6"><span>[pei80211ofdm]</span></a>, <a class="reference internal" href="index.html#pei80211b" id="id7"><span>[pei80211b]</span></a>, <a class="reference internal" href="index.html#lacage2006yans" id="id8"><span>[lacage2006yans]</span></a>, <a class="reference internal" href="index.html#haccoun" id="id9"><span>[Haccoun]</span></a>,
<a class="reference internal" href="index.html#hepner2015" id="id10"><span>[hepner2015]</span></a> and <a class="reference internal" href="index.html#frenger" id="id11"><span>[Frenger]</span></a> for a detailed description of the legacy PER models.</p>
<p>The current <em>ns-3</em> error rate models are for additive white gaussian
noise channels (AWGN) only; any potential frequency-selective fading
effects are not modeled.</p>
<p>In summary, there are four error models:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code>: for OFDM modes and reuses
<code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code> for 802.11b modes.
This is the default for 802.11n/ac/ax.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code>: for OFDM modes and reuses
<code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code> for 802.11b modes.
This is the default for 802.11a/g.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code>:  contains models for 802.11b modes.  The
802.11b 1 Mbps and 2 Mbps error models are based on classical modulation
analysis.  If GNU Scientific Library (GSL) is installed, the 5.5 Mbps
and 11 Mbps from <a class="reference internal" href="index.html#pursley2009" id="id12"><span>[pursley2009]</span></a> are used for CCK modulation;
otherwise, results from a backup MATLAB-based CCK model are used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ns3::NistErrorRateModel</span></code>: for OFDM modes and reuses
<code class="docutils literal notranslate"><span class="pre">ns3::DsssErrorRateModel</span></code> for 802.11b modes.</p></li>
</ol>
<p>Users may select either NIST, YANS or Table-based models for OFDM,
and DSSS will be used in either case for 802.11b.  The NIST model was
a long-standing default in ns-3 (through release 3.32).</p>
</section>
<section id="tablebasederrorratemodel">
<h6><span class="section-number">35.1.3.1.6. </span>TableBasedErrorRateModel<a class="headerlink" href="#tablebasederrorratemodel" title="Link to this heading">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code> has been recently added and is now the <em>ns-3</em> default
for 802.11n/ac/ax, while <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code> is the <em>ns-3</em> default for 802.11a/g.</p>
<p>Unlike analytical error models based on error bounds, <code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code> contains
end-to-end link simulation tables (PER vs SNR) for AWGN channels. Since it is infeasible to generate
such look-up tables for all desired packet sizes and input SNRs, we adopt the recommendation of IEEE P802.11 TGax <a class="reference internal" href="index.html#porat2016" id="id13"><span>[porat2016]</span></a> that proposed
estimating PER for any desired packet length using BCC FEC encoding by extrapolating the results from two reference lengths:
32 (all lengths less than 400) bytes and 1458 (all lengths greater or equal to 400) bytes respectively.
In case of LDPC FEC encoding, IEEE P802.11 TGax recommends the use of a single reference length.
Hence, we provide two tables for BCC and one table for LDPC that are generated using a reliable and publicly
available commercial link simulator (MATLAB WLAN Toolbox) for each modulation and coding scheme.
Note that BCC tables are limited to MCS 9. For higher MCSs, the models fall back to the use of the YANS analytical model.</p>
<p>The validation scenario is set as follows:</p>
<ol class="arabic simple">
<li><p>Ideal channel and perfect channel estimation.</p></li>
<li><p>Perfect packet synchronization and detection.</p></li>
<li><p>Phase tracking, phase correction, phase noise, carrier frequency offset, power amplifier non-linearities etc. are not considered.</p></li>
</ol>
<p>Several packets are simulated across the link to obtain PER, the number of packets needed to reliably
estimate a PER value is computed using the consideration that the ratio of the estimation error to the
true value should be within 10 % with probability 0.95.
For each SNR value, simulations were run until a total of 40000 packets were simulated.</p>
<p>The obtained results are very close to TGax curves as shown in Figure
<a class="reference internal" href="#default-table-based-error-model-validation"><span class="std std-ref">Comparison of table-based OFDM Error Model with TGax results.</span></a></p>
<figure class="align-default" id="id43">
<span id="default-table-based-error-model-validation"></span><a class="reference internal image-reference" href="_images/default-table-based-error-model-validation.png"><img alt="_images/default-table-based-error-model-validation.png" src="_images/default-table-based-error-model-validation.png" style="width: 420.0px; height: 315.0px;" /></a>
<figcaption>
<p><span class="caption-text"><em>Comparison of table-based OFDM Error Model with TGax results.</em></span><a class="headerlink" href="#id43" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="legacy-errorratemodels">
<h6><span class="section-number">35.1.3.1.7. </span>Legacy ErrorRateModels<a class="headerlink" href="#legacy-errorratemodels" title="Link to this heading">¶</a></h6>
<p>The original error rate model was called the <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code> and
was based on analytical results.  For 802.11b modulations, the 1 Mbps mode
is based on DBPSK. BER is from equation 5.2-69 from <a class="reference internal" href="index.html#proakis2001" id="id14"><span>[proakis2001]</span></a>.
The 2 Mbps model is based on DQPSK. Equation 8 of <a class="reference internal" href="index.html#ferrari2004" id="id15"><span>[ferrari2004]</span></a>.
More details are provided in <a class="reference internal" href="index.html#lacage2006yans" id="id16"><span>[lacage2006yans]</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ns3::NistErrorRateModel</span></code> was later added.
The model was largely aligned with the previous <code class="docutils literal notranslate"><span class="pre">ns3::YansErrorRateModel</span></code>
for DSSS modulations 1 Mbps and 2 Mbps, but the 5.5 Mbps and 11 Mbps models
were re-based on equations (17) and (18) from <a class="reference internal" href="index.html#pursley2009" id="id17"><span>[pursley2009]</span></a>.
For OFDM modulations, newer results were
obtained based on work previously done at NIST <a class="reference internal" href="index.html#miller2003" id="id18"><span>[miller2003]</span></a>.  The results
were also compared against the CMU wireless network emulator, and details
of the validation are provided in <a class="reference internal" href="index.html#pei80211ofdm" id="id19"><span>[pei80211ofdm]</span></a>.  Since OFDM modes use
hard-decision of punctured codes, the coded BER is calculated using
Chernoff bounds <a class="reference internal" href="index.html#hepner2015" id="id20"><span>[hepner2015]</span></a>.</p>
<p>The 802.11b model was split from the OFDM model when the NIST error rate
model was added, into a new model called DsssErrorRateModel.</p>
<p>Furthermore, the 5.5 Mbps and 11 Mbps models for 802.11b rely on library
methods implemented in the GNU Scientific Library (GSL).  The ns3 build
system tries to detect whether the host platform has GSL installed; if so,
it compiles in the newer models from <a class="reference internal" href="index.html#pursley2009" id="id21"><span>[pursley2009]</span></a> for 5.5 Mbps and 11 Mbps;
if not, it uses a backup model derived from MATLAB simulations.</p>
<p>The error curves for analytical models are shown to diverge from link simulation results for higher MCS in
Figure <a class="reference internal" href="#error-models-comparison"><span class="std std-ref">YANS and NIST error model comparison with TGn results</span></a>. This prompted the move to a new error
model based on link simulations (the default TableBasedErrorRateModel, which
provides curves close to those depicted by the TGn dashed line).</p>
<figure class="align-default" id="id44">
<span id="error-models-comparison"></span><img alt="_images/error-models-comparison.png" src="_images/error-models-comparison.png" />
<figcaption>
<p><span class="caption-text"><em>YANS and NIST error model comparison with TGn results</em></span><a class="headerlink" href="#id44" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="spectrumwifiphy">
<h6><span class="section-number">35.1.3.1.8. </span>SpectrumWifiPhy<a class="headerlink" href="#spectrumwifiphy" title="Link to this heading">¶</a></h6>
<p>This section describes the implementation of the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code>
class that can be found in <code class="docutils literal notranslate"><span class="pre">src/wifi/model/spectrum-wifi-phy.{cc,h}</span></code>.</p>
<p>The implementation also makes use of additional classes found in the
same directory:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wifi-spectrum-phy-interface.{cc,h}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wifi-spectrum-signal-parameters.{cc,h}</span></code></p></li>
</ul>
<p>and classes found in the spectrum module:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wifi-spectrum-value-helper.{cc,h}</span></code></p></li>
</ul>
<p>The current <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> class
reuses the existing interference manager and error rate models originally
built for <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, but allows, as a first step, foreign (non Wi-Fi)
signals to be treated as additive noise.</p>
<p>Two main changes were needed to adapt the Spectrum framework to Wi-Fi.
First, the physical layer must send signals compatible with the
Spectrum channel framework, and in particular, the
<code class="docutils literal notranslate"><span class="pre">MultiModelSpectrumChannel</span></code> that allows signals from different
technologies to coexist.  Second, the InterferenceHelper must be
extended to support the insertion of non-Wi-Fi signals and to
add their received power to the noise, in the same way that
unintended Wi-Fi signals (perhaps from a different SSID or arriving
late from a hidden node) are added to the noise.</p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, where there are no foreign signals, CCA_BUSY state
will be raised for foreign signals that are higher than CcaEdThreshold
(see section 16.4.8.5 in the 802.11-2012 standard for definition of
CCA Mode 1).  The attribute <code class="docutils literal notranslate"><span class="pre">WifiPhy::CcaEdThreshold</span></code> therefore
potentially plays a larger role in this model than in the <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>
model.</p>
<p>To support the Spectrum channel, the <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code> transmit and receive methods
were adapted to use the Spectrum channel API.  This required developing
a few <code class="docutils literal notranslate"><span class="pre">SpectrumModel</span></code>-related classes.  The class
<code class="docutils literal notranslate"><span class="pre">WifiSpectrumValueHelper</span></code> is used to create Wi-Fi signals with the
spectrum framework and spread their energy across the bands. The
spectrum is sub-divided into sub-bands (the width of an OFDM
subcarrier, which depends on the technology). The power allocated to a particular channel
is spread across the sub-bands roughly according to how power would
be allocated to sub-carriers. Adjacent channels are models by the use of
OFDM transmit spectrum masks as defined in the standards.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">WifiBandwidthFilter</span></code> is used to discard signals early in the
transmission process by ignoring any Wi-Fi PPDU whose TX band (including guard bands)
does not overlap the current operating channel. Therefore, it bypasses the signal
propagation/loss calculations reducing the computational load and increasing the
simulation performance. To enable the <code class="docutils literal notranslate"><span class="pre">WifiBandwidthFilter</span></code>, the user can use object
aggregation as follows:
.. sourcecode:: cpp</p>
<blockquote>
<div><p>Ptr&lt;WifiBandwidthFilter&gt; wifiFilter = CreateObject&lt;WifiBandwidthFilter&gt; ();
Ptr&lt;MultiModelSpectrumChannel&gt; spectrumChannel = CreateObject&lt;MultiModelSpectrumChannel&gt; ();
spectrumChannel-&gt;AddSpectrumTransmitFilter(wifiFilter);</p>
</div></blockquote>
<p>To support an easier user configuration experience, the existing
YansWifi helper classes (in <code class="docutils literal notranslate"><span class="pre">src/wifi/helper</span></code>) were copied and
adapted to provide equivalent SpectrumWifi helper classes.</p>
<p>Finally, for reasons related to avoiding C++ multiple inheritance
issues, a small forwarding class called <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code>
was inserted as a shim between the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> and the
Spectrum channel.  The <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code> calls a different
<code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy::StartRx</span> <span class="pre">()</span></code> method to start the reception process.
This method performs the check of the signal power against the
<code class="docutils literal notranslate"><span class="pre">WifiPhy::RxSensitivity</span></code> attribute and discards weak signals, and
also checks if the signal is a Wi-Fi signal; non-Wi-Fi signals are added
to the InterferenceHelper and can raise CCA_BUSY but are not further processed
in the reception chain.   After this point, valid Wi-Fi signals cause
<code class="docutils literal notranslate"><span class="pre">WifiPhy::StartReceivePreamble</span></code> to be called, and the processing continues
as described above.</p>
<p>Furthermore, in order to support more flexible channel switching,
the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> can hold multiple instances of <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code>
(<a class="reference internal" href="#fig-spectrum-wifi-phy-multiple-interfaces"><span class="std std-ref">Multiple RF interfaces concept</span></a>).
Each of these instances handles a given frequency range of the spectrum, identified by
a start and a stop frequency expressed in MHz, and there can be no overlap in spectrum between them.
Only one of these <code class="docutils literal notranslate"><span class="pre">WifiSpectrumPhyInterface</span></code> instances corresponds to the active RF interface of the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code>,
the other ones are referred to as inactive RF interfaces and might be disconnected from the spectrum channel.</p>
<figure class="align-center" id="id45">
<span id="fig-spectrum-wifi-phy-multiple-interfaces"></span><img alt="_images/spectrum-wifi-phy-multiple-interfaces.png" src="_images/spectrum-wifi-phy-multiple-interfaces.png" />
<figcaption>
<p><span class="caption-text">Multiple RF interfaces concept</span><a class="headerlink" href="#id45" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>If the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy::TrackSignalsFromInactiveInterfaces</span></code> attribute is set to true (default),
inactive RF interfaces are connected to their respective spectrum channels and the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code>
also receive signals from these inactive RF interfaces when they belong to a configured portion
of the frequency range covered by the interface.
The portion of the spectrum being monitored by an inactive interface is specified by a center frequency
and a channel width, and is seamlessly set to equivalent of the operating channel of the spectrum PHY
that is actively using that frequency range. The <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy``forwards</span> <span class="pre">these</span> <span class="pre">received</span> <span class="pre">signals</span>
<span class="pre">from</span> <span class="pre">inactive</span> <span class="pre">interfaces</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">``InterferenceHelper</span></code> without further processing them.
The benefit of the latter is that more accurate PHY-CCA.indication can be generated upon channel switching
if one or more signals started to be transmitted on the new channel before the switch occurs,
which would be ignored otherwise. This is illustrated in Figure <a class="reference internal" href="#fig-cca-channel-switching-multiple-interfaces"><span class="std std-ref">Illustration of signals tracking upon channel switching</span></a>, where the parts in red are only generated when <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy::TrackSignalsFromInactiveInterfaces</span></code> is set to true.</p>
<figure class="align-center" id="id46">
<span id="fig-cca-channel-switching-multiple-interfaces"></span><img alt="_images/cca-channel-switching-multiple-interfaces.png" src="_images/cca-channel-switching-multiple-interfaces.png" />
<figcaption>
<p><span class="caption-text">Illustration of signals tracking upon channel switching</span><a class="headerlink" href="#id46" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="the-mac-model">
<h5><span class="section-number">35.1.3.2. </span>The MAC model<a class="headerlink" href="#the-mac-model" title="Link to this heading">¶</a></h5>
<section id="infrastructure-association">
<h6><span class="section-number">35.1.3.2.1. </span>Infrastructure association<a class="headerlink" href="#infrastructure-association" title="Link to this heading">¶</a></h6>
<p>Association in infrastructure mode is a high-level MAC function performed by
the Association Manager, which is implemented through a base class (<code class="docutils literal notranslate"><span class="pre">WifiAssocManager</span></code>)
and a default subclass (<code class="docutils literal notranslate"><span class="pre">WifiDefaultAssocManager</span></code>). The interaction between
the station MAC, the Association Manager base class and subclass is illustrated
in Figure <a class="reference internal" href="#fig-assoc-manager"><span class="std std-ref">Scanning procedure</span></a>.</p>
<figure class="align-center" id="id47">
<span id="fig-assoc-manager"></span><img alt="_images/assoc-manager.png" src="_images/assoc-manager.png" />
<figcaption>
<p><span class="caption-text">Scanning procedure</span><a class="headerlink" href="#id47" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The STA wifi MAC requests the Association Manager to start a scanning procedure
with specified parameters, including the type of scanning (active or passive),
the desired SSID, the list of channels to scan, etc. The STA wifi MAC then expects
to be notified of the best AP to associate with at the end of the scanning procedure.
Every Beacon or Probe Response frame received during scanning is forwarded to the
Association Manager, which keeps a list of candidate APs that match the scanning
parameters. The sorting criterium for such a list is defined by the Association
Manager subclass. The default Association Manager sorts APs in decreasing order
of the SNR of the received Beacon/Probe Response frame.</p>
<p>When notified of the start of a scanning procedure, the default Association Manager
schedules a call to a method that processes the information included in the frames
received up to the time such a method is called. When both the AP and the STA have
multiple links (i.e., they are 802.11be MLDs), the default Association Manager attempts
to setup as many links as possible. This involves switching operating channel on some of
the STA’s links to match those on which the APs affiliated with the AP MLD are operating.</p>
<p>If association is rejected by the AP for some reason, the STA will try to
associate to the next best AP until the candidate list is exhausted which
then sends STA to ‘REFUSED’ state. If this occurs, the simulation user will
need to force reassociation retry in some way, perhaps by changing
configuration (i.e. the STA will not persistently try to associate upon a
refusal).</p>
<p>When associated, if the configuration is changed by the simulation user,
the STA will try to reassociate with the existing AP.</p>
<p>If the number of missed beacons exceeds the threshold, the STA will notify
the rest of the device that the link is down (association is lost) and
restart the scanning process. Note that this can also happen when an
association request fails without explicit refusal (i.e., the AP fails to
respond to association request).</p>
</section>
<section id="roaming">
<h6><span class="section-number">35.1.3.2.2. </span>Roaming<a class="headerlink" href="#roaming" title="Link to this heading">¶</a></h6>
<p>Roaming at layer-2 (i.e. a STA migrates its association from one AP to
another) is not presently supported. Because of that, the Min/Max channel
dwelling time implementation as described by the IEEE 802.11 standard
<a class="reference internal" href="index.html#ieee80211" id="id22"><span>[ieee80211]</span></a> is also omitted, since it is only meaningful on the context
of channel roaming.</p>
</section>
<section id="channel-access">
<h6><span class="section-number">35.1.3.2.3. </span>Channel access<a class="headerlink" href="#channel-access" title="Link to this heading">¶</a></h6>
<p>The 802.11 Distributed Coordination Function is used to calculate when to grant
access to the transmission medium. While implementing the DCF would have been
particularly easy if we had used a recurring timer that expired every slot, we
chose to use the method described in <a class="reference internal" href="index.html#ji2004sslswn" id="id23"><span>[ji2004sslswn]</span></a>
where the backoff timer duration is lazily calculated whenever needed since it
is claimed to have much better performance than the simpler recurring timer
solution.</p>
<p>The DCF basic access is described in section 10.3.4.2 of <a class="reference internal" href="index.html#ieee80211-2016" id="id24"><span>[ieee80211-2016]</span></a>.</p>
<ul class="simple">
<li><p>“A STA may transmit an MPDU when it is operating under the DCF access method
[..] when the STA determines that the medium is idle when a frame is queued
for transmission, and remains idle for a period of a DIFS, or an EIFS
(10.3.2.3.7) from the end of the immediately preceding medium-busy event,
whichever is the greater, and the backoff timer is zero. Otherwise the random
backoff procedure described in 10.3.4.3 shall be followed.”</p></li>
</ul>
<p>Thus, a station is allowed not to invoke the backoff procedure if all of the
following conditions are met:</p>
<ul class="simple">
<li><p>the medium is idle when a frame is queued for transmission</p></li>
<li><p>the medium remains idle until the most recent of these two events: a DIFS
from the time when the frame is queued for transmission; an EIFS from the
end of the immediately preceding medium-busy event (associated with the
reception of an erroneous frame)</p></li>
<li><p>the backoff timer is zero</p></li>
</ul>
<p>The backoff procedure of DCF is described in section 10.3.4.3 of <a class="reference internal" href="index.html#ieee80211-2016" id="id25"><span>[ieee80211-2016]</span></a>.</p>
<ul class="simple">
<li><p>“A STA shall invoke the backoff procedure to transfer a frame
when finding the medium busy as indicated by either the physical or
virtual CS mechanism.”</p></li>
<li><p>“A backoff procedure shall be performed immediately after the end of
every transmission with the More Fragments bit set to 0 of an MPDU of
type Data, Management, or Control with subtype PS-Poll, even if no
additional transmissions are currently queued.”</p></li>
</ul>
<p>The EDCA backoff procedure is slightly different than the DCF backoff procedure
and is described in section 10.22.2.2 of <a class="reference internal" href="index.html#ieee80211-2016" id="id26"><span>[ieee80211-2016]</span></a>. The backoff procedure
shall be invoked by an EDCAF when any of the following events occur:</p>
<ul class="simple">
<li><p>a frame is “queued for transmission such that one of the transmit queues
associated with that AC has now become non-empty and any other transmit queues
associated with that AC are empty; the medium is busy on the primary channel”</p></li>
<li><p>“The transmission of the MPDU in the final PPDU transmitted by the TXOP holder
during the TXOP for that AC has completed and the TXNAV timer has expired, and
the AC was a primary AC”</p></li>
<li><p>“The transmission of an MPDU in the initial PPDU of a TXOP fails [..] and the
AC was a primary AC”</p></li>
<li><p>“The transmission attempt collides internally with another EDCAF of an AC that
has higher priority”</p></li>
<li><p>(optionally) “The transmission by the TXOP holder of an MPDU in a non-initial
PPDU of a TXOP fails”</p></li>
</ul>
<p>Additionally, section 10.22.2.4 of <a class="reference internal" href="index.html#ieee80211-2016" id="id27"><span>[ieee80211-2016]</span></a> introduces the notion of
slot boundary, which basically occurs following SIFS + AIFSN * slotTime of idle
medium after the last busy medium that was the result of a reception of a frame
with a correct FCS or following EIFS - DIFS + AIFSN * slotTime + SIFS of idle
medium after the last indicated busy medium that was the result of a frame reception
that has resulted in FCS error, or following a slotTime of idle medium occurring
immediately after any of these conditions.</p>
<p>On these specific slot boundaries, each EDCAF shall make a determination to perform
one and only one of the following functions:</p>
<ul class="simple">
<li><p>Decrement the backoff timer.</p></li>
<li><p>Initiate the transmission of a frame exchange sequence.</p></li>
<li><p>Invoke the backoff procedure due to an internal collision.</p></li>
<li><p>Do nothing.</p></li>
</ul>
<p>Thus, if an EDCAF decrements its backoff timer on a given slot boundary and, as
a result, the backoff timer has a zero value, the EDCAF cannot immediately
transmit, but it has to wait for another slotTime of idle medium before transmission
can start.</p>
<p>When the Channel Access Manager determines that channel access can be granted, it
determines the largest primary channel that is considered idle based on the CCA-BUSY
indication provided by the PHY. Such an information is passed to the Frame Exchange
Manager, which in turn informs the Multi-User Scheduler (if any) and the Wifi Remote
Station Manager. As a result, PPDUs are transmitted on the largest idle primary channel.
For example, if a STA is operating on a 40 MHz channel and the secondary20 channel
is indicated to be busy, transmissions will occur on the primary20 channel.</p>
<p>The higher-level MAC functions are implemented in a set of other C++ classes and
deal with:</p>
<ul class="simple">
<li><p>packet fragmentation and defragmentation,</p></li>
<li><p>use of the RTS/CTS protocol,</p></li>
<li><p>rate control algorithm,</p></li>
<li><p>connection and disconnection to and from an Access Point,</p></li>
<li><p>the MAC transmission queue,</p></li>
<li><p>beacon generation,</p></li>
<li><p>MSDU aggregation,</p></li>
<li><p>etc.</p></li>
</ul>
</section>
<section id="frame-exchange-managers">
<h6><span class="section-number">35.1.3.2.4. </span>Frame Exchange Managers<a class="headerlink" href="#frame-exchange-managers" title="Link to this heading">¶</a></h6>
<p>As the IEEE 802.11 standard evolves, more and more features are added and it is
more and more difficult to have a single component handling all of the allowed
frame exchange sequences. A hierarchy of FrameExchangeManager classes has been
introduced to make the code clean and scalable, while avoiding code duplication.
Each FrameExchangeManager class handles the frame exchange sequences introduced
by a given amendment. The FrameExchangeManager hierarchy is depicted in Figure
<a class="reference internal" href="#fem-hierarchy"><span class="std std-ref">FrameExchangeManager hierarchy</span></a>.</p>
<figure class="align-default" id="id48">
<span id="fem-hierarchy"></span><img alt="_images/FemHierarchy.png" src="_images/FemHierarchy.png" />
<figcaption>
<p><span class="caption-text"><em>FrameExchangeManager hierarchy</em></span><a class="headerlink" href="#id48" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The features supported by every FrameExchangeManager class are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FrameExchangeManager</span></code> is the base class. It handles the basic sequences
for non-QoS stations: MPDU followed by Normal Ack, RTS/CTS and CTS-to-self,
NAV setting and resetting, MPDU fragmentation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QosFrameExchangeManager</span></code> adds TXOP support: multiple protection setting,
TXOP truncation via CF-End, TXOP recovery, ignore NAV when responding to an
RTS sent by the TXOP holder</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HtFrameExchangeManager</span></code> adds support for Block Ack (compressed variant),
A-MSDU and A-MPDU aggregation, Implicit Block Ack Request policy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VhtFrameExchangeManager</span></code> adds support for S-MPDUs</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HeFrameExchangeManager</span></code> adds support for the transmission and reception of
multi-user frames via DL OFDMA and UL OFDMA, as detailed below.</p></li>
</ul>
</section>
<section id="mac-queues">
<span id="wifi-mu-ack-sequences"></span><h6><span class="section-number">35.1.3.2.5. </span>MAC queues<a class="headerlink" href="#mac-queues" title="Link to this heading">¶</a></h6>
<p>Each EDCA function (on QoS stations) and the DCF (on non-QoS stations) have their own
MAC queue (an instance of the <code class="docutils literal notranslate"><span class="pre">WifiMacQueue</span></code> class) to store packets received from
the upper layer and waiting for transmission. On QoS stations, each received packet is
assigned a User Priority based on the socket priority (see, e.g., the wifi-multi-tos or
the wifi-mac-ofdma examples), which determines the Access Category that handles the
packet. By default, wifi MAC queues support flow control, hence upper layers do not
forward a packet down if there is no room for it in the corresponding MAC queue.
Wifi MAC queues do not support dynamic queue limits (byte queue limits); therefore,
there is no backpressure into the traffic control layer until the WifiMacQueue for
an access category is completely full (i.e., when the queue depth reaches the value
of the MaxSize attribute, which defaults to 500 packets).
TCP small queues (TSQ) <a class="reference internal" href="index.html#corbet2012" id="id28"><span>[corbet2012]</span></a> is a Linux feature that provides feedback from the
Wi-Fi device to the socket layer, to control how much data is queued at the Wi-Fi
level.  <em>ns-3</em> TCP does not implement TSQ, nor does the WifiNetDevice provide that
specific feedback (although some use of the existing trace sources may be enough to
support it).  Regardless, experimental tests have demonstrated that TSQ interferes with
Wi-Fi aggregation on uplink transfers <a class="reference internal" href="index.html#grazia2022" id="id29"><span>[grazia2022]</span></a>.
Packets stay in the wifi MAC queue until they are acknowledged or discarded. A packet
may be discarded because, e.g., its lifetime expired (i.e., it stayed in the queue for too
long) or the maximum number of retries was reached. The maximum lifetime for a packet can
be configured via the <code class="docutils literal notranslate"><span class="pre">MaxDelay</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">WifiMacQueue</span></code>. There are a number of
traces that can be used to track the outcome of a packet transmission (see the corresponding
doxygen documentation):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WifiMac</span></code> trace sources: <code class="docutils literal notranslate"><span class="pre">AckedMpdu</span></code>, <code class="docutils literal notranslate"><span class="pre">NAckedMpdu</span></code>, <code class="docutils literal notranslate"><span class="pre">DroppedMpdu</span></code>,
<code class="docutils literal notranslate"><span class="pre">MpduResponseTimeout</span></code>, <code class="docutils literal notranslate"><span class="pre">PsduResponseTimeout</span></code>, <code class="docutils literal notranslate"><span class="pre">PsduMapResponseTimeout</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WifiMacQueue</span></code> trace source: <code class="docutils literal notranslate"><span class="pre">Expired</span></code></p></li>
</ul>
<p>Internally, a wifi MAC queue is made of multiple sub-queues, each storing frames of
a given type (i.e., data or management) and having a given receiver address and TID.
For single-user transmissions, the next station to serve is determined by a wifi MAC
queue scheduler (held by the <code class="docutils literal notranslate"><span class="pre">WifiMac</span></code> instance). A wifi MAC queue scheduler is
implemented through a base class (<code class="docutils literal notranslate"><span class="pre">WifiMacQueueScheduler</span></code>) and subclasses defining
specific scheduling policies. The default scheduler (<code class="docutils literal notranslate"><span class="pre">FcfsWifiQueueScheduler</span></code>)
gives management frames higher priority than data frames and serves data frames in a
first come first serve fashion. For multi-user transmissions (see below), scheduling
is performed by a Multi-User scheduler, which may or may not consult the wifi MAC queue
scheduler to identify the stations to serve with a Multi-User DL or UL transmission.</p>
</section>
<section id="multi-user-transmissions">
<h6><span class="section-number">35.1.3.2.6. </span>Multi-user transmissions<a class="headerlink" href="#multi-user-transmissions" title="Link to this heading">¶</a></h6>
<p>Since the introduction of the IEEE 802.11ax amendment, multi-user (MU) transmissions are
possible, both in downlink (DL) and uplink (UL), by using OFDMA and/or MU-MIMO. Currently,
ns-3 only supports multi-user transmissions via OFDMA. Three acknowledgment sequences are
implemented for DL OFDMA.</p>
<p>The first acknowledgment sequence is made of multiple BlockAckRequest/BlockAck frames sent
as single-user frames, as shown in Figure <a class="reference internal" href="#fig-ack-su-format-80211ax"><span class="std std-ref">Acknowledgment of DL MU frames in single-user format</span></a>.</p>
<figure class="align-center" id="id49">
<span id="fig-ack-su-format-80211ax"></span><img alt="_images/ack-su-format.png" src="_images/ack-su-format.png" />
<figcaption>
<p><span class="caption-text">Acknowledgment of DL MU frames in single-user format</span><a class="headerlink" href="#id49" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For the second acknowledgment sequence, an MU-BAR Trigger Frame is sent (as a single-user
frame) to solicit BlockAck responses sent in TB PPDUs, as shown in Figure <a class="reference internal" href="#fig-mu-bar-80211ax"><span class="std std-ref">Acknowledgment of DL MU frames via MU-BAR Trigger Frame sent as single-user frame</span></a>.</p>
<figure class="align-center" id="id50">
<span id="fig-mu-bar-80211ax"></span><img alt="_images/mu-bar.png" src="_images/mu-bar.png" />
<figcaption>
<p><span class="caption-text">Acknowledgment of DL MU frames via MU-BAR Trigger Frame sent as single-user frame</span><a class="headerlink" href="#id50" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For the third acknowledgment sequence, an MU-BAR Trigger Frame is aggregated to every PSDU
included in the DL MU PPDU and the BlockAck responses are sent in TB PPDUs, as shown in
Figure <a class="reference internal" href="#fig-aggr-mu-bar-80211ax"><span class="std std-ref">Acknowledgment of DL MU frames via aggregated MU-BAR Trigger Frames</span></a>.</p>
<figure class="align-center" id="id51">
<span id="fig-aggr-mu-bar-80211ax"></span><img alt="_images/aggr-mu-bar.png" src="_images/aggr-mu-bar.png" />
<figcaption>
<p><span class="caption-text">Acknowledgment of DL MU frames via aggregated MU-BAR Trigger Frames</span><a class="headerlink" href="#id51" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>For UL OFDMA, both BSRP Trigger Frames and Basic Trigger Frames are supported, as shown in
Figure <a class="reference internal" href="#fig-ul-ofdma-80211ax"><span class="std std-ref">Frame exchange sequences using UL OFDMA</span></a>. A BSRP Trigger Frame is sent by an AP to solicit stations
to send QoS Null frames containing Buffer Status Reports. A Basic Trigger Frame is sent by an AP
to solicit stations to send data frames in TB PPDUs, which are acknowledged by the AP via a
Multi-STA BlockAck frame. Note that, in order for the two frame exchange sequences to be separated
by a SIFS (as shown in Figure <a class="reference internal" href="#fig-ul-ofdma-80211ax"><span class="std std-ref">Frame exchange sequences using UL OFDMA</span></a>), it is necessary that the transmitting
Access Category has a non-zero TXOP Limit, there is enough remaining time in the TXOP to perform
the frame exchange sequence initiated by the Basic Trigger Frame and the Multi-User scheduler
(described next) chooses to send a Basic Trigger Frame after a BSRP Trigger Frame.</p>
<figure class="align-center" id="id52">
<span id="fig-ul-ofdma-80211ax"></span><img alt="_images/ul-ofdma.png" src="_images/ul-ofdma.png" />
<figcaption>
<p><span class="caption-text">Frame exchange sequences using UL OFDMA</span><a class="headerlink" href="#id52" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="multi-user-scheduler">
<h6><span class="section-number">35.1.3.2.7. </span>Multi-User Scheduler<a class="headerlink" href="#multi-user-scheduler" title="Link to this heading">¶</a></h6>
<p>A new component, named <strong>MultiUserScheduler</strong>, is in charge of determining what frame exchange
sequence the aggregated AP has to perform when gaining a TXOP (DL OFDMA, UL OFDMA or BSRP Trigger
Frame), along with the information needed to perform the selected frame exchange sequence (e.g.,
the set of PSDUs to send in case of DL OFDMA). A TXOP is gained (some time) after requesting
channel access, which is normally done by DCF/EDCA (Txop/QosTxop) if the device has frames to transmit. In order for an AP to coordinate UL MU transmissions even without DL traffic, the
duration of the access request interval can be set to a non-zero value through the
<code class="docutils literal notranslate"><span class="pre">AccessReqInterval</span></code> attribute. The access request interval is the interval between two
consecutive requests for channel access made by the MultiUserScheduler; such requests are made
independently of the presence of frames in the queues of the AP. It is also possible to set the
Access Category for which the MultiUserScheduler makes requests for channel access (via the
<code class="docutils literal notranslate"><span class="pre">AccessReqAc</span></code> attribute) and to choose whether the access request interval is measured starting
from the last time the MultiUserScheduler made a request for channel access or from the last time
channel access was obtained by DCF/EDCA (via the <code class="docutils literal notranslate"><span class="pre">DelayAccessReqUponAccess</span></code> attribute).</p>
<p><code class="docutils literal notranslate"><span class="pre">MultiUserScheduler</span></code> is an abstract base class. Currently, the only available subclass is
<strong>RrMultiUserScheduler</strong>. By default, no multi-user scheduler is aggregated to an AP (hence,
OFDMA is not enabled).</p>
</section>
<section id="round-robin-multi-user-scheduler">
<h6><span class="section-number">35.1.3.2.8. </span>Round-robin Multi-User Scheduler<a class="headerlink" href="#round-robin-multi-user-scheduler" title="Link to this heading">¶</a></h6>
<p>The Round-robin Multi-User Scheduler dynamically assigns a priority to each station to ensure
airtime fairness in the selection of stations for DL multi-user transmissions. The <code class="docutils literal notranslate"><span class="pre">NStations</span></code>
attribute enables to set the maximum number of stations that can be the recipients of a DL
multi-user frame. Therefore, every time an HE AP accesses the channel to transmit a DL
multi-user frame, the scheduler determines the number of stations the AP has frames to send
to (capped at the value specified through the mentioned attribute) and attempts to allocate
equal sized RUs to as many such stations as possible without leaving RUs of the same size
unused. For instance, if the channel bandwidth is 40 MHz and the determined number of stations
is 5, the first 4 stations (in order of priority) are allocated a 106-tone RU each (if 52-tone
RUs were allocated, we would have three 52-tone RUs unused). If central 26-tone RUs can be
allocated (as determined by the <code class="docutils literal notranslate"><span class="pre">UseCentral26TonesRus</span></code> attribute), possible stations that
have not been allocated an RU are assigned one of such 26-tone RU. In the previous example,
the fifth station would have been allocated one of the two available central 26-tone RUs.</p>
<p>When UL OFDMA is enabled (via the <code class="docutils literal notranslate"><span class="pre">EnableUlOfdma</span></code> attribute), every DL OFDMA frame exchange
is followed by an UL OFDMA frame exchange involving the same set of stations and the same RU
allocation as the preceding DL multi-user frame. The transmission of a BSRP Trigger Frame can
optionally (depending on the value of the <code class="docutils literal notranslate"><span class="pre">EnableBsrp</span></code> attribute) precede the transmission
of a Basic Trigger Frame in order for the AP to collect information about the buffer status
of the stations.</p>
</section>
<section id="enhanced-multi-link-single-radio-operation-emlsr">
<h6><span class="section-number">35.1.3.2.9. </span>Enhanced multi-link single radio operation (EMLSR)<a class="headerlink" href="#enhanced-multi-link-single-radio-operation-emlsr" title="Link to this heading">¶</a></h6>
<p>The IEEE 802.11be amendment introduced EMLSR operating mode to allow a non-AP MLD to alternate
frame exchanges over a subset of setup links identified as EMLSR links. <em>ns-3</em> supports EMLSR
operations as described in the following.</p>
<section id="non-ap-mld-side">
<h6 aria-level="7"><span class="section-number">35.1.3.2.9.1. </span>Non-AP MLD side<a class="headerlink" href="#non-ap-mld-side" title="Link to this heading">¶</a></h6>
<p>A non-AP MLD supports EMLSR operating mode if the <code class="docutils literal notranslate"><span class="pre">EmlsrActivated</span></code> attribute of the EHT
configuration is set to true. In such a case, the WifiMacHelper will install an EMLSR Manager
by using the type and attribute values configured through the <code class="docutils literal notranslate"><span class="pre">SetEmlsrManager</span></code> method. The
EMLSR Manager is a base class providing the <code class="docutils literal notranslate"><span class="pre">EmlsrLinkSet</span></code> attribute, which can be used to
enable or disable EMLSR mode (after multi-link setup, EMLSR mode is disabled by default). Setting
the <code class="docutils literal notranslate"><span class="pre">EmlsrLinkSet</span></code> attribute triggers the transmission of an EML Operating Mode Notification
frame to the AP to communicate the new set of EMLSR links, if ML setup has been completed.
Otherwise, the set of EMLSR links is stored and the EML Operating Mode Notification frame is
sent as soon as the ML setup is completed. The selection of the link used to transmit
the EML Operating Mode Notification frame is done by the EMLSR Manager subclass. The default
EMLSR Manager subclass, <code class="docutils literal notranslate"><span class="pre">DefaultEmlsrManager</span></code>, selects the link that was used to perform
ML setup. When the non-AP MLD receives the acknowledgment for the EML Operating Mode Notification
frame, it starts a timer whose duration is the transition timeout advertised by the AP MLD.
When the timer expires, or the non-AP MLD receives an EML Operating Mode Notification frame
from the AP MLD, the EMLSR mode is assumed to be enabled (or disabled).</p>
</section>
<section id="ap-mld-side">
<h6 aria-level="7"><span class="section-number">35.1.3.2.9.2. </span>AP MLD side<a class="headerlink" href="#ap-mld-side" title="Link to this heading">¶</a></h6>
<p>An AP MLD supports EMLSR operating mode if the <code class="docutils literal notranslate"><span class="pre">EmlsrActivated</span></code> attribute of the EHT
configuration is set to true. When an AP MLD that supports EMLSR operating mode has to initiate a
frame exchange with a non-AP MLD that is operating in EMLSR mode, it sends an MU-RTS Trigger Frame
soliciting a response from the non-AP MLD (and possibly others) as the initial Control frame for
that exchange. The MU-RTS Trigger Frame includes a Padding field whose transmission duration is the
maximum among the padding delays advertised by all the EMLSR clients solicited by the MU-RTS
Trigger Frame. Also, the MU-RTS Trigger Frame is carried in a non-HT (duplicate) PPDU transmitted
at a rate of 6 Mbps, 12 Mbps or 24 Mbps. When the transmission of an initial Control frame starts,
the AP MLD blocks transmissions to the solicited EMLSR clients on the EMLSR links other than the
link used to transmit the initial Control frame, so that the AP MLD does not initiate another
frame exchange on such links. The frame exchange with an EMLSR client is assumed to terminate
when the AP MLD does not start a frame transmission a SIFS after the response to the last frame
transmitted by the AP MLD or the AP MLD transmits a frame that is not addressed to the EMLSR
client. When a frame exchange with an EMLSR client terminates, the AP MLD blocks transmissions on
all the EMLSR links and starts a timer whose duration is the transition delay advertised by the
EMLSR client. When the timer expires, the EMLSR client is assumed to be back to the listening
operations and transmissions on all the EMLSR links are unblocked.</p>
</section>
</section>
<section id="ack-manager">
<h6><span class="section-number">35.1.3.2.10. </span>Ack manager<a class="headerlink" href="#ack-manager" title="Link to this heading">¶</a></h6>
<p>Since the introduction of the IEEE 802.11e amendment, multiple acknowledgment policies
are available, which are coded in the Ack Policy subfield in the QoS Control field of
QoS Data frames (see Section 9.2.4.5.4 of the IEEE 802.11-2016 standard). For instance,
an A-MPDU can be sent with the <em>Normal Ack or Implicit Block Ack Request</em> policy, in which
case the receiver replies with a Normal Ack or a Block Ack depending on whether the A-MPDU
contains a single MPDU or multiple MPDUs, or with the <em>Block Ack</em> policy, in which case
the receiver waits to receive a Block Ack Request in the future to which it replies with
a Block Ack.</p>
<p><code class="docutils literal notranslate"><span class="pre">WifiAckManager</span></code> is the abstract base class introduced to provide an interface
for multiple ack managers. Currently, the default ack manager is
the <code class="docutils literal notranslate"><span class="pre">WifiDefaultAckManager</span></code>.</p>
</section>
<section id="wifidefaultackmanager">
<h6><span class="section-number">35.1.3.2.11. </span>WifiDefaultAckManager<a class="headerlink" href="#wifidefaultackmanager" title="Link to this heading">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">WifiDefaultAckManager</span></code> allows to determine which acknowledgment policy
to use depending on the value of its attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UseExplicitBar</span></code>: used to determine the ack policy to use when a response is needed from
the recipient and the current transmission includes multiple frames (A-MPDU) or there are
frames transmitted previously for which an acknowledgment is needed. If this attribute is
true, the <em>Block Ack</em> policy is used. Otherwise, the <em>Implicit Block Ack Request</em> policy is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BaThreshold</span></code>: used to determine when the originator of a Block Ack agreement needs to
request a response from the recipient. A value of zero means that a response is requested
at every frame transmission. Otherwise, a non-zero value (less than or equal to 1) means
that a response is requested upon transmission of a frame whose sequence number is distant
at least BaThreshold multiplied by the transmit window size from the starting sequence
number of the transmit window.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DlMuAckSequenceType</span></code>: used to select the acknowledgment sequence for DL MU frames
(acknowledgment in single-user format, acknowledgment via MU-BAR Trigger Frame sent as
single-user frame, or acknowledgment via MU-BAR Trigger Frames aggregated to the data
frames).</p></li>
</ul>
</section>
<section id="protection-manager">
<h6><span class="section-number">35.1.3.2.12. </span>Protection manager<a class="headerlink" href="#protection-manager" title="Link to this heading">¶</a></h6>
<p>The protection manager is in charge of determining the protection mechanism to use,
if any, when sending a frame.</p>
<p><code class="docutils literal notranslate"><span class="pre">WifiProtectionManager</span></code> is the abstract base class introduced to provide an interface
for multiple protection managers. Currently, the default protection manager is
the <code class="docutils literal notranslate"><span class="pre">WifiDefaultProtectionManager</span></code>.</p>
</section>
<section id="wifidefaultprotectionmanager">
<h6><span class="section-number">35.1.3.2.13. </span>WifiDefaultProtectionManager<a class="headerlink" href="#wifidefaultprotectionmanager" title="Link to this heading">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">WifiDefaultProtectionManager</span></code> selects a protection mechanism based on the
information provided by the remote station manager.</p>
</section>
<section id="rate-control-algorithms">
<h6><span class="section-number">35.1.3.2.14. </span>Rate control algorithms<a class="headerlink" href="#rate-control-algorithms" title="Link to this heading">¶</a></h6>
<p>Multiple rate control algorithms are available in <em>ns-3</em>.
Some rate control algorithms are modeled after real algorithms used in real devices;
others are found in literature.
The following rate control algorithms can be used by the MAC low layer:</p>
<p>Algorithms found in real devices:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ArfWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OnoeWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConstantRateWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinstrelWifiManager</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MinstrelHtWifiManager</span></code></p></li>
</ul>
<p>Algorithms in literature:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IdealWifiManager</span></code>  (default for <code class="docutils literal notranslate"><span class="pre">WifiHelper</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AarfWifiManager</span></code> <a class="reference internal" href="index.html#lacage2004aarfamrr" id="id30"><span>[lacage2004aarfamrr]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AmrrWifiManager</span></code> <a class="reference internal" href="index.html#lacage2004aarfamrr" id="id31"><span>[lacage2004aarfamrr]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CaraWifiManager</span></code> <a class="reference internal" href="index.html#kim2006cara" id="id32"><span>[kim2006cara]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RraaWifiManager</span></code> <a class="reference internal" href="index.html#wong2006rraa" id="id33"><span>[wong2006rraa]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AarfcdWifiManager</span></code> <a class="reference internal" href="index.html#maguolo2008aarfcd" id="id34"><span>[maguolo2008aarfcd]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParfWifiManager</span></code> <a class="reference internal" href="index.html#akella2007parf" id="id35"><span>[akella2007parf]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AparfWifiManager</span></code> <a class="reference internal" href="index.html#chevillat2005aparf" id="id36"><span>[chevillat2005aparf]</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThompsonSamplingWifiManager</span></code> <a class="reference internal" href="index.html#krotov2020rate" id="id37"><span>[krotov2020rate]</span></a></p></li>
</ul>
</section>
<section id="constantratewifimanager">
<h6><span class="section-number">35.1.3.2.15. </span>ConstantRateWifiManager<a class="headerlink" href="#constantratewifimanager" title="Link to this heading">¶</a></h6>
<p>The constant rate control algorithm always uses the same
transmission mode for every packet. Users can set a desired
‘DataMode’ for all ‘unicast’ packets and ‘ControlMode’ for all
‘request’ control packets (e.g. RTS).</p>
<p>To specify different data mode for non-unicast packets, users
must set the ‘NonUnicastMode’ attribute of the
WifiRemoteStationManager.  Otherwise, WifiRemoteStationManager
will use a mode with the lowest rate for non-unicast packets.</p>
<p>The 802.11 standard is quite clear on the rules for selection
of transmission parameters for control response frames (e.g.
CTS and ACK).  <em>ns-3</em> follows the standard and selects the rate
of control response frames from the set of basic rates or
mandatory rates. This means that control response frames may
be sent using different rate even though the ConstantRateWifiManager
is used.  The ControlMode attribute of the ConstantRateWifiManager
is used for RTS frames only.  The rate of CTS and ACK frames are
selected according to the 802.11 standard.  However, users can still
manually add WifiMode to the basic rate set that will allow control
response frames to be sent at other rates.  Please consult the
<a class="reference external" href="https://www.nsnam.org/wiki/HOWTO_add_basic_rates_to_802.11">project wiki</a> on how to do this.</p>
<p>Available attributes:</p>
<ul class="simple">
<li><p>DataMode (default WifiMode::OfdmRate6Mbps): specify a mode for
all non-unicast packets</p></li>
<li><p>ControlMode (default WifiMode::OfdmRate6Mbps): specify a mode for
all ‘request’ control packets</p></li>
</ul>
</section>
<section id="idealwifimanager">
<h6><span class="section-number">35.1.3.2.16. </span>IdealWifiManager<a class="headerlink" href="#idealwifimanager" title="Link to this heading">¶</a></h6>
<p>The ideal rate control algorithm selects the best
mode according to the SNR of the previous packet sent.
Consider node <em>A</em> sending a unicast packet to node <em>B</em>.
When <em>B</em> successfully receives the packet sent from <em>A</em>,
<em>B</em> records the SNR of the received packet into a <code class="docutils literal notranslate"><span class="pre">ns3::SnrTag</span></code>
and adds the tag to an ACK back to <em>A</em>.
By doing this, <em>A</em> is able to learn the SNR of the packet sent to <em>B</em>
using an out-of-band mechanism (thus the name ‘ideal’).
<em>A</em> then uses the SNR to select a transmission mode based
on a set of SNR thresholds, which was built from a target BER and
mode-specific SNR/BER curves.</p>
<p>Available attribute:</p>
<ul class="simple">
<li><p>BerThreshold (default 1e-6): The maximum Bit Error Rate
that is used to calculate the SNR threshold for each mode.</p></li>
</ul>
<p>Note that the BerThreshold has to be low enough to select a robust enough MCS
(or mode) for a given SNR value, without being too restrictive on the target BER.
Indeed we had noticed that the previous default value (i.e. 1e-5) led to the
selection of HE MCS-11 which resulted in high PER.
With this new default value (i.e. 1e-6), a HE STA moving away from a HE AP has
smooth throughput decrease (whereas with 1e-5, better performance was seen further
away, which is not “ideal”).</p>
</section>
<section id="thompsonsamplingwifimanager">
<h6><span class="section-number">35.1.3.2.17. </span>ThompsonSamplingWifiManager<a class="headerlink" href="#thompsonsamplingwifimanager" title="Link to this heading">¶</a></h6>
<p>Thompson Sampling (TS) is a classical solution to the Multi-Armed
Bandit problem.  <cite>ThompsonSamplingWifiManager</cite> implements a rate
control algorithm based on TS with the goal of providing a simple
statistics-based algorithm with a low number of parameters.</p>
<p>The algorithm maintains the number of successful transmissions
<img class="math" src="_images/math/bc58c6693b4ac49be11f139916296dcbc22c3191.png" alt="\alpha_i"/> and the number of unsuccessful transmissions
<img class="math" src="_images/math/f83fcfca3eb762c71e468c16e685f3fcea7fe2f0.png" alt="\beta_i"/> for each MCS <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.png" alt="i"/>, both of which are initially
set to zero.</p>
<p>To select MCS for a data frame, the algorithm draws a sample frame
success rate <img class="math" src="_images/math/a554e42bdccfdc2c87802f5d26d2fff6d3c72a6f.png" alt="q_i"/> from the beta distribution with shape
parameters <img class="math" src="_images/math/5c3caccd34cb5a5655847f730a199259be544471.png" alt="(1 + \alpha_i, 1 + \beta_i)"/> for each MCS and then
selects MCS with the highest expected throughput calculated as the
sample frame success rate multiplied by MCS rate.</p>
<p>To account for changing channel conditions, exponential decay is
applied to <img class="math" src="_images/math/bc58c6693b4ac49be11f139916296dcbc22c3191.png" alt="\alpha_i"/> and <img class="math" src="_images/math/f83fcfca3eb762c71e468c16e685f3fcea7fe2f0.png" alt="\beta_i"/>. The rate of
exponential decay is controlled with the <cite>Decay</cite> attribute which is
the inverse of the time constant. Default value of 1 Hz results in
using exponential window with the time constant of 1 second.  Setting
this value to zero effectively disables exponential decay and can be
used in static scenarios.</p>
<p>Control frames are always transmitted using the most robust MCS,
except when the standard specifies otherwise, such as for ACK frames.</p>
<p>As the main goal of this algorithm is to provide a stable baseline, it
does not take into account backoff overhead, inter-frame spaces and
aggregation for MCS rate calculation. For an example of a more complex
statistics-based rate control algorithm used in real devices, consider
Minstrel-HT described below.</p>
</section>
<section id="minstrelwifimanager">
<h6><span class="section-number">35.1.3.2.18. </span>MinstrelWifiManager<a class="headerlink" href="#minstrelwifimanager" title="Link to this heading">¶</a></h6>
<p>The minstrel rate control algorithm is a rate control algorithm originated from
madwifi project. It is currently the default rate control algorithm of the Linux kernel.</p>
<p>Minstrel keeps track of the probability of successfully sending a frame of each available rate.
Minstrel then calculates the expected throughput by multiplying the probability with the rate.
This approach is chosen to make sure that lower rates are not selected in favor of the higher
rates (since lower rates are more likely to have higher probability).</p>
<p>In minstrel, roughly 10 percent of transmissions are sent at the so-called lookaround rate.
The goal of the lookaround rate is to force minstrel to try higher rate than the currently used rate.</p>
<p>For a more detailed information about minstrel, see <a class="reference internal" href="index.html#linuxminstrel" id="id38"><span>[linuxminstrel]</span></a>.</p>
</section>
<section id="minstrelhtwifimanager">
<h6><span class="section-number">35.1.3.2.19. </span>MinstrelHtWifiManager<a class="headerlink" href="#minstrelhtwifimanager" title="Link to this heading">¶</a></h6>
<p>This is the extension of minstrel for 802.11n/ac/ax.</p>
</section>
<section id="ax-obss-pd-spatial-reuse">
<h6><span class="section-number">35.1.3.2.20. </span>802.11ax OBSS PD spatial reuse<a class="headerlink" href="#ax-obss-pd-spatial-reuse" title="Link to this heading">¶</a></h6>
<p>802.11ax mode supports OBSS PD spatial reuse feature.
OBSS PD stands for Overlapping Basic Service Set Preamble-Detection.
OBSS PD is an 802.11ax specific feature that allows a STA, under specific conditions,
to ignore an inter-BSS PPDU.</p>
</section>
<section id="obss-pd-algorithm">
<h6><span class="section-number">35.1.3.2.21. </span>OBSS PD Algorithm<a class="headerlink" href="#obss-pd-algorithm" title="Link to this heading">¶</a></h6>
<p><code class="docutils literal notranslate"><span class="pre">ObssPdAlgorithm</span></code> is the base class of OBSS PD algorithms.
It implements the common functionalities. First, it makes sure the necessary callbacks are setup.
Second, when a PHY reset is requested by the algorithm, it performs the computation to determine the TX power
restrictions and informs the PHY object.</p>
<p>The PHY keeps tracks of incoming requests from the MAC to get access to the channel.
If a request is received and if PHY reset(s) indicating TX power limitations occurred
before a packet was transmitted, the next packet to be transmitted will be sent with
a reduced power. Otherwise, no TX power restrictions will be applied.</p>
</section>
<section id="constant-obss-pd-algorithm">
<h6><span class="section-number">35.1.3.2.22. </span>Constant OBSS PD Algorithm<a class="headerlink" href="#constant-obss-pd-algorithm" title="Link to this heading">¶</a></h6>
<p>Constant OBSS PD algorithm is a simple OBSS PD algorithm implemented in the <code class="docutils literal notranslate"><span class="pre">ConstantObssPdAlgorithm</span></code> class.</p>
<p>Once a HE preamble and its header have been received by the PHY, <code class="docutils literal notranslate"><span class="pre">ConstantObssPdAlgorithm::</span>
<span class="pre">ReceiveHeSig</span></code> is triggered.
The algorithm then checks whether this is an OBSS frame by comparing its own BSS color with the BSS color of the received preamble.
If this is an OBSS frame, it compares the received RSSI with its configured OBSS PD level value. The PHY then gets reset to IDLE
state in case the received RSSI is lower than that constant OBSS PD level value, and is informed about a TX power restrictions.</p>
<p>Note: since our model is based on a single threshold, the PHY only supports one restricted power level.</p>
</section>
<section id="modifying-wifi-model">
<h6><span class="section-number">35.1.3.2.23. </span>Modifying Wifi model<a class="headerlink" href="#modifying-wifi-model" title="Link to this heading">¶</a></h6>
<p>Modifying the default wifi model is one of the common tasks when performing research.
We provide an overview of how to make changes to the default wifi model in this section.
Depending on your goal, the common tasks are (in no particular order):</p>
<ul class="simple">
<li><p>Creating or modifying the default Wi-Fi frames/headers by making changes to <code class="docutils literal notranslate"><span class="pre">wifi-mac-header.*</span></code>.</p></li>
<li><p>MAC low modification. For example, handling new/modified control frames (think RTS/CTS/ACK/Block ACK),
making changes to two-way transaction/four-way transaction.  Users usually make changes to
<code class="docutils literal notranslate"><span class="pre">frame-exchange-manager.*</span></code> or its subclasses to accomplish this.
Handling of control frames is performed in <code class="docutils literal notranslate"><span class="pre">FrameExchangeManager::ReceiveMpdu</span></code>.</p></li>
<li><p>MAC high modification. For example, handling new management frames (think beacon/probe),
beacon/probe generation.  Users usually make changes to <code class="docutils literal notranslate"><span class="pre">wifi-mac.*</span></code>,``sta-wifi-mac.*``, <code class="docutils literal notranslate"><span class="pre">ap-wifi-mac.*</span></code>, or <code class="docutils literal notranslate"><span class="pre">adhoc-wifi-mac.*</span></code> to accomplish this.</p></li>
<li><p>Wi-Fi queue management.  The files <code class="docutils literal notranslate"><span class="pre">txop.*</span></code> and <code class="docutils literal notranslate"><span class="pre">qos-txop.*</span></code> are of interest for this task.</p></li>
<li><p>Channel access management.  Users should modify the files <code class="docutils literal notranslate"><span class="pre">channel-access-manager.*</span></code>, which grant access to
<code class="docutils literal notranslate"><span class="pre">Txop</span></code> and <code class="docutils literal notranslate"><span class="pre">QosTxop</span></code>.</p></li>
<li><p>Fragmentation and RTS threholds are handled by Wi-Fi remote station manager.  Note that Wi-Fi remote
station manager simply indicates if fragmentation and RTS are needed.  Fragmentation is handled by
<code class="docutils literal notranslate"><span class="pre">Txop</span></code> or <code class="docutils literal notranslate"><span class="pre">QosTxop</span></code> while RTS/CTS transaction is handled by <code class="docutils literal notranslate"><span class="pre">FrameExchangeManager</span></code>.</p></li>
<li><p>Modifying or creating new rate control algorithms can be done by creating a new child class of Wi-Fi remote
station manager or modifying the existing ones.</p></li>
</ul>
</section>
</section>
</section>
</section>
<span id="document-wifi-user"></span><section id="user-documentation">
<span id="sec-wifi-user-doc"></span><h3><span class="section-number">35.2. </span>User Documentation<a class="headerlink" href="#user-documentation" title="Link to this heading">¶</a></h3>
<section id="using-the-wifinetdevice">
<h4><span class="section-number">35.2.1. </span>Using the WifiNetDevice<a class="headerlink" href="#using-the-wifinetdevice" title="Link to this heading">¶</a></h4>
<p>The modularity provided by the implementation makes low-level configuration of
the WifiNetDevice powerful but complex. For this reason, we provide some helper
classes to perform common operations in a simple matter, and leverage the <em>ns-3</em>
attribute system to allow users to control the parameterization of the underlying
models.</p>
<p>Users who use the low-level <em>ns-3</em> API and who wish to add a WifiNetDevice to
their node must create an instance of a WifiNetDevice, plus a number of
constituent objects, and bind them together appropriately (the WifiNetDevice is
very modular in this regard, for future extensibility). At the low-level API,
this can be done with about 20 lines of code (see <code class="docutils literal notranslate"><span class="pre">ns3::WifiHelper::Install</span></code>,
and <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhyHelper::Create</span></code>). They also must create, at some point, a
Channel, which also contains a number of constituent objects (see
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannelHelper::Create</span></code>).</p>
<p>However, a few helpers are available for users to add these devices and channels
with only a few lines of code, if they are willing to use defaults, and the
helpers provide additional API to allow the passing of attribute values to
change default values.  Commonly used attribute values are listed in the
Attributes section.  The scripts in <code class="docutils literal notranslate"><span class="pre">examples/wireless</span></code> can be browsed to
see how this is done.  Next, we describe the common steps to create a WifiNetDevice
from the bottom layer (Channel) up to the device layer (WifiNetDevice).</p>
<p>To create a WifiNetDevice, users need to follow these steps:</p>
<ul class="simple">
<li><p>Decide on which physical layer framework, the <code class="docutils literal notranslate"><span class="pre">SpectrumWifiPhy</span></code> or
<code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code>, to use.  This will affect which Channel and Phy type to use.</p></li>
<li><p>Configure the Channel: Channel takes care of getting signal
from one device to other devices on the same Wi-Fi channel.
The main configurations of WifiChannel are propagation loss model and propagation delay model.</p></li>
<li><p>Configure the WifiPhy: WifiPhy takes care of actually sending and receiving wireless
signal from Channel.  Here, WifiPhy decides whether each frame will be successfully
decoded or not depending on the received signal strength and noise.  Thus, the main
configuration of WifiPhy is the error rate model, which is the one that actually
calculates the probability of successfully decoding the frame based on the signal.</p></li>
<li><p>Configure WifiMac: this step is more related to the architecture and device level.
The users configure the wifi architecture (i.e. ad-hoc or ap-sta) and whether QoS (802.11e),
HT (802.11n) and/or VHT (802.11ac) and/or HE (802.11ax) features are supported or not.</p></li>
<li><p>Create WifiDevice: at this step, users configure the desired wifi standard
(e.g. <strong>802.11b</strong>, <strong>802.11g</strong>, <strong>802.11a</strong>, <strong>802.11n</strong>, <strong>802.11ac</strong> or <strong>802.11ax</strong>) and rate control algorithm.</p></li>
<li><p>Configure mobility: finally, a mobility model is (usually) required before WifiNetDevice
can be used; even if the devices are stationary, their relative positions
are needed for propagation loss calculations.</p></li>
</ul>
<p>The following sample code illustrates a typical configuration using mostly
default values in the simulator, and infrastructure mode:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">wifiStaNode</span><span class="p">;</span>
<span class="n">wifiStaNode</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">   </span><span class="c1">// Create 10 station node objects</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="n">wifiApNode</span><span class="p">;</span>
<span class="n">wifiApNode</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">   </span><span class="c1">// Create 1 access point node object</span>

<span class="c1">// Create a channel helper and phy helper, and then create the channel</span>
<span class="n">YansWifiChannelHelper</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YansWifiChannelHelper</span><span class="o">::</span><span class="n">Default</span><span class="p">();</span>
<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">phy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YansWifiPhyHelper</span><span class="o">::</span><span class="n">Default</span><span class="p">();</span>
<span class="n">phy</span><span class="p">.</span><span class="n">SetChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">.</span><span class="n">Create</span><span class="p">());</span>

<span class="c1">// Create a WifiMacHelper, which is reused across STA and AP configurations</span>
<span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">mac</span><span class="p">;</span>

<span class="c1">// Create a WifiHelper, which will use the above helpers to create</span>
<span class="c1">// and install Wifi devices.  Configure a Wifi standard to use, which</span>
<span class="c1">// will align various parameters in the Phy and Mac to standard defaults.</span>
<span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211n</span><span class="p">);</span>
<span class="c1">// Declare NetDeviceContainers to hold the container returned by the helper</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">wifiStaDevices</span><span class="p">;</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">wifiApDevice</span><span class="p">;</span>

<span class="c1">// Perform the installation</span>
<span class="n">mac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">);</span>
<span class="n">wifiStaDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="n">mac</span><span class="p">,</span><span class="w"> </span><span class="n">wifiStaNodes</span><span class="p">);</span>
<span class="n">mac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::ApWifiMac&quot;</span><span class="p">);</span>
<span class="n">wifiApDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="n">mac</span><span class="p">,</span><span class="w"> </span><span class="n">wifiApNode</span><span class="p">);</span>
</pre></div>
</div>
<p>At this point, the 11 nodes have Wi-Fi devices configured, attached to a
common channel.  The rest of this section describes how additional
configuration may be performed.</p>
<section id="yanswifichannelhelper">
<h5><span class="section-number">35.2.1.1. </span>YansWifiChannelHelper<a class="headerlink" href="#yanswifichannelhelper" title="Link to this heading">¶</a></h5>
<p>The YansWifiChannelHelper has an unusual name. Readers may wonder why it is
named this way. The reference is to the <a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/1190455.1190467?download=true">yans simulator</a> from which this model is taken. The
helper can be used to create a YansWifiChannel with a default PropagationLoss and
PropagationDelay model.</p>
<p>Users will typically type code such as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">YansWifiChannelHelper</span><span class="w"> </span><span class="n">wifiChannelHelper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YansWifiChannelHelper</span><span class="o">::</span><span class="n">Default</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wifiChannel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifiChannelHelper</span><span class="p">.</span><span class="n">Create</span><span class="p">();</span>
</pre></div>
</div>
<p>to get the defaults.  Specifically, the default is a channel model with a
propagation delay equal to a constant, the speed of light (<code class="docutils literal notranslate"><span class="pre">ns3::ConstantSpeedPropagationDelayModel</span></code>),
and a propagation loss based on a default log distance model (<code class="docutils literal notranslate"><span class="pre">ns3::LogDistancePropagationLossModel</span></code>), using a default exponent of 3.
Please note that the default log distance model is configured with a reference
loss of 46.6777 dB at reference distance of 1m.  The reference loss of 46.6777 dB
was calculated using Friis propagation loss model at 5.15 GHz.  The reference loss
must be changed if <strong>802.11b</strong>, <strong>802.11g</strong>, <strong>802.11n</strong> (at 2.4 GHz) or <strong>802.11ax</strong> (at 2.4 GHz) are used since they operate at 2.4 Ghz.</p>
<p>Note the distinction above in creating a helper object vs. an actual simulation
object.  In <em>ns-3</em>, helper objects (used at the helper API only) are created on
the stack (they could also be created with operator new and later deleted).
However, the actual <em>ns-3</em> objects typically inherit from <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">ns3::Object</span></code>
and are assigned to a smart pointer.  See the chapter in the <em>ns-3</em> manual for
a discussion of the <em>ns-3</em> object model, if you are not familiar with it.</p>
<p>The following two methods are useful when configuring YansWifiChannelHelper:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">YansWifiChannelHelper::AddPropagationLoss</span></code> adds a PropagationLossModel; if one or more PropagationLossModels already exist, the new model is chained to the end</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YansWifiChannelHelper::SetPropagationDelay</span></code> sets a PropagationDelayModel (not chainable)</p></li>
</ul>
</section>
<section id="yanswifiphyhelper">
<h5><span class="section-number">35.2.1.2. </span>YansWifiPhyHelper<a class="headerlink" href="#yanswifiphyhelper" title="Link to this heading">¶</a></h5>
<p>Physical devices (base class <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code>) connect to <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code> models in
<em>ns-3</em>.  We need to create WifiPhy objects appropriate for the YansWifiChannel; here
the <code class="docutils literal notranslate"><span class="pre">YansWifiPhyHelper</span></code> will do the work.</p>
<p>The YansWifiPhyHelper class configures an object factory to create instances of
a <code class="docutils literal notranslate"><span class="pre">YansWifiPhy</span></code> and adds some other objects to it, including possibly a
supplemental ErrorRateModel and a pointer to a MobilityModel. The user code is
typically:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">wifiPhyHelper</span><span class="p">;</span>
<span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">SetChannel</span><span class="p">(</span><span class="n">wifiChannel</span><span class="p">);</span>
</pre></div>
</div>
<p>The default YansWifiPhyHelper is configured with TableBasedErrorRateModel
(<code class="docutils literal notranslate"><span class="pre">ns3::TableBasedErrorRateModel</span></code>). You can change the error rate model by
calling the <code class="docutils literal notranslate"><span class="pre">YansWifiPhyHelper::SetErrorRateModel</span></code> method.</p>
<p>Optionally, if pcap tracing is needed, a user may use the following
command to enable pcap tracing:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">YansWifiPhyHelper</span><span class="o">::</span><span class="n">SetPcapDataLinkType</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">SupportedPcapDataLinkTypes</span><span class="w"> </span><span class="n">dlt</span><span class="p">)</span>
</pre></div>
</div>
<p><em>ns-3</em> supports RadioTap and Prism tracing extensions for 802.11.</p>
<p>Note that we haven’t actually created any WifiPhy objects yet; we’ve just
prepared the YansWifiPhyHelper by telling it which channel it is connected to.
The Phy objects are created in the next step.</p>
<p>In order to enable 802.11n/ac/ax MIMO, the number of antennas as well as the number of supported spatial streams need to be configured.
For example, this code enables MIMO with 2 antennas and 2 spatial streams:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;Antennas&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;MaxSupportedTxSpatialStreams&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;MaxSupportedRxSpatialStreams&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</pre></div>
</div>
<p>It is also possible to configure less streams than the number of antennas in order to benefit from diversity gain, and to define different MIMO capabilities for downlink and uplink.
For example, this code configures a node with 3 antennas that supports 2 spatial streams in downstream and 1 spatial stream in upstream:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;Antennas&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;MaxSupportedTxSpatialStreams&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;MaxSupportedRxSpatialStreams&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>802.11n PHY layer can support both 20 (default) or 40 MHz channel width, and 802.11ac/ax PHY layer can use either 20, 40, 80 (default) or 160 MHz channel width.  See below for further documentation on setting the frequency, channel width, and channel number.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211ac</span><span class="p">);</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;VhtMcs9&quot;</span><span class="p">),</span>
<span class="w">                             </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;VhtMcs0&quot;</span><span class="p">));</span>

<span class="c1">//Install PHY and MAC</span>
<span class="n">Ssid</span><span class="w"> </span><span class="n">ssid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ssid</span><span class="p">(</span><span class="s">&quot;ns3-wifi&quot;</span><span class="p">);</span>
<span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">mac</span><span class="p">;</span>

<span class="n">mac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">             </span><span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>

<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">staDevice</span><span class="p">;</span>
<span class="n">staDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="n">mac</span><span class="p">,</span><span class="w"> </span><span class="n">wifiStaNode</span><span class="p">);</span>

<span class="n">mac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::ApWifiMac&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">));</span>

<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">apDevice</span><span class="p">;</span>
<span class="n">apDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="n">mac</span><span class="p">,</span><span class="w"> </span><span class="n">wifiApNode</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="channel-frequency-channel-width-and-band-configuration">
<span id="channel-settings"></span><h5><span class="section-number">35.2.1.3. </span>Channel, frequency, channel width, and band configuration<a class="headerlink" href="#channel-frequency-channel-width-and-band-configuration" title="Link to this heading">¶</a></h5>
<p>There is a unique <code class="docutils literal notranslate"><span class="pre">ns3::WifiPhy</span></code> attribute, named <code class="docutils literal notranslate"><span class="pre">ChannelSettings</span></code>, that
enables to set channel number, channel width, frequency band and primary20 index
all together, in order to eliminate the possibility of inconsistent settings.
The <code class="docutils literal notranslate"><span class="pre">ChannelSettings</span></code> attribute can be set in a number of ways (see below) by
providing either a StringValue object or a TupleValue object:</p>
<ul class="simple">
<li><p>Defining a StringValue object to set the <code class="docutils literal notranslate"><span class="pre">ChannelSettings</span></code> attribute</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">StringValue</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="s">&quot;{38, 40, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Defining a TupleValue object to set the <code class="docutils literal notranslate"><span class="pre">ChannelSettings</span></code> attribute</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TupleValue</span><span class="o">&lt;</span><span class="n">UintegerValue</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">,</span><span class="w"> </span><span class="n">EnumValue</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="n">value</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">WifiPhy</span><span class="o">::</span><span class="n">ChannelTuple</span><span class="w"> </span><span class="p">{</span><span class="mi">38</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="n">WIFI_PHY_BAND_5GHZ</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">});</span>
</pre></div>
</div>
<p>In both cases, the operating channel will be channel 38 in the 5 GHz band, which
has a width of 40 MHz, and the primary20 channel will be the 20 MHz subchannel
with the lowest center frequency (index 0).</p>
<p>The operating channel settings can then be configured in a number of ways:</p>
<ul class="simple">
<li><p>by setting global configuration default; e.g.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::WifiPhy::ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{38, 40, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
</pre></div>
</div>
<ul class="simple">
<li><p>by setting an attribute value in the helper; e.g.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TupleValue</span><span class="o">&lt;</span><span class="n">UintegerValue</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">,</span><span class="w"> </span><span class="n">EnumValue</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="n">value</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">WifiPhy</span><span class="o">::</span><span class="n">ChannelTuple</span><span class="w"> </span><span class="p">{</span><span class="mi">38</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="n">WIFI_PHY_BAND_5GHZ</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">});</span>
<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">wifiPhyHelper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YansWifiPhyHelper</span><span class="o">::</span><span class="n">Default</span><span class="p">();</span>
<span class="n">wifiPhyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>by setting the WifiHelper::SetStandard(enum WifiStandard) method; and</p></li>
<li><p>by performing post-installation configuration of the option, either
via a Ptr to the WifiPhy object, or through the Config namespace; e.g.:</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/ChannelSettings&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{38, 40, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This section provides guidance on how to properly configure these settings.</p>
<section id="wifihelper-setstandard">
<h6><span class="section-number">35.2.1.3.1. </span>WifiHelper::SetStandard()<a class="headerlink" href="#wifihelper-setstandard" title="Link to this heading">¶</a></h6>
<p><code class="docutils literal notranslate"><span class="pre">WifiHelper::SetStandard</span> <span class="pre">()</span></code> is a method required to set various parameters
in the Mac and Phy to standard values, but also to check that the channel
settings as described above are allowed. For instance, a channel in the 2.4 GHz
band cannot be configured if the standard is 802.11ac, or a channel in the 6 GHz
band can only be configured if the standard is 802.11ax (or beyond).</p>
<p>The following values for WifiStandard are defined in
<code class="docutils literal notranslate"><span class="pre">src/wifi/model/wifi-standards.h</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WIFI_STANDARD_80211a</span><span class="p">,</span>
<span class="n">WIFI_STANDARD_80211b</span><span class="p">,</span>
<span class="n">WIFI_STANDARD_80211g</span><span class="p">,</span>
<span class="n">WIFI_STANDARD_80211p</span><span class="p">,</span>
<span class="n">WIFI_STANDARD_80211n</span><span class="p">,</span>
<span class="n">WIFI_STANDARD_80211ac</span><span class="p">,</span>
<span class="n">WIFI_STANDARD_80211ax</span>
</pre></div>
</div>
<p>By default, the WifiHelper (the typical use case for WifiPhy creation) will
configure the WIFI_STANDARD_80211ax standard by default.  Other values
for standards should be passed explicitly to the WifiHelper object.</p>
<p>If user has not already configured ChannelSettings when SetStandard is called,
the user obtains default values, as described next.</p>
</section>
<section id="default-settings-for-the-operating-channel">
<h6><span class="section-number">35.2.1.3.2. </span>Default settings for the operating channel<a class="headerlink" href="#default-settings-for-the-operating-channel" title="Link to this heading">¶</a></h6>
<p>Not all the parameters in the channel settings have to be set to a valid value,
but they can be left unspecified, in which case default values are substituted
as soon as the WifiStandard is set. Here are the rules (applied in the given order):</p>
<ul class="simple">
<li><p>If the band is unspecified (i.e., it is set to WIFI_PHY_BAND_UNSPECIFIED or
“BAND_UNSPECIFIED”), the default band for the configured standard is set
(5 GHz band for 802.11{a, ac, ax, p} and 2.4 GHz band for all the others).</p></li>
<li><p>If both the channel width and the channel number are unspecified (i.e., they
are set to zero), the default channel width for the configured standard and
band is set (22 MHz for 802.11b, 10 MHz for 802.11p, 80 MHz for 802.11ac and
for 802.11ax if the band is 5 GHz, and 20 MHz for all other cases).</p></li>
<li><p>If the channel width is unspecified but the channel number is valid, the settings
are valid only if there exists a unique channel with the given number for the
configured standard and band, in which case the channel width is set to the width
of such unique channel. Otherwise, the simulation aborts.</p></li>
<li><p>If the channel number is unspecified (i.e., it is set to zero), the default
channel number for the configured standard, band and channel width is used
(the default channel number is the first one in the list of channels that can
be used with the configured standard, band and channel width)</p></li>
</ul>
<p>Following are a few examples to clarify these rules:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211ac</span><span class="p">);</span>
<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">phyHelper</span><span class="p">;</span>
<span class="n">phyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{58, 0, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
<span class="c1">// channel width unspecified</span>
<span class="c1">// -&gt; it is set to 80 MHz (width of channel 58)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211n</span><span class="p">);</span>
<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">phyHelper</span><span class="p">;</span>
<span class="n">phyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{0, 40, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
<span class="c1">// channel number unspecified</span>
<span class="c1">// -&gt; it is set to channel 38 (first 40 MHz channel in the 5GHz band)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211ax</span><span class="p">);</span>
<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">phyHelper</span><span class="p">;</span>
<span class="n">phyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{0, 0, BAND_2_4GHZ, 0}&quot;</span><span class="p">));</span>
<span class="c1">// both channel number and width unspecified</span>
<span class="c1">// -&gt; width set to 20 MHz (default width for 802.11ax in the 2.4 GHZ band)</span>
<span class="c1">// -&gt; channel number set to 1 (first 20 MHz channel in the 2.4 GHz band)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211a</span><span class="p">);</span>
<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">phyHelper</span><span class="p">;</span>
<span class="n">phyHelper</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{0, 0, BAND_UNSPECIFIED, 0}&quot;</span><span class="p">));</span>
<span class="c1">// band, channel number and width unspecified</span>
<span class="c1">// -&gt; band is set to WIFI_PHY_BAND_5GHZ (default band for 802.11a)</span>
<span class="c1">// -&gt; width set to 20 MHz (default width for 802.11a in the 5 GHZ band)</span>
<span class="c1">// -&gt; channel number set to 36 (first 20 MHz channel in the 5 GHz band)</span>
</pre></div>
</div>
<p>The default value for the ChannelSettings attribute leaves all the parameters
unspecified, except for the primary20 index, which is equal to zero.</p>
</section>
<section id="wifiphy-frequency">
<h6><span class="section-number">35.2.1.3.3. </span>WifiPhy::Frequency<a class="headerlink" href="#wifiphy-frequency" title="Link to this heading">¶</a></h6>
<p>The configured WifiPhy channel center frequency can be got via the attribute
<code class="docutils literal notranslate"><span class="pre">Frequency</span></code> in the class <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code>.  It is expressed in units of MHz.</p>
<p>Note that this is a change in definition from ns-3.25 and earlier releases,
where this attribute referred to the start of the overall frequency band
on which the channel resides, not the specific channel center frequency.</p>
</section>
<section id="wifiphy-channelwidth">
<h6><span class="section-number">35.2.1.3.4. </span>WifiPhy::ChannelWidth<a class="headerlink" href="#wifiphy-channelwidth" title="Link to this heading">¶</a></h6>
<p>The configured WifiPhy channel width can be got via the attribute <code class="docutils literal notranslate"><span class="pre">ChannelWidth</span></code>
in the class <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code>.  It is expressed in units of MHz.</p>
</section>
<section id="wifiphy-channelnumber">
<h6><span class="section-number">35.2.1.3.5. </span>WifiPhy::ChannelNumber<a class="headerlink" href="#wifiphy-channelnumber" title="Link to this heading">¶</a></h6>
<p>Several channel numbers are defined and well-known in practice.  However,
valid channel numbers vary by geographical region around the world, and
there is some overlap between the different standards.</p>
<p>The configured WifiPhy channel number can be got via the attribute <code class="docutils literal notranslate"><span class="pre">ChannelNumber</span></code>
in the class <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code>.</p>
<p>In <em>ns-3</em>, a ChannelNumber may be defined or unknown.  These terms
are not found in the code; they are just used to describe behavior herein.</p>
<p>If a ChannelNumber is defined, it means that WifiPhy has stored a
map of ChannelNumber to the center frequency and channel width commonly
known for that channel in practice.  For example:</p>
<ul class="simple">
<li><p>Channel 1, when IEEE 802.11b is configured, corresponds to a channel
width of 22 MHz and a center frequency of 2412 MHz.</p></li>
<li><p>Channel 36, when IEEE 802.11n is configured at 5 GHz, corresponds to
a channel width of 20 MHz and a center frequency of 5180 MHz.</p></li>
</ul>
<p>The following channel numbers are well-defined for 2.4 GHz standards:</p>
<ul class="simple">
<li><p>channels 1-14 with ChannelWidth of 22 MHz for 802.11b</p></li>
<li><p>channels 1-14 with ChannelWidth of 20 MHz for 802.11n-2.4GHz and 802.11g</p></li>
</ul>
<p>The following channel numbers are well-defined for 5 GHz standards:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">5 GHz channel numbers</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 22.2%" />
<col style="width: 77.8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ChannelWidth</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ChannelNumber</span></code></p></td>
</tr>
<tr class="row-even"><td><p>20 MHz</p></td>
<td><p>36, 40, 44, 48, 52, 56, 60, 64, 100,
104, 108, 112, 116, 120, 124,
128, 132, 136, 140, 144,
149, 153, 161, 165, 169</p></td>
</tr>
<tr class="row-odd"><td><p>40 MHz</p></td>
<td><p>38, 46, 54, 62, 102, 110, 118, 126,
134, 142, 151, 159</p></td>
</tr>
<tr class="row-even"><td><p>80 MHz</p></td>
<td><p>42, 58, 106, 122, 138, 155</p></td>
</tr>
<tr class="row-odd"><td><p>160 MHz</p></td>
<td><p>50, 114</p></td>
</tr>
<tr class="row-even"><td><p>10 MHz (802.11p)</p></td>
<td><p>172, 174, 176, 178, 180, 182, 184</p></td>
</tr>
<tr class="row-odd"><td><p>5 MHz (802.11p)</p></td>
<td><p>171, 173, 175, 177, 179, 181, 183</p></td>
</tr>
</tbody>
</table>
<p>The following channel numbers are well-defined for 6 GHz standards (802.11ax only):</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">6 GHz channel numbers</span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 22.2%" />
<col style="width: 77.8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ChannelWidth</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ChannelNumber</span></code></p></td>
</tr>
<tr class="row-even"><td><p>20 MHz</p></td>
<td><p>1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41,
45, 49, 53, 57, 61, 65, 69, 73, 77, 81,
85, 89, 93, 97, 101, 105, 109, 113, 117,
121, 125, 129, 133, 137, 141, 145, 149,
153, 157, 161, 165, 169, 173, 177, 181,
185, 189, 193, 197, 201, 205, 209, 213,
217, 221, 225, 229, 233</p></td>
</tr>
<tr class="row-odd"><td><p>40 MHz</p></td>
<td><p>3, 11, 19, 27, 35, 43, 51, 59, 67, 75,
83, 91, 99, 107, 115, 123, 131, 139, 147,
155, 163, 171, 179, 187, 195, 203, 211,
219, 227</p></td>
</tr>
<tr class="row-even"><td><p>80 MHz</p></td>
<td><p>7, 23, 39, 55, 71, 87, 103, 119, 135,
151, 167, 183, 199, 215</p></td>
</tr>
<tr class="row-odd"><td><p>160 MHz</p></td>
<td><p>15, 47, 79, 111, 143, 175, 207</p></td>
</tr>
</tbody>
</table>
<p>The channel number may be set either before or after creation of the
WifiPhy object.</p>
<p>If an unknown channel number (other than zero) is configured, the
simulator will exit with an error; for instance, such as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">WifiPhy</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wifiPhy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">wifiPhy</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{1321, 20, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>The known channel numbers are defined in the implementation file
<code class="docutils literal notranslate"><span class="pre">src/wifi/model/wifi-phy-operating-channel.cc</span></code>. Of course, this file may be edited
by users to extend to additional channel numbers.</p>
<p>If a known channel number is configured against an incorrect value
of the WifiPhyStandard, the simulator will exit with an error; for instance,
such as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211n</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">WifiPhy</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wifiPhy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">wifiPhy</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{14, 20, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>In the above, while channel number 14 is well-defined in practice for 802.11b
only, it is for 2.4 GHz band, not 5 GHz band.</p>
</section>
<section id="wifiphy-primary20mhzindex">
<h6><span class="section-number">35.2.1.3.6. </span>WifiPhy::Primary20MHzIndex<a class="headerlink" href="#wifiphy-primary20mhzindex" title="Link to this heading">¶</a></h6>
<p>The configured WifiPhy primary 20MHz channel index can be got via the attribute
<code class="docutils literal notranslate"><span class="pre">Primary20MHzIndex</span></code> in the class <code class="docutils literal notranslate"><span class="pre">WifiPhy</span></code>.</p>
</section>
<section id="order-of-operation-issues">
<h6><span class="section-number">35.2.1.3.7. </span>Order of operation issues<a class="headerlink" href="#order-of-operation-issues" title="Link to this heading">¶</a></h6>
<p>Channel settings can be configured either before or after the wifi standard.
If the channel settings are configured before the wifi standard, the channel
settings are stored and applied when the wifi standard is configured.
Otherwise, they are applied immediately.</p>
<p>The wifi standard can be configured only once, i.e., it is not possible to
change standard during a simulation. It is instead possible to change the
channel settings at any time.</p>
</section>
</section>
<section id="spectrumwifiphyhelper">
<h5><span class="section-number">35.2.1.4. </span>SpectrumWifiPhyHelper<a class="headerlink" href="#spectrumwifiphyhelper" title="Link to this heading">¶</a></h5>
<p>The API for this helper closely tracks the API of the YansWifiPhyHelper,
with the exception that a channel of type <code class="docutils literal notranslate"><span class="pre">ns3::SpectrumChannel</span></code> instead
of type <code class="docutils literal notranslate"><span class="pre">ns3::YansWifiChannel</span></code> must be used with it.</p>
<p>Its API has been extended for 802.11be multi-link and EMLSR in order to
attach multiple spectrum channels to a same PHY. For that purpose, a user
may use the following command to attach a spectrum channel to the PHY objects
that will be created upon a call to <code class="docutils literal notranslate"><span class="pre">ns3::WifiHelper::Install</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SpectrumWifiPhyHelper</span><span class="o">::</span><span class="n">SetPcapDataLinkType</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">SpectrumChannel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span>
<span class="w">                                           </span><span class="k">const</span><span class="w"> </span><span class="n">FrequencyRange</span><span class="o">&amp;</span><span class="w"> </span><span class="n">freqRange</span><span class="p">)</span>
</pre></div>
</div>
<p>where FrequencyRange is a structure that contains the start and stop frequencies
expressed in MHz which corresponds to the spectrum portion that is covered by the channel.</p>
</section>
<section id="wifimachelper">
<h5><span class="section-number">35.2.1.5. </span>WifiMacHelper<a class="headerlink" href="#wifimachelper" title="Link to this heading">¶</a></h5>
<p>The next step is to configure the MAC model. We use WifiMacHelper to accomplish this.
WifiMacHelper takes care of both the MAC low model and MAC high model, and configures an object factory to create instances of a <code class="docutils literal notranslate"><span class="pre">ns3::WifiMac</span></code>.
It is used to configure MAC parameters like type of MAC, and to select whether 802.11/WMM-style QoS and/or 802.11n-style High Throughput (HT)
and/or 802.11ac-style Very High Throughput (VHT) support and/or 802.11ax-style High Efficiency (HE) support are/is required.</p>
<p>By default, it creates an ad-hoc MAC instance that does not have 802.11e/WMM-style QoS nor 802.11n-style High Throughput (HT)
nor 802.11ac-style Very High Throughput (VHT) nor 802.11ax-style High Efficiency (HE) support enabled.</p>
<p>For example the following user code configures a non-QoS and non-HT/non-VHT/non-HE MAC that
will be a non-AP STA in an infrastructure network where the AP has SSID <code class="docutils literal notranslate"><span class="pre">ns-3-ssid</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMacHelper</span><span class="p">;</span>
<span class="n">Ssid</span><span class="w"> </span><span class="n">ssid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ssid</span><span class="p">(</span><span class="s">&quot;ns-3-ssid&quot;</span><span class="p">);</span>
<span class="n">wifiMacHelper</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="w">                     </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">                     </span><span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>The following code shows how to create an AP with QoS enabled:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMacHelper</span><span class="p">;</span>
<span class="n">wifiMacHelper</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::ApWifiMac&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;QosSupported&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;BeaconGeneration&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;BeaconInterval&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">Seconds</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)));</span>
</pre></div>
</div>
<p>To create ad-hoc MAC instances, simply use <code class="docutils literal notranslate"><span class="pre">ns3::AdhocWifiMac</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ns3::StaWifiMac</span></code> or <code class="docutils literal notranslate"><span class="pre">ns3::ApWifiMac</span></code>.</p>
<p>With QoS-enabled MAC models it is possible to work with traffic belonging to
four different Access Categories (ACs): <strong>AC_VO</strong> for voice traffic,
<strong>AC_VI</strong> for video traffic, <strong>AC_BE</strong> for best-effort
traffic and <strong>AC_BK</strong> for background traffic.</p>
<p>When selecting <strong>802.11n</strong> as the desired wifi standard, both 802.11e/WMM-style QoS and 802.11n-style High Throughput (HT) support gets enabled.
Similarly when selecting <strong>802.11ac</strong> as the desired wifi standard, 802.11e/WMM-style QoS, 802.11n-style High Throughput (HT) and 802.11ac-style Very High Throughput (VHT)
support gets enabled. And when selecting <strong>802.11ax</strong> as the desired wifi standard, 802.11e/WMM-style QoS, 802.11n-style High Throughput (HT),
802.11ac-style Very High Throughput (VHT) and 802.11ax-style High Efficiency (HE) support gets enabled.</p>
<p>For MAC instances that have QoS support enabled, the <code class="docutils literal notranslate"><span class="pre">ns3::WifiMacHelper</span></code> can be also used to set:</p>
<ul class="simple">
<li><p>block ack threshold (number of packets for which block ack mechanism should be used);</p></li>
<li><p>block ack inactivity timeout.</p></li>
</ul>
<p>For example the following user code configures a MAC that will be a non-AP STA with QoS enabled and a block ack threshold for AC_BE set to 2 packets,
in an infrastructure network where the AP has SSID <code class="docutils literal notranslate"><span class="pre">ns-3-ssid</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMacHelper</span><span class="p">;</span>
<span class="n">Ssid</span><span class="w"> </span><span class="n">ssid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ssid</span><span class="p">(</span><span class="s">&quot;ns-3-ssid&quot;</span><span class="p">);</span>
<span class="n">wifiMacHelper</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="w">                     </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">                     </span><span class="s">&quot;QosSupported&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span>
<span class="w">                     </span><span class="s">&quot;BE_BlockAckThreshold&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="w">                     </span><span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>For MAC instances that have 802.11n-style High Throughput (HT) and/or 802.11ac-style Very High Throughput (VHT) and/or 802.11ax-style High Efficiency (HE) support enabled,
the <code class="docutils literal notranslate"><span class="pre">ns3::WifiMacHelper</span></code> can be also used to set:</p>
<ul class="simple">
<li><p>MSDU aggregation parameters for a particular Access Category (AC) in order to use 802.11n/ac A-MSDU feature;</p></li>
<li><p>MPDU aggregation parameters for a particular Access Category (AC) in order to use 802.11n/ac A-MPDU feature.</p></li>
</ul>
<p>By default, MSDU aggregation feature is disabled for all ACs and MPDU aggregation is enabled for AC_VI and AC_BE, with a maximum aggregation size of 65535 bytes.</p>
<p>For example the following user code configures a MAC that will be a non-AP STA with HT and QoS enabled, MPDU aggregation enabled for AC_VO with a maximum aggregation size of 65535 bytes, and MSDU aggregation enabled for AC_BE with a maximum aggregation size of 7935 bytes,
in an infrastructure network where the AP has SSID <code class="docutils literal notranslate"><span class="pre">ns-3-ssid</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211n</span><span class="p">);</span>

<span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMacHelper</span><span class="p">;</span>
<span class="n">Ssid</span><span class="w"> </span><span class="n">ssid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ssid</span><span class="p">(</span><span class="s">&quot;ns-3-ssid&quot;</span><span class="p">);</span>
<span class="n">wifiMacHelper</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="w">                      </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;VO_MaxAmpduSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">65535</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;BE_MaxAmsduSize&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">7935</span><span class="p">),</span>
<span class="w">                      </span><span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>802.11ax APs support sending multi-user frames via DL OFDMA and UL OFDMA if a Multi-User Scheduler is
aggregated to the wifi MAC(by default no scheduler is aggregated). WifiMacHelper enables to aggregate
a Multi-User Scheduler to an AP and set its parameters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMacHelper</span><span class="p">;</span>
<span class="n">wifiMacHelper</span><span class="p">.</span><span class="n">SetMultiUserScheduler</span><span class="p">(</span><span class="s">&quot;ns3::RrMultiUserScheduler&quot;</span><span class="p">,</span>
<span class="w">                                    </span><span class="s">&quot;EnableUlOfdma&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span>
<span class="w">                                    </span><span class="s">&quot;EnableBsrp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
</pre></div>
</div>
<p>The Ack Manager is in charge of selecting the acknowledgment method among the three
available methods(see section <a class="reference internal" href="index.html#wifi-mu-ack-sequences"><span class="std std-ref">MAC queues</span></a> ). The default ack manager
enables to select the acknowledgment method, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">SetDefault</span><span class="p">(</span><span class="s">&quot;ns3::WifiDefaultAckManager::DlMuAckSequenceType&quot;</span><span class="p">,</span>
<span class="w">                   </span><span class="n">EnumValue</span><span class="p">(</span><span class="n">WifiAcknowledgment</span><span class="o">::</span><span class="n">DL_MU_AGGREGATE_TF</span><span class="p">));</span>
</pre></div>
</div>
<section id="selection-of-the-access-category-ac">
<h6><span class="section-number">35.2.1.5.1. </span>Selection of the Access Category (AC)<a class="headerlink" href="#selection-of-the-access-category-ac" title="Link to this heading">¶</a></h6>
<p>Since ns-3.26, the QosTag is no longer used to assign a user priority to an MSDU.
Instead, the selection of the Access Category (AC) for an MSDU is based on the
value of the DS field in the IP header of the packet (ToS field in case of IPv4,
Traffic Class field in case of IPv6). Details on how to set the ToS field of IPv4
packets are given in the <a class="reference internal" href="index.html#type-of-service"><span class="std std-ref">ToS (Type of Service)</span></a> section of the documentation. In
summary, users can create an address of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::InetSocketAddress</span></code>
with the desired type of service value and pass it to the application helpers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">InetSocketAddress</span><span class="w"> </span><span class="nf">destAddress</span><span class="p">(</span><span class="n">ipv4Address</span><span class="p">,</span><span class="w"> </span><span class="n">udpPort</span><span class="p">);</span>
<span class="n">destAddress</span><span class="p">.</span><span class="n">SetTos</span><span class="p">(</span><span class="n">tos</span><span class="p">);</span>
<span class="n">OnOffHelper</span><span class="w"> </span><span class="n">onoff</span><span class="p">(</span><span class="s">&quot;ns3::UdpSocketFactory&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">destAddress</span><span class="p">);</span>
</pre></div>
</div>
<p>Mapping the values of the DS field onto user priorities is performed similarly to the
Linux mac80211 subsystem. Basically, the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::WifiNetDevice::SelectQueue()</span></code>
method sets the user priority (UP) of an MSDU to the three most significant
bits of the DS field. The Access Category is then determined based on the user priority
according to the following table:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UP</p></th>
<th class="head"><p>Access Category</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>7</p></td>
<td><p>AC_VO</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>AC_VO</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>AC_BK</p></td>
</tr>
</tbody>
</table>
<p>TOS and DSCP values map onto user priorities and access categories according
to the following table.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>DiffServ PHB</p></th>
<th class="head"><p>TOS (binary)</p></th>
<th class="head"><p>UP</p></th>
<th class="head"><p>Access Category</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>EF</p></td>
<td><p>101110xx</p></td>
<td><p>5</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-odd"><td><p>AF11</p></td>
<td><p>001010xx</p></td>
<td><p>1</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-even"><td><p>AF21</p></td>
<td><p>010010xx</p></td>
<td><p>2</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-odd"><td><p>AF31</p></td>
<td><p>011010xx</p></td>
<td><p>3</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-even"><td><p>AF41</p></td>
<td><p>100010xx</p></td>
<td><p>4</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-odd"><td><p>AF12</p></td>
<td><p>001100xx</p></td>
<td><p>1</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-even"><td><p>AF22</p></td>
<td><p>010100xx</p></td>
<td><p>2</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-odd"><td><p>AF32</p></td>
<td><p>011100xx</p></td>
<td><p>3</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-even"><td><p>AF42</p></td>
<td><p>100100xx</p></td>
<td><p>4</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-odd"><td><p>AF13</p></td>
<td><p>001110xx</p></td>
<td><p>1</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-even"><td><p>AF23</p></td>
<td><p>010110xx</p></td>
<td><p>2</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-odd"><td><p>AF33</p></td>
<td><p>011110xx</p></td>
<td><p>3</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-even"><td><p>AF43</p></td>
<td><p>100110xx</p></td>
<td><p>4</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-odd"><td><p>CS0</p></td>
<td><p>000000xx</p></td>
<td><p>0</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-even"><td><p>CS1</p></td>
<td><p>001000xx</p></td>
<td><p>1</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-odd"><td><p>CS2</p></td>
<td><p>010000xx</p></td>
<td><p>2</p></td>
<td><p>AC_BK</p></td>
</tr>
<tr class="row-even"><td><p>CS3</p></td>
<td><p>011000xx</p></td>
<td><p>3</p></td>
<td><p>AC_BE</p></td>
</tr>
<tr class="row-odd"><td><p>CS4</p></td>
<td><p>100000xx</p></td>
<td><p>4</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-even"><td><p>CS5</p></td>
<td><p>101000xx</p></td>
<td><p>5</p></td>
<td><p>AC_VI</p></td>
</tr>
<tr class="row-odd"><td><p>CS6</p></td>
<td><p>110000xx</p></td>
<td><p>6</p></td>
<td><p>AC_VO</p></td>
</tr>
<tr class="row-even"><td><p>CS7</p></td>
<td><p>111000xx</p></td>
<td><p>7</p></td>
<td><p>AC_VO</p></td>
</tr>
</tbody>
</table>
<p>So, for example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">destAddress</span><span class="p">.</span><span class="n">SetTos</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">);</span>
</pre></div>
</div>
<p>will map to CS6, User Priority 6, and Access Category AC_VO.
Also, the ns3-wifi-ac-mapping test suite (defined in
src/test/ns3wifi/wifi-ac-mapping-test-suite.cc) can provide additional
useful information.</p>
<p>Note that <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::WifiNetDevice::SelectQueue()</span></code> also sets the packet
priority to the user priority, thus overwriting the value determined by the
socket priority (users can read <a class="reference internal" href="index.html#socket-options"><span class="std std-ref">Use of Send() vs. SendTo()</span></a> for details on how to
set the packet priority). Also, given that the Traffic Control layer calls
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ns3::WifiNetDevice::SelectQueue()</span></code> before enqueuing the packet
into a queue disc, it turns out that queuing disciplines (such as
PfifoFastQueueDisc) that classifies packets based on their priority will
use the user priority instead of the socket priority.</p>
</section>
</section>
<section id="wifihelper">
<h5><span class="section-number">35.2.1.6. </span>WifiHelper<a class="headerlink" href="#wifihelper" title="Link to this heading">¶</a></h5>
<p>We’re now ready to create WifiNetDevices. First, let’s create
a WifiHelper with default settings:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifiHelper</span><span class="p">;</span>
</pre></div>
</div>
<p>What does this do?  It sets the default wifi standard to <strong>802.11a</strong> and sets the RemoteStationManager to
<code class="docutils literal notranslate"><span class="pre">ns3::ArfWifiManager</span></code>.  You can change the RemoteStationManager by calling the
<code class="docutils literal notranslate"><span class="pre">WifiHelper::SetRemoteStationManager</span></code> method. To change the wifi standard, call the
<code class="docutils literal notranslate"><span class="pre">WifiHelper::SetStandard</span></code> method with the desired standard.</p>
<p>Now, let’s use the wifiPhyHelper and wifiMacHelper created above to install WifiNetDevices
on a set of nodes in a NodeContainer “c”:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">wifiContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WifiHelper</span><span class="o">::</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiPhyHelper</span><span class="p">,</span><span class="w"> </span><span class="n">wifiMacHelper</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>This creates the WifiNetDevice which includes also a WifiRemoteStationManager, a
WifiMac, and a WifiPhy (connected to the matching Channel).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">WifiHelper::SetStandard</span></code> method sets various default timing parameters as defined in the selected standard version, overwriting values that may exist or have been previously configured.
In order to change parameters that are overwritten by <code class="docutils literal notranslate"><span class="pre">WifiHelper::SetStandard</span></code>, this should be done post-install using <code class="docutils literal notranslate"><span class="pre">Config::Set</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211n</span><span class="p">);</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;HtMcs7&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;HtMcs0&quot;</span><span class="p">));</span>

<span class="c1">//Install PHY and MAC</span>
<span class="n">Ssid</span><span class="w"> </span><span class="n">ssid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ssid</span><span class="p">(</span><span class="s">&quot;ns3-wifi&quot;</span><span class="p">);</span>

<span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">mac</span><span class="p">;</span>
<span class="n">mac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>

<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">staDevice</span><span class="p">;</span>
<span class="n">staDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="n">mac</span><span class="p">,</span><span class="w"> </span><span class="n">wifiStaNode</span><span class="p">);</span>

<span class="n">mac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::ApWifiMac&quot;</span><span class="p">,</span>
<span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">));</span>

<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">apDevice</span><span class="p">;</span>
<span class="n">apDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span><span class="w"> </span><span class="n">mac</span><span class="p">,</span><span class="w"> </span><span class="n">wifiApNode</span><span class="p">);</span>

<span class="c1">//Once install is done, we overwrite the standard timing values</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Slot&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">MicroSeconds</span><span class="p">(</span><span class="n">slot</span><span class="p">)));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Sifs&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">MicroSeconds</span><span class="p">(</span><span class="n">sifs</span><span class="p">)));</span>
<span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Pifs&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TimeValue</span><span class="p">(</span><span class="n">MicroSeconds</span><span class="p">(</span><span class="n">pifs</span><span class="p">)));</span>
</pre></div>
</div>
<p>The WifiHelper can be used to set the attributes of the default ack policy selector
(<code class="docutils literal notranslate"><span class="pre">ConstantWifiAckPolicySelector</span></code>) or to select a different (user provided) ack
policy selector, for each of the available Access Categories. As an example, the
following code can be used to set the BaThreshold attribute of the default ack
policy selector associated with BE AC to 0.5:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetAckPolicySelectorForAc</span><span class="p">(</span><span class="n">AC_BE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ns3::ConstantWifiAckPolicySelector&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="s">&quot;BaThreshold&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">0.5</span><span class="p">));</span>
</pre></div>
</div>
<p>The WifiHelper is also used to configure OBSS PD spatial reuse for 802.11ax.
The following lines configure a WifiHelper to support OBSS PD spatial reuse
using the <code class="docutils literal notranslate"><span class="pre">ConstantObssPdAlgorithm</span></code> with a threshold set to -72 dBm:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetObssPdAlgorithm</span><span class="p">(</span><span class="s">&quot;ns3::ConstantObssPdAlgorithm&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;ObssPdLevel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">-72.0</span><span class="p">));</span>
</pre></div>
</div>
<p>There are many other <em>ns-3</em> attributes that can be set on the above helpers to
deviate from the default behavior; the example scripts show how to do some of
this reconfiguration.</p>
</section>
<section id="ht-configuration">
<h5><span class="section-number">35.2.1.7. </span>HT configuration<a class="headerlink" href="#ht-configuration" title="Link to this heading">¶</a></h5>
<p>HT is an acronym for High Throughput, a term synonymous with the IEEE 802.11n
standard.  Once the <code class="docutils literal notranslate"><span class="pre">ns3::WifiHelper::Install</span></code> has been called and the
user sets the standard to a variant that supports HT capabilities (802.11n,
802.11ac, or 802.11ax), an HT configuration object will automatically be
created for the device.  The configuration object is used to store and
manage HT-specific attributes.</p>
<p>802.11n/ac PHY layer can use either long (800 ns) or short (400 ns) OFDM guard intervals. To configure this parameter for a given device, the following lines of code could be used (in this example, it enables the support of a short guard interval for the first station):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifiStaDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">WifiNetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">WifiNetDevice</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">HtConfiguration</span><span class="o">&gt;</span><span class="w"> </span><span class="n">htConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wnd</span><span class="o">-&gt;</span><span class="n">GetHtConfiguration</span><span class="p">();</span>
<span class="n">htConfiguration</span><span class="o">-&gt;</span><span class="n">SetShortGuardIntervalSupported</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>It is also possible to configure HT-specific attributes using <code class="docutils literal notranslate"><span class="pre">Config::Set</span></code>.
The following line of code enables the support of a short guard interval for all stations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Config</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="vht-configuration">
<h5><span class="section-number">35.2.1.8. </span>VHT configuration<a class="headerlink" href="#vht-configuration" title="Link to this heading">¶</a></h5>
<p>IEEE 802.11ac devices are also known as supporting Very High Throughput (VHT).  Once the <code class="docutils literal notranslate"><span class="pre">ns3::WifiHelper::Install</span></code> has been called and either the 802.11ac
or 802.11ax 5 GHz standards are configured, a VHT configuration object will be
automatically created to manage VHT-specific attributes.</p>
<p>As of ns-3.29, however, there are no VHT-specific configuration items to
manage; therefore, this object is a placeholder for future growth.</p>
</section>
<section id="he-configuration">
<h5><span class="section-number">35.2.1.9. </span>HE configuration<a class="headerlink" href="#he-configuration" title="Link to this heading">¶</a></h5>
<p>IEEE 802.11ax is also known as High Efficiency (HE).  Once the <code class="docutils literal notranslate"><span class="pre">ns3::WifiHelper::Install</span></code> has been called and IEEE 802.11ax configured as the standard, an
HE configuration object will automatically be created to manage HE-specific
attributes for 802.11ax devices.</p>
<p>802.11ax PHY layer can use either 3200 ns, 1600 ns or 800 ns OFDM guard intervals. To configure this parameter, the following lines of code could be used (in this example, it enables the support of 1600 ns guard interval), such as in this example code snippet:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">NetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifiStaDevices</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">WifiNetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="o">&lt;</span><span class="n">WifiNetDevice</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">HeConfiguration</span><span class="o">&gt;</span><span class="w"> </span><span class="n">heConfiguration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wnd</span><span class="o">-&gt;</span><span class="n">GetHeConfiguration</span><span class="p">();</span>
<span class="n">heConfiguration</span><span class="o">-&gt;</span><span class="n">SetGuardInterval</span><span class="p">(</span><span class="n">NanoSeconds</span><span class="p">(</span><span class="mi">1600</span><span class="p">));</span>
</pre></div>
</div>
<p>802.11ax allows extended compressed Block ACKs containing a 256-bits bitmap, making
possible transmissions of A-MPDUs containing up to 256 MPDUs, depending on the
negotiated buffer size. In order to configure the buffer size of an 802.11ax device,
the following line of code could be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">heConfiguration</span><span class="o">-&gt;</span><span class="n">SetMpduBufferSize</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
</pre></div>
</div>
<p>For transmitting large MPDUs, it might also be needed to increase the maximum
aggregation size (see above).</p>
<p>When using UL MU transmissions, solicited TB PPDUs can arrive at the AP with a
different delay, due to the different propagation delay from the various stations.
In real systems, late TB PPDUs cause a variable amount of interference depending on
the receiver’s sensitivity. This phenomenon can be modeled through the
<code class="docutils literal notranslate"><span class="pre">ns3::HeConfiguration::MaxTbPpduDelay</span></code> attribute, which defines the maximum delay
with which a TB PPDU can arrive with respect to the first TB PPDU in order to be
decoded properly. TB PPDUs arriving after more than <code class="docutils literal notranslate"><span class="pre">MaxTbPpduDelay</span></code> since the
first TB PPDU are discarded and considered as interference.</p>
</section>
<section id="mobility-configuration">
<h5><span class="section-number">35.2.1.10. </span>Mobility configuration<a class="headerlink" href="#mobility-configuration" title="Link to this heading">¶</a></h5>
<p>Finally, a mobility model must be configured on each node with Wi-Fi device.
Mobility model is used for calculating propagation loss and propagation delay.
Two examples are provided in the next section.
Users are referred to the chapter on <a class="reference internal" href="index.html#mobility"><span class="std std-ref">Mobility</span></a> module for detailed information.</p>
</section>
<section id="example-configuration">
<h5><span class="section-number">35.2.1.11. </span>Example configuration<a class="headerlink" href="#example-configuration" title="Link to this heading">¶</a></h5>
<p>We provide two typical examples of how a user might configure a Wi-Fi network –
one example with an ad-hoc network and one example with an infrastructure network.
The two examples were modified from the two examples in the <code class="docutils literal notranslate"><span class="pre">examples/wireless</span></code> folder
(<code class="docutils literal notranslate"><span class="pre">wifi-simple-adhoc.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">wifi-simple-infra.cc</span></code>).
Users are encouraged to see examples in the <code class="docutils literal notranslate"><span class="pre">examples/wireless</span></code> folder.</p>
<section id="adhoc-wifinetdevice-configuration">
<h6><span class="section-number">35.2.1.11.1. </span>AdHoc WifiNetDevice configuration<a class="headerlink" href="#adhoc-wifinetdevice-configuration" title="Link to this heading">¶</a></h6>
<p>In this example, we create two ad-hoc nodes equipped with 802.11a Wi-Fi devices.
We use the <code class="docutils literal notranslate"><span class="pre">ns3::ConstantSpeedPropagationDelayModel</span></code> as the propagation delay model and
<code class="docutils literal notranslate"><span class="pre">ns3::LogDistancePropagationLossModel</span></code> with the exponent of 3.0 as the propagation loss model.
Both devices are configured with <code class="docutils literal notranslate"><span class="pre">ConstantRateWifiManager</span></code> at the fixed rate of 12Mbps.
Finally, we manually place them by using the <code class="docutils literal notranslate"><span class="pre">ns3::ListPositionAllocator</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">phyMode</span><span class="p">(</span><span class="s">&quot;OfdmRate12Mbps&quot;</span><span class="p">);</span>

<span class="n">NodeContainer</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211a</span><span class="p">);</span>

<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">wifiPhy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YansWifiPhyHelper</span><span class="o">::</span><span class="n">Default</span><span class="p">();</span>
<span class="c1">// ns-3 supports RadioTap and Prism tracing extensions for 802.11</span>
<span class="n">wifiPhy</span><span class="p">.</span><span class="n">SetPcapDataLinkType</span><span class="p">(</span><span class="n">WifiPhyHelper</span><span class="o">::</span><span class="n">DLT_IEEE802_11_RADIO</span><span class="p">);</span>

<span class="n">YansWifiChannelHelper</span><span class="w"> </span><span class="n">wifiChannel</span><span class="p">;</span>
<span class="n">wifiChannel</span><span class="p">.</span><span class="n">SetPropagationDelay</span><span class="p">(</span><span class="s">&quot;ns3::ConstantSpeedPropagationDelayModel&quot;</span><span class="p">);</span>
<span class="n">wifiChannel</span><span class="p">.</span><span class="n">AddPropagationLoss</span><span class="p">(</span><span class="s">&quot;ns3::LogDistancePropagationLossModel&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="s">&quot;Exponent&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">3.0</span><span class="p">));</span>
<span class="n">wifiPhy</span><span class="p">.</span><span class="n">SetChannel</span><span class="p">(</span><span class="n">wifiChannel</span><span class="p">.</span><span class="n">Create</span><span class="p">());</span>

<span class="c1">// Add a non-QoS upper mac, and disable rate control (i.e. ConstantRateWifiManager)</span>
<span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="n">StringValue</span><span class="p">(</span><span class="n">phyMode</span><span class="p">),</span>
<span class="w">                             </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="n">StringValue</span><span class="p">(</span><span class="n">phyMode</span><span class="p">));</span>
<span class="c1">// Set it to adhoc mode</span>
<span class="n">wifiMac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::AdhocWifiMac&quot;</span><span class="p">);</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiPhy</span><span class="p">,</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">// Configure mobility</span>
<span class="n">MobilityHelper</span><span class="w"> </span><span class="n">mobility</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">ListPositionAllocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">positionAlloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">ListPositionAllocator</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">SetPositionAllocator</span><span class="p">(</span><span class="n">positionAlloc</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">SetMobilityModel</span><span class="p">(</span><span class="s">&quot;ns3::ConstantPositionMobilityModel&quot;</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="c1">// other set up (e.g. InternetStack, Application)</span>
</pre></div>
</div>
</section>
<section id="infrastructure-access-point-and-clients-wifinetdevice-configuration">
<h6><span class="section-number">35.2.1.11.2. </span>Infrastructure (access point and clients) WifiNetDevice configuration<a class="headerlink" href="#infrastructure-access-point-and-clients-wifinetdevice-configuration" title="Link to this heading">¶</a></h6>
<p>This is a typical example of how a user might configure an access point and a set of clients.
In this example, we create one access point and two clients.
Each node is equipped with 802.11b Wi-Fi device:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">phyMode</span><span class="p">(</span><span class="s">&quot;DsssRate1Mbps&quot;</span><span class="p">);</span>

<span class="n">NodeContainer</span><span class="w"> </span><span class="n">ap</span><span class="p">;</span>
<span class="n">ap</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="n">stas</span><span class="p">;</span>
<span class="n">stas</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211b</span><span class="p">);</span>

<span class="n">YansWifiPhyHelper</span><span class="w"> </span><span class="n">wifiPhy</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">YansWifiPhyHelper</span><span class="o">::</span><span class="n">Default</span><span class="p">();</span>
<span class="c1">// ns-3 supports RadioTap and Prism tracing extensions for 802.11</span>
<span class="n">wifiPhy</span><span class="p">.</span><span class="n">SetPcapDataLinkType</span><span class="p">(</span><span class="n">WifiPhyHelper</span><span class="o">::</span><span class="n">DLT_IEEE802_11_RADIO</span><span class="p">);</span>

<span class="n">YansWifiChannelHelper</span><span class="w"> </span><span class="n">wifiChannel</span><span class="p">;</span>
<span class="c1">// reference loss must be changed since 802.11b is operating at 2.4GHz</span>
<span class="n">wifiChannel</span><span class="p">.</span><span class="n">SetPropagationDelay</span><span class="p">(</span><span class="s">&quot;ns3::ConstantSpeedPropagationDelayModel&quot;</span><span class="p">);</span>
<span class="n">wifiChannel</span><span class="p">.</span><span class="n">AddPropagationLoss</span><span class="p">(</span><span class="s">&quot;ns3::LogDistancePropagationLossModel&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="s">&quot;Exponent&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">3.0</span><span class="p">),</span>
<span class="w">                               </span><span class="s">&quot;ReferenceLoss&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleValue</span><span class="p">(</span><span class="mf">40.0459</span><span class="p">));</span>
<span class="n">wifiPhy</span><span class="p">.</span><span class="n">SetChannel</span><span class="p">(</span><span class="n">wifiChannel</span><span class="p">.</span><span class="n">Create</span><span class="p">());</span>

<span class="c1">// Add a non-QoS upper mac, and disable rate control</span>
<span class="n">WifiMacHelper</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="n">StringValue</span><span class="p">(</span><span class="n">phyMode</span><span class="p">),</span>
<span class="w">                             </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="n">StringValue</span><span class="p">(</span><span class="n">phyMode</span><span class="p">));</span>

<span class="c1">// Setup the rest of the upper mac</span>
<span class="n">Ssid</span><span class="w"> </span><span class="n">ssid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ssid</span><span class="p">(</span><span class="s">&quot;wifi-default&quot;</span><span class="p">);</span>

<span class="c1">// setup AP.</span>
<span class="n">wifiMac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::ApWifiMac&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">apDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiPhy</span><span class="p">,</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">,</span><span class="w"> </span><span class="n">ap</span><span class="p">);</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apDevice</span><span class="p">;</span>

<span class="c1">// setup STAs.</span>
<span class="n">wifiMac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">                </span><span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">staDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiPhy</span><span class="p">,</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">,</span><span class="w"> </span><span class="n">stas</span><span class="p">);</span>
<span class="n">devices</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">staDevices</span><span class="p">);</span>

<span class="c1">// Configure mobility</span>
<span class="n">MobilityHelper</span><span class="w"> </span><span class="n">mobility</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">ListPositionAllocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">positionAlloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">ListPositionAllocator</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">SetPositionAllocator</span><span class="p">(</span><span class="n">positionAlloc</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">SetMobilityModel</span><span class="p">(</span><span class="s">&quot;ns3::ConstantPositionMobilityModel&quot;</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">sta</span><span class="p">);</span>

<span class="c1">// other set up (e.g. InternetStack, Application)</span>
</pre></div>
</div>
</section>
<section id="multiple-rf-interfaces-configuration">
<h6><span class="section-number">35.2.1.11.3. </span>Multiple RF interfaces configuration<a class="headerlink" href="#multiple-rf-interfaces-configuration" title="Link to this heading">¶</a></h6>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NodeContainer</span><span class="w"> </span><span class="n">ap</span><span class="p">;</span>
<span class="n">ap</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="n">sta</span><span class="p">;</span>
<span class="n">sta</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">WifiHelper</span><span class="w"> </span><span class="n">wifi</span><span class="p">;</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetStandard</span><span class="p">(</span><span class="n">WIFI_STANDARD_80211be</span><span class="p">);</span>

<span class="c1">// Create multiple spectrum channels</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MultiModelSpectrumChannel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spectrumChannel2_4Ghz</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">MultiModelSpectrumChannel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MultiModelSpectrumChannel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spectrumChannel5Ghz</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">MultiModelSpectrumChannel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">MultiModelSpectrumChannel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spectrumChannel6Ghz</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">MultiModelSpectrumChannel</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// optional: set up propagation loss model separately for each spectrum channel</span>

<span class="c1">// SpectrumWifiPhyHelper (3 links)</span>
<span class="n">SpectrumWifiPhyHelper</span><span class="w"> </span><span class="nf">phy</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">phy</span><span class="p">.</span><span class="n">SetPcapDataLinkType</span><span class="p">(</span><span class="n">WifiPhyHelper</span><span class="o">::</span><span class="n">DLT_IEEE802_11_RADIO</span><span class="p">);</span>
<span class="n">phy</span><span class="p">.</span><span class="n">AddChannel</span><span class="p">(</span><span class="n">spectrumChannel2_4Ghz</span><span class="p">,</span><span class="w"> </span><span class="n">WIFI_SPECTRUM_2_4_GHZ</span><span class="p">);</span>
<span class="n">phy</span><span class="p">.</span><span class="n">AddChannel</span><span class="p">(</span><span class="n">spectrumChannel5Ghz</span><span class="p">,</span><span class="w"> </span><span class="n">WIFI_SPECTRUM_5_GHZ</span><span class="p">);</span>
<span class="n">phy</span><span class="p">.</span><span class="n">AddChannel</span><span class="p">(</span><span class="n">spectrumChannel6Ghz</span><span class="p">,</span><span class="w"> </span><span class="n">WIFI_SPECTRUM_6_GHZ</span><span class="p">);</span>

<span class="c1">// configure operating channel for each link</span>
<span class="n">phy</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{42, 0, BAND_2_4GHZ, 0}&quot;</span><span class="p">));</span>
<span class="n">phy</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{42, 0, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
<span class="n">phy</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{215, 0, BAND_6GHZ, 0}&quot;</span><span class="p">));</span>

<span class="c1">// configure rate manager for each link</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;EhtMcs11&quot;</span><span class="p">),</span>
<span class="w">                             </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;ErpOfdmRate24Mbps&quot;</span><span class="p">));</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;EhtMcs9&quot;</span><span class="p">),</span>
<span class="w">                             </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;OfdmRate24Mbps&quot;</span><span class="p">));</span>
<span class="n">wifi</span><span class="p">.</span><span class="n">SetRemoteStationManager</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;ns3::ConstantRateWifiManager&quot;</span><span class="p">,</span>
<span class="w">                             </span><span class="s">&quot;DataMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;EhtMcs7&quot;</span><span class="p">),</span>
<span class="w">                             </span><span class="s">&quot;ControlMode&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;HeMcs4&quot;</span><span class="p">));</span>

<span class="c1">// setup AP.</span>
<span class="n">wifiMac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::ApWifiMac&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">apDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiPhy</span><span class="p">,</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">,</span><span class="w"> </span><span class="n">ap</span><span class="p">);</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apDevice</span><span class="p">;</span>

<span class="c1">// setup STA.</span>
<span class="n">wifiMac</span><span class="p">.</span><span class="n">SetType</span><span class="p">(</span><span class="s">&quot;ns3::StaWifiMac&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Ssid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SsidValue</span><span class="p">(</span><span class="n">ssid</span><span class="p">),</span>
<span class="w">                </span><span class="s">&quot;ActiveProbing&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BooleanValue</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">staDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wifi</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">wifiPhy</span><span class="p">,</span><span class="w"> </span><span class="n">wifiMac</span><span class="p">,</span><span class="w"> </span><span class="n">sta</span><span class="p">);</span>
<span class="n">devices</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">staDevice</span><span class="p">);</span>

<span class="c1">// Configure mobility</span>
<span class="n">MobilityHelper</span><span class="w"> </span><span class="n">mobility</span><span class="p">;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">ListPositionAllocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">positionAlloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">ListPositionAllocator</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">positionAlloc</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">SetPositionAllocator</span><span class="p">(</span><span class="n">positionAlloc</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">SetMobilityModel</span><span class="p">(</span><span class="s">&quot;ns3::ConstantPositionMobilityModel&quot;</span><span class="p">);</span>
<span class="n">mobility</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="c1">// other set up (e.g. InternetStack, Application)</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<span id="document-wifi-testing"></span><section id="testing-documentation">
<h3><span class="section-number">35.3. </span>Testing Documentation<a class="headerlink" href="#testing-documentation" title="Link to this heading">¶</a></h3>
<p>At present, most of the available documentation about testing and validation
exists in publications, some of which are referenced below.</p>
<section id="error-model">
<h4><span class="section-number">35.3.1. </span>Error model<a class="headerlink" href="#error-model" title="Link to this heading">¶</a></h4>
<p>Validation results for the 802.11b error model are available in this
<a class="reference external" href="http://www.nsnam.org/~pei/80211b.pdf">technical report</a></p>
<p>Two clarifications on the results should be noted.  First, Figure 1-4
of the above reference
corresponds to the <em>ns-3</em> NIST BER model.   In the program in the
Appendix of the paper (80211b.c), there are two constants used to generate
the data.  The first, packet size, is set to 1024 bytes.  The second,
“noise”, is set to a value of 7 dB; this was empirically picked to align
the curves the best with the reported data from the CMU testbed.  Although
a value of 1.55 dB would correspond to the reported -99 dBm noise floor
from the CMU paper, a noise figure of 7 dB results in the best fit with the
CMU experimental data.  This default of 7 dB is the RxNoiseFigure in the
<code class="docutils literal notranslate"><span class="pre">ns3::YansWifiPhy</span></code> model.  Other values for noise figure will shift the
curves leftward or rightward but not change the slope.</p>
<p>The curves can be reproduced by running the <code class="docutils literal notranslate"><span class="pre">wifi-clear-channel-cmu.cc</span></code>
example program in the <code class="docutils literal notranslate"><span class="pre">examples/wireless</span></code> directory, and the figure produced
(when GNU Scientific Library (GSL) is enabled) is reproduced below in
Figure <a class="reference internal" href="#fig-clear-channel-80211b"><span class="std std-ref">Clear channel (AWGN) error model for 802.11b</span></a>.</p>
<figure class="align-center" id="id6">
<span id="fig-clear-channel-80211b"></span><img alt="_images/clear-channel.png" src="_images/clear-channel.png" />
<figcaption>
<p><span class="caption-text">Clear channel (AWGN) error model for 802.11b</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Validation results for the 802.11a/g OFDM error model are available in this
<a class="reference external" href="https://www.nsnam.org/~pei/80211ofdm.pdf">technical report</a>.  The curves
can be reproduced by running the <code class="docutils literal notranslate"><span class="pre">wifi-ofdm-validation.cc</span></code> example program
in the <code class="docutils literal notranslate"><span class="pre">examples/wireless</span></code> directory, and the figure is reproduced below
in Figure <a class="reference internal" href="#fig-nist-frame-success-rate"><span class="std std-ref">Frame error rate (NIST model) for 802.11a/g (OFDM) Wi-Fi</span></a>.</p>
<figure class="align-center" id="id7">
<span id="fig-nist-frame-success-rate"></span><img alt="_images/nist-frame-success-rate.png" src="_images/nist-frame-success-rate.png" />
<figcaption>
<p><span class="caption-text">Frame error rate (NIST model) for 802.11a/g (OFDM) Wi-Fi</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Similar curves for 802.11n/ac/ax can be obtained by running the <code class="docutils literal notranslate"><span class="pre">wifi-ofdm-ht-validation.cc</span></code>,
<code class="docutils literal notranslate"><span class="pre">wifi-ofdm-vht-validation.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">wifi-ofdm-he-validation.cc</span></code> example programs
in the <code class="docutils literal notranslate"><span class="pre">examples/wireless</span></code> directory, and the figures are reproduced below
in Figure <a class="reference internal" href="#fig-nist-frame-success-rate-n"><span class="std std-ref">Frame error rate (NIST model) for 802.11n (HT OFDM) Wi-Fi</span></a>, Figure <a class="reference internal" href="#fig-nist-frame-success-rate-ac"><span class="std std-ref">Frame error rate (NIST model) for 802.11ac (VHT OFDM) Wi-Fi</span></a>
and Figure <a class="reference internal" href="#fig-nist-frame-success-rate-ax"><span class="std std-ref">Frame error rate (NIST model) for 802.11ax (HE OFDM) Wi-Fi</span></a>, respectively.
There is no validation for those curves yet.</p>
<figure class="align-center" id="id8">
<span id="fig-nist-frame-success-rate-n"></span><img alt="_images/nist-frame-success-rate-n.png" src="_images/nist-frame-success-rate-n.png" />
<figcaption>
<p><span class="caption-text">Frame error rate (NIST model) for 802.11n (HT OFDM) Wi-Fi</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id9">
<span id="fig-nist-frame-success-rate-ac"></span><img alt="_images/nist-frame-success-rate-ac.png" src="_images/nist-frame-success-rate-ac.png" />
<figcaption>
<p><span class="caption-text">Frame error rate (NIST model) for 802.11ac (VHT OFDM) Wi-Fi</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id10">
<span id="fig-nist-frame-success-rate-ax"></span><img alt="_images/nist-frame-success-rate-ax.png" src="_images/nist-frame-success-rate-ax.png" />
<figcaption>
<p><span class="caption-text">Frame error rate (NIST model) for 802.11ax (HE OFDM) Wi-Fi</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="mac-validation">
<h4><span class="section-number">35.3.2. </span>MAC validation<a class="headerlink" href="#mac-validation" title="Link to this heading">¶</a></h4>
<p>Validation of the 802.11 DCF MAC layer has been performed in <a class="reference internal" href="index.html#baldo2010" id="id1"><span>[baldo2010]</span></a>.</p>
<p>802.11 PCF operation has been verified by running ‘wifi-pcf’ example with PCAP files generation enabled, and observing the frame exchange using Wireshark.</p>
</section>
<section id="spectrumwifiphy">
<h4><span class="section-number">35.3.3. </span>SpectrumWiFiPhy<a class="headerlink" href="#spectrumwifiphy" title="Link to this heading">¶</a></h4>
<p>The SpectrumWifiPhy implementation has been verified to produce equivalent
results to the legacy YansWifiPhy by using the saturation and packet
error rate programs (described below) and toggling the implementation
between the two physical layers.</p>
<p>A basic unit test is provided using injection of hand-crafted packets to
a receiving Phy object, controlling the timing and receive power of
each packet arrival and checking the reception results.  However, most of
the testing of this Phy implementation has been performed using example
programs described below, and during the course of a (separate) LTE/Wi-Fi
coexistence study not documented herein.</p>
<section id="saturation-performance">
<h5><span class="section-number">35.3.3.1. </span>Saturation performance<a class="headerlink" href="#saturation-performance" title="Link to this heading">¶</a></h5>
<p>The program <code class="docutils literal notranslate"><span class="pre">examples/wireless/wifi-spectrum-saturation-example.cc</span></code>
allows user to select either the <cite>SpectrumWifiPhy</cite> or <cite>YansWifiPhy</cite> for
saturation tests.  The wifiType can be toggled by the argument
<code class="docutils literal notranslate"><span class="pre">'--wifiType=ns3::YansWifiPhy'</span></code> or <code class="docutils literal notranslate"><span class="pre">--wifiType=ns3::SpectrumWifiPhy'</span></code></p>
<p>There isn’t any difference in the output, which is to be expected because
this test is more of a test of the DCF than the physical layer.</p>
<p>By default, the program will use the <cite>SpectrumWifiPhy</cite> and will run
for 10 seconds of saturating UDP data, with 802.11n features enabled.
It produces this output for the main 802.11n rates (with short and long guard
intervals):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wifiType:<span class="w"> </span>ns3::SpectrumWifiPhy<span class="w"> </span>distance:<span class="w"> </span>1m
index<span class="w">   </span>MCS<span class="w">   </span>width<span class="w"> </span>Rate<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Tput<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Received
<span class="w">    </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w">      </span><span class="m">20</span><span class="w">       </span><span class="m">6</span>.5<span class="w">     </span><span class="m">5</span>.81381<span class="w">    </span><span class="m">4937</span>
<span class="w">    </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">13</span><span class="w">     </span><span class="m">11</span>.8266<span class="w">   </span><span class="m">10043</span>
<span class="w">    </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w">      </span><span class="m">20</span><span class="w">      </span><span class="m">19</span>.5<span class="w">     </span><span class="m">17</span>.7935<span class="w">   </span><span class="m">15110</span>
<span class="w">    </span><span class="m">3</span><span class="w">     </span><span class="m">3</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">26</span><span class="w">     </span><span class="m">23</span>.7958<span class="w">   </span><span class="m">20207</span>
<span class="w">    </span><span class="m">4</span><span class="w">     </span><span class="m">4</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">39</span><span class="w">     </span><span class="m">35</span>.7331<span class="w">   </span><span class="m">30344</span>
<span class="w">    </span><span class="m">5</span><span class="w">     </span><span class="m">5</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">52</span><span class="w">     </span><span class="m">47</span>.6174<span class="w">   </span><span class="m">40436</span>
<span class="w">    </span><span class="m">6</span><span class="w">     </span><span class="m">6</span><span class="w">      </span><span class="m">20</span><span class="w">      </span><span class="m">58</span>.5<span class="w">     </span><span class="m">53</span>.6102<span class="w">   </span><span class="m">45525</span>
<span class="w">    </span><span class="m">7</span><span class="w">     </span><span class="m">7</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">65</span><span class="w">     </span><span class="m">59</span>.5501<span class="w">   </span><span class="m">50569</span>
<span class="w">  </span>...
<span class="w">   </span><span class="m">63</span><span class="w">    </span><span class="m">15</span><span class="w">      </span><span class="m">40</span><span class="w">       </span><span class="m">300</span><span class="w">     </span><span class="m">254</span>.902<span class="w">  </span><span class="m">216459</span>
</pre></div>
</div>
<p>The above output shows the first 8 (of 32) modes, and last mode, that will be
output from the program.  The first 8 modes correspond
to short guard interval disabled and channel bonding disabled.  The
subsequent 24 modes run by this program are variations with short guard
interval enabled (cases 9-16), and then with channel bonding enabled and
short guard first disabled then enabled (cases 17-32).  Cases 33-64 repeat
the same configurations but for two spatial streams (MIMO abstraction).</p>
<p>When run with the legacy YansWifiPhy, as in <code class="docutils literal notranslate"><span class="pre">./ns3</span> <span class="pre">run</span> <span class="pre">&quot;wifi-spectrum-saturation-example</span> <span class="pre">--wifiType=ns3::YansWifiPhy&quot;</span></code>, the same output is observed:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wifiType:<span class="w"> </span>ns3::YansWifiPhy<span class="w"> </span>distance:<span class="w"> </span>1m
index<span class="w">   </span>MCS<span class="w">   </span>width<span class="w"> </span>Rate<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Tput<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Received
<span class="w">    </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w">      </span><span class="m">20</span><span class="w">       </span><span class="m">6</span>.5<span class="w">     </span><span class="m">5</span>.81381<span class="w">    </span><span class="m">4937</span>
<span class="w">    </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">13</span><span class="w">     </span><span class="m">11</span>.8266<span class="w">   </span><span class="m">10043</span>
<span class="w">    </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w">      </span><span class="m">20</span><span class="w">      </span><span class="m">19</span>.5<span class="w">     </span><span class="m">17</span>.7935<span class="w">   </span><span class="m">15110</span>
<span class="w">    </span><span class="m">3</span><span class="w">     </span><span class="m">3</span><span class="w">      </span><span class="m">20</span><span class="w">        </span><span class="m">26</span><span class="w">     </span><span class="m">23</span>.7958<span class="w">   </span><span class="m">20207</span>
<span class="w">  </span>...
</pre></div>
</div>
<p>This is to be expected since YansWifiPhy and SpectrumWifiPhy use the
same error rate model in this case.</p>
</section>
<section id="packet-error-rate-performance">
<h5><span class="section-number">35.3.3.2. </span>Packet error rate performance<a class="headerlink" href="#packet-error-rate-performance" title="Link to this heading">¶</a></h5>
<p>The program <code class="docutils literal notranslate"><span class="pre">examples/wireless/wifi-spectrum-per-example.cc</span></code> allows users
to select either <cite>SpectrumWifiPhy</cite> or <cite>YansWifiPhy</cite>, as above, and select
the distance between the nodes, and to log the reception statistics and
received SNR (as observed by the WifiPhy::MonitorSnifferRx trace source), using a
Friis propagation loss model.  The transmit power is lowered from the default
of 40 mW (16 dBm) to 1 dBm to lower the baseline SNR; the distance between
the nodes can be changed to further change the SNR.  By default, it steps
through the same index values as in the saturation example (0 through 31)
for a 50m distance, for 10 seconds of simulation time, producing output such as:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wifiType:<span class="w"> </span>ns3::SpectrumWifiPhy<span class="w"> </span>distance:<span class="w"> </span>50m<span class="p">;</span><span class="w"> </span>time:<span class="w"> </span><span class="m">10</span><span class="p">;</span><span class="w"> </span>TxPower:<span class="w"> </span><span class="m">1</span><span class="w"> </span>dBm<span class="w"> </span><span class="o">(</span><span class="m">1</span>.3<span class="w"> </span>mW<span class="o">)</span>
index<span class="w">   </span>MCS<span class="w">  </span>Rate<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Tput<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Received<span class="w"> </span>Signal<span class="w"> </span><span class="o">(</span>dBm<span class="o">)</span><span class="w"> </span>Noise<span class="w"> </span><span class="o">(</span>dBm<span class="o">)</span><span class="w"> </span>SNR<span class="w"> </span><span class="o">(</span>dB<span class="o">)</span>
<span class="w">    </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w">      </span><span class="m">6</span>.50<span class="w">        </span><span class="m">5</span>.77<span class="w">    </span><span class="m">7414</span><span class="w">      </span>-79.71<span class="w">      </span>-93.97<span class="w">       </span><span class="m">14</span>.25
<span class="w">    </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w">     </span><span class="m">13</span>.00<span class="w">       </span><span class="m">11</span>.58<span class="w">   </span><span class="m">14892</span><span class="w">      </span>-79.71<span class="w">      </span>-93.97<span class="w">       </span><span class="m">14</span>.25
<span class="w">    </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w">     </span><span class="m">19</span>.50<span class="w">       </span><span class="m">17</span>.39<span class="w">   </span><span class="m">22358</span><span class="w">      </span>-79.71<span class="w">      </span>-93.97<span class="w">       </span><span class="m">14</span>.25
<span class="w">    </span><span class="m">3</span><span class="w">     </span><span class="m">3</span><span class="w">     </span><span class="m">26</span>.00<span class="w">       </span><span class="m">22</span>.96<span class="w">   </span><span class="m">29521</span><span class="w">      </span>-79.71<span class="w">      </span>-93.97<span class="w">       </span><span class="m">14</span>.25
<span class="w">    </span><span class="m">4</span><span class="w">     </span><span class="m">4</span><span class="w">     </span><span class="m">39</span>.00<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
<span class="w">    </span><span class="m">5</span><span class="w">     </span><span class="m">5</span><span class="w">     </span><span class="m">52</span>.00<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
<span class="w">    </span><span class="m">6</span><span class="w">     </span><span class="m">6</span><span class="w">     </span><span class="m">58</span>.50<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
<span class="w">    </span><span class="m">7</span><span class="w">     </span><span class="m">7</span><span class="w">     </span><span class="m">65</span>.00<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
</pre></div>
</div>
<p>As in the above saturation example, running this program with YansWifiPhy
will yield identical output.</p>
</section>
<section id="interference-performance">
<h5><span class="section-number">35.3.3.3. </span>Interference performance<a class="headerlink" href="#interference-performance" title="Link to this heading">¶</a></h5>
<p>The program <code class="docutils literal notranslate"><span class="pre">examples/wireless/wifi-spectrum-per-interference.cc</span></code> is based
on the previous packet error rate example, but copies over the
WaveformGenerator from the unlicensed LTE interferer test, to allow
users to inject a non-Wi-Fi signal (using the <code class="docutils literal notranslate"><span class="pre">--waveformPower</span></code> argument)
from the command line.  Another difference with respect to the packet
error rate example program is that the transmit power is set back to the
default of 40 mW (16 dBm).  By default, the interference generator is off,
and the program should behave similarly to the other packet error rate example,
but by adding small
amounts of power (e.g. <code class="docutils literal notranslate"><span class="pre">--waveformPower=0.001</span></code>), one will start to observe
SNR degradation and frame loss.</p>
<p>Some sample output with default arguments (no interference) is:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;wifi-spectrum-per-interference&quot;</span>

wifiType:<span class="w"> </span>ns3::SpectrumWifiPhy<span class="w"> </span>distance:<span class="w"> </span>50m<span class="p">;</span><span class="w"> </span>time:<span class="w"> </span><span class="m">10</span><span class="p">;</span><span class="w"> </span>TxPower:<span class="w"> </span><span class="m">16</span><span class="w"> </span>dBm<span class="w"> </span><span class="o">(</span><span class="m">40</span><span class="w"> </span>mW<span class="o">)</span>
index<span class="w">   </span>MCS<span class="w">  </span>Rate<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Tput<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Received<span class="w"> </span>Signal<span class="w"> </span><span class="o">(</span>dBm<span class="o">)</span>Noi+Inf<span class="o">(</span>dBm<span class="o">)</span><span class="w"> </span>SNR<span class="w"> </span><span class="o">(</span>dB<span class="o">)</span>
<span class="w">    </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w">      </span><span class="m">6</span>.50<span class="w">        </span><span class="m">5</span>.77<span class="w">    </span><span class="m">7414</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w">     </span><span class="m">13</span>.00<span class="w">       </span><span class="m">11</span>.58<span class="w">   </span><span class="m">14892</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w">     </span><span class="m">19</span>.50<span class="w">       </span><span class="m">17</span>.39<span class="w">   </span><span class="m">22358</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">3</span><span class="w">     </span><span class="m">3</span><span class="w">     </span><span class="m">26</span>.00<span class="w">       </span><span class="m">23</span>.23<span class="w">   </span><span class="m">29875</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">4</span><span class="w">     </span><span class="m">4</span><span class="w">     </span><span class="m">39</span>.00<span class="w">       </span><span class="m">34</span>.90<span class="w">   </span><span class="m">44877</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">5</span><span class="w">     </span><span class="m">5</span><span class="w">     </span><span class="m">52</span>.00<span class="w">       </span><span class="m">46</span>.51<span class="w">   </span><span class="m">59813</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">6</span><span class="w">     </span><span class="m">6</span><span class="w">     </span><span class="m">58</span>.50<span class="w">       </span><span class="m">52</span>.39<span class="w">   </span><span class="m">67374</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">    </span><span class="m">7</span><span class="w">     </span><span class="m">7</span><span class="w">     </span><span class="m">65</span>.00<span class="w">       </span><span class="m">58</span>.18<span class="w">   </span><span class="m">74819</span><span class="w">      </span>-64.69<span class="w">      </span>-93.97<span class="w">       </span><span class="m">29</span>.27
<span class="w">  </span>...
</pre></div>
</div>
<p>while a small amount of waveform power will cause frame losses to occur at
higher order modulations, due to lower SNR:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;wifi-spectrum-per-interference --waveformPower=0.001&quot;</span>

wifiType:<span class="w"> </span>ns3::SpectrumWifiPhy<span class="w"> </span>distance:<span class="w"> </span>50m<span class="p">;</span><span class="w"> </span>sent:<span class="w"> </span><span class="m">1000</span><span class="w"> </span>TxPower:<span class="w"> </span><span class="m">16</span><span class="w"> </span>dBm<span class="w"> </span><span class="o">(</span><span class="m">40</span><span class="w"> </span>mW<span class="o">)</span>
index<span class="w">   </span>MCS<span class="w"> </span>Rate<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Tput<span class="w"> </span><span class="o">(</span>Mb/s<span class="o">)</span><span class="w"> </span>Received<span class="w"> </span>Signal<span class="w"> </span><span class="o">(</span>dBm<span class="o">)</span>Noi+Inf<span class="o">(</span>dBm<span class="o">)</span><span class="w">  </span>SNR<span class="w"> </span><span class="o">(</span>dB<span class="o">)</span>
<span class="w">    </span><span class="m">0</span><span class="w">     </span><span class="m">0</span><span class="w">      </span><span class="m">6</span>.50<span class="w">        </span><span class="m">5</span>.77<span class="w">    </span><span class="m">7414</span><span class="w">      </span>-64.69<span class="w">      </span>-80.08<span class="w">       </span><span class="m">15</span>.38
<span class="w">    </span><span class="m">1</span><span class="w">     </span><span class="m">1</span><span class="w">     </span><span class="m">13</span>.00<span class="w">       </span><span class="m">11</span>.58<span class="w">   </span><span class="m">14892</span><span class="w">      </span>-64.69<span class="w">      </span>-80.08<span class="w">       </span><span class="m">15</span>.38
<span class="w">    </span><span class="m">2</span><span class="w">     </span><span class="m">2</span><span class="w">     </span><span class="m">19</span>.50<span class="w">       </span><span class="m">17</span>.39<span class="w">   </span><span class="m">22358</span><span class="w">      </span>-64.69<span class="w">      </span>-80.08<span class="w">       </span><span class="m">15</span>.38
<span class="w">    </span><span class="m">3</span><span class="w">     </span><span class="m">3</span><span class="w">     </span><span class="m">26</span>.00<span class="w">       </span><span class="m">23</span>.23<span class="w">   </span><span class="m">29873</span><span class="w">      </span>-64.69<span class="w">      </span>-80.08<span class="w">       </span><span class="m">15</span>.38
<span class="w">    </span><span class="m">4</span><span class="w">     </span><span class="m">4</span><span class="w">     </span><span class="m">39</span>.00<span class="w">        </span><span class="m">0</span>.41<span class="w">     </span><span class="m">531</span><span class="w">      </span>-64.69<span class="w">      </span>-80.08<span class="w">       </span><span class="m">15</span>.38
<span class="w">    </span><span class="m">5</span><span class="w">     </span><span class="m">5</span><span class="w">     </span><span class="m">52</span>.00<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
<span class="w">    </span><span class="m">6</span><span class="w">     </span><span class="m">6</span><span class="w">     </span><span class="m">58</span>.50<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
<span class="w">    </span><span class="m">7</span><span class="w">     </span><span class="m">7</span><span class="w">     </span><span class="m">65</span>.00<span class="w">        </span><span class="m">0</span>.00<span class="w">       </span><span class="m">0</span><span class="w">         </span>N/A<span class="w">         </span>N/A<span class="w">         </span>N/A
<span class="w">  </span>...
</pre></div>
</div>
<p>If ns3::YansWifiPhy is selected as the wifiType, the waveform generator will
not be enabled because only transmitters of type YansWifiPhy may be connected
to a YansWifiChannel.</p>
<p>The interference signal as received by the sending node is typically below
the default -62 dBm CCA Mode 1 threshold in this example.  If it raises
above, the sending node will suppress all transmissions.</p>
</section>
</section>
<section id="bianchi-validation">
<h4><span class="section-number">35.3.4. </span>Bianchi validation<a class="headerlink" href="#bianchi-validation" title="Link to this heading">¶</a></h4>
<p>The program <code class="docutils literal notranslate"><span class="pre">src/wifi/examples/wifi-bianchi.cc</span></code> allows user to
compare ns-3 simulation results against the Bianchi model
presented in <a class="reference internal" href="index.html#bianchi2000" id="id2"><span>[bianchi2000]</span></a> and <a class="reference internal" href="index.html#bianchi2005" id="id3"><span>[bianchi2005]</span></a>.</p>
<p>The MATLAB code used to generate the Bianchi model,
as well as the generated outputs, are provided in
the folder <code class="docutils literal notranslate"><span class="pre">src/wifi/examples/reference</span></code>.
User can regenerate Bianchi results by running
<code class="docutils literal notranslate"><span class="pre">generate_bianchi.m</span></code> in MATLAB.</p>
<p>By default, the program <code class="docutils literal notranslate"><span class="pre">src/wifi/examples/wifi-bianchi.cc</span></code>
simulates an 802.11a adhoc ring scenario, with a PHY rate set to
54 Mbit/s, and loop from 5 stations to 50 stations, by a step of
5 stations. It generates a plt file, which allows user to quickly
generate an eps file using gnuplot and visualize the graph.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;wifi-bianchi&quot;</span>
</pre></div>
</div>
<figure class="align-center" id="id11">
<span id="fig-wifi-bianchi-11a-54-adhoc"></span><img alt="_images/wifi-11a-p-1500-adhoc-r-54-min-5-max-50-step-5-throughput.png" src="_images/wifi-11a-p-1500-adhoc-r-54-min-5-max-50-step-5-throughput.png" />
<figcaption>
<p><span class="caption-text">Bianchi throughput validation results for 802.11a 54 Mbps in adhoc configuration</span><a class="headerlink" href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The user has the possibility to select the standard (only
11a, 11b or 11g currently supported), to select the PHY rate (in Mbit/s),
as well as to choose between an adhoc or an infrastructure configuration.</p>
<p>When run for 802.11g 6 Mbit/s in infrastructure mode, the output is:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./ns3<span class="w"> </span>run<span class="w"> </span><span class="s2">&quot;wifi-bianchi --standard=11g --phyRate=6 --duration=500 --infra&quot;</span>
</pre></div>
</div>
<figure class="align-center" id="id12">
<span id="fig-wifi-bianchi-11g-6-infra"></span><img alt="_images/wifi-11g-p-1500-infrastructure-r-6-min-5-max-50-step-5-throughput.png" src="_images/wifi-11g-p-1500-infrastructure-r-6-min-5-max-50-step-5-throughput.png" />
<figcaption>
<p><span class="caption-text">Bianchi throughput validation results for 802.11g 6 Mbps in infrastructure configuration</span><a class="headerlink" href="#id12" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="multi-user-transmissions-validation">
<h4><span class="section-number">35.3.5. </span>Multi-user transmissions validation<a class="headerlink" href="#multi-user-transmissions-validation" title="Link to this heading">¶</a></h4>
<p>The implementation of the OFDMA support has been validated against a theoretical model <a class="reference internal" href="index.html#magrin2021mu" id="id4"><span>[magrin2021mu]</span></a> .</p>
<p>A preliminary evaluation of the usage of OFDMA in 802.11ax, in terms of latency in non-saturated
conditions, throughput in saturated conditions and transmission range with UL OFDMA, is provided
in <a class="reference internal" href="index.html#avallone2021wcm" id="id5"><span>[avallone2021wcm]</span></a> .</p>
</section>
</section>
<span id="document-wifi-changelog"></span><section id="api-and-behavior-changes-across-releases">
<span id="sec-wifi-changelog-doc"></span><h3><span class="section-number">35.4. </span>API and behavior changes across releases<a class="headerlink" href="#api-and-behavior-changes-across-releases" title="Link to this heading">¶</a></h3>
<p>This page tracks the most relevant changes to the API and behavior of the wifi
module occurred across the various releases of <em>ns-3</em>.</p>
<section id="channelsettings-attribute">
<h4><span class="section-number">35.4.1. </span>ChannelSettings attribute<a class="headerlink" href="#channelsettings-attribute" title="Link to this heading">¶</a></h4>
<p>Prior to ns-3.36, channels, channel widths, and operating bands were set
separately.  As of ns-3.36, a new tuple object that we call ChannelSettings has
consolidated all of these settings.  Users should specify the channel number,
channel width, frequency band, and primary channel index as a tuple (and
continue to set the Wi-Fi standard separately).</p>
<p>For instance, where pre-ns-3.36 code may have said:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiPhyHelper</span><span class="w"> </span><span class="n">phy</span><span class="p">;</span>
<span class="n">phy</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelNumber&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">UintegerValue</span><span class="p">(</span><span class="mi">36</span><span class="p">));</span>
</pre></div>
</div>
<p>the equivalent new code is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WifiPhyHelper</span><span class="w"> </span><span class="n">phy</span><span class="p">;</span>
<span class="n">phy</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;ChannelSettings&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">StringValue</span><span class="p">(</span><span class="s">&quot;{36, 20, BAND_5GHZ, 0}&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>which denotes that channel 36 is used on a 20 MHz channel in the 5GHz band,
and because a larger channel width greater than 20 MHz is not being used, there
is no need to indicate the primary 20 MHz channel so it is set to zero in the
last argument. Users can read <a class="reference internal" href="index.html#channel-settings"><span class="std std-ref">Channel, frequency, channel width, and band configuration</span></a> for more details.</p>
</section>
</section>
<span id="document-wifi-references"></span><section id="references">
<h3><span class="section-number">35.5. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h3>
<div role="list" class="citation-list">
<div class="citation" id="ieee80211" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ieee80211<span class="fn-bracket">]</span></span>
<p>IEEE Std 802.11-2012, <em>Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications</em></p>
</div>
<div class="citation" id="ieee80211-2016" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ieee80211-2016<span class="fn-bracket">]</span></span>
<p>IEEE Std 802.11-2016, <em>Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications</em></p>
</div>
<div class="citation" id="pei80211b" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>pei80211b<span class="fn-bracket">]</span></span>
<p>G. Pei and Tom Henderson, <a class="reference external" href="http://www.nsnam.org/~pei/80211b.pdf">Validation of ns-3 802.11b PHY model</a></p>
</div>
<div class="citation" id="pei80211ofdm" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>pei80211ofdm<span class="fn-bracket">]</span></span>
<p>G. Pei and Tom Henderson, <a class="reference external" href="http://www.nsnam.org/~pei/80211ofdm.pdf">Validation of OFDM error rate model in ns-3</a></p>
</div>
<div class="citation" id="lacage2006yans" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>lacage2006yans<span class="fn-bracket">]</span></span>
<p>M. Lacage and T. Henderson, <a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/1190455.1190467?download=true">Yet another Network Simulator</a></p>
</div>
<div class="citation" id="haccoun" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Haccoun<span class="fn-bracket">]</span></span>
<p>D. Haccoun and G. Begin, <em>High-Rate Punctured Convolutional Codes for Viterbi Sequential Decoding</em>, IEEE Transactions on Communications, Vol. 32, Issue 3, pp.315-319.</p>
</div>
<div class="citation" id="frenger" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Frenger<span class="fn-bracket">]</span></span>
<p>Pâl Frenger et al., “Multi-rate Convolutional Codes”.</p>
</div>
<div class="citation" id="ji2004sslswn" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ji2004sslswn<span class="fn-bracket">]</span></span>
<p>Z. Ji, J. Zhou, M. Takai and R. Bagrodia, <em>Scalable simulation of large-scale wireless networks with bounded inaccuracies</em>, in Proc. of the Seventh ACM Symposium on Modeling, Analysis and Simulation of Wireless and Mobile Systems, October 2004.</p>
</div>
<div class="citation" id="linuxminstrel" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>linuxminstrel<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://wireless.wiki.kernel.org/en/developers/documentation/mac80211/ratecontrol/minstrel">minstrel linux wireless</a></p>
</div>
<div class="citation" id="lacage2004aarfamrr" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>lacage2004aarfamrr<span class="fn-bracket">]</span></span>
<p>M. Lacage, H. Manshaei, and T. Turletti, <em>IEEE 802.11 rate adaptation: a practical approach</em>, in Proc. 7th ACM International Symposium on Modeling, Analysis and Simulation of Wireless and Mobile Systems, 2004.</p>
</div>
<div class="citation" id="kim2006cara" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>kim2006cara<span class="fn-bracket">]</span></span>
<p>J. Kim, S. Kim, S. Choi, and D. Qiao, <em>CARA: Collision-Aware Rate Adaptation for IEEE 802.11 WLANs</em>, in Proc. 25th IEEE International Conference on Computer Communications, 2006</p>
</div>
<div class="citation" id="wong2006rraa" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>wong2006rraa<span class="fn-bracket">]</span></span>
<p>S. Wong, H. Yang, S. Lu, and V. Bharghavan, <em>Robust Rate Adaptation for 802.11 Wireless Networks</em>, in Proc. 12th Annual International Conference on Mobile Computing and Networking, 2006</p>
</div>
<div class="citation" id="maguolo2008aarfcd" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>maguolo2008aarfcd<span class="fn-bracket">]</span></span>
<p>F. Maguolo, M. Lacage, and T. Turletti, <em>Efficient collision detection for auto rate fallback algorithm</em>, in IEEE Symposium on Computers and Communications, 2008</p>
</div>
<div class="citation" id="proakis2001" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>proakis2001<span class="fn-bracket">]</span></span>
<p>J. Proakis, Digital Communications, Wiley, 2001.</p>
</div>
<div class="citation" id="miller2003" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>miller2003<span class="fn-bracket">]</span></span>
<p> L. E. Miller, “Validation of 802.11a/UWB Coexistence Simulation.” Technical Report, October 2003.  Available <a class="reference external" href="https://doi.org/10.6028/NIST.WCTG.10-17-2003">online</a></p>
</div>
<div class="citation" id="ferrari2004" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ferrari2004<span class="fn-bracket">]</span></span>
<p>G. Ferrari and G. Corazza, “Tight bounds and accurate approximations for DQPSK transmission bit error rate”, Electronics Letters, 40(20):1284-85, September 2004.</p>
</div>
<div class="citation" id="pursley2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>pursley2009<span class="fn-bracket">]</span></span>
<p>M. Pursley and T. Royster, “Properties and performance of the IEEE 802.11b complementary code key signal sets,” IEEE Transactions on Communications, 57(2);440-449, February 2009.</p>
</div>
<div class="citation" id="akella2007parf" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>akella2007parf<span class="fn-bracket">]</span></span>
<p>A. Akella, G. Judd, S. Seshan, and P. Steenkiste, ‘Self-management in chaotic wireless deployments’, in Wireless Networks, Kluwer Academic Publishers, 2007, 13, 737-755.  <a class="reference external" href="https://web.archive.org/web/20200709172505/https://www.cs.odu.edu/~nadeem/classes/cs795-WNS-S13/papers/enter-006.pdf">https://web.archive.org/web/20200709172505/https://www.cs.odu.edu/~nadeem/classes/cs795-WNS-S13/papers/enter-006.pdf</a></p>
</div>
<div class="citation" id="chevillat2005aparf" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>chevillat2005aparf<span class="fn-bracket">]</span></span>
<p> Chevillat, P.; Jelitto, J., and Truong, H. L., ‘Dynamic data rate and transmit power adjustment in IEEE 802.11 wireless LANs’, in International Journal of Wireless Information Networks, Springer, 2005, 12, 123-145.  <a class="reference external" href="https://web.archive.org/web/20170810111231/http://www.cs.mun.ca/~yzchen/papers/papers/rate_adaptation/80211_dynamic_rate_power_adjustment_chevillat_j2005.pdf">https://web.archive.org/web/20170810111231/http://www.cs.mun.ca/~yzchen/papers/papers/rate_adaptation/80211_dynamic_rate_power_adjustment_chevillat_j2005.pdf</a></p>
</div>
<div class="citation" id="hepner2015" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>hepner2015<span class="fn-bracket">]</span></span>
<p>C. Hepner, A. Witt, and R. Muenzner, “In depth analysis of the ns-3 physical layer abstraction for WLAN systems and evaluation of its influences on network simulation results”, BW-CAR Symposium on Information and Communication Systems (SInCom) 2015.  <a class="reference external" href="https://core.ac.uk/download/pdf/75487102.pdf#page=50">https://core.ac.uk/download/pdf/75487102.pdf#page=50</a></p>
</div>
<div class="citation" id="baldo2010" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>baldo2010<span class="fn-bracket">]</span></span>
<p>N. Baldo et al., “Validation of the ns-3 IEEE 802.11 model using the EXTREME testbed”, Proceedings of SIMUTools Conference, March 2010.</p>
</div>
<div class="citation" id="lanante2019" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>lanante2019<span class="fn-bracket">]</span></span>
<p>L. Lanante Jr. et al., “Improved Abstraction for Clear Channel Assessment in ns-3 802.11 WLAN Model”, Proceedings of the 2019 Workshop on ns-3, June 2019.</p>
</div>
<div class="citation" id="bianchi2000" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>bianchi2000<span class="fn-bracket">]</span></span>
<p>G. Bianchi, “Performance analysis of the IEEE 802.11 distributed coordination function”, IEEE Communications Letters, 18(3):535–547, 2000.</p>
</div>
<div class="citation" id="bianchi2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>bianchi2005<span class="fn-bracket">]</span></span>
<p>G. Bianchi and I. Tinnirello. “Remarks on IEEE 802.11 DCF performance analysis”, IEEE Communications Letters, 9(8):765–767, 2005.</p>
</div>
<div class="citation" id="patidar2017" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>patidar2017<span class="fn-bracket">]</span></span>
<p>R. Patidar et al., “Link-to-System Mapping for ns-3 Wi-Fi OFDM Error Models”, Proceedings of the Workshop on ns-3, June 2017. <a class="reference external" href="https://dl.acm.org/doi/10.1145/3067665.3067671">https://dl.acm.org/doi/10.1145/3067665.3067671</a></p>
</div>
<div class="citation" id="erceg2004" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>erceg2004<span class="fn-bracket">]</span></span>
<p>V. Erceg and L. Schumacher and P. Kyritsi, “Tgn channel models”, IEEE 802.11-03/940r4, 2004.</p>
</div>
<div class="citation" id="porat2016" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>porat2016<span class="fn-bracket">]</span></span>
<p>R. Porat et al., “11ax Evaluation Methodology”, IEE P802.11 Wireless LANs, 11-14-0571r3, 2016.</p>
</div>
<div class="citation" id="krotov2020rate" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>krotov2020rate<span class="fn-bracket">]</span></span>
<p>A. Krotov, A. Kiryanov, E. Khorov., <a class="reference external" href="https://doi.org/10.1109/ACCESS.2020.3023552">Rate Control With Spatial Reuse for Wi-Fi 6 Dense Deployments</a>, IEEE Access, September 2020</p>
</div>
<div class="citation" id="magrin2021mu" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>magrin2021mu<span class="fn-bracket">]</span></span>
<p>D. Magrin, S. Avallone, S. Roy, and M. Zorzi, ‘Validation of the ns-3 802.11ax OFDMA implementation’, in Proceedings of WNS3 2021.</p>
</div>
<div class="citation" id="avallone2021wcm" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>avallone2021wcm<span class="fn-bracket">]</span></span>
<p>S. Avallone, P. Imputato, G. Redieteab, C. Ghosh and S. Roy, “Will OFDMA Improve the Performance of 802.11 WiFi Networks?”, in IEEE Wireless Communications Magazine, DOI: 10.1109/MWC.001.2000332, to appear.</p>
</div>
<div class="citation" id="corbet2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>corbet2012<span class="fn-bracket">]</span></span>
<p>J. Corbet, “TCP Small Queues”, <a class="reference external" href="https://lwn.net/Articles/507065/">LWN.net, July 17, 2012</a></p>
</div>
<div class="citation" id="grazia2022" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>grazia2022<span class="fn-bracket">]</span></span>
<p>C. Grazia, N. Patriciello, T. Hoiland-Jorgensen, M. Klapez and M. Casoni, “Aggregating Without Bloating: Hard Times for TCP on Wi-Fi”, IEEE/ACM Transactions on Networking, Vol. 30, No.5, October 2022.</p>
</div>
</div>
</section>
</div>
</section>
<span id="document-wimax"></span><section id="wimax-netdevice">
<h2><span class="section-number">36. </span>Wimax NetDevice<a class="headerlink" href="#wimax-netdevice" title="Link to this heading">¶</a></h2>
<p>This chapter describes the <em>ns-3</em> WimaxNetDevice and related models. By
adding WimaxNetDevice objects to <em>ns-3</em> nodes, one can create models of
802.16-based networks. Below, we list some more details about what
the <em>ns-3</em> WiMAX models cover but, in summary, the most important features
of the <em>ns-3</em> model are:</p>
<ul class="simple">
<li><p>a scalable and realistic physical layer and channel model</p></li>
<li><p>a packet classifier for the IP convergence sublayer</p></li>
<li><p>efficient uplink and downlink schedulers</p></li>
<li><p>support for Multicast and Broadcast Service (MBS), and</p></li>
<li><p>packet tracing functionality</p></li>
</ul>
<p>The source code for the WiMAX models lives in the directory
<code class="docutils literal notranslate"><span class="pre">src/wimax</span></code>.</p>
<p>There have been two academic papers published on this model:</p>
<ul class="simple">
<li><p>M.A. Ismail, G. Piro, L.A. Grieco, and T. Turletti, “An Improved IEEE 802.16
WiMAX Module for the NS-3 Simulator”, SIMUTools 2010 Conference, March 2010.</p></li>
<li><p>J. Farooq and T. Turletti, “An IEEE 802.16 WiMAX module for the NS-3
Simulator,” SIMUTools 2009 Conference, March 2009.</p></li>
</ul>
<section id="scope-of-the-model">
<h3><span class="section-number">36.1. </span>Scope of the model<a class="headerlink" href="#scope-of-the-model" title="Link to this heading">¶</a></h3>
<p>From a MAC perspective, there are two basic modes of operation, that of a
Subscriber Station (SS) or a Base Station (BS). These are implemented as two
subclasses of the base class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ns3::NetDevice</span></code>, class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">SubscriberStationNetDevice</span></code> and class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BaseStationNetDevice</span></code>. As is typical in <em>ns-3</em>, there is also a
physical layer class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">WimaxPhy</span></code> and a channel class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">WimaxChannel</span></code> which serves to hold the references to all of the
attached Phy devices. The main physical layer class is the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">SimpleOfdmWimaxChannel</span></code> class.</p>
<p>Another important aspect of WiMAX is the uplink and downlink scheduler, and
there are three primary scheduler types implemented:</p>
<ul class="simple">
<li><p>SIMPLE:  a simple priority based FCFS scheduler</p></li>
<li><p>RTPS:  a real-time polling service (rtPS) scheduler</p></li>
<li><p>MBQOS:  a migration-based uplink scheduler</p></li>
</ul>
<p>The following additional aspects of the 802.16 specifications, as well as
physical layer and channel models, are modelled:</p>
<ul class="simple">
<li><p>leverages existing <em>ns-3</em> wireless propagation loss and delay models, as well
as <em>ns-3</em> mobility models</p></li>
<li><p>Point-to-Multipoint (PMP) mode and the WirelessMAN-OFDM PHY layer</p></li>
<li><p>Initial Ranging</p></li>
<li><p>Service Flow Initialization</p></li>
<li><p>Management Connection</p></li>
<li><p>Transport Initialization</p></li>
<li><p>UGS, rtPS, nrtPS, and BE connections</p></li>
</ul>
<p>The following aspects are not presently modelled but would be good topics for
future extensions:</p>
<ul class="simple">
<li><p>OFDMA PHY layer</p></li>
<li><p>Link adaptation</p></li>
<li><p>Mesh topologies</p></li>
<li><p>ARQ</p></li>
<li><p>ertPS connection</p></li>
<li><p>packet header suppression</p></li>
</ul>
</section>
<section id="using-the-wimax-models">
<h3><span class="section-number">36.2. </span>Using the Wimax models<a class="headerlink" href="#using-the-wimax-models" title="Link to this heading">¶</a></h3>
<p>The main way that users who write simulation scripts will typically interact
with the Wimax models is through the helper API and through the publicly visible
attributes of the model.</p>
<p>The helper API is defined in <code class="docutils literal notranslate"><span class="pre">src/wimax/helper/wimax-helper.{cc,h}</span></code>.</p>
<p>The example <code class="docutils literal notranslate"><span class="pre">src/wimax/examples/wimax-simple.cc</span></code> contains some basic code that
shows how to set up the model:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">schedType</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">    </span><span class="n">scheduler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SCHED_TYPE_SIMPLE</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="n">scheduler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SCHED_TYPE_MBQOS</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">    </span><span class="n">scheduler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SCHED_TYPE_RTPS</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">scheduler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SCHED_TYPE_SIMPLE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="n">NodeContainer</span><span class="w"> </span><span class="n">ssNodes</span><span class="p">;</span>
<span class="n">NodeContainer</span><span class="w"> </span><span class="n">bsNodes</span><span class="p">;</span>

<span class="n">ssNodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bsNodes</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">WimaxHelper</span><span class="w"> </span><span class="n">wimax</span><span class="p">;</span>

<span class="n">NetDeviceContainer</span><span class="w"> </span><span class="n">ssDevs</span><span class="p">,</span><span class="w"> </span><span class="n">bsDevs</span><span class="p">;</span>

<span class="n">ssDevs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wimax</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">ssNodes</span><span class="p">,</span>
<span class="w">                       </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">DEVICE_TYPE_SUBSCRIBER_STATION</span><span class="p">,</span>
<span class="w">                       </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SIMPLE_PHY_TYPE_OFDM</span><span class="p">,</span>
<span class="w">                       </span><span class="n">scheduler</span><span class="p">);</span>
<span class="n">bsDevs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wimax</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">bsNodes</span><span class="p">,</span><span class="w"> </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">DEVICE_TYPE_BASE_STATION</span><span class="p">,</span><span class="w"> </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SIMPLE_PHY_TYPE_OFDM</span><span class="p">,</span><span class="w"> </span><span class="n">scheduler</span><span class="p">);</span>
</pre></div>
</div>
<p>This example shows that there are two subscriber stations and one base station
created. The helper method <code class="docutils literal notranslate"><span class="pre">Install</span></code> allows the user to specify the scheduler
type, the physical layer type, and the device type.</p>
<p>Different variants of <code class="docutils literal notranslate"><span class="pre">Install</span></code> are available; for instance, the example
<code class="docutils literal notranslate"><span class="pre">src/wimax/examples/wimax-multicast.cc</span></code> shows how to specify a non-default channel
or propagation model:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateObject</span><span class="o">&lt;</span><span class="n">SimpleOfdmWimaxChannel</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">channel</span><span class="o">-&gt;</span><span class="n">SetPropagationModel</span><span class="p">(</span><span class="n">SimpleOfdmWimaxChannel</span><span class="o">::</span><span class="n">COST231_PROPAGATION</span><span class="p">);</span>
<span class="n">ssDevs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wimax</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">ssNodes</span><span class="p">,</span>
<span class="w">                       </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">DEVICE_TYPE_SUBSCRIBER_STATION</span><span class="p">,</span>
<span class="w">                       </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SIMPLE_PHY_TYPE_OFDM</span><span class="p">,</span>
<span class="w">                       </span><span class="n">channel</span><span class="p">,</span>
<span class="w">                       </span><span class="n">scheduler</span><span class="p">);</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">WimaxNetDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wimax</span><span class="p">.</span><span class="n">Install</span><span class="p">(</span><span class="n">bsNodes</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="w">                                        </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">DEVICE_TYPE_BASE_STATION</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">WimaxHelper</span><span class="o">::</span><span class="n">SIMPLE_PHY_TYPE_OFDM</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">channel</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">scheduler</span><span class="p">);</span>
</pre></div>
</div>
<p>Mobility is also supported in the same way as in Wifi models; see the
<code class="docutils literal notranslate"><span class="pre">src/wimax/examples/wimax-multicast.cc</span></code>.</p>
<p>Another important concept in WiMAX is that of a service flow. This is a
unidirectional flow of packets with a set of QoS parameters such as traffic
priority, rate, scheduling type, etc. The base station is responsible for
issuing service flow identifiers and mapping them to WiMAX connections. The
following code from <code class="docutils literal notranslate"><span class="pre">src/wimax/examples/wimax-multicast.cc</span></code> shows how this is
configured from a helper level:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ServiceFlow</span><span class="w"> </span><span class="n">MulticastServiceFlow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wimax</span><span class="p">.</span><span class="n">CreateServiceFlow</span><span class="p">(</span><span class="n">ServiceFlow</span><span class="o">::</span><span class="n">SF_DIRECTION_DOWN</span><span class="p">,</span>
<span class="w">                                                           </span><span class="n">ServiceFlow</span><span class="o">::</span><span class="n">SF_TYPE_UGS</span><span class="p">,</span>
<span class="w">                                                           </span><span class="n">MulticastClassifier</span><span class="p">);</span>

<span class="w"> </span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">GetServiceFlowManager</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddMulticastServiceFlow</span><span class="p">(</span><span class="n">MulticastServiceFlow</span><span class="p">,</span><span class="w"> </span><span class="n">WimaxPhy</span><span class="o">::</span><span class="n">MODULATION_TYPE_QPSK_12</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="wimax-attributes">
<h3><span class="section-number">36.3. </span>Wimax Attributes<a class="headerlink" href="#wimax-attributes" title="Link to this heading">¶</a></h3>
<p>The WimaxNetDevice makes heavy use of the <em>ns-3</em> attributes subsystem for
configuration and default value management.  Presently, approximately 60 values
are stored in this system.</p>
<p>For instance, class <code class="docutils literal notranslate"><span class="pre">ns-3::SimpleOfdmWimaxPhy</span></code> exports these
attributes:</p>
<ul class="simple">
<li><p>NoiseFigure:  Loss (dB) in the Signal-to-Noise-Ratio due to non-idealities in the receiver.</p></li>
<li><p>TxPower:  Transmission power (dB)</p></li>
<li><p>G:  The ratio of CP time to useful time</p></li>
<li><p>txGain:  Transmission gain (dB)</p></li>
<li><p>RxGain:  Reception gain (dB)</p></li>
<li><p>Nfft:  FFT size</p></li>
<li><p>TraceFilePath:  Path to the directory containing SNR to block error rate files</p></li>
</ul>
<p>For a full list of attributes in these models, consult the Doxygen page that
lists all attributes for <em>ns-3</em>.</p>
</section>
<section id="wimax-tracing">
<h3><span class="section-number">36.4. </span>Wimax Tracing<a class="headerlink" href="#wimax-tracing" title="Link to this heading">¶</a></h3>
<p><em>ns-3</em> has a sophisticated tracing infrastructure that allows users to hook into
existing trace sources, or to define and export new ones.</p>
<p>Many <em>ns-3</em> users use the built-in Pcap or Ascii tracing, and the
WimaxHelper has similar APIs:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">AsciiTraceHelper</span><span class="w"> </span><span class="n">ascii</span><span class="p">;</span>
<span class="n">WimaxHelper</span><span class="w"> </span><span class="n">wimax</span><span class="p">;</span>
<span class="n">wimax</span><span class="p">.</span><span class="n">EnablePcap</span><span class="p">(</span><span class="s">&quot;wimax-program&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="n">wimax</span><span class="p">.</span><span class="n">EnableAsciiAll</span><span class="p">(</span><span class="n">ascii</span><span class="p">.</span><span class="n">CreateFileStream</span><span class="p">(</span><span class="s">&quot;wimax-program.tr&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Unlike other helpers, there is also a special <code class="docutils literal notranslate"><span class="pre">EnableAsciiForConnection()</span></code>
method that limits the ascii tracing to a specific device and connection.</p>
<p>These helpers access the low level trace sources that exist in the WiMAX
physical layer, net device, and queue models. Like other <em>ns-3</em> trace sources,
users may hook their own functions to these trace sources if they want to do
customized things based on the packet events. See the Doxygen List of trace
sources for a complete list of these sources.</p>
</section>
<section id="wimax-mac-model">
<h3><span class="section-number">36.5. </span>Wimax MAC model<a class="headerlink" href="#wimax-mac-model" title="Link to this heading">¶</a></h3>
<p>The 802.16 model provided in <em>ns-3</em> attempts to provide an accurate MAC and PHY
level implementation of the 802.16 specification with the Point-to-Multipoint
(PMP) mode and the WirelessMAN-OFDM PHY layer. The model is mainly composed of
three layers:</p>
<ul class="simple">
<li><p>The convergence sublayer (CS)</p></li>
<li><p>The MAC CP Common Part Sublayer (MAC-CPS)</p></li>
<li><p>Physical (PHY) layer</p></li>
</ul>
<p>The following figure <a class="reference internal" href="#wimax-architecture"><span class="std std-ref">WiMAX architecture</span></a> shows the relationships of these
models.</p>
<figure class="align-default" id="id1">
<span id="wimax-architecture"></span><img alt="_images/WimaxArchitecture.png" src="_images/WimaxArchitecture.png" />
<figcaption>
<p><span class="caption-text">WiMAX architecture</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<section id="convergence-sublayer">
<h4><span class="section-number">36.5.1. </span>Convergence Sublayer<a class="headerlink" href="#convergence-sublayer" title="Link to this heading">¶</a></h4>
<p>The Convergence sublayer (CS) provided with this module implements the Packet
CS, designed to work with the packet-based protocols at higher layers. The CS is
responsible of receiving packet from the higher layer and from peer stations,
classifying packets to appropriate connections (or service flows) and processing
packets. It keeps a mapping of transport connections to service flows. This
enables the MAC CPS identifying the Quality of Service (QoS) parameters
associated to a transport connection and ensuring the QoS requirements. The CS
currently employs an IP classifier.</p>
</section>
<section id="ip-packet-classifier">
<h4><span class="section-number">36.5.2. </span>IP Packet Classifier<a class="headerlink" href="#ip-packet-classifier" title="Link to this heading">¶</a></h4>
<p>An IP packet classifier is used to map incoming packets to appropriate
connections based on a set of criteria. The classifier maintains a list of
mapping rules which associate an IP flow (src IP address and mask, dst IP
address and mask, src port range, dst port range and protocol) to one of the
service flows.  By analyzing the IP and the TCP/UDP headers the classifier will
append the incoming packet (from the upper layer) to the queue of the
appropriate WiMAX connection. Class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">IpcsClassifier</span></code> and class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">IpcsClassifierRecord</span></code> implement the classifier module for both SS
and BS</p>
</section>
<section id="mac-common-part-sublayer">
<h4><span class="section-number">36.5.3. </span>MAC Common Part Sublayer<a class="headerlink" href="#mac-common-part-sublayer" title="Link to this heading">¶</a></h4>
<p>The MAC Common Part Sublayer (CPS) is the main sublayer of the IEEE 802.16 MAC
and performs the fundamental functions of the MAC. The module implements the
Point-Multi-Point (PMP) mode. In PMP mode BS is responsible of managing
communication among multiple SSs. The key functionalities of the MAC CPS include
framing and addressing, generation of MAC management messages, SS initialization
and registration, service flow management, bandwidth management and scheduling
services.  Class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">WimaxNetDevice</span></code> represents the MAC layer of a WiMAX
network device. This class extends the class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">NetDevice</span></code> of the <em>ns-3</em>
API that provides abstraction of a network device. Class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">WimaxNetDevice</span></code> is further extended by class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BaseStationNetDevice</span></code> and class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">SubscriberStationNetDevice</span></code>, defining MAC layers of BS and SS,
respectively.  Besides these main classes, the key functions of MAC are
distributed to several other classes.</p>
</section>
<section id="framing-and-management-messages">
<h4><span class="section-number">36.5.4. </span>Framing and Management Messages<a class="headerlink" href="#framing-and-management-messages" title="Link to this heading">¶</a></h4>
<p>The module implements a frame as a fixed duration of time, i.e., frame
boundaries are defined with respect to time. Each frame is further subdivided
into downlink (DL) and uplink (UL) subframes. The module implements the Time
Division Duplex (TDD) mode where DL and UL operate on same frequency but are
separated in time. A number of DL and UL bursts are then allocated in DL and UL
subframes, respectively. Since the standard allows sending and receiving bursts
of packets in a given DL or UL burst, the unit of transmission at the MAC layer
is a packet burst. The module implements a special PacketBurst data structure
for this purpose. A packet burst is essentially a list of packets. The BS
downlink and uplink schedulers, implemented by class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BSScheduler</span></code>
and class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UplinkScheduler</span></code>, are responsible of generating DL and UL
subframes, respectively. In the case of DL, the subframe is simulated by
transmitting consecutive bursts (instances PacketBurst). In case of UL, the
subframe is divided, with respect to time, into a number of slots. The bursts
transmitted by the SSs in these slots are then aligned to slot boundaries. The
frame is divided into integer number of symbols and Physical Slots (PS) which
helps in managing bandwidth more effectively. The number of symbols per frame
depends on the  underlying implementation of the PHY layer. The size of a DL or
UL burst is specified in units of symbols.</p>
</section>
<section id="network-entry-and-initialization">
<h4><span class="section-number">36.5.5. </span>Network Entry and Initialization<a class="headerlink" href="#network-entry-and-initialization" title="Link to this heading">¶</a></h4>
<p>The network entry and initialization phase is basically divided into two
sub-phases, (1) scanning and synchronization and (2) initial ranging. The entire
phase is performed by the LinkManager component of SS and BS. Once an SS wants
to join the network, it first scans the downlink frequencies to search for a
suitable channel. The search is complete as soon as it detects a PHY frame. The
next step is to establish synchronization with the BS. Once SS receives a
Downlink-MAP (DL-MAP) message the synchronization phase is complete and it
remains synchronized as long as it keeps receiving DL-MAP and  Downlink Channel
Descriptor (DCD) messages. After the synchronization is established, SS waits
for a Uplink Channel Descriptor (UCD) message to acquire uplink channel
parameters. Once acquired, the first sub-phase of the network entry and
initialization is complete. Once synchronization is achieved, the SS waits for a
UL-MAP message to locate a special grant, called initial ranging interval, in
the UL subframe. This grant is allocated by the BS Uplink Scheduler at regular
intervals. Currently this interval is set to 0.5 ms, however the user is enabled
to modify its value from the simulation script.</p>
</section>
<section id="connections-and-addressing">
<h4><span class="section-number">36.5.6. </span>Connections and Addressing<a class="headerlink" href="#connections-and-addressing" title="Link to this heading">¶</a></h4>
<p>All communication at the MAC layer is carried in terms of connections. The
standard defines a connection as a unidirectional mapping between the SS and
BS’s MAC entities for the transmission of traffic. The standard defines two
types of connections: management connections for transmitting control messages
and transport connections for data transmission. A connection is identified by a
16-bit Connection Identifier (CID).  Class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">WimaxConnection</span></code> and
class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Cid</span></code> implement the connection and CID, respectively. Note that
each connection maintains its own transmission queue where packets to transmit
on that connection are queued. The ConnectionManager component of BS is
responsible of creating and managing connections for all SSs.</p>
<p>The two key management connections defined by the standard, namely the Basic and
Primary management connections, are created and allocated to the SS during the
ranging process. Basic connection plays an important role throughout the
operation of SS also because all (unicast) DL and UL grants are directed towards
SS’s Basic CID. In addition to management connections, an SS may have one or
more transport connections to send data packets. The Connection Manager
component of SS manages the connections associated to SS. As defined by the
standard, a management connection is bidirectional, i.e., a pair of downlink and
uplink connections is represented by the same CID. This feature is implemented
in a way that one connection (in DL direction) is created by the BS and upon
receiving the CID the SS then creates an identical connection (in UL direction)
with the same CID.</p>
</section>
<section id="scheduling-services">
<h4><span class="section-number">36.5.7. </span>Scheduling Services<a class="headerlink" href="#scheduling-services" title="Link to this heading">¶</a></h4>
<p>The module supports the four scheduling services defined by the 802.16-2004
standard:</p>
<ul class="simple">
<li><p>Unsolicited Grant Service (UGS)</p></li>
<li><p>Real-Time Polling Services (rtPS)</p></li>
<li><p>Non Real-Time Polling Services (nrtPS)</p></li>
<li><p>Best Effort (BE)</p></li>
</ul>
<p>These scheduling services behave differently with respect to how they request
bandwidth as well as how the it is granted. Each service flow is associated to
exactly one scheduling service, and the QoS parameter set associated to a
service flow actually defines the scheduling service it belongs to. When a
service flow is created the UplinkScheduler calculates necessary parameters such
as grant size and grant interval based on QoS parameters associated to it.</p>
</section>
<section id="wimax-uplink-scheduler-model">
<h4><span class="section-number">36.5.8. </span>WiMAX Uplink Scheduler Model<a class="headerlink" href="#wimax-uplink-scheduler-model" title="Link to this heading">¶</a></h4>
<p>Uplink Scheduler at the BS decides which of the SSs will be assigned uplink
allocations based on the QoS parameters associated to a service flow (or
scheduling service) and bandwidth requests from the SSs. Uplink scheduler
together with Bandwidth Manager implements the complete scheduling service
functionality. The standard defines up to four scheduling services (BE, UGS,
rtPS, nrtPS) for applications with different types of QoS requirements. The
service flows of these scheduling services behave differently with respect to
how they request for bandwidth as well as how the bandwidth is granted. The
module supports all four scheduling services. Each service flow is associated to
exactly one transport connection and one scheduling service. The QoS parameters
associated to a service flow actually define the scheduling service it belongs
to. Standard QoS parameters for UGS, rtPS, nrtPS and BE services, as specified
in Tables 111a to 111d of the 802.16e amendment, are supported. When a service
flow is created the uplink scheduler calculates necessary parameters such as
grant size and allocation interval based on QoS parameters associated to it.
The current WiMAX module provides three different versions of schedulers.</p>
<ul class="simple">
<li><p>The first one is a simple priority-based First Come First Serve (FCFS).  For
the real-time services (UGS and rtPS) the BS then allocates grants/polls on
regular basis based on the calculated interval. For the non real-time services
(nrtPS and BE) only minimum reserved bandwidth is guaranteed if available
after servicing real-time flows. Note that not all of these parameters are
utilized by the uplink scheduler. Also note that currently only service flow
with fixed-size packet size are supported, as currently set up in simulation
scenario with OnOff application of fixed packet size. This scheduler is
implemented by class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BSSchedulerSimple</span></code> and class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UplinkSchedulerSimple</span></code>.</p></li>
<li><p>The second one is similar to first scheduler except by rtPS service flow. All
rtPS Connections are able to transmit all packet in the queue according to the
available bandwidth. The bandwidth saturation control has been implemented to
redistribute the effective available bandwidth to all rtPS that have at least
one packet to transmit. The remaining bandwidth is allocated to nrtPS and BE
Connections. This scheduler is implemented by class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BSSchedulerRtps</span></code> and class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UplinkSchedulerRtps</span></code>.</p></li>
<li><p>The third one is a Migration-based Quality of Service uplink scheduler This
uplink scheduler uses three queues, the low priority queue, the intermediate
queue and the high priority queue. The scheduler serves the requests in
strict priority order from the high priority queue to the low priority queue.
The low priority queue stores the bandwidth requests of the BE service flow.
The intermediate queue holds bandwidth requests sent by rtPS and by nrtPS
connections. rtPS and nrtPS requests can migrate to the high priority queue to
guarantee that their QoS requirements are met. Besides the requests migrated
from the intermediate queue, the high priority queue stores periodic grants
and unicast request opportunities that must be scheduled in the following
frame. To guarantee the maximum delay requirement, the BS assigns a deadline
to each rtPS bandwidth request in the intermediate queue. The minimum
bandwidth requirement of both rtPS and nrtPS connections is guaranteed over a
window of duration T. This scheduler is implemented by class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">UplinkSchedulerMBQoS</span></code>.</p></li>
</ul>
</section>
<section id="wimax-outbound-schedulers-model">
<h4><span class="section-number">36.5.9. </span>WiMAX Outbound Schedulers Model<a class="headerlink" href="#wimax-outbound-schedulers-model" title="Link to this heading">¶</a></h4>
<p>Besides the uplink scheduler these are the outbound schedulers at BS and SS side
(BSScheduler and SSScheduler). The outbound schedulers decide which of the
packets from the outbound queues will be transmitted in a given allocation. The
outbound scheduler at the BS schedules the downlink traffic, i.e., packets to be
transmitted to the SSs in the downlink subframe. Similarly the outbound
scheduler at a SS schedules the packet to be transmitted in the uplink
allocation assigned to that SS in the uplink subframe. All three schedulers have
been implemented to work as FCFS scheduler, as they allocate grants starting
from highest priority scheduling service to the lower priority one (UGS&gt; rtPS&gt;
nrtPS&gt; BE). The standard does not suggest any scheduling algorithm and instead
leaves this decision up to the manufacturers. Of course more sophisticated
algorithms can be added later if required.</p>
</section>
</section>
<section id="wimaxchannel-and-wimaxphy-models">
<h3><span class="section-number">36.6. </span>WimaxChannel and WimaxPhy models<a class="headerlink" href="#wimaxchannel-and-wimaxphy-models" title="Link to this heading">¶</a></h3>
<p>The module implements the Wireless MAN OFDM PHY specifications as the more
relevant for implementation as it is the schema chosen by the WiMAX Forum. This
specification is designed for non-light-of-sight (NLOS) including fixed and
mobile broadband wireless access. The proposed model uses a 256 FFT processor,
with 192 data subcarriers. It supports all the seven modulation and coding
schemes specified by Wireless MAN-OFDM. It is composed of two parts: the channel
model and the physical model.</p>
</section>
<section id="channel-model">
<h3><span class="section-number">36.7. </span>Channel model<a class="headerlink" href="#channel-model" title="Link to this heading">¶</a></h3>
<p>The channel model we propose is implemented by the class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">SimpleOFDMWimaxChannel</span></code> which extends the class
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wimaxchannel</span></code>. The channel entity has a private structure named
m_phyList which handles all the physical devices connected to it. When a
physical device sends a packet (FEC Block) to the channel, the channel handles
the packet, and then for each physical device connected to it, it calculates the
propagation delay, the path loss according to a given propagation model and
eventually forwards the packet to the receiver device.  The channel class uses
the method <cite>GetDistanceFrom()</cite> to calculate the distance between two physical
entities according to their 3D coordinates. The delay is
computed as <cite>delay = distance/C</cite>, where <cite>C</cite> is the speed of the light.</p>
</section>
<section id="physical-model">
<h3><span class="section-number">36.8. </span>Physical model<a class="headerlink" href="#physical-model" title="Link to this heading">¶</a></h3>
<p>The physical layer performs two main operations: (i) It receives a burst from a
channel and forwards it to the MAC layer, (ii) it receives a burst from the MAC
layer and transmits it on the channel. In order to reduce the simulation
complexity of the WiMAX physical layer, we have chosen to model offline part of
the physical layer. More specifically we have developed an OFDM simulator to
generate trace files used by the reception process to evaluate if a FEC block
can be correctly decoded or not.</p>
<p>Transmission Process: A burst is a set of WiMAX MAC PDUs. At the sending
process, a burst is converted into bit-streams and then split into smaller
FEC blocks which are then sent to the channel with a power equal P_tx.</p>
<p>Reception Process: The reception process includes the following operations:</p>
<ol class="arabic simple">
<li><p>Receive a FEC block from the channel.</p></li>
<li><p>Calculate the noise level.</p></li>
<li><p>Estimate the signal to noise ratio (SNR) with the following formula.</p></li>
<li><p>Determine if a FEC block can be correctly decoded.</p></li>
<li><p>Concatenate received FEC blocks to reconstruct the original burst.</p></li>
<li><p>Forward the burst to the upper layer.</p></li>
</ol>
<p>The developed process to evaluate if a FEC block can be correctly received or
not uses pre-generated traces.  The trace files are generated by an external
OFDM simulator (described later). A class named SNRToBlockErrorRateManager
handles a repository containing seven trace files (one for each modulation and
coding scheme). A repository is specific for a particular channel model.</p>
<p>A trace file is made of 6 columns. The first column provides the SNR value (1),
whereas the other columns give respectively the bit error rate BER (2), the
block error rate BlcER(3), the standard deviation on BlcER, and the confidence
interval (4 and 5).  These trace files are loaded into memory by the
SNRToBlockErrorRateManager entity at the beginning of the simulation.</p>
<p>Currently, The first process uses the first and third columns to determine if a
FEC block is correctly received. When the physical layer receives a packet with
an SNR equal to SNR_rx, it asks the SNRToBlockErrorRateManager to return the
corresponding block error rate BlcER. A random number RAND between 0 and 1 is
then generated. If RAND is greater than BlcER, then the block is correctly
received, otherwise the block is considered erroneous and is ignored.</p>
<p>The module provides defaults SNR to block error rate traces in default-traces.h.
The traces have been generated by an External WiMAX OFDM simulator. The
simulator is based on an external mathematics and signal processing library IT++
and includes : a random block generator, a Reed Solomon (RS) coder, a
convolutional coder, an interleaver, a 256 FFT-based OFDM modulator, a
multi-path channel simulator and an equalizer. The multipath channel is
simulated using the TDL_channel class of the IT++ library.</p>
<p>Users can configure the module to use their own traces generated by another OFDM
simulator or ideally by performing experiments in real environment. For this
purpose, a path to a repository containing trace files should be provided.  If
no repository is provided the traces form default-traces.h will be loaded. A
valid repository should contain 7 files, one for each modulation and coding
scheme.</p>
<p>The names of the files should respect the following format: modulation0.txt for
modulation 0, modulation1.txt for modulation 1 and so on…  The file format
should be as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SNR_value1   BER  Blc_ER  STANDARD_DEVIATION  CONFIDENCE_INTERVAL1  CONFIDENCE_INTERVAL2
SNR_value2   BER  Blc_ER  STANDARD_DEVIATION  CONFIDENCE_INTERVAL1  CONFIDENCE_INTERVAL2
 ...          ...  ...     ...                 ...                   ...
 ...          ...  ...     ...                 ...                   ...
</pre></div>
</div>
</section>
</section>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="#">Table of Contents</a></h3>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-organization">1. Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-animation">2. Animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-antenna">3. Antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-aodv">4. Ad Hoc On-Demand Distance Vector (AODV)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-applications">5. 3GPP HTTP applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-bridge">6. Bridge NetDevice</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-brite">7. BRITE Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-buildings">8. Buildings Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-click">9. Click Modular Router Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-csma">10. CSMA NetDevice</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-dsdv">11. DSDV Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-dsr">12. DSR Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-emulation-overview">13. Emulation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-energy">14. Energy Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-flow-monitor">15. Flow Monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internet-models">16. Internet Models (IP, TCP, Routing, UDP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-internet-apps">17. Internet Applications Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-lorawan">18. LoRaWAN Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-lr-wpan">19. Low-Rate Wireless Personal Area Network (LR-WPAN)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-lte">20. LTE Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-mesh">21. Wi-Fi Mesh Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-distributed">22. MPI for Distributed Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-mobility">23. Mobility</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-network">24. Network Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-nix-vector-routing">25. Nix-Vector Routing Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-olsr">26. Optimized Link State Routing (OLSR)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-openflow-switch">27. OpenFlow switch support</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-point-to-point">28. PointToPoint NetDevice</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-propagation">29. Propagation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-spectrum">30. Spectrum Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-sixlowpan">31. 6LoWPAN: Transmission of IPv6 Packets over IEEE 802.15.4 Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-topology">32. Topology Input Readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-traffic-control">33. Traffic Control Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-uan">34. UAN Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-wifi">35. Wi-Fi Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-wimax">36. Wimax NetDevice</a></li>
</ul>

  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li class="nav-item nav-item-0"><a href="#">Models</a><span class="navelem">&nbsp;</span></li>

        <li class="nav-item nav-item-this"><a href="">Model Library</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006-2019.
      Last updated on Dec 19, 2023 13:22.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>